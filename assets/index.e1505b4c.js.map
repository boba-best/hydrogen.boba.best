{"version":3,"file":"index.e1505b4c.js","sources":["../../src/utils/enum.ts","../../src/matrix/well-known.js","../../src/utils/error.ts","../../src/observable/BaseObservable.ts","../../src/observable/ObservableValue.ts","../../src/utils/AbortableOperation.ts","../../src/platform/web/dom/BlobHandle.js","../../src/matrix/net/common.ts","../../src/matrix/error.js","../../src/matrix/net/HomeServerRequest.ts","../../src/matrix/net/HomeServerApi.ts","../../src/matrix/net/ExponentialRetryDelay.ts","../../src/matrix/net/Reconnector.ts","../../src/matrix/e2ee/attachment.js","../../src/matrix/net/MediaRepository.ts","../../src/matrix/net/RequestScheduler.ts","../../src/matrix/Sync.js","../../src/utils/EventEmitter.ts","../../src/matrix/e2ee/common.js","../../src/matrix/room/RoomSummary.js","../../src/matrix/storage/common.ts","../../src/matrix/room/timeline/EventKey.ts","../../src/matrix/room/timeline/entries/BaseEntry.ts","../../src/matrix/room/common.ts","../../src/matrix/room/timeline/relations.js","../../src/matrix/room/timeline/PendingAnnotation.js","../../src/matrix/room/timeline/entries/reply.js","../../src/matrix/room/timeline/entries/BaseEventEntry.js","../../src/matrix/room/timeline/entries/PendingEventEntry.js","../../src/matrix/room/sending/PendingEvent.js","../../src/matrix/room/timeline/entries/EventEntry.js","../../src/matrix/room/timeline/persistence/common.js","../../src/matrix/room/members/RoomMember.js","../../src/matrix/room/timeline/common.js","../../src/matrix/room/timeline/FragmentIdComparer.js","../../vite/preload-helper","../../src/matrix/storage/idb/error.ts","../../src/matrix/storage/idb/utils.ts","../../src/matrix/storage/idb/QueryTarget.ts","../../src/matrix/storage/idb/Store.ts","../../src/utils/typedJSON.ts","../../src/matrix/storage/idb/stores/SessionStore.ts","../../src/matrix/storage/idb/stores/RoomSummaryStore.ts","../../src/matrix/storage/idb/stores/InviteStore.ts","../../src/logging/LogFilter.ts","../../src/logging/NullLogger.ts","../../src/matrix/storage/idb/stores/TimelineEventStore.ts","../../src/matrix/storage/idb/stores/common.ts","../../src/matrix/storage/idb/stores/TimelineRelationStore.ts","../../src/matrix/storage/idb/stores/RoomStateStore.ts","../../src/matrix/storage/idb/stores/RoomMemberStore.ts","../../src/matrix/storage/idb/stores/TimelineFragmentStore.ts","../../src/matrix/storage/idb/stores/PendingEventStore.ts","../../src/matrix/storage/idb/stores/UserIdentityStore.ts","../../src/matrix/storage/idb/stores/DeviceIdentityStore.ts","../../src/matrix/storage/idb/stores/OlmSessionStore.ts","../../src/matrix/storage/idb/stores/InboundGroupSessionStore.ts","../../src/matrix/storage/idb/stores/OutboundGroupSessionStore.ts","../../src/matrix/storage/idb/stores/GroupSessionDecryptionStore.ts","../../src/matrix/storage/idb/stores/OperationStore.ts","../../src/matrix/storage/idb/stores/AccountDataStore.ts","../../src/matrix/storage/idb/Transaction.ts","../../src/matrix/storage/idb/Storage.ts","../../src/matrix/storage/idb/export.ts","../../src/matrix/e2ee/DeviceTracker.js","../../src/matrix/storage/idb/schema.ts","../../src/matrix/storage/idb/quirks.ts","../../src/matrix/storage/idb/StorageFactory.ts","../../src/matrix/room/timeline/persistence/RelationWriter.js","../../src/matrix/room/timeline/Direction.ts","../../src/matrix/room/timeline/entries/FragmentBoundaryEntry.js","../../src/matrix/room/timeline/persistence/SyncWriter.js","../../src/utils/LRUCache.ts","../../src/matrix/room/timeline/persistence/MemberWriter.js","../../src/matrix/room/timeline/persistence/GapWriter.js","../../src/observable/list/BaseObservableList.ts","../../src/utils/sortedIndex.ts","../../src/observable/map/BaseObservableMap.js","../../src/observable/map/ObservableMap.js","../../src/observable/list/SortedMapList.js","../../src/observable/map/FilteredMap.js","../../src/observable/map/MappedMap.js","../../src/observable/map/JoinedMap.js","../../src/observable/list/ObservableArray.ts","../../src/observable/list/common.ts","../../src/observable/list/SortedArray.ts","../../src/observable/list/BaseMappedList.ts","../../src/observable/list/AsyncMappedList.ts","../../src/observable/list/ConcatList.ts","../../src/observable/index.js","../../src/utils/Disposables.ts","../../src/matrix/room/timeline/persistence/TimelineReader.js","../../src/matrix/room/timeline/entries/NonPersistedEventEntry.js","../../src/matrix/User.js","../../src/matrix/room/timeline/Timeline.js","../../src/matrix/room/members/load.js","../../src/utils/RetainedValue.ts","../../src/matrix/room/members/MemberList.js","../../src/matrix/room/members/Heroes.js","../../src/matrix/room/ObservedEventMap.js","../../src/logging/utils.ts","../../src/matrix/room/PowerLevels.js","../../src/matrix/room/BaseRoom.js","../../src/matrix/common.js","../../src/matrix/room/sending/SendQueue.js","../../src/matrix/room/AttachmentUpload.js","../../src/matrix/room/Room.js","../../src/matrix/room/ArchivedRoom.js","../../src/matrix/profile.ts","../../src/matrix/room/RoomBeingCreated.ts","../../src/matrix/room/Invite.js","../../src/matrix/push/Pusher.ts","../../src/utils/groupBy.ts","../../src/matrix/DeviceMessageHandler.js","../../src/matrix/e2ee/Account.js","../../src/matrix/ssss/common.ts","../../src/matrix/ssss/passphrase.ts","../../src/matrix/ssss/recoveryKey.ts","../../src/matrix/ssss/index.ts","../../src/matrix/e2ee/Dehydration.js","../../src/utils/Lock.ts","../../src/matrix/e2ee/olm/Session.js","../../src/matrix/e2ee/DecryptionResult.js","../../src/matrix/e2ee/olm/Decryption.js","../../src/matrix/e2ee/olm/Encryption.js","../../src/matrix/e2ee/megolm/decryption/DecryptionChanges.js","../../src/utils/mergeMap.ts","../../src/matrix/e2ee/megolm/decryption/DecryptionPreparation.js","../../src/matrix/e2ee/megolm/decryption/ReplayDetectionEntry.ts","../../src/matrix/e2ee/megolm/decryption/SessionDecryption.ts","../../src/matrix/e2ee/megolm/decryption/utils.ts","../../src/matrix/e2ee/megolm/decryption/RoomKey.ts","../../src/matrix/e2ee/megolm/Decryption.ts","../../src/matrix/e2ee/megolm/decryption/KeyLoader.ts","../../src/matrix/e2ee/megolm/keybackup/Curve25519.ts","../../src/matrix/e2ee/megolm/keybackup/KeyBackup.ts","../../src/matrix/e2ee/megolm/Encryption.js","../../src/matrix/e2ee/RoomEncryption.js","../../src/utils/LockMap.ts","../../src/matrix/ssss/SecretStorage.ts","../../src/matrix/Session.js","../../src/matrix/login/PasswordLoginMethod.ts","../../src/matrix/login/TokenLoginMethod.ts","../../src/matrix/login/SSOLoginHelper.ts","../../src/matrix/registration/stages/BaseRegistrationStage.ts","../../src/matrix/registration/stages/DummyAuth.ts","../../src/matrix/registration/stages/TermsAuth.ts","../../src/matrix/registration/Registration.ts","../../src/matrix/Client.js","../../src/domain/ViewModel.js","../../src/domain/avatar.js","../../src/domain/session/leftpanel/BaseTileViewModel.js","../../src/domain/session/leftpanel/RoomTileViewModel.js","../../src/domain/session/leftpanel/common.js","../../src/domain/session/leftpanel/InviteTileViewModel.js","../../src/domain/session/leftpanel/RoomBeingCreatedTileViewModel.js","../../src/domain/session/leftpanel/RoomFilter.js","../../src/observable/map/ApplyMap.js","../../src/domain/navigation/Navigation.js","../../src/domain/navigation/URLRouter.js","../../src/domain/navigation/index.js","../../src/domain/session/leftpanel/LeftPanelViewModel.js","../../src/domain/session/room/timeline/UpdateAction.js","../../src/domain/session/room/timeline/TilesCollection.js","../../src/domain/session/room/timeline/TimelineViewModel.js","../../src/domain/session/room/ComposerViewModel.js","../../src/domain/session/room/timeline/tiles/SimpleTile.js","../../src/domain/session/room/timeline/tiles/GapTile.js","../../src/domain/session/room/timeline/ReactionsViewModel.js","../../src/domain/session/room/timeline/tiles/BaseMessageTile.js","../../src/domain/session/room/timeline/linkify/regex.js","../../src/domain/session/room/timeline/linkify/linkify.js","../../src/domain/session/room/timeline/MessageBody.js","../../src/domain/session/room/timeline/tiles/BaseTextTile.js","../../src/domain/session/room/timeline/deserialize.js","../../src/domain/session/room/timeline/tiles/TextTile.js","../../src/domain/session/room/timeline/tiles/RedactedTile.js","../../src/domain/session/room/timeline/tiles/BaseMediaTile.js","../../src/domain/session/room/timeline/tiles/ImageTile.js","../../src/domain/session/room/timeline/tiles/VideoTile.js","../../src/utils/formatSize.ts","../../src/domain/session/room/timeline/tiles/FileTile.js","../../src/domain/session/room/timeline/tiles/LocationTile.js","../../src/domain/session/room/timeline/tiles/RoomNameTile.js","../../src/domain/session/room/timeline/tiles/RoomMemberTile.js","../../src/domain/session/room/timeline/tiles/EncryptedEventTile.js","../../src/domain/session/room/timeline/tiles/EncryptionEnabledTile.js","../../src/domain/session/room/timeline/tiles/MissingAttachmentTile.js","../../src/domain/session/room/timeline/tilesCreator.js","../../src/domain/session/common.js","../../src/domain/session/room/RoomViewModel.js","../../src/domain/session/room/UnknownRoomViewModel.js","../../src/domain/session/room/InviteViewModel.js","../../src/domain/session/room/RoomBeingCreatedViewModel.js","../../src/domain/session/room/LightboxViewModel.js","../../src/domain/session/SessionStatusViewModel.js","../../src/domain/session/RoomGridViewModel.js","../../src/domain/session/settings/KeyBackupViewModel.js","../../src/domain/session/settings/SettingsViewModel.js","../../src/domain/session/CreateRoomViewModel.js","../../src/domain/session/RoomViewModelObservable.js","../../src/domain/session/rightpanel/RoomDetailsViewModel.js","../../src/domain/session/rightpanel/MemberTileViewModel.js","../../src/domain/session/rightpanel/members/comparator.js","../../src/domain/session/rightpanel/members/disambiguator.js","../../src/domain/session/rightpanel/MemberListViewModel.js","../../src/domain/session/rightpanel/MemberDetailsViewModel.js","../../src/domain/session/rightpanel/RightPanelViewModel.js","../../src/domain/session/SessionViewModel.js","../../src/domain/AccountSetupViewModel.js","../../src/domain/SessionLoadViewModel.js","../../src/domain/login/PasswordLoginViewModel.js","../../src/domain/login/StartSSOLoginViewModel.js","../../src/domain/login/CompleteSSOLoginViewModel.js","../../src/domain/login/LoginViewModel.js","../../src/domain/LogoutViewModel.js","../../src/domain/SessionPickerViewModel.js","../../src/domain/RootViewModel.js","../../src/platform/web/main.js","../../src/utils/timeout.ts","../../src/platform/web/dom/request/common.js","../../src/platform/web/dom/request/xhr.js","../../src/platform/web/dom/request/fetch.js","../../src/matrix/sessioninfo/localstorage/SessionInfoStorage.ts","../../src/platform/web/dom/SettingsStorage.js","../../src/platform/web/dom/UTF8.js","../../src/platform/web/utils/Base64.js","../../src/platform/web/utils/Base58.js","../../src/platform/web/utils/Encoding.js","../../src/matrix/e2ee/OlmWorker.js","../../src/logging/LogItem.ts","../../src/logging/BaseLogger.ts","../../src/logging/IDBLogger.ts","../../src/logging/ConsoleLogger.ts","../../src/platform/web/ui/general/html.ts","../../src/platform/web/ui/general/utils.ts","../../src/platform/web/ui/general/ListView.ts","../../src/platform/web/ui/general/BaseUpdateView.ts","../../src/platform/web/ui/general/TemplateView.ts","../../src/platform/web/ui/avatar.js","../../src/platform/web/ui/AvatarView.js","../../src/platform/web/ui/common.js","../../src/platform/web/ui/session/leftpanel/RoomTileView.js","../../src/platform/web/ui/session/leftpanel/LeftPanelView.js","../../src/platform/web/ui/general/Popup.js","../../src/platform/web/ui/general/Menu.js","../../src/platform/web/ui/session/room/timeline/ReactionsView.js","../../src/platform/web/ui/session/room/timeline/BaseMessageView.js","../../src/platform/web/ui/session/room/timeline/ReplyPreviewView.js","../../src/platform/web/ui/session/room/timeline/TextMessageView.js","../../src/platform/web/ui/session/room/timeline/BaseMediaView.js","../../src/platform/web/ui/session/room/timeline/ImageView.js","../../src/platform/web/dom/utils.js","../../src/platform/web/ui/session/room/timeline/VideoView.js","../../src/platform/web/ui/session/room/timeline/FileView.js","../../src/platform/web/ui/session/room/timeline/LocationView.js","../../src/platform/web/ui/session/room/timeline/MissingAttachmentView.js","../../src/platform/web/ui/session/room/timeline/AnnouncementView.js","../../src/platform/web/ui/session/room/timeline/RedactedView.js","../../src/platform/web/ui/session/room/timeline/GapView.js","../../src/platform/web/ui/session/room/common.ts","../../src/platform/web/ui/session/room/TimelineView.ts","../../src/platform/web/ui/session/room/TimelineLoadingView.js","../../src/platform/web/ui/session/room/MessageComposer.js","../../src/platform/web/ui/session/room/RoomArchivedView.js","../../src/platform/web/ui/session/room/RoomView.js","../../src/platform/web/ui/session/room/UnknownRoomView.js","../../src/platform/web/ui/general/StaticView.js","../../src/platform/web/ui/general/LoadingView.js","../../src/platform/web/ui/session/room/RoomBeingCreatedView.js","../../src/platform/web/ui/session/room/InviteView.js","../../src/platform/web/ui/session/room/LightboxView.js","../../src/platform/web/ui/session/SessionStatusView.js","../../src/platform/web/ui/session/RoomGridView.js","../../src/platform/web/ui/session/settings/KeyBackupSettingsView.js","../../src/platform/web/ui/session/settings/SettingsView.js","../../src/platform/web/ui/session/CreateRoomView.js","../../src/platform/web/ui/session/rightpanel/RoomDetailsView.js","../../src/platform/web/ui/general/Range.ts","../../src/platform/web/ui/general/ListRange.ts","../../src/platform/web/ui/general/LazyListView.ts","../../src/platform/web/ui/session/rightpanel/MemberTileView.js","../../src/platform/web/ui/session/rightpanel/MemberListView.js","../../src/platform/web/ui/session/rightpanel/MemberDetailsView.js","../../src/platform/web/ui/session/rightpanel/RightPanelView.js","../../src/platform/web/ui/session/SessionView.js","../../src/platform/web/ui/login/common.js","../../src/platform/web/ui/login/PasswordLoginView.js","../../src/platform/web/ui/login/AccountSetupView.js","../../src/platform/web/ui/login/SessionLoadStatusView.js","../../src/platform/web/ui/login/CompleteSSOView.js","../../src/platform/web/ui/login/LoginView.js","../../src/platform/web/ui/LogoutView.js","../../src/platform/web/ui/login/SessionLoadView.js","../../src/platform/web/ui/login/SessionPickerView.js","../../src/platform/web/ui/RootView.js","../../src/platform/web/dom/Clock.js","../../src/platform/web/dom/ServiceWorkerHandler.js","../../src/platform/web/dom/NotificationService.js","../../src/platform/web/dom/History.js","../../src/platform/web/dom/OnlineStatus.js","../../src/platform/web/dom/Crypto.js","../../src/platform/web/dom/StorageEstimate.js","../../src/platform/web/dom/WorkerPool.js","../../src/platform/web/dom/ImageHandle.js","../../src/platform/web/dom/download.js","../../src/platform/web/parsehtml.js","../../src/platform/web/Platform.js","../../src/platform/web/assets/config.json?raw","../../src/platform/web/assets/download-sandbox.html?url","../../src/platform/web/worker/main.js?url","../../src/platform/web/sdk/paths/vite.js","../../src/platform/web/index.html?html-proxy&index=0.js"],"sourcesContent":["/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function createEnum(...values: string[]): Readonly<{}> {\n    const obj = {};\n    for (const value of values) {\n        obj[value] = value;\n    }\n    return Object.freeze(obj);\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nfunction normalizeHomeserver(homeserver) {\n    try {\n        return new URL(homeserver).origin;\n    } catch (err) {\n        return new URL(`https://${homeserver}`).origin;\n    }\n}\n\nasync function getWellKnownResponse(homeserver, request) {\n    const requestOptions = {format: \"json\", timeout: 30000, method: \"GET\"};\n    try {\n        const wellKnownUrl = `${homeserver}/.well-known/matrix/client`;\n        return await request(wellKnownUrl, requestOptions).response();\n    } catch (err) {\n        if (err.name === \"ConnectionError\") {\n            // don't fail lookup on a ConnectionError,\n            // there might be a missing CORS header on a 404 response or something,\n            // which won't be a problem necessarily with homeserver requests later on ...\n            return null;\n        } else {\n            throw err;\n        }\n    }\n}\n\nexport async function lookupHomeserver(homeserver, request) {\n    homeserver = normalizeHomeserver(homeserver);\n    const wellKnownResponse = await getWellKnownResponse(homeserver, request);\n    if (wellKnownResponse && wellKnownResponse.status === 200) {\n        const {body} = wellKnownResponse;\n        const wellKnownHomeserver = body[\"m.homeserver\"]?.[\"base_url\"];\n        if (typeof wellKnownHomeserver === \"string\") {\n            homeserver = normalizeHomeserver(wellKnownHomeserver);\n        }\n    }\n    return homeserver;\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class AbortError extends Error {\n    get name(): string {\n        return \"AbortError\";\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// we return undefined so you can reassign any member\n// that uses `member?: T` syntax in one statement.\nexport type SubscriptionHandle = () => undefined;\n\nexport abstract class BaseObservable<T> {\n    protected _handlers: Set<T> = new Set<T>();\n\n    onSubscribeFirst(): void {\n\n    }\n\n    onUnsubscribeLast(): void {\n\n    }\n\n    subscribe(handler: T): SubscriptionHandle {\n        this._handlers.add(handler);\n        if (this._handlers.size === 1) {\n            this.onSubscribeFirst();\n        }\n        return () => {\n            return this.unsubscribe(handler);\n        };\n    }\n\n    unsubscribe(handler?: T): undefined {\n        if (handler) {\n            this._handlers.delete(handler);\n            if (this._handlers.size === 0) {\n                this.onUnsubscribeLast();\n            }\n        }\n        return undefined;\n    }\n\n    unsubscribeAll(): void {\n        if (this._handlers.size !== 0) {\n            this._handlers.clear();\n            this.onUnsubscribeLast();\n        }\n    }\n\n    get hasSubscriptions(): boolean {\n        return this._handlers.size !== 0;\n    }\n\n    // Add iterator over handlers here\n}\n\nexport function tests() {\n    class Collection extends BaseObservable<{}> {\n        firstSubscribeCalls: number = 0;\n        firstUnsubscribeCalls: number = 0;\n\n        onSubscribeFirst() { this.firstSubscribeCalls += 1; }\n        onUnsubscribeLast() { this.firstUnsubscribeCalls += 1; }\n    }\n\n    return {\n        test_unsubscribe(assert) {\n            const c = new Collection();\n            const unsubscribe = c.subscribe({});\n            unsubscribe();\n            assert.equal(c.firstSubscribeCalls, 1);\n            assert.equal(c.firstUnsubscribeCalls, 1);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {AbortError} from \"../utils/error\";\nimport {BaseObservable} from \"./BaseObservable\";\nimport type {SubscriptionHandle} from \"./BaseObservable\";\n\n// like an EventEmitter, but doesn't have an event type\nexport abstract class BaseObservableValue<T> extends BaseObservable<(value: T) => void> {\n    emit(argument: T) {\n        for (const h of this._handlers) {\n            h(argument);\n        }\n    }\n\n    abstract get(): T;\n\n    waitFor(predicate: (value: T) => boolean): IWaitHandle<T> {\n        if (predicate(this.get())) {\n            return new ResolvedWaitForHandle(Promise.resolve(this.get()));\n        } else {\n            return new WaitForHandle(this, predicate);\n        }\n    }\n\n    flatMap<C>(mapper: (value: T) => (BaseObservableValue<C> | undefined)): BaseObservableValue<C | undefined> {\n        return new FlatMapObservableValue<T, C>(this, mapper);\n    }\n}\n\ninterface IWaitHandle<T> {\n    promise: Promise<T>;\n    dispose(): void;\n}\n\nclass WaitForHandle<T> implements IWaitHandle<T> {\n    private _promise: Promise<T>\n    private _reject: ((reason?: any) => void) | null;\n    private _subscription: (() => void) | null;\n\n    constructor(observable: BaseObservableValue<T>, predicate: (value: T) => boolean) {\n        this._promise = new Promise((resolve, reject) => {\n            this._reject = reject;\n            this._subscription = observable.subscribe(v => {\n                if (predicate(v)) {\n                    this._reject = null;\n                    resolve(v);\n                    this.dispose();\n                }\n            });\n        });\n    }\n\n    get promise(): Promise<T> {\n        return this._promise;\n    }\n\n    dispose() {\n        if (this._subscription) {\n            this._subscription();\n            this._subscription = null;\n        }\n        if (this._reject) {\n            this._reject(new AbortError());\n            this._reject = null;\n        }\n    }\n}\n\nclass ResolvedWaitForHandle<T> implements IWaitHandle<T> {\n    constructor(public promise: Promise<T>) {}\n    dispose() {}\n}\n\nexport class ObservableValue<T> extends BaseObservableValue<T> {\n    private _value: T;\n\n    constructor(initialValue: T) {\n        super();\n        this._value = initialValue;\n    }\n\n    get(): T {\n        return this._value;\n    }\n\n    set(value: T): void {\n        if (value !== this._value) {\n            this._value = value;\n            this.emit(this._value);\n        }\n    }\n}\n\nexport class RetainedObservableValue<T> extends ObservableValue<T> {\n    private _freeCallback: () => void;\n\n    constructor(initialValue: T, freeCallback: () => void) {\n        super(initialValue);\n        this._freeCallback = freeCallback;\n    }\n\n    onUnsubscribeLast() {\n        super.onUnsubscribeLast();\n        this._freeCallback();\n    }\n}\n\nexport class FlatMapObservableValue<P, C> extends BaseObservableValue<C | undefined> {\n    private sourceSubscription?: SubscriptionHandle;\n    private targetSubscription?: SubscriptionHandle;\n\n    constructor(\n        private readonly source: BaseObservableValue<P>,\n        private readonly mapper: (value: P) => (BaseObservableValue<C> | undefined)\n    ) {\n        super();\n    }\n\n    onUnsubscribeLast() {\n        super.onUnsubscribeLast();\n        this.sourceSubscription = this.sourceSubscription!();\n        if (this.targetSubscription) {\n            this.targetSubscription = this.targetSubscription();\n        }\n    }\n\n    onSubscribeFirst() {\n        super.onSubscribeFirst();\n        this.sourceSubscription = this.source.subscribe(() => {\n            this.updateTargetSubscription();\n            this.emit(this.get());\n        });\n        this.updateTargetSubscription();\n    }\n\n    private updateTargetSubscription() {\n        const sourceValue = this.source.get();\n        if (sourceValue) {\n            const target = this.mapper(sourceValue);\n            if (target) {\n                if (!this.targetSubscription) {\n                    this.targetSubscription = target.subscribe(() => this.emit(this.get()));\n                }\n                return;\n            }\n        }\n        // if no sourceValue or target\n        if (this.targetSubscription) {\n            this.targetSubscription = this.targetSubscription();\n        }\n    }\n\n    get(): C | undefined {\n        const sourceValue = this.source.get();\n        if (!sourceValue) {\n            return undefined;\n        }\n        const mapped = this.mapper(sourceValue);\n        return mapped?.get();\n    }\n}\n\nexport function tests() {\n    return {\n        \"set emits an update\": assert => {\n            const a = new ObservableValue<number>(0);\n            let fired = false;\n            const subscription = a.subscribe(v => {\n                fired = true;\n                assert.strictEqual(v, 5);\n            });\n            a.set(5);\n            assert(fired);\n            subscription();\n        },\n        \"set doesn't emit if value hasn't changed\": assert => {\n            const a = new ObservableValue(5);\n            let fired = false;\n            const subscription = a.subscribe(() => {\n                fired = true;\n            });\n            a.set(5);\n            a.set(5);\n            assert(!fired);\n            subscription();\n        },\n        \"waitFor promise resolves on matching update\": async assert => {\n            const a = new ObservableValue(5);\n            const handle = a.waitFor(v => v === 6);\n            Promise.resolve().then(() => {\n                a.set(6);\n            });\n            await handle.promise;\n            assert.strictEqual(a.get(), 6);\n        },\n        \"waitFor promise rejects when disposed\": async assert => {\n            const a = new ObservableValue<number>(0);\n            const handle = a.waitFor(() => false);\n            Promise.resolve().then(() => {\n                handle.dispose();\n            });\n            await assert.rejects(handle.promise, AbortError);\n        },\n        \"flatMap.get\": assert => {\n            const a = new ObservableValue<undefined | {count: ObservableValue<number>}>(undefined);\n            const countProxy = a.flatMap(a => a!.count);\n            assert.strictEqual(countProxy.get(), undefined);\n            const count = new ObservableValue<number>(0);\n            a.set({count});\n            assert.strictEqual(countProxy.get(), 0);\n        },\n        \"flatMap update from source\": assert => {\n            const a = new ObservableValue<undefined | {count: ObservableValue<number>}>(undefined);\n            const updates: (number | undefined)[] = [];\n            a.flatMap(a => a!.count).subscribe(count => {\n                updates.push(count);\n            });\n            const count = new ObservableValue<number>(0);\n            a.set({count});\n            assert.deepEqual(updates, [0]);\n        },\n        \"flatMap update from target\": assert => {\n            const a = new ObservableValue<undefined | {count: ObservableValue<number>}>(undefined);\n            const updates: (number | undefined)[] = [];\n            a.flatMap(a => a!.count).subscribe(count => {\n                updates.push(count);\n            });\n            const count = new ObservableValue<number>(0);\n            a.set({count});\n            count.set(5);\n            assert.deepEqual(updates, [0, 5]);\n        }\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableValue, ObservableValue} from \"../observable/ObservableValue\";\n\nexport interface IAbortable {\n    abort();\n}\n\nexport type SetAbortableFn = (a: IAbortable) => typeof a;\nexport type SetProgressFn<P> = (progress: P) => void;\ntype RunFn<T, P> = (setAbortable: SetAbortableFn, setProgress: SetProgressFn<P>) => T;\n\nexport class AbortableOperation<T, P = void> implements IAbortable {\n    public readonly result: T;\n    private _abortable?: IAbortable;\n    private _progress: ObservableValue<P | undefined>;\n\n    constructor(run: RunFn<T, P>) {\n        this._abortable = undefined;\n        const setAbortable: SetAbortableFn = abortable => {\n            this._abortable = abortable;\n            return abortable;\n        };\n        this._progress = new ObservableValue<P | undefined>(undefined);\n        const setProgress: SetProgressFn<P> = (progress: P) => {\n            this._progress.set(progress);\n        };\n        this.result = run(setAbortable, setProgress);\n    }\n\n    get progress(): BaseObservableValue<P | undefined> {\n        return this._progress;\n    }\n\n    abort() {\n        this._abortable?.abort();\n        this._abortable = undefined;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n// WARNING: We have to be very careful about what mime-types we allow into blobs.\n//\n// This means that the content is rendered using the origin of the script which\n// called createObjectURL(), and so if the content contains any scripting then it\n// will pose a XSS vulnerability when the browser renders it.  This is particularly\n// bad if the user right-clicks the URI and pastes it into a new window or tab,\n// as the blob will then execute with access to Element's full JS environment(!)\n//\n// See https://github.com/matrix-org/matrix-react-sdk/pull/1820#issuecomment-385210647\n// for details.\n//\n// We mitigate this by only allowing mime-types into blobs which we know don't\n// contain any scripting, and instantiate all others as application/octet-stream\n// regardless of what mime-type the event claimed.  Even if the payload itself\n// is some malicious HTML, the fact we instantiate it with a media mimetype or\n// application/octet-stream means the browser doesn't try to render it as such.\n//\n// One interesting edge case is image/svg+xml, which empirically *is* rendered\n// correctly if the blob is set to the src attribute of an img tag (for thumbnails)\n// *even if the mimetype is application/octet-stream*.  However, empirically JS\n// in the SVG isn't executed in this scenario, so we seem to be okay.\n//\n// Tested on Chrome 65 and Firefox 60\n//\n// The list below is taken mainly from\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats\n// N.B. Matrix doesn't currently specify which mimetypes are valid in given\n// events, so we pick the ones which HTML5 browsers should be able to display\n//\n// For the record, mime-types which must NEVER enter this list below include:\n//   text/html, text/xhtml, image/svg, image/svg+xml, image/pdf, and similar.\n\nconst ALLOWED_BLOB_MIMETYPES = {\n    'image/jpeg': true,\n    'image/gif': true,\n    'image/png': true,\n\n    'video/mp4': true,\n    'video/webm': true,\n    'video/ogg': true,\n    'video/quicktime': true,\n    'video/VP8': true,\n\n    'audio/mp4': true,\n    'audio/webm': true,\n    'audio/aac': true,\n    'audio/mpeg': true,\n    'audio/ogg': true,\n    'audio/wave': true,\n    'audio/wav': true,\n    'audio/x-wav': true,\n    'audio/x-pn-wav': true,\n    'audio/flac': true,\n    'audio/x-flac': true,\n};\n\nconst DEFAULT_MIMETYPE = 'application/octet-stream';\n\nexport class BlobHandle {\n    constructor(blob, buffer = null) {\n        this._blob = blob;\n        this._buffer = buffer;\n        this._url = null;\n    }\n\n    static fromBuffer(buffer, mimetype) {\n        mimetype = mimetype ? mimetype.split(\";\")[0].trim() : '';\n        if (!ALLOWED_BLOB_MIMETYPES[mimetype]) {\n            mimetype = DEFAULT_MIMETYPE;\n        }\n        return new BlobHandle(new Blob([buffer], {type: mimetype}), buffer);\n    }\n\n    static fromBlob(blob) {\n        // ok to not filter mimetypes as these are local files\n        return new BlobHandle(blob);\n    }\n\n    get nativeBlob() {\n        return this._blob;\n    }\n\n    async readAsBuffer() {\n        if (this._buffer) {\n            return this._buffer;\n        } else {\n            const reader = new FileReader();\n            const promise = new Promise((resolve, reject) => {\n                reader.addEventListener(\"load\", evt => resolve(evt.target.result)); \n                reader.addEventListener(\"error\", evt => reject(evt.target.error)); \n            });\n            reader.readAsArrayBuffer(this._blob);\n            return promise;\n        }\n    }\n\n    get url() {\n        if (!this._url) {\n             this._url = URL.createObjectURL(this._blob);\n        }\n        return this._url;\n    }\n\n    get size() {\n        return this._blob.size;\n    }\n\n    get mimeType() {\n        return this._blob.type || DEFAULT_MIMETYPE;\n    }\n\n    dispose() {\n        if (this._url) {\n            URL.revokeObjectURL(this._url);\n            this._url = null;\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BlobHandle} from \"../../platform/web/dom/BlobHandle.js\";\n\nexport type EncodedBody = {\n    mimeType: string;\n    body: BlobHandle | string;\n}\n\nexport function encodeQueryParams(queryParams?: object): string {\n    return Object.entries(queryParams || {})\n        .filter(([, value]) => value !== undefined)\n        .map(([name, value]) => {\n            if (typeof value === \"object\") {\n                value = JSON.stringify(value);\n            }\n            return `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;\n        })\n        .join(\"&\");\n}\n\nexport function encodeBody(body: BlobHandle | object): EncodedBody {\n    if (body instanceof BlobHandle) {\n        const blob = body as BlobHandle;\n        return {\n            mimeType: blob.mimeType,\n            body: blob // will be unwrapped in request fn\n        };\n    } else if (typeof body === \"object\") {\n        const json = JSON.stringify(body);\n        return {\n            mimeType: \"application/json\",\n            body: json\n        }\n    } else {\n        throw new Error(\"Unknown body type: \" + body);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class WrappedError extends Error {\n    constructor(message, cause) {\n        super(`${message}: ${cause.message}`);\n        this.cause = cause;\n    }\n\n    get name() {\n        return \"WrappedError\";\n    }\n}\n\nexport class HomeServerError extends Error {\n    constructor(method, url, body, status) {\n        super(`${body ? body.error : status} on ${method} ${url}`);\n        this.errcode = body ? body.errcode : null;\n        this.retry_after_ms = body ? body.retry_after_ms : 0;\n        this.statusCode = status;\n    }\n\n    get name() {\n        return \"HomeServerError\";\n    }\n}\n\nexport {AbortError} from \"../utils/error\";\n\nexport class ConnectionError extends Error {\n    constructor(message, isTimeout) {\n        super(message || \"ConnectionError\");\n        this.isTimeout = isTimeout;\n    }\n\n    get name() {\n        return \"ConnectionError\";\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {HomeServerError, ConnectionError} from \"../error.js\";\nimport type {RequestResult} from \"../../platform/web/dom/request/fetch.js\";\nimport type {ILogItem} from \"../../logging/types\";\n\nexport interface IHomeServerRequest {\n    abort(): void;\n    response(): Promise<any>;\n    responseCode(): Promise<number>;\n}\n\ntype HomeServerRequestOptions = {\n    log?: ILogItem;\n    allowedStatusCodes?: number[];\n};\n\nexport class HomeServerRequest implements IHomeServerRequest {\n    private readonly _log?: ILogItem;\n    private _sourceRequest?: RequestResult;\n    // as we add types for expected responses from hs, this could be a generic class instead\n    private readonly _promise: Promise<any>;\n\n    constructor(method: string, url: string, sourceRequest: RequestResult, options?: HomeServerRequestOptions) {\n        let log: ILogItem | undefined;\n        if (options?.log) {\n            const parent = options?.log;\n            log = parent.child({ t: \"network\", url, method, }, parent.level.Info);\n        }\n        this._log = log;\n        this._sourceRequest = sourceRequest;\n        this._promise = sourceRequest.response().then(response => {\n            log?.set(\"status\", response.status);\n            // ok?\n            if (response.status >= 200 && response.status < 300 || options?.allowedStatusCodes?.includes(response.status)) {\n                log?.finish();\n                return response.body;\n            } else {\n                if (response.status >= 500) {\n                    const err = new ConnectionError(`Internal Server Error`);\n                    log?.catch(err);\n                    throw err;\n                } else if (response.status >= 400 && !response.body?.errcode) {\n                    const err = new ConnectionError(`HTTP error status ${response.status} without errcode in body, assume this is a load balancer complaining the server is offline.`);\n                    log?.catch(err);\n                    throw err;\n                } else {\n                    const err = new HomeServerError(method, url, response.body, response.status);\n                    log?.set(\"errcode\", err.errcode);\n                    log?.catch(err);\n                    throw err;\n                }\n            }\n        }, err => {\n            // if this._sourceRequest is still set,\n            // the abort error came not from calling abort here\n            if (err.name === \"AbortError\" && this._sourceRequest) {\n                // The service worker sometimes (only on Firefox, on long, large request,\n                // perhaps it has its own timeout?) aborts the request, see #187.\n                // When it happens, the best thing to do seems to be to retry.\n                // \n                // In the service worker, we will also actively abort all\n                // ongoing requests when trying to get a new service worker to activate\n                // (this may surface in the app as a TypeError, which already gets mapped\n                // to a ConnectionError in the request function, or an AbortError,\n                // depending on the browser), as the service worker will only be\n                // replaced when there are no more (fetch) events for the\n                // current one to handle.\n                // \n                // In that case, the request function (in fetch.js) will check \n                // the haltRequests flag on the service worker handler, and\n                // block any new requests, as that would break the update process.\n                // \n                // So it is OK to return a ConnectionError here.\n                // If we're updating the service worker, the /versions polling will\n                // be blocked at the fetch level because haltRequests is set.\n                // And for #187, retrying is the right thing to do.\n                const err = new ConnectionError(`Service worker aborted, either updating or hit #187.`);\n                log?.catch(err);\n                throw err;\n            } else {\n                if (err.name === \"ConnectionError\") {\n                    log?.set(\"timeout\", err.isTimeout);\n                }\n                log?.catch(err);\n                throw err;\n            }\n        });\n    }\n\n    abort(): void {\n        if (this._sourceRequest) {\n            this._log?.set(\"aborted\", true);\n            this._sourceRequest.abort();\n            // to mark that it was on purpose in above rejection handler\n            this._sourceRequest = undefined;\n        }\n    }\n\n    response(): Promise<any> {\n        return this._promise;\n    }\n\n    async responseCode(): Promise<number> {\n        const response = await this._sourceRequest.response();\n        return response.status;\n    }\n}\n\nimport {Request as MockRequest} from \"../../mocks/Request.js\";\nimport {AbortError} from \"../error.js\";\n\nexport function tests() {\n    return {\n        \"Response is passed through\": async assert => {\n            const request = new MockRequest();\n            const hsRequest = new HomeServerRequest(\"GET\", \"https://hs.tld/foo\", request);\n            request.respond(200, \"foo\");\n            assert.equal(await hsRequest.response(), \"foo\");\n        },\n        \"Unexpected AbortError is mapped to ConnectionError\": async assert => {\n            const request = new MockRequest();\n            const hsRequest = new HomeServerRequest(\"GET\", \"https://hs.tld/foo\", request);\n            request.reject(new AbortError());\n            await assert.rejects(hsRequest.response(), ConnectionError);\n        },\n        \"500 response is mapped to ConnectionError\": async assert => {\n            const request = new MockRequest();\n            const hsRequest = new HomeServerRequest(\"GET\", \"https://hs.tld/foo\", request);\n            request.respond(500);\n            await assert.rejects(hsRequest.response(), ConnectionError);\n        },\n        \"4xx response is mapped to HomeServerError\": async assert => {\n            const request = new MockRequest();\n            const hsRequest = new HomeServerRequest(\"GET\", \"https://hs.tld/foo\", request);\n            request.respond(400, {errcode: \"FOO\"});\n            await assert.rejects(hsRequest.response(), HomeServerError);\n        },\n        \"4xx response without errcode is mapped to ConnectionError\": async assert => {\n            const request = new MockRequest();\n            const hsRequest = new HomeServerRequest(\"GET\", \"https://hs.tld/foo\", request);\n            request.respond(400);\n            await assert.rejects(hsRequest.response(), ConnectionError);\n        },\n        \"Other errors are passed through\": async assert => {\n            class MyError extends Error {}\n            const request = new MockRequest();\n            const hsRequest = new HomeServerRequest(\"GET\", \"https://hs.tld/foo\", request);\n            request.reject(new MyError());\n            await assert.rejects(hsRequest.response(), MyError);\n        },\n    };\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {encodeQueryParams, encodeBody} from \"./common\";\nimport {HomeServerRequest} from \"./HomeServerRequest\";\nimport type {IHomeServerRequest} from \"./HomeServerRequest\";\nimport type {Reconnector} from \"./Reconnector\";\nimport type {EncodedBody} from \"./common\";\nimport type {RequestFunction} from \"../../platform/types/types\";\nimport type {ILogItem} from \"../../logging/types\";\n\ntype RequestMethod = \"POST\" | \"GET\" | \"PUT\";\n\nconst CS_R0_PREFIX = \"/_matrix/client/r0\";\nconst CS_V3_PREFIX = \"/_matrix/client/v3\";\nconst DEHYDRATION_PREFIX = \"/_matrix/client/unstable/org.matrix.msc2697.v2\";\n\ntype Options = {\n    homeserver: string;\n    accessToken: string;\n    request: RequestFunction;\n    reconnector: Reconnector;\n};\n\ntype BaseRequestOptions = {\n    log?: ILogItem;\n    allowedStatusCodes?: number[];\n    uploadProgress?: (loadedBytes: number) => void;\n    timeout?: number;\n    prefix?: string;\n};\n\nexport class HomeServerApi {\n    private readonly _homeserver: string;\n    private readonly _accessToken: string;\n    private readonly _requestFn: RequestFunction;\n    private readonly _reconnector: Reconnector;\n\n    constructor({homeserver, accessToken, request, reconnector}: Options) {\n        // store these both in a closure somehow so it's harder to get at in case of XSS?\n        // one could change the homeserver as well so the token gets sent there, so both must be protected from read/write\n        this._homeserver = homeserver;\n        this._accessToken = accessToken;\n        this._requestFn = request;\n        this._reconnector = reconnector;\n    }\n\n    private _url(csPath: string, prefix: string = CS_R0_PREFIX): string {\n        return this._homeserver + prefix + csPath;\n    }\n\n    private _baseRequest(method: RequestMethod, url: string, queryParams?: Record<string, any>, body?: Record<string, any>, options?: BaseRequestOptions, accessToken?: string): IHomeServerRequest {\n        const queryString = encodeQueryParams(queryParams);\n        url = `${url}?${queryString}`;\n        let encodedBody: EncodedBody[\"body\"];\n        const headers: Map<string, string | number> = new Map();\n        if (accessToken) {\n            headers.set(\"Authorization\", `Bearer ${accessToken}`);\n        }\n        headers.set(\"Accept\", \"application/json\");\n        if (body) {\n            const encoded = encodeBody(body);\n            headers.set(\"Content-Type\", encoded.mimeType);\n            encodedBody = encoded.body;\n        }\n\n        const requestResult = this._requestFn(url, {\n            method,\n            headers,\n            body: encodedBody,\n            timeout: options?.timeout,\n            uploadProgress: options?.uploadProgress,\n            format: \"json\",  // response format\n            cache: method !== \"GET\",\n        });\n\n        const hsRequest = new HomeServerRequest(method, url, requestResult, options);\n        \n        if (this._reconnector) {\n            hsRequest.response().catch(err => {\n                // Some endpoints such as /sync legitimately time-out\n                // (which is also reported as a ConnectionError) and will re-attempt,\n                // but spinning up the reconnector in this case is ok,\n                // as all code ran on session and sync start should be reentrant\n                if (err.name === \"ConnectionError\") {\n                    this._reconnector.onRequestFailed(this);\n                }\n            });\n        }\n\n        return hsRequest;\n    }\n\n    private _unauthedRequest(method: RequestMethod, url: string, queryParams?: Record<string, any>, body?: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._baseRequest(method, url, queryParams, body, options);\n    }\n\n    private _authedRequest(method: RequestMethod, url: string, queryParams?: Record<string, any>, body?: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._baseRequest(method, url, queryParams, body, options, this._accessToken);\n    }\n\n    private _post(csPath: string, queryParams: Record<string, any>, body: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._authedRequest(\"POST\", this._url(csPath, options?.prefix || CS_R0_PREFIX), queryParams, body, options);\n    }\n\n    private _put(csPath: string, queryParams: Record<string, any>, body?: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._authedRequest(\"PUT\", this._url(csPath, options?.prefix || CS_R0_PREFIX), queryParams, body, options);\n    }\n\n    private _get(csPath: string, queryParams?: Record<string, any>, body?: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._authedRequest(\"GET\", this._url(csPath, options?.prefix || CS_R0_PREFIX), queryParams, body, options);\n    }\n\n    sync(since: string, filter: string, timeout: number, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._get(\"/sync\", {since, timeout, filter}, undefined, options);\n    }\n\n    context(roomId: string, eventId: string, limit: number, filter: string): IHomeServerRequest {\n        return this._get(`/rooms/${encodeURIComponent(roomId)}/context/${encodeURIComponent(eventId)}`, {filter, limit});\n    }\n\n    // params is from, dir and optionally to, limit, filter.\n    messages(roomId: string, params: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._get(`/rooms/${encodeURIComponent(roomId)}/messages`, params, undefined, options);\n    }\n\n    // params is at, membership and not_membership\n    members(roomId: string, params: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._get(`/rooms/${encodeURIComponent(roomId)}/members`, params, undefined, options);\n    }\n\n    send(roomId: string, eventType: string, txnId: string, content: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._put(`/rooms/${encodeURIComponent(roomId)}/send/${encodeURIComponent(eventType)}/${encodeURIComponent(txnId)}`, {}, content, options);\n    }\n\n    redact(roomId: string, eventId: string, txnId: string, content: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._put(`/rooms/${encodeURIComponent(roomId)}/redact/${encodeURIComponent(eventId)}/${encodeURIComponent(txnId)}`, {}, content, options);\n    }\n\n    receipt(roomId: string, receiptType: string, eventId: string, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._post(`/rooms/${encodeURIComponent(roomId)}/receipt/${encodeURIComponent(receiptType)}/${encodeURIComponent(eventId)}`,\n            {}, {}, options);\n    }\n\n    state(roomId: string, eventType: string, stateKey: string, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._get(`/rooms/${encodeURIComponent(roomId)}/state/${encodeURIComponent(eventType)}/${encodeURIComponent(stateKey)}`, {}, undefined, options);\n    }\n\n    getLoginFlows(): IHomeServerRequest {\n        return this._unauthedRequest(\"GET\", this._url(\"/login\"));\n    }\n\n    register(username: string | null, password: string, initialDeviceDisplayName: string, auth?: Record<string, any>, inhibitLogin: boolean = true , options: BaseRequestOptions = {}): IHomeServerRequest {\n        options.allowedStatusCodes = [401];\n        const body: any = {\n            auth,\n            password,\n            initial_device_displayname: initialDeviceDisplayName,\n            inhibit_login: inhibitLogin,\n        };\n        if (username) {\n            // username is optional for registration\n            body.username = username;\n        }\n        return this._unauthedRequest( \"POST\", this._url(\"/register\", CS_V3_PREFIX), undefined, body, options);\n    }\n\n    passwordLogin(username: string, password: string, initialDeviceDisplayName: string, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._unauthedRequest(\"POST\", this._url(\"/login\"), undefined, {\n          \"type\": \"m.login.password\",\n          \"identifier\": {\n            \"type\": \"m.id.user\",\n            \"user\": username\n          },\n          \"password\": password,\n          \"initial_device_display_name\": initialDeviceDisplayName\n        }, options);\n    }\n\n    tokenLogin(loginToken: string, txnId: string, initialDeviceDisplayName: string, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._unauthedRequest(\"POST\", this._url(\"/login\"), undefined, {\n          \"type\": \"m.login.token\",\n          \"identifier\": {\n            \"type\": \"m.id.user\",\n          },\n          \"token\": loginToken,\n          \"txn_id\": txnId,\n          \"initial_device_display_name\": initialDeviceDisplayName\n        }, options);\n    }\n\n    createFilter(userId: string, filter: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._post(`/user/${encodeURIComponent(userId)}/filter`, {}, filter, options);\n    }\n\n    versions(options?: BaseRequestOptions): IHomeServerRequest {\n        return this._unauthedRequest(\"GET\", `${this._homeserver}/_matrix/client/versions`, undefined, undefined, options);\n    }\n\n    uploadKeys(dehydratedDeviceId: string, payload: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        let path = \"/keys/upload\";\n        if (dehydratedDeviceId) {\n            path = path + `/${encodeURIComponent(dehydratedDeviceId)}`;\n        }\n        return this._post(path, {}, payload, options);\n    }\n\n    queryKeys(queryRequest: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._post(\"/keys/query\", {}, queryRequest, options);\n    }\n\n    claimKeys(payload: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._post(\"/keys/claim\", {}, payload, options);\n    }\n\n    sendToDevice(type: string, payload: Record<string, any>, txnId: string, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._put(`/sendToDevice/${encodeURIComponent(type)}/${encodeURIComponent(txnId)}`, {}, payload, options);\n    }\n    \n    roomKeysVersion(version?: string, options?: BaseRequestOptions): IHomeServerRequest {\n        let versionPart = \"\";\n        if (version) {\n            versionPart = `/${encodeURIComponent(version)}`;\n        }\n        return this._get(`/room_keys/version${versionPart}`, undefined, undefined, options);\n    }\n\n    roomKeyForRoomAndSession(version: string, roomId: string, sessionId: string, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._get(`/room_keys/keys/${encodeURIComponent(roomId)}/${encodeURIComponent(sessionId)}`, {version}, undefined, options);\n    }\n\n    uploadRoomKeysToBackup(version: string, payload: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._put(`/room_keys/keys`, {version}, payload, options);\n    }\n\n    uploadAttachment(blob: Blob, filename: string, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._authedRequest(\"POST\", `${this._homeserver}/_matrix/media/r0/upload`, {filename}, blob, options);\n    }\n\n    setPusher(pusher: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._post(\"/pushers/set\", {}, pusher, options);\n    }\n\n    getPushers(options?: BaseRequestOptions): IHomeServerRequest {\n        return this._get(\"/pushers\", undefined, undefined, options);\n    }\n\n    join(roomId: string, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._post(`/rooms/${encodeURIComponent(roomId)}/join`, {}, {}, options);\n    }\n\n    joinIdOrAlias(roomIdOrAlias: string, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._post(`/join/${encodeURIComponent(roomIdOrAlias)}`, {}, {}, options);\n    }\n\n    leave(roomId: string, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._post(`/rooms/${encodeURIComponent(roomId)}/leave`, {}, {}, options);\n    }\n\n    forget(roomId: string, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._post(`/rooms/${encodeURIComponent(roomId)}/forget`, {}, {}, options);\n    }\n\n    logout(options?: BaseRequestOptions): IHomeServerRequest {\n        return this._post(`/logout`, {}, {}, options);\n    }\n\n    getDehydratedDevice(options: BaseRequestOptions = {}): IHomeServerRequest {\n        options.prefix = DEHYDRATION_PREFIX;\n        return this._get(`/dehydrated_device`, undefined, undefined, options);\n    }\n\n    createDehydratedDevice(payload: Record<string, any>, options: BaseRequestOptions = {}): IHomeServerRequest {\n        options.prefix = DEHYDRATION_PREFIX;\n        return this._put(`/dehydrated_device`, {}, payload, options);\n    }\n\n    claimDehydratedDevice(deviceId: string, options: BaseRequestOptions = {}): IHomeServerRequest {\n        options.prefix = DEHYDRATION_PREFIX;\n        return this._post(`/dehydrated_device/claim`, {}, {device_id: deviceId}, options);\n    }\n\n    profile(userId: string, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._get(`/profile/${encodeURIComponent(userId)}`);\n    }\n\n    createRoom(payload: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._post(`/createRoom`, {}, payload, options);\n    }\n    \n    setAccountData(ownUserId: string, type: string, content: Record<string, any>, options?: BaseRequestOptions): IHomeServerRequest {\n        return this._put(`/user/${encodeURIComponent(ownUserId)}/account_data/${encodeURIComponent(type)}`, {}, content, options);\n    }\n}\n\nimport {Request as MockRequest} from \"../../mocks/Request.js\";\n\nexport function tests() {\n    return {\n        \"superficial happy path for GET\": async assert => {\n            // @ts-ignore\n            const hsApi = new HomeServerApi({\n                request: () => new MockRequest().respond(200, 42),\n                homeserver: \"https://hs.tld\",\n            });\n            // @ts-ignore\n            const result = await hsApi._get(\"foo\").response();\n            assert.strictEqual(result, 42);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {AbortError} from \"../../utils/error\";\nimport type {Timeout} from \"../../platform/web/dom/Clock.js\";\n\ntype TimeoutCreator = (ms: number) => Timeout;\n\nconst enum Default { start = 2000 }\n\nexport class ExponentialRetryDelay {\n    private readonly _start: number = Default.start;\n    private _current: number = Default.start;\n    private readonly _createTimeout: TimeoutCreator;\n    private readonly _max: number;\n    private _timeout?: Timeout;\n\n    constructor(createTimeout: TimeoutCreator) {\n        const start = 2000;\n        this._start = start;\n        this._current = start;\n        this._createTimeout = createTimeout;\n        this._max = 60 * 5 * 1000; //5 min\n    }\n\n    async waitForRetry(): Promise<void> {\n        this._timeout = this._createTimeout(this._current);\n        try {\n            await this._timeout.elapsed();\n            // only increase delay if we didn't get interrupted\n            const next = 2 * this._current;\n            this._current = Math.min(this._max, next);\n        } catch(err) {\n            // swallow AbortError, means abort was called\n            if (!(err instanceof AbortError)) {\n                throw err;\n            }\n        } finally {\n            this._timeout = undefined;\n        }\n    }\n\n    abort(): void {\n        if (this._timeout) {\n            this._timeout.abort();\n        }\n    }\n\n    reset(): void {\n        this._current = this._start;\n        this.abort();\n    }\n\n    get nextValue(): number {\n        return this._current;\n    }\n}\n\n\nimport {Clock as MockClock} from \"../../mocks/Clock.js\";\n\nexport function tests() {\n    return {\n        \"test sequence\": async assert => {\n            const clock = new MockClock();\n            const retryDelay = new ExponentialRetryDelay(clock.createTimeout);\n            let promise;\n\n            assert.strictEqual(retryDelay.nextValue, 2000);\n            promise = retryDelay.waitForRetry();\n            clock.elapse(2000);\n            await promise;\n\n            assert.strictEqual(retryDelay.nextValue, 4000);\n            promise = retryDelay.waitForRetry();\n            clock.elapse(4000);\n            await promise;\n\n            assert.strictEqual(retryDelay.nextValue, 8000);\n            promise = retryDelay.waitForRetry();\n            clock.elapse(8000);\n            await promise;\n\n            assert.strictEqual(retryDelay.nextValue, 16000);\n            promise = retryDelay.waitForRetry();\n            clock.elapse(16000);\n            await promise;\n\n            assert.strictEqual(retryDelay.nextValue, 32000);\n            promise = retryDelay.waitForRetry();\n            clock.elapse(32000);\n            await promise;\n\n            assert.strictEqual(retryDelay.nextValue, 64000);\n            promise = retryDelay.waitForRetry();\n            clock.elapse(64000);\n            await promise;\n\n            assert.strictEqual(retryDelay.nextValue, 128000);\n            promise = retryDelay.waitForRetry();\n            clock.elapse(128000);\n            await promise;\n\n            assert.strictEqual(retryDelay.nextValue, 256000);\n            promise = retryDelay.waitForRetry();\n            clock.elapse(256000);\n            await promise;\n\n            assert.strictEqual(retryDelay.nextValue, 300000);\n            promise = retryDelay.waitForRetry();\n            clock.elapse(300000);\n            await promise;\n\n            assert.strictEqual(retryDelay.nextValue, 300000);\n            promise = retryDelay.waitForRetry();\n            clock.elapse(300000);\n            await promise;\n        },\n    }\n    \n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ObservableValue} from \"../../observable/ObservableValue\";\nimport type {ExponentialRetryDelay} from \"./ExponentialRetryDelay\";\nimport type {TimeMeasure} from \"../../platform/web/dom/Clock.js\";\nimport type {OnlineStatus} from \"../../platform/web/dom/OnlineStatus.js\";\nimport type {VersionResponse} from \"./types/response\";\nimport type {HomeServerApi} from \"./HomeServerApi\";\n\nexport enum ConnectionStatus {\n    \"Waiting\",\n    \"Reconnecting\",\n    \"Online\"\n};\n\ntype Ctor = {\n    retryDelay: ExponentialRetryDelay;\n    createMeasure: () => TimeMeasure;\n    onlineStatus: OnlineStatus\n};\n\nexport class Reconnector {\n    private readonly _retryDelay: ExponentialRetryDelay;\n    private readonly _createTimeMeasure: () => TimeMeasure;\n    private readonly _onlineStatus: OnlineStatus;\n    private readonly _state: ObservableValue<ConnectionStatus>;\n    private _isReconnecting: boolean;\n    private _versionsResponse?: VersionResponse;\n    private _stateSince: TimeMeasure;\n\n    constructor({retryDelay, createMeasure, onlineStatus}: Ctor) {\n        this._onlineStatus = onlineStatus;\n        this._retryDelay = retryDelay;\n        this._createTimeMeasure = createMeasure;\n        // assume online, and do our thing when something fails\n        this._state = new ObservableValue(ConnectionStatus.Online);\n        this._isReconnecting = false;\n    }\n\n    get lastVersionsResponse(): VersionResponse | undefined {\n        return this._versionsResponse;\n    }\n\n    get connectionStatus(): ObservableValue<ConnectionStatus> {\n        return this._state;\n    }\n\n    get retryIn(): number {\n        if (this._state.get() === ConnectionStatus.Waiting) {\n            return this._retryDelay.nextValue - this._stateSince.measure();\n        }\n        return 0;\n    }\n\n    async onRequestFailed(hsApi: HomeServerApi): Promise<void> {\n        if (!this._isReconnecting) {  \n            this._isReconnecting = true;\n \n            const onlineStatusSubscription = this._onlineStatus && this._onlineStatus.subscribe(online => {\n                if (online) {\n                    this.tryNow();\n                }\n            });\n\n            try {\n                await this._reconnectLoop(hsApi);\n            } catch (err) {\n                // nothing is catching the error above us,\n                // so just log here\n                console.error(err);\n            } finally {\n                if (onlineStatusSubscription) {\n                    // unsubscribe from this._onlineStatus\n                    onlineStatusSubscription();\n                }\n                this._isReconnecting = false;\n            }\n        }\n    }\n\n    tryNow(): void {\n        if (this._retryDelay) {\n            // this will interrupt this._retryDelay.waitForRetry() in _reconnectLoop\n            this._retryDelay.abort();\n        }\n    }\n\n    private _setState(state: ConnectionStatus): void {\n        if (state !== this._state.get()) {\n            if (state === ConnectionStatus.Waiting) {\n                this._stateSince = this._createTimeMeasure();\n            } else {\n                this._stateSince = null;\n            }\n            this._state.set(state);\n        }\n    }\n    \n    private async _reconnectLoop(hsApi: HomeServerApi): Promise<void> {\n        this._versionsResponse = undefined;\n        this._retryDelay.reset();\n\n        while (!this._versionsResponse) {\n            try {\n                this._setState(ConnectionStatus.Reconnecting);\n                // use 30s timeout, as a tradeoff between not giving up\n                // too quickly on a slow server, and not waiting for\n                // a stale connection when we just came online again\n                const versionsRequest = hsApi.versions({timeout: 30000});\n                this._versionsResponse = await versionsRequest.response();\n                this._setState(ConnectionStatus.Online);\n            } catch (err) {\n                if (err.name === \"ConnectionError\") {\n                    this._setState(ConnectionStatus.Waiting);\n                    await this._retryDelay.waitForRetry();\n                } else {\n                    throw err;\n                }\n            }\n        }\n    }\n}\n\n\nimport {Clock as MockClock} from \"../../mocks/Clock.js\";\nimport {ExponentialRetryDelay as _ExponentialRetryDelay} from \"./ExponentialRetryDelay\";\nimport {ConnectionError} from \"../error.js\"\n\nexport function tests() {\n    function createHsApiMock(remainingFailures) {\n        return {\n            versions() {\n                return {\n                    response() {\n                        if (remainingFailures) {\n                            remainingFailures -= 1;\n                            return Promise.reject(new ConnectionError());\n                        } else {\n                            return Promise.resolve(42);\n                        }\n                    }\n                };\n            }\n        }\n    }\n\n    return {\n        \"test reconnecting with 1 failure\": async assert => {\n            const clock = new MockClock();\n            const {createMeasure} = clock;\n            const onlineStatus = new ObservableValue(false);\n            const retryDelay = new _ExponentialRetryDelay(clock.createTimeout);\n            const reconnector = new Reconnector({retryDelay, onlineStatus, createMeasure});\n            const {connectionStatus} = reconnector;\n            const statuses: ConnectionStatus[] = [];\n            const subscription = reconnector.connectionStatus.subscribe(s => {\n                statuses.push(s);\n            });\n            // @ts-ignore\n            reconnector.onRequestFailed(createHsApiMock(1));\n            await connectionStatus.waitFor(s => s === ConnectionStatus.Waiting).promise;\n            clock.elapse(2000);\n            await connectionStatus.waitFor(s => s === ConnectionStatus.Online).promise;\n            assert.deepEqual(statuses, [\n                ConnectionStatus.Reconnecting,\n                ConnectionStatus.Waiting,\n                ConnectionStatus.Reconnecting,\n                ConnectionStatus.Online\n            ]);\n            assert.strictEqual(reconnector.lastVersionsResponse, 42);\n            subscription();\n        },\n        \"test reconnecting with onlineStatus\": async assert => {\n            const clock = new MockClock();\n            const {createMeasure} = clock;\n            const onlineStatus = new ObservableValue(false);\n            const retryDelay = new _ExponentialRetryDelay(clock.createTimeout);\n            const reconnector = new Reconnector({retryDelay, onlineStatus, createMeasure});\n            const {connectionStatus} = reconnector;\n            // @ts-ignore\n            reconnector.onRequestFailed(createHsApiMock(1));\n            await connectionStatus.waitFor(s => s === ConnectionStatus.Waiting).promise;\n            onlineStatus.set(true); //skip waiting\n            await connectionStatus.waitFor(s => s === ConnectionStatus.Online).promise;\n            assert.equal(connectionStatus.get(), ConnectionStatus.Online);\n            assert.strictEqual(reconnector.lastVersionsResponse, 42);\n        },\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Decrypt an attachment.\n * @param {ArrayBuffer} ciphertextBuffer The encrypted attachment data buffer.\n * @param {Object} info The information needed to decrypt the attachment.\n * @param {Object} info.key AES-CTR JWK key object.\n * @param {string} info.iv Base64 encoded 16 byte AES-CTR IV.\n * @param {string} info.hashes.sha256 Base64 encoded SHA-256 hash of the ciphertext.\n * @return {Promise} A promise that resolves with an ArrayBuffer when the attachment is decrypted.\n */\nexport async function decryptAttachment(platform, ciphertextBuffer, info) {\n    if (info === undefined || info.key === undefined || info.iv === undefined\n        || info.hashes === undefined || info.hashes.sha256 === undefined) {\n       throw new Error(\"Invalid info. Missing info.key, info.iv or info.hashes.sha256 key\");\n    }\n\n    const {crypto} = platform;\n    const {base64} = platform.encoding;\n    var ivArray = base64.decode(info.iv);\n    // re-encode to not deal with padded vs unpadded\n    var expectedSha256base64 = base64.encode(base64.decode(info.hashes.sha256));\n    // Check the sha256 hash\n    const digestResult = await crypto.digest(\"SHA-256\", ciphertextBuffer);\n    if (base64.encode(new Uint8Array(digestResult)) != expectedSha256base64) {\n        throw new Error(\"Mismatched SHA-256 digest\");\n    }\n    var counterLength;\n    if (info.v == \"v1\" || info.v == \"v2\") {\n        // Version 1 and 2 use a 64 bit counter.\n        counterLength = 64;\n    } else {\n        // Version 0 uses a 128 bit counter.\n        counterLength = 128;\n    }\n\n    const decryptedBuffer = await crypto.aes.decryptCTR({\n        jwkKey: info.key,\n        iv: ivArray,\n        data: ciphertextBuffer,\n        counterLength\n    });\n    return decryptedBuffer;\n}\n\nexport async function encryptAttachment(platform, blob) {\n    const {crypto} = platform;\n    const {base64} = platform.encoding;\n    const iv = await crypto.aes.generateIV();\n    const key = await crypto.aes.generateKey(\"jwk\", 256);\n    const buffer = await blob.readAsBuffer();\n    const ciphertext = await crypto.aes.encryptCTR({jwkKey: key, iv, data: buffer});\n    const digest = await crypto.digest(\"SHA-256\", ciphertext);\n    return {\n        blob: platform.createBlob(ciphertext, 'application/octet-stream'),\n        info: {\n            v: \"v2\",\n            key,\n            iv: base64.encodeUnpadded(iv),\n            hashes: {\n                sha256: base64.encodeUnpadded(digest)\n            }\n        }\n    };\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {encodeQueryParams} from \"./common\";\nimport {decryptAttachment} from \"../e2ee/attachment.js\";\nimport {Platform} from \"../../platform/web/Platform.js\";\nimport {BlobHandle} from \"../../platform/web/dom/BlobHandle.js\";\nimport type {Attachment, EncryptedFile} from \"./types/response\";\n\nexport class MediaRepository {\n    private readonly _homeserver: string;\n    private readonly _platform: Platform;\n\n    constructor({homeserver, platform}: {homeserver:string, platform: Platform}) {\n        this._homeserver = homeserver;\n        this._platform = platform;\n    }\n\n    mxcUrlThumbnail(url: string, width: number, height: number, method: \"crop\" | \"scale\"): string | null {\n        const parts = this._parseMxcUrl(url);\n        if (parts) {\n            const [serverName, mediaId] = parts;\n            const httpUrl = `${this._homeserver}/_matrix/media/r0/thumbnail/${encodeURIComponent(serverName)}/${encodeURIComponent(mediaId)}`;\n            return httpUrl + \"?\" + encodeQueryParams({width: Math.round(width), height: Math.round(height), method});\n        }\n        return null;\n    }\n\n    mxcUrl(url: string): string | null {\n        const parts = this._parseMxcUrl(url);\n        if (parts) {\n            const [serverName, mediaId] = parts;\n            return `${this._homeserver}/_matrix/media/r0/download/${encodeURIComponent(serverName)}/${encodeURIComponent(mediaId)}`;\n        } else {\n            return null;\n        }\n    }\n\n    private _parseMxcUrl(url: string): string[] | null {\n        const prefix = \"mxc://\";\n        if (url.startsWith(prefix)) {\n            return url.substr(prefix.length).split(\"/\", 2);\n        } else {\n            return null;\n        }\n    }\n\n    async downloadEncryptedFile(fileEntry: EncryptedFile, cache: boolean = false): Promise<BlobHandle> {\n        const url = this.mxcUrl(fileEntry.url);\n        const {body: encryptedBuffer} = await this._platform.request(url, {method: \"GET\", format: \"buffer\", cache}).response();\n        const decryptedBuffer = await decryptAttachment(this._platform, encryptedBuffer, fileEntry);\n        return this._platform.createBlob(decryptedBuffer, fileEntry.mimetype);\n    }\n\n    async downloadPlaintextFile(mxcUrl: string, mimetype: string, cache: boolean = false): Promise<BlobHandle> {\n        const url = this.mxcUrl(mxcUrl);\n        const {body: buffer} = await this._platform.request(url, {method: \"GET\", format: \"buffer\", cache}).response();\n        return this._platform.createBlob(buffer, mimetype);\n    }\n\n    async downloadAttachment(content: Attachment, cache: boolean = false): Promise<BlobHandle> {\n        if (content.file) {\n            return this.downloadEncryptedFile(content.file, cache);\n        } else {\n            return this.downloadPlaintextFile(content.url!, content.info?.mimetype, cache);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {AbortError} from \"../../utils/error\";\nimport {HomeServerError} from \"../error.js\";\nimport {HomeServerApi} from \"./HomeServerApi\";\nimport {ExponentialRetryDelay} from \"./ExponentialRetryDelay\";\nimport {Clock} from \"../../platform/web/dom/Clock.js\";\nimport type {IHomeServerRequest} from \"./HomeServerRequest.js\";\n\nclass Request implements IHomeServerRequest {\n    public readonly methodName: string;\n    public readonly args: any[];\n    private responseResolve: (result: any) => void;\n    public responseReject: (error: Error) => void;\n    private responseCodeResolve: (result: any) => void;\n    private responseCodeReject: (result: any) => void;\n    private _requestResult?: IHomeServerRequest;\n    private readonly _responsePromise: Promise<any>;\n    private _responseCodePromise: Promise<any>;\n\n    constructor(methodName: string, args: any[]) {\n        this.methodName = methodName;\n        this.args = args;\n        this._responsePromise = new Promise((resolve, reject) => {\n            this.responseResolve = resolve;\n            this.responseReject = reject;\n        });\n    }\n\n    abort(): void {\n        if (this._requestResult) {\n            this._requestResult.abort();\n        } else {\n            this.responseReject(new AbortError());\n            this.responseCodeReject?.(new AbortError());\n        }\n    }\n\n    response(): Promise<any> {\n        return this._responsePromise;\n    }\n\n    responseCode(): Promise<number> {\n        if (this.requestResult) {\n            return this.requestResult.responseCode();\n        }\n        if (!this._responseCodePromise) {\n            this._responseCodePromise = new Promise((resolve, reject) => {\n                this.responseCodeResolve = resolve;\n                this.responseCodeReject = reject;\n            });\n        }\n        return this._responseCodePromise;\n    }\n\n    async setRequestResult(result) {\n        this._requestResult = result;\n        const response = await this._requestResult?.response();\n        this.responseResolve(response);\n        const responseCode = await this._requestResult?.responseCode();\n        this.responseCodeResolve(responseCode);\n    }\n\n    get requestResult() {\n        return this._requestResult;\n    }\n}\n\nclass HomeServerApiWrapper {\n    private readonly _scheduler: RequestScheduler;\n\n    constructor(scheduler: RequestScheduler) {\n        this._scheduler = scheduler;\n    }\n}\n\n// add request-wrapping methods to prototype\nfor (const methodName of Object.getOwnPropertyNames(HomeServerApi.prototype)) {\n    if (methodName !== \"constructor\" && !methodName.startsWith(\"_\")) {\n        HomeServerApiWrapper.prototype[methodName] = function(...args) {\n            return this._scheduler._hsApiRequest(methodName, args);\n        };\n    }\n}\n\nexport class RequestScheduler {\n    private readonly _hsApi: HomeServerApi;\n    private readonly _clock: Clock;\n    private readonly _requests: Set<Request> = new Set();\n    private _stopped = false;\n    private _wrapper = new HomeServerApiWrapper(this);\n\n    constructor({ hsApi, clock }: { hsApi: HomeServerApi; clock: Clock }) {\n        this._hsApi = hsApi;\n        this._clock = clock;\n    }\n\n    get hsApi(): HomeServerApi {\n        return this._wrapper as unknown as HomeServerApi;\n    }\n\n    stop(): void {\n        this._stopped = true;\n        for (const request of this._requests) {\n            request.abort();\n        }\n        this._requests.clear();\n    }\n\n    start(): void {\n        this._stopped = false;\n    }\n\n    private _hsApiRequest(name: string, args: any[]): Request {\n        const request = new Request(name, args);\n        this._doSend(request);\n        return request;\n    }\n\n    private async _doSend(request: Request): Promise<void> {\n        this._requests.add(request);\n        try {\n            let retryDelay: ExponentialRetryDelay | undefined;\n            while (!this._stopped) {\n                try {\n                    const requestResult = this._hsApi[\n                        request.methodName\n                    ].apply(this._hsApi, request.args);\n                    // so the request can be aborted\n                    await request.setRequestResult(requestResult);\n                    return;\n                } catch (err) {\n                    if (\n                        err instanceof HomeServerError &&\n                        err.errcode === \"M_LIMIT_EXCEEDED\"\n                    ) {\n                        if (Number.isSafeInteger(err.retry_after_ms)) {\n                            await this._clock\n                                .createTimeout(err.retry_after_ms)\n                                .elapsed();\n                        } else {\n                            if (!retryDelay) {\n                                retryDelay = new ExponentialRetryDelay(\n                                    this._clock.createTimeout\n                                );\n                            }\n                            await retryDelay.waitForRetry();\n                        }\n                    } else {\n                        request.responseReject(err);\n                        return;\n                    }\n                }\n            }\n            if (this._stopped) {\n                request.abort();\n            }\n        } finally {\n            this._requests.delete(request);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ObservableValue} from \"../observable/ObservableValue\";\nimport {createEnum} from \"../utils/enum\";\n\nconst INCREMENTAL_TIMEOUT = 30000;\n\nexport const SyncStatus = createEnum(\n    \"InitialSync\",\n    \"CatchupSync\",\n    \"Syncing\",\n    \"Stopped\"\n);\n\nfunction timelineIsEmpty(roomResponse) {\n    try {\n        const events = roomResponse?.timeline?.events;\n        return Array.isArray(events) && events.length === 0;\n    } catch (err) {\n        return true;\n    }\n}\n\n/**\n * Sync steps in js-pseudocode:\n * ```js\n * // can only read some stores\n * const preparation = await room.prepareSync(roomResponse, membership, newRoomKeys, prepareTxn);\n * // can do async work that is not related to storage (such as decryption)\n * await room.afterPrepareSync(preparation);\n * // writes and calculates changes\n * const changes = await room.writeSync(roomResponse, isInitialSync, preparation, syncTxn);\n * // applies and emits changes once syncTxn is committed\n * room.afterSync(changes);\n * if (room.needsAfterSyncCompleted(changes)) {\n *     // can do network requests\n *     await room.afterSyncCompleted(changes);\n * }\n * ```\n */\nexport class Sync {\n    constructor({hsApi, session, storage, logger}) {\n        this._hsApi = hsApi;\n        this._logger = logger;\n        this._session = session;\n        this._storage = storage;\n        this._currentRequest = null;\n        this._status = new ObservableValue(SyncStatus.Stopped);\n        this._error = null;\n    }\n\n    get status() {\n        return this._status;\n    }\n\n    /** the error that made the sync stop */\n    get error() {\n        return this._error;\n    }\n\n    start() {\n        // not already syncing?\n        if (this._status.get() !== SyncStatus.Stopped) {\n            return;\n        }\n        this._error = null;\n        let syncToken = this._session.syncToken;\n        if (syncToken) {\n            this._status.set(SyncStatus.CatchupSync);\n        } else {\n            this._status.set(SyncStatus.InitialSync);\n        }\n        this._syncLoop(syncToken);\n    }\n\n    async _syncLoop(syncToken) {\n        // if syncToken is falsy, it will first do an initial sync ... \n        while(this._status.get() !== SyncStatus.Stopped) {\n            let roomStates;\n            let sessionChanges;\n            let wasCatchupOrInitial = this._status.get() === SyncStatus.CatchupSync || this._status.get() === SyncStatus.InitialSync;\n            await this._logger.run(\"sync\", async log => {\n                log.set(\"token\", syncToken);\n                log.set(\"status\", this._status.get());\n                try {\n                    // unless we are happily syncing already, we want the server to return\n                    // as quickly as possible, even if there are no events queued. This\n                    // serves two purposes:\n                    //\n                    // * When the connection dies, we want to know asap when it comes back,\n                    //   so that we can hide the error from the user. (We don't want to\n                    //   have to wait for an event or a timeout).\n                    //\n                    // * We want to know if the server has any to_device messages queued up\n                    //   for us. We do that by calling it with a zero timeout until it\n                    //   doesn't give us any more to_device messages.\n                    const timeout = this._status.get() === SyncStatus.Syncing ? INCREMENTAL_TIMEOUT : 0; \n                    const syncResult = await this._syncRequest(syncToken, timeout, log);\n                    syncToken = syncResult.syncToken;\n                    roomStates = syncResult.roomStates;\n                    sessionChanges = syncResult.sessionChanges;\n                    // initial sync or catchup sync\n                    if (this._status.get() !== SyncStatus.Syncing && syncResult.hadToDeviceMessages) {\n                        this._status.set(SyncStatus.CatchupSync);\n                    } else {\n                        this._status.set(SyncStatus.Syncing);\n                    }\n                } catch (err) {\n                    // retry same request on timeout\n                    if (err.name === \"ConnectionError\" && err.isTimeout) {\n                        // don't run afterSyncCompleted\n                        return;\n                    }\n                    this._error = err;\n                    if (err.name !== \"AbortError\") {\n                        // sync wasn't asked to stop, but is stopping\n                        // because of the error.\n                        log.error = err;\n                        log.logLevel = log.level.Fatal;\n                    }\n                    log.set(\"stopping\", true);\n                    this._status.set(SyncStatus.Stopped);\n                }\n                if (this._status.get() !== SyncStatus.Stopped) {\n                    // TODO: if we're not going to run this phase in parallel with the next\n                    // sync request (because this causes OTKs to be uploaded twice)\n                    // should we move this inside _syncRequest?\n                    // Alternatively, we can try to fix the OTK upload issue while still\n                    // running in parallel.\n                    await log.wrap(\"afterSyncCompleted\", log => this._runAfterSyncCompleted(sessionChanges, roomStates, log));\n                }\n            },\n            this._logger.level.Info,\n            (filter, log) => {\n                if (log.durationWithoutType(\"network\") >= 2000 || log.error || wasCatchupOrInitial) {\n                    return filter.minLevel(log.level.Detail);\n                } else {\n                    return filter.minLevel(log.level.Info);\n                }\n            });\n        }\n    }\n\n    async _runAfterSyncCompleted(sessionChanges, roomStates, log) {\n        const isCatchupSync = this._status.get() === SyncStatus.CatchupSync;\n        const sessionPromise = (async () => {\n            try {\n                await log.wrap(\"session\", log => this._session.afterSyncCompleted(sessionChanges, isCatchupSync, log), log.level.Detail);\n            } catch (err) {} // error is logged, but don't fail sessionPromise\n        })();\n\n        const roomsNeedingAfterSyncCompleted = roomStates.filter(rs => {\n            return rs.room.needsAfterSyncCompleted(rs.changes);\n        });\n        const roomsPromises = roomsNeedingAfterSyncCompleted.map(async rs => {\n            try {\n                await log.wrap(\"room\", log => rs.room.afterSyncCompleted(rs.changes, log), log.level.Detail);\n            } catch (err) {} // error is logged, but don't fail roomsPromises\n        });\n        // run everything in parallel,\n        // we don't want to delay the next sync too much\n        // Also, since all promises won't reject (as they have a try/catch)\n        // it's fine to use Promise.all\n        await Promise.all(roomsPromises.concat(sessionPromise));\n    }\n\n    async _syncRequest(syncToken, timeout, log) {\n        let {syncFilterId} = this._session;\n        if (typeof syncFilterId !== \"string\") {\n            this._currentRequest = this._hsApi.createFilter(this._session.user.id, {room: {state: {lazy_load_members: true}}}, {log});\n            syncFilterId = (await this._currentRequest.response()).filter_id;\n        }\n        const totalRequestTimeout = timeout + (80 * 1000);  // same as riot-web, don't get stuck on wedged long requests\n        this._currentRequest = this._hsApi.sync(syncToken, syncFilterId, timeout, {timeout: totalRequestTimeout, log});\n        const response = await this._currentRequest.response();\n\n        const isInitialSync = !syncToken;\n        const sessionState = new SessionSyncProcessState();\n        const inviteStates = this._parseInvites(response.rooms);\n        const {roomStates, archivedRoomStates} = await this._parseRoomsResponse(\n            response.rooms, inviteStates, isInitialSync, log);\n\n        try {\n            // take a lock on olm sessions used in this sync so sending a message doesn't change them while syncing\n            sessionState.lock = await log.wrap(\"obtainSyncLock\", () => this._session.obtainSyncLock(response));\n            await log.wrap(\"prepare\", log => this._prepareSync(sessionState, roomStates, response, log));\n            await log.wrap(\"afterPrepareSync\", log => Promise.all(roomStates.map(rs => {\n                return rs.room.afterPrepareSync(rs.preparation, log);\n            })));\n            await log.wrap(\"write\", async log => this._writeSync(\n                sessionState, inviteStates, roomStates, archivedRoomStates,\n                response, syncFilterId, isInitialSync, log));\n        } finally {\n            sessionState.dispose();\n        }\n        // sync txn comitted, emit updates and apply changes to in-memory state\n        log.wrap(\"after\", log => this._afterSync(\n            sessionState, inviteStates, roomStates, archivedRoomStates, log));\n\n        const toDeviceEvents = response.to_device?.events;\n        return {\n            syncToken: response.next_batch,\n            roomStates,\n            sessionChanges: sessionState.changes,\n            hadToDeviceMessages: Array.isArray(toDeviceEvents) && toDeviceEvents.length > 0,\n        };\n    }\n\n    _openPrepareSyncTxn() {\n        const storeNames = this._storage.storeNames;\n        return this._storage.readTxn([\n            storeNames.olmSessions,\n            storeNames.inboundGroupSessions,\n            // to read fragments when loading sync writer when rejoining archived room\n            storeNames.timelineFragments,\n            // to read fragments when loading sync writer when rejoining archived room\n            // to read events that can now be decrypted\n            storeNames.timelineEvents,\n        ]);\n    }\n\n    async _prepareSync(sessionState, roomStates, response, log) {\n        const prepareTxn = await this._openPrepareSyncTxn();\n        sessionState.preparation = await log.wrap(\"session\", log => this._session.prepareSync(\n            response, sessionState.lock, prepareTxn, log));\n\n        const newKeysByRoom = sessionState.preparation?.newKeysByRoom;\n\n        // add any rooms with new keys but no sync response to the list of rooms to be synced\n        if (newKeysByRoom) {\n            const {hasOwnProperty} = Object.prototype;\n            for (const roomId of newKeysByRoom.keys()) {\n                const isRoomInResponse = response.rooms?.join && hasOwnProperty.call(response.rooms.join, roomId);\n                if (!isRoomInResponse) {\n                    let room = this._session.rooms.get(roomId);\n                    if (room) {\n                        roomStates.push(new RoomSyncProcessState(room, false, {}, room.membership));\n                    }\n                }\n            }\n        }\n        \n        await Promise.all(roomStates.map(async rs => {\n            const newKeys = newKeysByRoom?.get(rs.room.id);\n            rs.preparation = await log.wrap(\"room\", async log => {\n                // if previously joined and we still have the timeline for it,\n                // this loads the syncWriter at the correct position to continue writing the timeline\n                if (rs.isNewRoom) {\n                    await rs.room.load(null, prepareTxn, log);\n                }\n                return rs.room.prepareSync(\n                    rs.roomResponse, rs.membership, newKeys, prepareTxn, log)\n            }, log.level.Detail);\n        }));\n\n        // This is needed for safari to not throw TransactionInactiveErrors on the syncTxn. See docs/INDEXEDDB.md\n        await prepareTxn.complete();\n    }\n\n    async _writeSync(sessionState, inviteStates, roomStates, archivedRoomStates, response, syncFilterId, isInitialSync, log) {\n        const syncTxn = await this._openSyncTxn();\n        try {\n            sessionState.changes = await log.wrap(\"session\", log => this._session.writeSync(\n                response, syncFilterId, sessionState.preparation, syncTxn, log));\n            await Promise.all(inviteStates.map(async is => {\n                is.changes = await log.wrap(\"invite\", log => is.invite.writeSync(\n                    is.membership, is.roomResponse, syncTxn, log));\n            }));\n            await Promise.all(roomStates.map(async rs => {\n                rs.changes = await log.wrap(\"room\", log => rs.room.writeSync(\n                    rs.roomResponse, isInitialSync, rs.preparation, syncTxn, log));\n            }));\n            // important to do this after roomStates,\n            // as we're referring to the roomState to get the summaryChanges\n            await Promise.all(archivedRoomStates.map(async ars => {\n                const summaryChanges = ars.roomState?.summaryChanges;\n                ars.changes = await log.wrap(\"archivedRoom\", log => ars.archivedRoom.writeSync(\n                    summaryChanges, ars.roomResponse, ars.membership, syncTxn, log));\n            }));\n        } catch(err) {\n            // avoid corrupting state by only\n            // storing the sync up till the point\n            // the exception occurred\n            syncTxn.abort(log);\n            throw syncTxn.getCause(err);\n        }\n        await syncTxn.complete(log);\n    }\n\n    _afterSync(sessionState, inviteStates, roomStates, archivedRoomStates, log) {\n        log.wrap(\"session\", log => this._session.afterSync(sessionState.changes, log), log.level.Detail);\n        for(let ars of archivedRoomStates) {\n            log.wrap(\"archivedRoom\", log => {\n                ars.archivedRoom.afterSync(ars.changes, log);\n                ars.archivedRoom.release();\n            }, log.level.Detail);\n        }\n        for(let rs of roomStates) {\n            log.wrap(\"room\", log => rs.room.afterSync(rs.changes, log), log.level.Detail);\n        }\n        for(let is of inviteStates) {\n            log.wrap(\"invite\", log => is.invite.afterSync(is.changes, log), log.level.Detail);\n        }\n        this._session.applyRoomCollectionChangesAfterSync(inviteStates, roomStates, archivedRoomStates, log);\n    }\n\n    _openSyncTxn() {\n        const storeNames = this._storage.storeNames;\n        return this._storage.readWriteTxn([\n            storeNames.session,\n            storeNames.roomSummary,\n            storeNames.archivedRoomSummary,\n            storeNames.invites,\n            storeNames.roomState,\n            storeNames.roomMembers,\n            storeNames.timelineEvents,\n            storeNames.timelineRelations,\n            storeNames.timelineFragments,\n            storeNames.pendingEvents,\n            storeNames.userIdentities,\n            storeNames.groupSessionDecryptions,\n            storeNames.deviceIdentities,\n            // to discard outbound session when somebody leaves a room\n            // and to create room key messages when somebody joins\n            storeNames.outboundGroupSessions,\n            storeNames.operations,\n            storeNames.accountData,\n            // to decrypt and store new room keys\n            storeNames.olmSessions,\n            storeNames.inboundGroupSessions,\n        ]);\n    }\n    \n    async _parseRoomsResponse(roomsSection, inviteStates, isInitialSync, log) {\n        const roomStates = [];\n        const archivedRoomStates = [];\n        if (roomsSection) {\n            const allMemberships = [\"join\", \"leave\"];\n            for(const membership of allMemberships) {\n                const membershipSection = roomsSection[membership];\n                if (membershipSection) {\n                    for (const [roomId, roomResponse] of Object.entries(membershipSection)) {\n                        // ignore rooms with empty timelines during initial sync,\n                        // see https://github.com/vector-im/hydrogen-web/issues/15\n                        if (isInitialSync && timelineIsEmpty(roomResponse)) {\n                            continue;\n                        }\n                        const invite = this._session.invites.get(roomId);\n                        // if there is an existing invite, add a process state for it\n                        // so its writeSync and afterSync will run and remove the invite\n                        if (invite) {\n                            inviteStates.push(new InviteSyncProcessState(invite, false, null, membership));\n                        }\n                        const roomState = this._createRoomSyncState(roomId, roomResponse, membership, isInitialSync);\n                        if (roomState) {\n                            roomStates.push(roomState);\n                        }\n                        const ars = await this._createArchivedRoomSyncState(roomId, roomState, roomResponse, membership, isInitialSync, log);\n                        if (ars) {\n                            archivedRoomStates.push(ars);\n                        }\n                    }\n                }\n            }\n        }\n        return {roomStates, archivedRoomStates};\n    }\n\n    _createRoomSyncState(roomId, roomResponse, membership, isInitialSync) {\n        let isNewRoom = false;\n        let room = this._session.rooms.get(roomId);\n        // create room only either on new join,\n        // or for an archived room during initial sync,\n        // where we create the summaryChanges with a joined\n        // room to then adopt by the archived room.\n        // This way the limited timeline, members, ...\n        // we receive also gets written.\n        // In any case, don't create a room for a rejected invite\n        if (!room && (membership === \"join\" || (isInitialSync && membership === \"leave\"))) {\n            room = this._session.createJoinedRoom(roomId);\n            isNewRoom = true;\n        }\n        if (room) {\n            return new RoomSyncProcessState(\n                room, isNewRoom, roomResponse, membership);\n        }\n    }\n\n    async _createArchivedRoomSyncState(roomId, roomState, roomResponse, membership, isInitialSync, log) {\n        let archivedRoom;\n        if (roomState?.shouldAdd && !isInitialSync) {\n            // when adding a joined room during incremental sync,\n            // always create the archived room to write the removal\n            // of the archived summary\n            archivedRoom = this._session.createOrGetArchivedRoomForSync(roomId);\n        } else if (membership === \"leave\") {\n            if (roomState) {\n                // we still have a roomState, so we just left it\n                // in this case, create a new archivedRoom\n                archivedRoom = this._session.createOrGetArchivedRoomForSync(roomId);\n            } else {\n                // this is an update of an already left room, restore\n                // it from storage first, so we can increment it.\n                // this happens for example when our membership changes\n                // after leaving (e.g. being (un)banned, possibly after being kicked), etc\n                archivedRoom = await this._session.loadArchivedRoom(roomId, log);\n            }\n        }\n        if (archivedRoom) {\n            return new ArchivedRoomSyncProcessState(\n                archivedRoom, roomState, roomResponse, membership);\n        }\n    }\n\n    _parseInvites(roomsSection) {\n        const inviteStates = [];\n        if (roomsSection?.invite) {\n            for (const [roomId, roomResponse] of Object.entries(roomsSection.invite)) {\n                let invite = this._session.invites.get(roomId);\n                let isNewInvite = false;\n                if (!invite) {\n                    invite = this._session.createInvite(roomId);\n                    isNewInvite = true;\n                }\n                inviteStates.push(new InviteSyncProcessState(invite, isNewInvite, roomResponse, \"invite\"));\n            }\n        }\n        return inviteStates;\n    }\n\n    stop() {\n        if (this._status.get() === SyncStatus.Stopped) {\n            return;\n        }\n        this._status.set(SyncStatus.Stopped);\n        if (this._currentRequest) {\n            this._currentRequest.abort();\n            this._currentRequest = null;\n        }\n    }\n}\n\nclass SessionSyncProcessState {\n    constructor() {\n        this.lock = null;\n        this.preparation = null;\n        this.changes = null;\n    }\n\n    dispose() {\n        this.lock?.release();\n    }\n}\n\nclass RoomSyncProcessState {\n    constructor(room, isNewRoom, roomResponse, membership) {\n        this.room = room;\n        this.isNewRoom = isNewRoom;\n        this.roomResponse = roomResponse;\n        this.membership = membership;\n        this.preparation = null;\n        this.changes = null;\n    }\n\n    get id() {\n        return this.room.id;\n    }\n\n    get shouldAdd() {\n        return this.isNewRoom && this.membership === \"join\";\n    }\n\n    get shouldRemove() {\n        return !this.isNewRoom && this.membership !== \"join\";\n    }\n\n    get summaryChanges() {\n        return this.changes?.summaryChanges;\n    }\n}\n\n\nclass ArchivedRoomSyncProcessState {\n    constructor(archivedRoom, roomState, roomResponse, membership, isInitialSync) {\n        this.archivedRoom = archivedRoom;\n        this.roomState = roomState;\n        this.roomResponse = roomResponse;\n        this.membership = membership;\n        this.isInitialSync = isInitialSync;\n        this.changes = null;\n    }\n\n    get id() {\n        return this.archivedRoom.id;\n    }\n\n    get shouldAdd() {\n        return (this.roomState || this.isInitialSync) && this.membership === \"leave\";\n    }\n\n    get shouldRemove() {\n        return this.membership === \"join\";\n    }\n}\n\nclass InviteSyncProcessState {\n    constructor(invite, isNewInvite, roomResponse, membership) {\n        this.invite = invite;\n        this.isNewInvite = isNewInvite;\n        this.membership = membership;\n        this.roomResponse = roomResponse;\n        this.changes = null;\n    }\n\n    get id() {\n        return this.invite.id;\n    }\n\n    get shouldAdd() {\n        return this.isNewInvite;\n    }\n\n    get shouldRemove() {\n        return this.membership !== \"invite\";\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2021 Daniel Fedorin <danila.fedorin@gmail.com>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\ntype Handler<T> = (value?: T) => void;\n\nexport class EventEmitter<T> {\n    private _handlersByName: { [event in keyof T]?: Set<Handler<T[event]>> }\n\n    constructor() {\n        this._handlersByName = {};\n    }\n\n    emit<K extends keyof T>(name: K, value?: T[K]): void {\n        const handlers = this._handlersByName[name];\n        if (handlers) {\n            handlers.forEach(h => h(value));\n        }\n    }\n\n    disposableOn<K extends keyof T>(name: K, callback: Handler<T[K]>): () => void {\n        this.on(name, callback);\n        return () => {\n            this.off(name, callback);\n        }\n    }\n\n    on<K extends keyof T>(name: K, callback: Handler<T[K]>): void {\n        let handlers = this._handlersByName[name];\n        if (!handlers) {\n            this.onFirstSubscriptionAdded(name);\n            this._handlersByName[name] = handlers = new Set();\n        }\n        handlers.add(callback);\n    }\n\n    off<K extends keyof T>(name: K, callback: Handler<T[K]>): void {\n        const handlers = this._handlersByName[name];\n        if (handlers) {\n            handlers.delete(callback);\n            if (handlers.size === 0) {\n                delete this._handlersByName[name];\n                this.onLastSubscriptionRemoved(name);\n            }\n        }\n    }\n\n    onFirstSubscriptionAdded<K extends keyof T>(name: K): void {}\n\n    onLastSubscriptionRemoved<K extends keyof T>(name: K): void {}\n}\n\nexport function tests() {\n    return {\n        test_on_off(assert) {\n            let counter = 0;\n            const e = new EventEmitter<{ change: never }>();\n            const callback = () => counter += 1;\n            e.on(\"change\", callback);\n            e.emit(\"change\");\n            e.off(\"change\", callback);\n            e.emit(\"change\");\n            assert.equal(counter, 1);\n        },\n\n        test_emit_value(assert) {\n            let value = 0;\n            const e = new EventEmitter<{ change: number }>();\n            const callback = (v) => value = v;\n            e.on(\"change\", callback);\n            e.emit(\"change\", 5);\n            e.off(\"change\", callback);\n            assert.equal(value, 5);\n        },\n\n        test_double_on(assert) {\n            let counter = 0;\n            const e = new EventEmitter<{ change: never }>();\n            const callback = () => counter += 1;\n            e.on(\"change\", callback);\n            e.on(\"change\", callback);\n            e.emit(\"change\");\n            e.off(\"change\", callback);\n            assert.equal(counter, 1);\n        }\n    };\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport anotherjson from \"another-json\";\nimport {createEnum} from \"../../utils/enum\";\n\nexport const DecryptionSource = createEnum(\"Sync\", \"Timeline\", \"Retry\");\n\n// use common prefix so it's easy to clear properties that are not e2ee related during session clear\nexport const SESSION_E2EE_KEY_PREFIX = \"e2ee:\";\nexport const OLM_ALGORITHM = \"m.olm.v1.curve25519-aes-sha2\";\nexport const MEGOLM_ALGORITHM = \"m.megolm.v1.aes-sha2\";\n\nexport class DecryptionError extends Error {\n    constructor(code, event, detailsObj = null) {\n        super(`Decryption error ${code}${detailsObj ? \": \"+JSON.stringify(detailsObj) : \"\"}`);\n        this.code = code;\n        this.event = event;\n        this.details = detailsObj;\n    }\n}\n\nexport const SIGNATURE_ALGORITHM = \"ed25519\";\n\nexport function verifyEd25519Signature(olmUtil, userId, deviceOrKeyId, ed25519Key, value, log = undefined) {\n    const clone = Object.assign({}, value);\n    delete clone.unsigned;\n    delete clone.signatures;\n    const canonicalJson = anotherjson.stringify(clone);\n    const signature = value?.signatures?.[userId]?.[`${SIGNATURE_ALGORITHM}:${deviceOrKeyId}`];\n    try {\n        if (!signature) {\n            throw new Error(\"no signature\");\n        }\n        // throws when signature is invalid\n        olmUtil.ed25519_verify(ed25519Key, canonicalJson, signature);\n        return true;\n    } catch (err) {\n        if (log) {\n            const logItem = log.log({l: \"Invalid signature, ignoring.\", ed25519Key, canonicalJson, signature});\n            logItem.error = err;\n            logItem.logLevel = log.level.Warn;\n        }\n        return false;\n    }\n}\n\nexport function createRoomEncryptionEvent() {\n    return {\n        \"type\": \"m.room.encryption\",\n        \"state_key\": \"\",\n        \"content\": {\n            \"algorithm\": MEGOLM_ALGORITHM,\n            \"rotation_period_ms\": 604800000,\n            \"rotation_period_msgs\": 100\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {MEGOLM_ALGORITHM} from \"../e2ee/common.js\";\n\n\nfunction applyTimelineEntries(data, timelineEntries, isInitialSync, canMarkUnread, ownUserId) {\n    if (timelineEntries.length) {\n        data = timelineEntries.reduce((data, entry) => {\n            return processTimelineEvent(data, entry,\n                isInitialSync, canMarkUnread, ownUserId);\n        }, data);\n    }\n    return data;\n}\n\nexport function reduceStateEvents(roomResponse, callback, value) {\n    const stateEvents = roomResponse?.state?.events;\n    // state comes before timeline\n    if (Array.isArray(stateEvents)) {\n        value = stateEvents.reduce(callback, value);\n    }\n    const timelineEvents = roomResponse?.timeline?.events;\n    // and after that state events in the timeline\n    if (Array.isArray(timelineEvents)) {\n        value = timelineEvents.reduce((data, event) => {\n            if (typeof event.state_key === \"string\") {\n                value = callback(value, event);\n            }\n            return value;\n        }, value);\n    }\n    return value;\n}\n\nfunction applySyncResponse(data, roomResponse, membership, ownUserId) {\n    if (roomResponse.summary) {\n        data = updateSummary(data, roomResponse.summary);\n    }\n    if (membership !== data.membership) {\n        data = data.cloneIfNeeded();\n        data.membership = membership;\n    }\n    if (roomResponse.account_data) {\n        data = roomResponse.account_data.events.reduce(processRoomAccountData, data);\n    }\n    // process state events in state and in timeline.\n    // non-state events are handled by applyTimelineEntries\n    // so decryption is handled properly\n    data = reduceStateEvents(roomResponse, (data, event) => processStateEvent(data, event, ownUserId), data);\n    const unreadNotifications = roomResponse.unread_notifications;\n    if (unreadNotifications) {\n        data = processNotificationCounts(data, unreadNotifications);\n    }\n\n    return data;\n}\n\nfunction processNotificationCounts(data, unreadNotifications) {\n    const highlightCount = unreadNotifications.highlight_count || 0;\n    if (highlightCount !== data.highlightCount) {\n        data = data.cloneIfNeeded();\n        data.highlightCount = highlightCount;\n    }\n    const notificationCount = unreadNotifications.notification_count;\n    if (notificationCount !== data.notificationCount) {\n        data = data.cloneIfNeeded();\n        data.notificationCount = notificationCount;\n    }\n    return data;\n} \n\nfunction processRoomAccountData(data, event) {\n    if (event?.type === \"m.tag\") {\n        let tags = event?.content?.tags;\n        if (!tags || Array.isArray(tags) || typeof tags !== \"object\") {\n            tags = null;\n        }\n        data = data.cloneIfNeeded();\n        data.tags = tags;\n    }\n    return data;\n}\n\nexport function processStateEvent(data, event, ownUserId) {\n    if (event.type === \"m.room.create\") {\n        data = data.cloneIfNeeded();\n        data.lastMessageTimestamp = event.origin_server_ts;\n    } else if (event.type === \"m.room.encryption\") {\n        const algorithm = event.content?.algorithm;\n        if (!data.encryption && algorithm === MEGOLM_ALGORITHM) {\n            data = data.cloneIfNeeded();\n            data.encryption = event.content;\n        }\n    } else if (event.type === \"m.room.name\") {\n        const newName = event.content?.name;\n        if (newName !== data.name) {\n            data = data.cloneIfNeeded();\n            data.name = newName;\n        }\n    } else if (event.type === \"m.room.avatar\") {\n        const newUrl = event.content?.url;\n        if (newUrl !== data.avatarUrl) {\n            data = data.cloneIfNeeded();\n            data.avatarUrl = newUrl;\n        }\n    } else if (event.type === \"m.room.canonical_alias\") {\n        const content = event.content;\n        data = data.cloneIfNeeded();\n        data.canonicalAlias = content.alias;\n    } else if (event.type === \"m.room.member\") {\n        const content = event.content;\n        if (content.is_direct === true && content.membership === \"invite\" && !data.isDirectMessage) {\n            let other;\n            if (event.sender === ownUserId) {\n                other = event.state_key;\n            } else if (event.state_key === ownUserId) {\n                other = event.sender;\n            }\n            if (other) {\n                data = data.cloneIfNeeded();\n                data.isDirectMessage = true;\n                data.dmUserId = other;\n            }\n        } else if (content.membership === \"leave\" && data.isDirectMessage && data.dmUserId === event.state_key) {\n            data = data.cloneIfNeeded();\n            data.isDirectMessage = false;\n            data.dmUserId = null;\n        }\n    }\n    return data;\n}\n\nfunction processTimelineEvent(data, eventEntry, isInitialSync, canMarkUnread, ownUserId) {\n    if (eventEntry.eventType === \"m.room.message\") {\n        if (!data.lastMessageTimestamp || eventEntry.timestamp > data.lastMessageTimestamp) {\n            data = data.cloneIfNeeded();\n            data.lastMessageTimestamp = eventEntry.timestamp;\n        }\n        if (!isInitialSync && eventEntry.sender !== ownUserId && canMarkUnread) {\n            data = data.cloneIfNeeded();\n            data.isUnread = true;\n        }\n    }\n    return data;\n}\n\nfunction updateSummary(data, summary) {\n    const heroes = summary[\"m.heroes\"];\n    const joinCount = summary[\"m.joined_member_count\"];\n    const inviteCount = summary[\"m.invited_member_count\"];\n    // TODO: we could easily calculate if all members are available here and set hasFetchedMembers?\n    // so we can avoid calling /members...\n    // we'd need to do a count query in the roomMembers store though ...\n    if (heroes && Array.isArray(heroes)) {\n        data = data.cloneIfNeeded();\n        data.heroes = heroes;\n    }\n    if (Number.isInteger(inviteCount)) {\n        data = data.cloneIfNeeded();\n        data.inviteCount = inviteCount;\n    }\n    if (Number.isInteger(joinCount)) {\n        data = data.cloneIfNeeded();\n        data.joinCount = joinCount;\n    }\n    return data;\n}\n\nexport class SummaryData {\n    constructor(copy, roomId) {\n        this.roomId = copy ? copy.roomId : roomId;\n        this.name = copy ? copy.name : null;\n        this.lastMessageTimestamp = copy ? copy.lastMessageTimestamp : null;\n        this.isUnread = copy ? copy.isUnread : false;\n        this.encryption = copy ? copy.encryption : null;\n        this.membership = copy ? copy.membership : null;\n        this.inviteCount = copy ? copy.inviteCount : 0;\n        this.joinCount = copy ? copy.joinCount : 0;\n        this.heroes = copy ? copy.heroes : null;\n        this.canonicalAlias = copy ? copy.canonicalAlias : null;\n        this.hasFetchedMembers = copy ? copy.hasFetchedMembers : false;\n        this.isTrackingMembers = copy ? copy.isTrackingMembers : false;\n        this.avatarUrl = copy ? copy.avatarUrl : null;\n        this.notificationCount = copy ? copy.notificationCount : 0;\n        this.highlightCount = copy ? copy.highlightCount : 0;\n        this.tags = copy ? copy.tags : null;\n        this.isDirectMessage = copy ? copy.isDirectMessage : false;\n        this.dmUserId = copy ? copy.dmUserId : null;\n        this.cloned = copy ? true : false;\n    }\n\n    diff(other) {\n        const props = Object.getOwnPropertyNames(this);\n        return props.reduce((diff, prop) => {\n            if (prop !== \"cloned\") {\n                if (this[prop] !== other[prop]) {\n                    diff[prop] = this[prop];\n                }\n            }\n            return diff;\n        }, {});\n    }\n\n    cloneIfNeeded() {\n        if (this.cloned) {\n            return this;\n        } else {\n            return new SummaryData(this);\n        }\n    }\n\n    serialize() {\n        return Object.entries(this).reduce((obj, [key, value]) => {\n            if (key !== \"cloned\" && value !== null) {\n                obj[key] = value;\n            }\n            return obj;\n        }, {});\n    }\n\n    applyTimelineEntries(timelineEntries, isInitialSync, canMarkUnread, ownUserId) {\n        return applyTimelineEntries(this, timelineEntries, isInitialSync, canMarkUnread, ownUserId);\n    }\n\n    applySyncResponse(roomResponse, membership, ownUserId) {\n        return applySyncResponse(this, roomResponse, membership, ownUserId);\n    }\n\n    get needsHeroes() {\n        return !this.name && !this.canonicalAlias && this.heroes && this.heroes.length > 0;\n    }\n\n    isNewJoin(oldData) {\n        return this.membership === \"join\" && oldData.membership !== \"join\";\n    }\n}\n\nexport class RoomSummary {\n\tconstructor(roomId) {\n        this._data = null;\n        this.applyChanges(new SummaryData(null, roomId));\n\t}\n\n    get data() {\n        return this._data;\n    }\n\n    writeClearUnread(txn) {\n        const data = new SummaryData(this._data);\n        data.isUnread = false;\n        data.notificationCount = 0;\n        data.highlightCount = 0;\n        txn.roomSummary.set(data.serialize());\n        return data;\n    }\n\n    writeHasFetchedMembers(value, txn) {\n        const data = new SummaryData(this._data);\n        data.hasFetchedMembers = value;\n        txn.roomSummary.set(data.serialize());\n        return data;\n    }\n\n    writeIsTrackingMembers(value, txn) {\n        const data = new SummaryData(this._data);\n        data.isTrackingMembers = value;\n        txn.roomSummary.set(data.serialize());\n        return data;\n    }\n\n\twriteData(data, txn) {\n\t\tif (data !== this._data) {\n            txn.roomSummary.set(data.serialize());\n            return data;\n\t\t}\n\t}\n\n    /** move summary to archived store when leaving the room */\n    writeArchivedData(data, txn) {\n        if (data !== this._data) {\n            txn.archivedRoomSummary.set(data.serialize());\n            return data;\n        }\n    }\n\n    async writeAndApplyData(data, storage) {\n        if (data === this._data) {\n            return false;\n        }\n        const txn = await storage.readWriteTxn([\n            storage.storeNames.roomSummary,\n        ]);\n        try {\n            txn.roomSummary.set(data.serialize());\n        } catch (err) {\n            txn.abort();\n            throw err;\n        }\n        await txn.complete();\n        this.applyChanges(data);\n        return true;\n    }\n\n    applyChanges(data) {\n        this._data = data;\n        // clear cloned flag, so cloneIfNeeded makes a copy and\n        // this._data is not modified if any field is changed.\n        this._data.cloned = false;\n    }\n\n\tasync load(summary) {\n        this.applyChanges(new SummaryData(summary));\n\t}\n}\n\nexport function tests() {\n    return {\n        \"serialize doesn't include null fields or cloned\": assert => {\n            const roomId = \"!123:hs.tld\";\n            const data = new SummaryData(null, roomId);\n            const clone = data.cloneIfNeeded();\n            const serialized = clone.serialize();\n            assert.strictEqual(serialized.cloned, undefined);\n            assert.equal(serialized.roomId, roomId);\n            const nullCount = Object.values(serialized).reduce((count, value) => count + value === null ? 1 : 0, 0);\n            assert.strictEqual(nullCount, 0);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport enum StoreNames {\n    session = \"session\",\n    roomState = \"roomState\",\n    roomSummary = \"roomSummary\",\n    archivedRoomSummary = \"archivedRoomSummary\",\n    invites = \"invites\",\n    roomMembers = \"roomMembers\",\n    timelineEvents = \"timelineEvents\",\n    timelineRelations = \"timelineRelations\",\n    timelineFragments = \"timelineFragments\",\n    pendingEvents = \"pendingEvents\",\n    userIdentities = \"userIdentities\",\n    deviceIdentities = \"deviceIdentities\",\n    olmSessions = \"olmSessions\",\n    inboundGroupSessions = \"inboundGroupSessions\",\n    outboundGroupSessions = \"outboundGroupSessions\",\n    groupSessionDecryptions = \"groupSessionDecryptions\",\n    operations = \"operations\",\n    accountData = \"accountData\",\n}\n\nexport const STORE_NAMES: Readonly<StoreNames[]> = Object.values(StoreNames);\n\nexport class StorageError extends Error {\n    errcode?: string;\n    cause: Error | null;\n\n    constructor(message: string, cause: Error | null = null) {\n        super(message);\n        if (cause) {\n            this.errcode = cause.name;\n        }\n        this.cause = cause;\n    }\n\n    get name(): string {\n        return \"StorageError\";\n    }\n}\n\nexport const KeyLimits = {\n    get minStorageKey(): number {\n        // for indexeddb, we use unsigned 32 bit integers as keys\n        return 0;\n    },\n    \n    get middleStorageKey(): number {\n        // for indexeddb, we use unsigned 32 bit integers as keys\n        return 0x7FFFFFFF;\n    },\n\n    get maxStorageKey(): number {\n        // for indexeddb, we use unsigned 32 bit integers as keys\n        return 0xFFFFFFFF;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {KeyLimits} from \"../../storage/common\";\nimport {Direction} from \"./Direction\";\n\n// key for events in the timelineEvents store\nexport class EventKey {\n    constructor(\n        public fragmentId: number,\n        public eventIndex: number\n    ) {\n    }\n\n    nextFragmentKey(): EventKey {\n        // could take MIN_EVENT_INDEX here if it can't be paged back\n        return new EventKey(this.fragmentId + 1, KeyLimits.middleStorageKey);\n    }\n\n    nextKeyForDirection(direction: Direction): EventKey {\n        if (direction.isForward) {\n            return this.nextKey();\n        } else {\n            return this.previousKey();\n        }\n    }\n\n    previousKey(): EventKey {\n        return new EventKey(this.fragmentId, this.eventIndex - 1);\n    }\n\n    nextKey(): EventKey {\n        return new EventKey(this.fragmentId, this.eventIndex + 1);\n    }\n\n    static get maxKey(): EventKey {\n        return new EventKey(KeyLimits.maxStorageKey, KeyLimits.maxStorageKey);\n    }\n\n    static get minKey(): EventKey {\n        return new EventKey(KeyLimits.minStorageKey, KeyLimits.minStorageKey);\n    }\n\n    static get defaultLiveKey(): EventKey {\n        return EventKey.defaultFragmentKey(KeyLimits.minStorageKey);\n    }\n\n    static defaultFragmentKey(fragmentId: number): EventKey {\n        return new EventKey(fragmentId, KeyLimits.middleStorageKey);\n    }\n\n    toString(): string {\n        return `[${this.fragmentId}/${this.eventIndex}]`;\n    }\n\n    equals(other: EventKey): boolean {\n        return this.fragmentId === other?.fragmentId && this.eventIndex === other?.eventIndex;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n//entries can be sorted, first by fragment, then by entry index.\nimport {EventKey} from \"../EventKey\";\nexport const PENDING_FRAGMENT_ID = Number.MAX_SAFE_INTEGER;\n\ninterface FragmentIdComparer {\n    compare: (a: number, b: number) => number\n}\n\nexport abstract class BaseEntry {\n    constructor(\n        protected readonly _fragmentIdComparer: FragmentIdComparer\n    ) {\n    }\n\n    abstract get fragmentId(): number;\n    abstract get entryIndex(): number;\n    abstract updateFrom(other: BaseEntry): void;\n\n    compare(otherEntry: BaseEntry): number {\n        if (this.fragmentId === otherEntry.fragmentId) {\n            return this.entryIndex - otherEntry.entryIndex;\n        } else if (this.fragmentId === PENDING_FRAGMENT_ID) {\n            return 1;\n        } else if (otherEntry.fragmentId === PENDING_FRAGMENT_ID) {\n            return -1;\n        } else {\n            // This might throw if the relation of two fragments is unknown.\n            return this._fragmentIdComparer.compare(this.fragmentId, otherEntry.fragmentId);\n        }\n    }\n\n    asEventKey(): EventKey {\n        return new EventKey(this.fragmentId, this.entryIndex);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function getPrevContentFromStateEvent(event) {\n    // where to look for prev_content is a bit of a mess,\n    // see https://matrix.to/#/!NasysSDfxKxZBzJJoE:matrix.org/$DvrAbZJiILkOmOIuRsNoHmh2v7UO5CWp_rYhlGk34fQ?via=matrix.org&via=pixie.town&via=amorgan.xyz\n    return event.unsigned?.prev_content || event.prev_content;\n}\n\nexport const REDACTION_TYPE = \"m.room.redaction\";\n\nexport function isRedacted(event) {\n    return !!event?.unsigned?.redacted_because;\n}\n\nexport enum RoomStatus {\n    None = 1 << 0,\n    BeingCreated = 1 << 1,\n    Invited = 1 << 2,\n    Joined = 1 << 3,\n    Replaced = 1 << 4,\n    Archived = 1 << 5,\n}\n\nexport enum RoomType {\n    DirectMessage,\n    Private,\n    Public\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {REDACTION_TYPE} from \"../common\";\n\nexport const REACTION_TYPE = \"m.reaction\";\nexport const ANNOTATION_RELATION_TYPE = \"m.annotation\";\n\nexport function createAnnotation(targetId, key) {\n    return {\n        \"m.relates_to\": {\n            \"event_id\": targetId,\n            key,\n            \"rel_type\": ANNOTATION_RELATION_TYPE\n        }\n    };\n}\n\nexport function getRelationTarget(relation) {\n    return relation.event_id || relation[\"m.in_reply_to\"]?.event_id\n}\n\nexport function setRelationTarget(relation, target) {\n    if (relation.event_id !== undefined) {\n        relation.event_id = target;\n    } else if (relation[\"m.in_reply_to\"]) {\n        relation[\"m.in_reply_to\"].event_id = target;\n    }\n}\n\nexport function getRelatedEventId(event) {\n\tif (event.type === REDACTION_TYPE) {\n        return event.redacts;\n    } else {\n        const relation = getRelation(event);\n        if (relation) {\n            return getRelationTarget(relation);\n        }\n    }\n    return null;\n}\n\nexport function getRelationFromContent(content) {\n    return content?.[\"m.relates_to\"];\n}\n\nexport function getRelation(event) {\n\treturn getRelationFromContent(event.content);\n}\n\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class PendingAnnotation {\n    constructor() {\n        // TODO: use simple member for reaction and redaction as we can't/shouldn't really have more than 2 entries\n        // this contains both pending annotation entries, and pending redactions of remote annotation entries \n        this._entries = [];\n    }\n\n    get firstTimestamp() {\n        return this._entries.reduce((ts, e) => {\n            if (e.isRedaction) {\n                return ts;\n            }\n            return Math.min(e.timestamp, ts);\n        }, Number.MAX_SAFE_INTEGER);\n    }\n\n    get annotationEntry() {\n        return this._entries.find(e => !e.isRedaction);\n    }\n\n    get redactionEntry() {\n        return this._entries.find(e => e.isRedaction);\n    }\n\n    get count() {\n        return this._entries.reduce((count, e) => {\n            return count + (e.isRedaction ? -1 : 1);\n        }, 0);\n    }\n\n    add(entry) {\n        this._entries.push(entry);\n    }\n\n    remove(entry) {\n        const idx = this._entries.indexOf(entry);\n        if (idx === -1) {\n            return false;\n        }\n        this._entries.splice(idx, 1);\n        return true;\n    }\n\n    get willAnnotate() {\n        const lastEntry = this._entries.reduce((lastEntry, e) => {\n            if (!lastEntry || e.pendingEvent.queueIndex > lastEntry.pendingEvent.queueIndex) {\n                return e;\n            }\n            return lastEntry;\n        }, null);\n        if (lastEntry) {\n            return !lastEntry.isRedaction;\n        }\n        return false;\n    }\n\n    get isEmpty() {\n        return this._entries.length === 0;\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nfunction htmlEscape(string) {\n    return string.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\n\nfunction fallbackForNonTextualMessage(msgtype) {\n    switch (msgtype) {\n        case \"m.file\":\n            return \"sent a file.\";\n        case \"m.image\":\n            return \"sent an image.\";\n        case \"m.video\":\n            return \"sent a video.\";\n        case \"m.audio\":\n            return \"sent an audio file.\";\n    }\n    return null;\n}\n\nfunction fallbackPrefix(msgtype) {\n    return msgtype === \"m.emote\" ? \"* \" : \"\";\n}\n\nfunction _createReplyContent(targetId, msgtype, body, formattedBody) {\n    return {\n        msgtype,\n        body,\n        \"format\": \"org.matrix.custom.html\",\n        \"formatted_body\": formattedBody,\n        \"m.relates_to\": {\n            \"m.in_reply_to\": {\n                \"event_id\": targetId\n            }\n        }\n    };\n}\n\nexport function createReplyContent(entry, msgtype, body) {\n    // TODO check for absense of sender / body / msgtype / etc?\n    const nonTextual = fallbackForNonTextualMessage(entry.content.msgtype);\n    const prefix = fallbackPrefix(entry.content.msgtype);\n    const sender = entry.sender;\n    const name = entry.displayName || sender;\n\n    const formattedBody = nonTextual || entry.content.formatted_body ||\n        (entry.content.body && htmlEscape(entry.content.body)) || \"\";\n    const formattedFallback = `<mx-reply><blockquote>In reply to ${prefix}` +\n        `<a href=\"https://matrix.to/#/${sender}\">${name}</a><br />` +\n        `${formattedBody}</blockquote></mx-reply>`;\n\n    const plainBody = nonTextual || entry.content.body || \"\";\n    const bodyLines = plainBody.split(\"\\n\");\n    bodyLines[0] = `> ${prefix}<${sender}> ${bodyLines[0]}`\n    const plainFallback = bodyLines.join(\"\\n> \");\n\n    const newBody = plainFallback + '\\n\\n' + body;\n    const newFormattedBody = formattedFallback + htmlEscape(body);\n    return _createReplyContent(entry.id, msgtype, newBody, newFormattedBody);\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseEntry} from \"./BaseEntry\";\nimport {REDACTION_TYPE} from \"../../common\";\nimport {createAnnotation, ANNOTATION_RELATION_TYPE, getRelationFromContent} from \"../relations.js\";\nimport {PendingAnnotation} from \"../PendingAnnotation.js\";\nimport {createReplyContent} from \"./reply.js\"\n\n/** Deals mainly with local echo for relations and redactions,\n * so it is shared between PendingEventEntry and EventEntry */\nexport class BaseEventEntry extends BaseEntry {\n    constructor(fragmentIdComparer) {\n        super(fragmentIdComparer);\n        this._pendingRedactions = null;\n        this._pendingAnnotations = null;\n        this._contextEntry = null;\n        this._contextForEntries = null;\n    }\n\n    get isReply() {\n        return !!this.relation?.[\"m.in_reply_to\"];\n    }\n\n    get isRedacting() {\n        return !!this._pendingRedactions;\n    }\n\n    get isRedacted() {\n        return this.isRedacting;\n    }\n\n    get isRedaction() {\n        return this.eventType === REDACTION_TYPE;\n    }\n\n    get redactionReason() {\n        if (this._pendingRedactions) {\n            return this._pendingRedactions[0].content?.reason;\n        }\n        return null;\n    }\n\n    setContextEntry(entry) {\n        this._contextEntry = entry;\n        entry._setAsContextOf(this);\n    }\n\n    _setAsContextOf(entry) {\n        if (!this._contextForEntries) {\n            this._contextForEntries = [];\n        }\n        this._contextForEntries.push(entry);\n    }\n\n    get contextForEntries() {\n        return this._contextForEntries;\n    }\n\n    get contextEntry() {\n        return this._contextEntry;\n    }\n\n    /**\n        Aggregates relation or redaction of remote relation.  \n        Used in two situations:\n        - to aggregate local relation/redaction of remote relation\n        - to mark this entry as being redacted in Timeline._updateEntriesFetchedFromHomeserver\n        @return [string] returns the name of the field that has changed, if any\n    */\n    addLocalRelation(entry) {\n        if (entry.eventType === REDACTION_TYPE && entry.isRelatedToId(this.id)) {\n            if (!this._pendingRedactions) {\n                this._pendingRedactions = [];\n            }\n            this._pendingRedactions.push(entry);\n            if (this._pendingRedactions.length === 1) {\n                return \"isRedacted\";\n            }\n        } else {\n            const relationEntry = entry.redactingEntry || entry;\n            if (relationEntry.isRelatedToId(this.id)) {\n                if (relationEntry.relation.rel_type === ANNOTATION_RELATION_TYPE) {\n                    if (this._addPendingAnnotation(entry)) {\n                        return \"pendingAnnotations\";\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n        deaggregates local relation or a local redaction of a remote relation.\n        @return [string] returns the name of the field that has changed, if any\n    */\n    removeLocalRelation(entry) {\n        if (entry.eventType === REDACTION_TYPE && entry.isRelatedToId(this.id) && this._pendingRedactions) {\n            const countBefore = this._pendingRedactions.length;\n            this._pendingRedactions = this._pendingRedactions.filter(e => e !== entry);\n            if (this._pendingRedactions.length === 0) {\n                this._pendingRedactions = null;\n                if (countBefore !== 0) {\n                    return \"isRedacted\";\n                }\n            }\n        } else {\n            const relationEntry = entry.redactingEntry || entry;\n            if (relationEntry.isRelatedToId(this.id)) {\n                if (relationEntry.relation?.rel_type === ANNOTATION_RELATION_TYPE && this._pendingAnnotations) {\n                    if (this._removePendingAnnotation(entry)) {\n                        return \"pendingAnnotations\";\n                    }\n                }\n            }\n        }\n    }\n\n    _addPendingAnnotation(entry) {\n        if (!this._pendingAnnotations) {\n            this._pendingAnnotations = new Map();\n        }\n        const {key} = (entry.redactingEntry || entry).relation;\n        if (key) {\n            let annotation = this._pendingAnnotations.get(key);\n            if (!annotation) {\n                annotation = new PendingAnnotation();\n                this._pendingAnnotations.set(key, annotation);\n            }\n            annotation.add(entry);\n            return true;\n        }\n        return false;\n    }\n\n    _removePendingAnnotation(entry) {\n        const {key} = (entry.redactingEntry || entry).relation;\n        if (key) {\n            let annotation = this._pendingAnnotations.get(key);\n            if (annotation.remove(entry) && annotation.isEmpty) {\n                this._pendingAnnotations.delete(key);\n            }\n            if (this._pendingAnnotations.size === 0) {\n                this._pendingAnnotations = null;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    async abortPendingRedaction() {\n        if (this._pendingRedactions) {\n            for (const pee of this._pendingRedactions) {\n                await pee.pendingEvent.abort();\n            }\n            // removing the pending events will call removeLocalRelation,\n            // so don't clear _pendingRedactions here\n        }\n    }\n\n    get pendingRedaction() {\n        if (this._pendingRedactions) {\n            return this._pendingRedactions[0];\n        }\n        return null;\n    }\n\n    annotate(key) {\n        return createAnnotation(this.id, key);\n    }\n\n    reply(msgtype, body) {\n        return createReplyContent(this, msgtype, body);\n    }\n\n    /** takes both remote event id and local txn id into account, see overriding in PendingEventEntry */\n    isRelatedToId(id) {\n        return id && this.relatedEventId === id;\n    }\n\n    haveAnnotation(key) {\n        const haveRemoteReaction = this.annotations?.[key]?.me || false;\n        const pendingAnnotation = this.pendingAnnotations?.get(key);\n        const willAnnotate = pendingAnnotation?.willAnnotate || false;\n        /*\n        We have an annotation in these case:\n        - remote annotation with me, no pending\n        - remote annotation with me, pending redaction and then annotation\n        - pending annotation without redaction after it\n        */\n        return (haveRemoteReaction && (!pendingAnnotation || willAnnotate)) ||\n            (!haveRemoteReaction && willAnnotate);\n    }\n\n    get relation() {\n        return getRelationFromContent(this.content);\n    }\n\n    get pendingAnnotations() {\n        return this._pendingAnnotations;\n    }\n\n    get annotations() {\n        return null; //overwritten in EventEntry\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {PENDING_FRAGMENT_ID} from \"./BaseEntry\";\nimport {BaseEventEntry} from \"./BaseEventEntry.js\";\n\nexport class PendingEventEntry extends BaseEventEntry {\n    constructor({pendingEvent, member, clock, redactingEntry}) {\n        super(null);\n        this._pendingEvent = pendingEvent;\n        /** @type {RoomMember} */\n        this._member = member;\n        // try to come up with a timestamp that is around construction time and\n        // will be roughly sorted by queueIndex, so it can be used to as a secondary\n        // sorting dimension for reactions\n        this._timestamp = clock.now() - (100 - pendingEvent.queueIndex);\n        this._redactingEntry = redactingEntry;\n    }\n\n    get fragmentId() {\n        return PENDING_FRAGMENT_ID;\n    }\n\n    get entryIndex() {\n        return this._pendingEvent.queueIndex;\n    }\n\n    get content() {\n        return this._pendingEvent.content;\n    }\n\n    get event() {\n        return null;\n    }\n\n    get eventType() {\n        return this._pendingEvent.eventType;\n    }\n\n    get stateKey() {\n        return null;\n    }\n\n    get sender() {\n        return this._member?.userId;\n    }\n\n    get displayName() {\n        return this._member?.name;\n    }\n\n    get avatarUrl() {\n        return this._member?.avatarUrl;\n    }\n\n    get timestamp() {\n        return this._timestamp;\n    }\n\n    get isPending() {\n        return true;\n    }\n\n    get id() {\n        return this._pendingEvent.txnId;\n    }\n\n    get pendingEvent() {\n        return this._pendingEvent;\n    }\n\n    notifyUpdate() {\n        \n    }\n\n    isRelatedToId(id) {\n        if (id && id === this._pendingEvent.relatedTxnId) {\n            return true;\n        }\n        return super.isRelatedToId(id);\n    }\n\n    get relatedEventId() {\n        return this._pendingEvent.relatedEventId;\n    }\n\n    get redactingEntry() {\n        return this._redactingEntry;\n    }\n\n    get contextEventId() {\n        if (this.isReply) {\n            return this._pendingEvent.relatedEventId ?? this._pendingEvent.relatedTxnId;\n        }\n        return null;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {createEnum} from \"../../../utils/enum\";\nimport {AbortError} from \"../../../utils/error\";\nimport {REDACTION_TYPE} from \"../common\";\nimport {getRelationFromContent, getRelationTarget, setRelationTarget} from \"../timeline/relations.js\";\n\nexport const SendStatus = createEnum(\n    \"Waiting\",\n    \"EncryptingAttachments\",\n    \"UploadingAttachments\",\n    \"Encrypting\",\n    \"Sending\",\n    \"Sent\",\n    \"Error\",\n);\n\nconst unencryptedContentFields = [ \"m.relates_to\" ];\n\nexport class PendingEvent {\n    constructor({data, remove, emitUpdate, attachments}) {\n        this._data = data;\n        this._attachments = attachments;\n        this._emitUpdate = emitUpdate;\n        this._removeFromQueueCallback = remove;\n        this._aborted = false;\n        this._status = SendStatus.Waiting;\n        this._sendRequest = null;\n        this._attachmentsTotalBytes = 0;\n        if (this._attachments) {\n            this._attachmentsTotalBytes = Object.values(this._attachments).reduce((t, a) => t + a.size, 0);\n        }\n    }\n\n    get roomId() { return this._data.roomId; }\n    get queueIndex() { return this._data.queueIndex; }\n    get eventType() { return this._data.eventType; }\n    get txnId() { return this._data.txnId; }\n    get remoteId() { return this._data.remoteId; }\n    get content() { return this._data.content; }\n    get relatedTxnId() { return this._data.relatedTxnId; }\n    get relatedEventId() {\n        const relation = getRelationFromContent(this.content);\n        if (relation) {\n            // may be null when target is not sent yet, is intended\n            return getRelationTarget(relation);\n        } else {\n            return this._data.relatedEventId;\n        }\n    }\n\n    setRelatedEventId(eventId) {\n        const relation = getRelationFromContent(this.content);\n        if (relation) {\n            setRelationTarget(relation, eventId);\n        } else {\n            this._data.relatedEventId = eventId;\n        }\n    }\n\n    get data() { return this._data; }\n\n    getAttachment(key) {\n        return this._attachments && this._attachments[key];\n    }\n\n    get needsSending() {\n        return !this.remoteId && !this.aborted;\n    }\n\n    get needsEncryption() {\n        return this._data.needsEncryption && !this.aborted;\n    }\n\n    get needsUpload() {\n        return this._data.needsUpload && !this.aborted;\n    }\n\n    get isMissingAttachments() {\n        return this.needsUpload && !this._attachments;\n    }\n\n    setEncrypting() {\n        this._status = SendStatus.Encrypting;\n        this._emitUpdate(\"status\");\n    }\n\n    get contentForEncryption() {\n        const content = Object.assign({}, this._data.content);\n        for (const field of unencryptedContentFields) {\n            delete content[field];\n        }\n        return content;\n    }\n\n    _preserveContentFields(into) {\n        const content = this._data.content;\n        for (const field of unencryptedContentFields) {\n            if (content[field] !== undefined) {\n                into[field] = content[field];\n            }\n        }\n    }\n\n    setEncrypted(type, content) {\n        this._preserveContentFields(content);\n        this._data.encryptedEventType = type;\n        this._data.encryptedContent = content;\n        this._data.needsEncryption = false;\n    }\n\n    setError(error) {\n        this._status = SendStatus.Error;\n        this._error = error;\n        this._emitUpdate(\"status\");\n    }\n\n    setWaiting() {\n        this._status = SendStatus.Waiting;\n        this._emitUpdate(\"status\");\n    }\n\n    get status() { return this._status; }\n    get error() { return this._error; }\n\n    get hasStartedSending() {\n        return this._status === SendStatus.Sending || this._status === SendStatus.Sent;\n    }\n\n    get attachmentsTotalBytes() {\n        return this._attachmentsTotalBytes;\n    }\n\n    get attachmentsSentBytes() {\n        return this._attachments && Object.values(this._attachments).reduce((t, a) => t + a.sentBytes, 0);\n    }\n\n    async uploadAttachments(hsApi, log) {\n        if (!this.needsUpload) {\n            return;\n        }\n        if (!this._attachments) {\n            throw new Error(\"attachments missing\");\n        }\n        if (this.needsEncryption) {\n            this._status = SendStatus.EncryptingAttachments;\n            this._emitUpdate(\"status\");\n            for (const attachment of Object.values(this._attachments)) {\n                await log.wrap(\"encrypt\", () => {\n                    log.set(\"size\", attachment.size);\n                    return attachment.encrypt();\n                });\n                if (this.aborted) {\n                    throw new AbortError();\n                }\n            }\n        }\n        this._status = SendStatus.UploadingAttachments;\n        this._emitUpdate(\"status\");\n        const entries = Object.entries(this._attachments);\n        // upload smallest attachments first\n        entries.sort(([, a1], [, a2]) => a1.size - a2.size);\n        for (const [urlPath, attachment] of entries) {\n            await log.wrap(\"upload\", log => {\n                log.set(\"size\", attachment.size);\n                return attachment.upload(hsApi, () => {\n                    this._emitUpdate(\"attachmentsSentBytes\");\n                }, log);\n            });\n            attachment.applyToContent(urlPath, this.content);\n        }\n        this._data.needsUpload = false;\n    }\n\n    async abort() {\n        if (!this._aborted) {\n            this._aborted = true;\n            if (this._attachments) {\n                for (const attachment of Object.values(this._attachments)) {\n                    attachment.abort();\n                }\n            }\n            this._sendRequest?.abort();\n            await this._removeFromQueueCallback();\n        }\n    }\n\n    get aborted() {\n        return this._aborted;\n    }\n\n    async send(hsApi, log) {\n        this._status = SendStatus.Sending;\n        this._emitUpdate(\"status\");\n        const eventType = this._data.encryptedEventType || this._data.eventType;\n        const content = this._data.encryptedContent || this._data.content;\n        if (eventType === REDACTION_TYPE) {\n            this._sendRequest = hsApi.redact(\n                    this.roomId,\n                    this._data.relatedEventId,\n                    this.txnId,\n                    content,\n                    {log}\n                );\n        } else {\n            this._sendRequest = hsApi.send(\n                    this.roomId,\n                    eventType,\n                    this.txnId,\n                    content,\n                    {log}\n                );\n        }\n        const response = await this._sendRequest.response();\n        this._sendRequest = null;\n        // both /send and /redact have the same response format\n        this._data.remoteId = response.event_id;\n        log.set(\"id\", this._data.remoteId);\n        this._status = SendStatus.Sent;\n        this._emitUpdate(\"status\");\n    }\n\n    dispose() {\n        if (this._attachments) {\n            for (const attachment of Object.values(this._attachments)) {\n                attachment.dispose();\n            }\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseEventEntry} from \"./BaseEventEntry.js\";\nimport {getPrevContentFromStateEvent, isRedacted} from \"../../common\";\nimport {getRelationFromContent, getRelatedEventId} from \"../relations.js\";\n\nexport class EventEntry extends BaseEventEntry {\n    constructor(eventEntry, fragmentIdComparer) {\n        super(fragmentIdComparer);\n        this._eventEntry = eventEntry;\n        this._decryptionError = null;\n        this._decryptionResult = null;\n    }\n\n    clone() {\n        const clone = new EventEntry(this._eventEntry, this._fragmentIdComparer);\n        clone.updateFrom(this);\n        return clone;\n    }\n\n    updateFrom(other) {\n        if (other._decryptionResult && !this._decryptionResult) {\n            this._decryptionResult = other._decryptionResult;\n        }\n        if (other._decryptionError && !this._decryptionError) {\n            this._decryptionError = other._decryptionError;\n        }\n        this._contextForEntries = other.contextForEntries;\n        this._contextEntry = other.contextEntry;\n    }\n\n    get event() {\n        return this._eventEntry.event;\n    }\n\n    get fragmentId() {\n        return this._eventEntry.fragmentId;\n    }\n\n    get entryIndex() {\n        return this._eventEntry.eventIndex;\n    }\n\n    get content() {\n        return this._decryptionResult?.event?.content || this._eventEntry.event.content;\n    }\n\n    get prevContent() {\n        // doesn't look at _decryptionResult because state events are not encrypted\n        return getPrevContentFromStateEvent(this._eventEntry.event);\n    }\n\n    get eventType() {\n        return this._decryptionResult?.event?.type || this._eventEntry.event.type;\n    }\n\n    get stateKey() {\n        return this._eventEntry.event.state_key;\n    }\n\n    get sender() {\n        return this._eventEntry.event.sender;\n    }\n\n    get displayName() {\n        return this._eventEntry.displayName;\n    }\n\n    get avatarUrl() {\n        return this._eventEntry.avatarUrl;\n    }\n\n    get timestamp() {\n        return this._eventEntry.event.origin_server_ts;\n    }\n\n    get id() {\n        return this._eventEntry.event.event_id;\n    }\n\n    setDecryptionResult(result) {\n        this._decryptionResult = result;\n    }\n\n    get isEncrypted() {\n        return this._eventEntry.event.type === \"m.room.encrypted\";\n    }\n\n    get isDecrypted() {\n        return !!this._decryptionResult?.event;\n    }\n\n    get isVerified() {\n        return this.isEncrypted && this._decryptionResult?.isVerified;\n    }\n\n    get isUnverified() {\n        return this.isEncrypted && this._decryptionResult?.isUnverified;\n    }\n\n    setDecryptionError(err) {\n        this._decryptionError = err;\n    }\n\n    get decryptionError() {\n        return this._decryptionError;\n    }\n\n    get relatedEventId() {\n        return getRelatedEventId(this.event);\n    }\n\n    get isRedacted() {\n        return super.isRedacted || isRedacted(this._eventEntry.event);\n    }\n\n    get redactionReason() {\n        const redactionEvent = this._eventEntry.event.unsigned?.redacted_because;\n        if (redactionEvent) {\n            return redactionEvent.content?.reason;\n        }\n        // fall back to local echo reason\n        return super.redactionReason;\n    }\n\n    get annotations() {\n        return this._eventEntry.annotations;\n    }\n\n    get relation() {\n        const originalContent = this._eventEntry.event.content;\n        const originalRelation = originalContent && getRelationFromContent(originalContent);\n        return originalRelation || getRelationFromContent(this.content);\n    }\n\n    // similar to relatedEventID but only for replies\n    get contextEventId() {\n        if (this.isReply) {\n            return this.relatedEventId;\n        }\n        return null;\n    }\n\n}\n\nimport {withTextBody, withContent, createEvent} from \"../../../../mocks/event.js\";\nimport {Clock as MockClock} from \"../../../../mocks/Clock.js\";\nimport {PendingEventEntry} from \"./PendingEventEntry.js\";\nimport {PendingEvent} from \"../../sending/PendingEvent.js\";\nimport {createAnnotation} from \"../relations.js\";\n\nexport function tests() {\n    let queueIndex = 0;\n    const clock = new MockClock();\n\n    function addPendingReaction(target, key) {\n        queueIndex += 1;\n        target.addLocalRelation(new PendingEventEntry({\n            pendingEvent: new PendingEvent({data: {\n                eventType: \"m.reaction\",\n                content: createAnnotation(target.id, key),\n                queueIndex,\n                txnId: `t${queueIndex}`\n            }}),\n            clock\n        }));\n        return target;\n    }\n\n    function addPendingRedaction(target, key) {\n        const pendingReaction = target.pendingAnnotations?.get(key)?.annotationEntry;\n        let redactingEntry = pendingReaction;\n        // make up a remote entry if we don't have a pending reaction and have an aggregated remote entry\n        if (!pendingReaction && target.annotations[key].me) {\n            redactingEntry = new EventEntry({\n                event: withContent(createAnnotation(target.id, key), createEvent(\"m.reaction\", \"!def\"))\n            });\n        }\n        queueIndex += 1;\n        target.addLocalRelation(new PendingEventEntry({\n            pendingEvent: new PendingEvent({data: {\n                eventType: \"m.room.redaction\",\n                relatedTxnId: pendingReaction ? pendingReaction.id : null,\n                relatedEventId: pendingReaction ? null : redactingEntry.id,\n                queueIndex,\n                txnId: `t${queueIndex}`\n            }}),\n            redactingEntry,\n            clock\n        }));\n        return target;\n    }\n\n    function remoteAnnotation(key, me, count, obj = {}) {\n        obj[key] = {me, count};\n        return obj;\n    }\n\n    return {\n        // testing it here because parent class always assumes annotations is null\n        \"haveAnnotation\": assert => {\n            const msgEvent = withTextBody(\"hi!\", createEvent(\"m.room.message\", \"!abc\"));\n            const e1 = new EventEntry({event: msgEvent});\n            assert.equal(false, e1.haveAnnotation(\"🚀\"));\n            const e2 = new EventEntry({event: msgEvent, annotations: remoteAnnotation(\"🚀\", false, 1)});\n            assert.equal(false, e2.haveAnnotation(\"🚀\"));\n            const e3 = new EventEntry({event: msgEvent, annotations: remoteAnnotation(\"🚀\", true, 1)});\n            assert.equal(true, e3.haveAnnotation(\"🚀\"));\n            const e4 = new EventEntry({event: msgEvent, annotations: remoteAnnotation(\"🚀\", true, 2)});\n            assert.equal(true, e4.haveAnnotation(\"🚀\"));\n            const e5 = addPendingReaction(new EventEntry({event: msgEvent}), \"🚀\");\n            assert.equal(true, e5.haveAnnotation(\"🚀\"));\n            const e6 = addPendingRedaction(new EventEntry({event: msgEvent, annotations: remoteAnnotation(\"🚀\", true, 1)}), \"🚀\");\n            assert.equal(false, e6.haveAnnotation(\"🚀\"));\n            const e7 = addPendingReaction(\n                addPendingRedaction(\n                    new EventEntry({event: msgEvent, annotations: remoteAnnotation(\"🚀\", true, 1)}),\n                \"🚀\"),\n            \"🚀\");\n            assert.equal(true, e7.haveAnnotation(\"🚀\"));\n            const e8 = addPendingRedaction(\n                addPendingReaction(\n                    new EventEntry({event: msgEvent}),\n                \"🚀\"),\n            \"🚀\");\n            assert.equal(false, e8.haveAnnotation(\"🚀\"));\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function createEventEntry(key, roomId, event) {\n    return {\n        fragmentId: key.fragmentId,\n        eventIndex: key.eventIndex,\n        roomId,\n        event: event,\n    };\n}\n\nexport function directionalAppend(array, value, direction) {\n    if (direction.isForward) {\n        array.push(value);\n    } else {\n        array.unshift(value);\n    }\n}\n\nexport function directionalConcat(array, otherArray, direction) {\n    if (direction.isForward) {\n        return array.concat(otherArray);\n    } else {\n        return otherArray.concat(array);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {getPrevContentFromStateEvent} from \"../common\";\n\nexport const EVENT_TYPE = \"m.room.member\";\n\nexport class RoomMember {\n    constructor(data) {\n        this._data = data;\n    }\n\n    static fromUserId(roomId, userId, membership) {\n        return new RoomMember({roomId, userId, membership});\n    }\n\n    static fromMemberEvent(roomId, memberEvent) {\n        const userId = memberEvent?.state_key;\n        if (typeof userId !== \"string\") {\n            return;\n        }\n        const content = memberEvent.content;\n        const prevContent = getPrevContentFromStateEvent(memberEvent);\n        const membership = content?.membership;\n        // fall back to prev_content for these as synapse doesn't (always?)\n        // put them on content for \"leave\" memberships\n        const displayName = content?.displayname || prevContent?.displayname;\n        const avatarUrl = content?.avatar_url || prevContent?.avatar_url;\n        return this._validateAndCreateMember(roomId, userId, membership, displayName, avatarUrl);\n    }\n    /**\n     * Creates a (historical) member from a member event that is the next member event\n     * after the point in time where we need a member for. This will use `prev_content`.\n     */\n    static fromReplacingMemberEvent(roomId, memberEvent) {\n        const userId = memberEvent && memberEvent.state_key;\n        if (typeof userId !== \"string\") {\n            return;\n        }\n        const content = getPrevContentFromStateEvent(memberEvent);\n        return this._validateAndCreateMember(roomId, userId,\n            content?.membership,\n            content?.displayname,\n            content?.avatar_url\n        );\n    }\n\n    static _validateAndCreateMember(roomId, userId, membership, displayName, avatarUrl) {\n        if (typeof membership !== \"string\") {\n            return;\n        }\n        return new RoomMember({\n            roomId,\n            userId,\n            membership,\n            avatarUrl,\n            displayName,\n        });\n    }\n\n    get membership() {\n        return this._data.membership;\n    }\n\n    /**\n     * @return {String?} the display name, if any\n     */\n    get displayName() {\n        return this._data.displayName;\n    }\n\n    /**\n     * @return {String} the display name or userId\n     */\n    get name() {\n        return this._data.displayName || this._data.userId;\n    }\n\n    /**\n     * @return {String?} the avatar mxc url, if any\n     */\n    get avatarUrl() {\n        return this._data.avatarUrl;\n    }\n\n    get roomId() {\n        return this._data.roomId;\n    }\n\n    get userId() {\n        return this._data.userId;\n    }\n\n    serialize() {\n        return this._data;\n    }\n\n    equals(other) {\n        const data = this._data;\n        const otherData = other._data;\n        return data.roomId === otherData.roomId &&\n            data.userId === otherData.userId &&\n            data.membership === otherData.membership &&\n            data.displayName === otherData.displayName &&\n            data.avatarUrl === otherData.avatarUrl;\n    }\n}\n\nexport class MemberChange {\n    constructor(member, previousMembership) {\n        this.member = member;\n        this.previousMembership = previousMembership;\n    }\n\n    get roomId() {\n        return this.member.roomId;\n    }\n\n    get userId() {\n        return this.member.userId;\n    }\n\n    get membership() {\n        return this.member.membership;\n    }\n\n    get hasLeft() {\n        return this.previousMembership === \"join\" && this.membership !== \"join\";\n    }\n\n    /** The result can be a false negative when all of these apply:\n     *  - the complete set of room members hasn't been fetched yet.\n     *  - the member event for this change was received in the\n     *    state section and wasn't present in the timeline section.\n     *  - the room response was limited, e.g. there was a gap.\n     * \n     * This is because during sync, in this case it is not possible\n     * to distinguish between a new member that joined the room\n     * during a gap and a lazy-loading member.\n     * */\n    get hasJoined() {\n        return this.previousMembership !== \"join\" && this.membership === \"join\";\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function isValidFragmentId(id) {\n    return typeof id === \"number\";\n}\n\n// copied over from matrix-js-sdk, copyright 2016 OpenMarket Ltd\n/* _REDACT_KEEP_KEY_MAP gives the keys we keep when an event is redacted\n *\n * This is specified here:\n *  http://matrix.org/speculator/spec/HEAD/client_server/latest.html#redactions\n *\n * Also:\n *  - We keep 'unsigned' since that is created by the local server\n *  - We keep user_id for backwards-compat with v1\n */\nconst _REDACT_KEEP_KEY_MAP = [\n    'event_id', 'type', 'room_id', 'user_id', 'sender', 'state_key', 'prev_state',\n    'content', 'unsigned', 'origin_server_ts',\n].reduce(function(ret, val) {\n    ret[val] = 1; return ret;\n}, {});\n\n// a map from event type to the .content keys we keep when an event is redacted\nconst _REDACT_KEEP_CONTENT_MAP = {\n    'm.room.member': {'membership': 1},\n    'm.room.create': {'creator': 1},\n    'm.room.join_rules': {'join_rule': 1},\n    'm.room.power_levels': {'ban': 1, 'events': 1, 'events_default': 1,\n                            'kick': 1, 'redact': 1, 'state_default': 1,\n                            'users': 1, 'users_default': 1,\n                           },\n    'm.room.aliases': {'aliases': 1},\n};\n// end of matrix-js-sdk code\n\nexport function redactEvent(redactionEvent, redactedEvent) {\n    for (const key of Object.keys(redactedEvent)) {\n        if (!_REDACT_KEEP_KEY_MAP[key]) {\n            delete redactedEvent[key];\n        }\n    }\n    const { content } = redactedEvent;\n    const keepMap = _REDACT_KEEP_CONTENT_MAP[redactedEvent.type];\n    for (const key of Object.keys(content)) {\n        if (!keepMap?.[key]) {\n            delete content[key];\n        }\n    }\n    redactedEvent.unsigned = redactedEvent.unsigned || {};\n    redactedEvent.unsigned.redacted_because = redactionEvent;\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\nlookups will be far more frequent than changing fragment order,\nso data structure should be optimized for fast lookup\n\nwe can have a Map: fragmentId to sortIndex\n\nchanging the order, we would need to rebuild the index\nlets do this the stupid way for now, changing any fragment rebuilds all islands\n\nto build this:\nfirst load all fragments\nput them in a map by id\nnow iterate through them\n\nuntil no more fragments\n    get the first\n    create an island array, and add to list with islands\n    going backwards and forwards\n        get and remove sibling and prepend/append it to island array\n        stop when no more previous/next\n    return list with islands\n\n*/\n\nimport {isValidFragmentId} from \"./common.js\";\n\nfunction findBackwardSiblingFragments(current, byId) {\n    const sortedSiblings = [];\n    while (isValidFragmentId(current.previousId)) {\n        const previous = byId.get(current.previousId);\n        if (!previous) {\n            break;\n        }\n        if (previous.nextId !== current.id) {\n            throw new Error(`Previous fragment ${previous.id} doesn't point back to ${current.id}`);\n        }\n        byId.delete(current.previousId);\n        sortedSiblings.unshift(previous);\n        current = previous;\n    }\n    return sortedSiblings;\n}\n\nfunction findForwardSiblingFragments(current, byId) {\n    const sortedSiblings = [];\n    while (isValidFragmentId(current.nextId)) {\n        const next = byId.get(current.nextId);\n        if (!next) {\n            break;\n        }\n        if (next.previousId !== current.id) {\n            throw new Error(`Next fragment ${next.id} doesn't point back to ${current.id}`);\n        }\n        byId.delete(current.nextId);\n        sortedSiblings.push(next);\n        current = next;\n    }\n    return sortedSiblings;\n}\n\n\nfunction createIslands(fragments) {\n    const byId = new Map();\n    for(let f of fragments) {\n        byId.set(f.id, f);\n    }\n\n    const islands = [];\n    while(byId.size) {\n        const current = byId.values().next().value;\n        byId.delete(current.id);\n        // new island\n        const previousSiblings = findBackwardSiblingFragments(current, byId);\n        const nextSiblings = findForwardSiblingFragments(current, byId);\n        const island = previousSiblings.concat(current, nextSiblings);\n        islands.push(island);\n    }\n    return islands.map(a => new Island(a));\n}\n\nclass Fragment {\n    constructor(id, previousId, nextId) {\n        this.id = id;\n        this.previousId = previousId;\n        this.nextId = nextId;\n    }\n}\n\nclass Island {\n    constructor(sortedFragments) {\n        this._idToSortIndex = new Map();\n        sortedFragments.forEach((f, i) => {\n            this._idToSortIndex.set(f.id, i);\n        });\n    }\n\n    compare(idA, idB) {\n        const sortIndexA = this._idToSortIndex.get(idA);\n        if (sortIndexA === undefined) {\n            throw new Error(`first id ${idA} isn't part of this island`);\n        }\n        const sortIndexB = this._idToSortIndex.get(idB);\n        if (sortIndexB === undefined) {\n            throw new Error(`second id ${idB} isn't part of this island`);\n        }\n        return sortIndexA - sortIndexB;\n    }\n\n    get fragmentIds() {\n        return this._idToSortIndex.keys();\n    }\n}\n\nexport class CompareError extends Error {\n    get name() { return \"CompareError\"; }\n}\n\n/*\nindex for fast lookup of how two fragments can be sorted\n*/\nexport class FragmentIdComparer {\n    constructor(fragments) {\n        this._fragmentsById = fragments.reduce((map, f) => {map.set(f.id, f); return map;}, new Map());\n        this.rebuild(fragments);\n    }\n\n    _getIsland(id) {\n        const island = this._idToIsland.get(id);\n        if (island === undefined) {\n            throw new CompareError(`Unknown fragment id ${id}`);\n        }\n        return island;\n    }\n\n    compare(idA, idB) {\n        if (idA === idB) {\n            return 0;\n        }\n        const islandA = this._getIsland(idA);\n        const islandB = this._getIsland(idB);\n        if (islandA !== islandB) {\n            throw new CompareError(`${idA} and ${idB} are on different islands, can't tell order`);\n        }\n        return islandA.compare(idA, idB);\n    }\n\n    rebuild(fragments) {\n        const islands = createIslands(fragments);\n        this._idToIsland = new Map();\n        for(let island of islands) {\n            for(let id of island.fragmentIds) {\n                this._idToIsland.set(id, island);\n            }\n        }\n    }\n\n    /** use for fragments coming out of persistence, not newly created ones, or also fragments for a new island (like for a permalink) */\n    add(fragment) {\n        const copy = new Fragment(fragment.id, fragment.previousId, fragment.nextId);\n        this._fragmentsById.set(fragment.id, copy);\n        this.rebuild(this._fragmentsById.values());\n    }\n\n    /** use for appending newly created fragments */\n    append(id, previousId) {\n        const fragment = new Fragment(id, previousId, null);\n        const prevFragment = this._fragmentsById.get(previousId);\n        if (prevFragment) {\n            prevFragment.nextId = id;\n        }\n        this._fragmentsById.set(id, fragment);\n        this.rebuild(this._fragmentsById.values());\n    }\n\n    /** use for prepending newly created fragments */\n    prepend(id, nextId) {\n        const fragment = new Fragment(id, null, nextId);\n        const nextFragment = this._fragmentsById.get(nextId);\n        if (nextFragment) {\n            nextFragment.previousId = id;\n        }\n        this._fragmentsById.set(id, fragment);\n        this.rebuild(this._fragmentsById.values());\n    }\n}\n\nexport function tests() {\n    return {\n        test_1_island_3_fragments(assert) {\n            const index = new FragmentIdComparer([\n                {id: 3, previousId: 2},\n                {id: 1, nextId: 2},\n                {id: 2, nextId: 3, previousId: 1},\n            ]);\n            assert(index.compare(1, 2) < 0);\n            assert(index.compare(2, 1) > 0);\n\n            assert(index.compare(1, 3) < 0);\n            assert(index.compare(3, 1) > 0);\n            \n            assert(index.compare(2, 3) < 0);\n            assert(index.compare(3, 2) > 0);\n            \n            assert.equal(index.compare(1, 1), 0);\n        },\n        test_falsy_id(assert) {\n            const index = new FragmentIdComparer([\n                {id: 0, nextId: 1},\n                {id: 1, previousId: 0},\n            ]);\n            assert(index.compare(0, 1) < 0);\n            assert(index.compare(1, 0) > 0);\n        },\n        test_falsy_id_reverse(assert) {\n            const index = new FragmentIdComparer([\n                {id: 1, previousId: 0},\n                {id: 0, nextId: 1},\n            ]);\n            assert(index.compare(0, 1) < 0);\n            assert(index.compare(1, 0) > 0);\n        },\n        test_allow_unknown_id(assert) {\n            // as we tend to load fragments incrementally\n            // as events come into view, we need to allow\n            // unknown previousId/nextId in the fragments that we do load\n            assert.doesNotThrow(() => {\n                new FragmentIdComparer([\n                    {id: 1, previousId: 2},\n                    {id: 0, nextId: 3},\n                ]);\n            });\n        },\n        test_throw_on_link_mismatch(assert) {\n            // as we tend to load fragments incrementally\n            // as events come into view, we need to allow\n            // unknown previousId/nextId in the fragments that we do load\n            assert.throws(() => {\n                new FragmentIdComparer([\n                    {id: 1, previousId: 0},\n                    {id: 0, nextId: 2},\n                ]);\n            });\n        },\n        test_2_island_dont_compare(assert) {\n            const index = new FragmentIdComparer([\n                {id: 1},\n                {id: 2},\n            ]);\n            assert.throws(() => index.compare(1, 2));\n            assert.throws(() => index.compare(2, 1));\n        },\n        test_2_island_compare_internally(assert) {\n            const index = new FragmentIdComparer([\n                {id: 1, nextId: 2},\n                {id: 2, previousId: 1},\n                {id: 11, nextId: 12},\n                {id: 12, previousId: 11},\n                \n            ]);\n\n            assert(index.compare(1, 2) < 0);\n            assert(index.compare(11, 12) < 0);\n            \n            assert.throws(() => index.compare(1, 11));\n            assert.throws(() => index.compare(12, 2));\n        },\n        test_unknown_id(assert) {\n            const index = new FragmentIdComparer([{id: 1}]);\n            assert.throws(() => index.compare(1, 2));\n            assert.throws(() => index.compare(2, 1));\n        },\n        test_rebuild_flushes_old_state(assert) {\n            const index = new FragmentIdComparer([\n                {id: 1, nextId: 2},\n                {id: 2, previousId: 1},\n            ]);\n            index.rebuild([\n                {id: 11, nextId: 12},\n                {id: 12, previousId: 11},\n            ]);\n            \n            assert.throws(() => index.compare(1, 2));\n            assert(index.compare(11, 12) < 0);\n        },\n        test_append(assert) {\n            const index = new FragmentIdComparer([]);\n            // add livefragment when opening timeline,\n            // note that there is no nextId as the sync\n            // hasn't come in yet\n            index.add({id: 1});\n            // now sync comes in and replaces the live fragment\n            index.append(2, 1);\n            assert(index.compare(1, 2) < 0);\n        },\n        test_prepend(assert) {\n            const index = new FragmentIdComparer([]);\n            index.add({id: 2});\n            index.prepend(1, 2);\n            assert(index.compare(1, 2) < 0);\n        }\n    }\n}\n","const scriptRel = (function detectScriptRel() {\n    // @ts-ignore\n    const relList = document.createElement('link').relList;\n    // @ts-ignore\n    return relList && relList.supports && relList.supports('modulepreload')\n        ? 'modulepreload'\n        : 'preload';\n})();const seen = {};const base = './';export const __vitePreload = function preload(baseModule, deps) {\n    // @ts-ignore\n    if (!__VITE_IS_MODERN__ || !deps || deps.length === 0) {\n        return baseModule();\n    }\n    return Promise.all(deps.map((dep) => {\n        // @ts-ignore\n        dep = `${base}${dep}`;\n        // @ts-ignore\n        if (dep in seen)\n            return;\n        // @ts-ignore\n        seen[dep] = true;\n        const isCss = dep.endsWith('.css');\n        const cssSelector = isCss ? '[rel=\"stylesheet\"]' : '';\n        // @ts-ignore check if the file is already preloaded by SSR markup\n        if (document.querySelector(`link[href=\"${dep}\"]${cssSelector}`)) {\n            return;\n        }\n        // @ts-ignore\n        const link = document.createElement('link');\n        // @ts-ignore\n        link.rel = isCss ? 'stylesheet' : scriptRel;\n        if (!isCss) {\n            link.as = 'script';\n            link.crossOrigin = '';\n        }\n        link.href = dep;\n        // @ts-ignore\n        document.head.appendChild(link);\n        if (isCss) {\n            return new Promise((res, rej) => {\n                link.addEventListener('load', res);\n                link.addEventListener('error', rej);\n            });\n        }\n    })).then(() => baseModule());\n}","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { StorageError } from \"../common\";\n\nfunction _sourceName(source: IDBIndex | IDBObjectStore): string {\n    return \"objectStore\" in source ?\n        `${source.objectStore.name}.${source.name}` :\n        source.name;\n}\n\nfunction _sourceDatabase(source: IDBIndex | IDBObjectStore): string {\n    return \"objectStore\" in source ?\n        source.objectStore?.transaction?.db?.name :\n        source.transaction?.db?.name;\n}\n\nexport class IDBError extends StorageError {\n    storeName: string;\n    databaseName: string;\n\n    constructor(message: string, sourceOrCursor: IDBIndex | IDBCursor | IDBObjectStore | null, cause: DOMException | null = null) {\n        const source = (sourceOrCursor && \"source\" in sourceOrCursor) ? sourceOrCursor.source : sourceOrCursor;\n        const storeName = source ? _sourceName(source) : \"\";\n        const databaseName = source ? _sourceDatabase(source) : \"\";\n        let fullMessage = `${message} on ${databaseName}.${storeName}`;\n        if (cause) {\n            fullMessage += \": \";\n            if (typeof cause.name === \"string\") {\n                fullMessage += `(name: ${cause.name}) `;\n            }\n            if (typeof cause.code === \"number\") {\n                fullMessage += `(code: ${cause.code}) `;\n            }\n        }\n        if (cause) {\n            fullMessage += cause.message;\n        }\n        super(fullMessage, cause);\n        this.storeName = storeName;\n        this.databaseName = databaseName;\n    }\n}\n\nexport class IDBRequestError extends IDBError {\n    private errorEvent: Event;\n\n    constructor(errorEvent: Event) {\n        const request = errorEvent.target as IDBRequest;\n        const source = request.source;\n        const cause = request.error;\n        super(\"IDBRequest failed\", source, cause);\n        this.errorEvent = errorEvent;\n    }\n\n    preventTransactionAbort() {\n        this.errorEvent.preventDefault();\n    }\n}\n\nexport class IDBRequestAttemptError extends IDBError {\n    constructor(method: string, source: IDBIndex | IDBObjectStore, cause: DOMException, params: any[]) {\n        super(`${method}(${params.map(p => JSON.stringify(p)).join(\", \")}) failed`, source, cause);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { IDBRequestError } from \"./error\";\nimport { StorageError } from \"../common\";\nimport { AbortError } from \"../../../utils/error\";\n\nlet needsSyncPromise = false;\n\nexport const DONE = { done: true }\nexport const NOT_DONE = { done: false }\n\n/* should be called on legacy platforms to see\n   if transactions close before draining the microtask queue (IE11 on Windows 7).\n   If this is the case, promises need to be resolved\n   synchronously from the idb request handler to prevent the transaction from closing prematurely.\n*/\nexport async function checkNeedsSyncPromise(): Promise<boolean> {\n    // important to have it turned off while doing the test,\n    // otherwise reqAsPromise would not fail\n    needsSyncPromise = false;\n    const NAME = \"test-idb-needs-sync-promise\";\n    const db = await openDatabase(NAME, db => {\n        db.createObjectStore(\"test\", {keyPath: \"key\"});\n    }, 1);\n    const txn = db.transaction(\"test\", \"readonly\");\n    try {\n        await reqAsPromise(txn.objectStore(\"test\").get(1));\n        await reqAsPromise(txn.objectStore(\"test\").get(2));\n    } catch (err) {\n        // err.name would be either TransactionInactiveError or InvalidStateError,\n        // but let's not exclude any other failure modes\n        needsSyncPromise = true;\n    }\n    // we could delete the store here, \n    // but let's not create it on every page load on legacy platforms,\n    // and just keep it around\n    return needsSyncPromise;\n}\n\n// storage keys are defined to be unsigned 32bit numbers in KeyLimits, which is assumed by idb\nexport function encodeUint32(n: number): string {\n    const hex = n.toString(16);\n    return \"0\".repeat(8 - hex.length) + hex;\n}\n\n// used for logs where timestamp is part of key, which is larger than 32 bit\nexport function encodeUint64(n: number): string {\n    const hex = n.toString(16);\n    return \"0\".repeat(16 - hex.length) + hex;\n}\n\nexport function decodeUint32(str: string): number {\n    return parseInt(str, 16);\n}\n\nexport type CreateObjectStore = (db : IDBDatabase, txn: IDBTransaction | null, oldVersion: number, version: number) => any\n\nexport function openDatabase(name: string, createObjectStore: CreateObjectStore, version: number, idbFactory: IDBFactory = window.indexedDB): Promise<IDBDatabase> {\n    const req = idbFactory.open(name, version);\n    req.onupgradeneeded = async (ev : IDBVersionChangeEvent) => {\n        const req = ev.target as IDBRequest<IDBDatabase>;\n        const db = req.result;\n        const txn = req.transaction!;\n        const oldVersion = ev.oldVersion;\n        try {\n            await createObjectStore(db, txn, oldVersion, version);\n        } catch (err) {\n            // try aborting on error, if that hasn't been done already\n            try {\n                txn.abort();\n            } catch (err) {}\n        }\n    }; \n    return reqAsPromise(req);\n}\n\nexport function reqAsPromise<T>(req: IDBRequest<T>): Promise<T> {\n    return new Promise((resolve, reject) => {\n        req.addEventListener(\"success\", event => {\n            resolve((event.target as IDBRequest<T>).result);\n            // @ts-ignore\n            needsSyncPromise && Promise._flush && Promise._flush();\n        });\n        req.addEventListener(\"error\", event => {\n            const error = new IDBRequestError(event);\n            reject(error);\n            // @ts-ignore\n            needsSyncPromise && Promise._flush && Promise._flush();\n        });\n    });\n}\n\nexport function txnAsPromise(txn): Promise<void> {\n    let error;\n    return new Promise((resolve, reject) => {\n        txn.addEventListener(\"complete\", () => {\n            resolve();\n            // @ts-ignore\n            needsSyncPromise && Promise._flush && Promise._flush();\n        });\n        txn.addEventListener(\"abort\", event => {\n            reject(new AbortError());\n            // @ts-ignore\n            needsSyncPromise && Promise._flush && Promise._flush();\n        });\n    });\n}\n\n/**\n * This type is rather complicated, but I hope that this is for a good reason. There\n * are currently two uses for `iterateCursor`: iterating a regular cursor, and iterating\n * a key-only cursor, which does not have values. These two uses are distinct, and iteration\n * never stops or starts having a value halfway through.\n *\n * Each of the argument functions currently either assumes the value will be there, or that it won't. We thus can't\n * just accept a function argument `(T | undefined) => { done: boolean }`, since this messes with\n * the type safety in both cases: the former case will have to check for `undefined`, and\n * the latter would have an argument that can be `T`, even though it never will.\n *\n * So the approach here is to let TypeScript infer and accept (via generics) the type of\n * the cursor, which is either `IDBCursorWithValue` or `IDBCursor`. Since the type is accepted\n * via generics, we can actually vary the types of the actual function arguments depending on it.\n * Thus, when a value is available (an `IDBCursorWithValue` is given), we require a function `(T) => ...`, and when it is not, we require\n * a function `(undefined) => ...`.\n */\ntype CursorIterator<T, I extends IDBCursor> = (value: I extends IDBCursorWithValue ? T : undefined, key: IDBValidKey, cursor: I) => { done: boolean, jumpTo?: IDBValidKey }\n\nexport function iterateCursor<T, I extends IDBCursor = IDBCursorWithValue>(cursorRequest: IDBRequest<I | null>, processValue: CursorIterator<T, I>): Promise<boolean> {\n    // TODO: does cursor already have a value here??\n    return new Promise<boolean>((resolve, reject) => {\n        cursorRequest.onerror = event => {\n            reject(new IDBRequestError(event));\n            // @ts-ignore\n            needsSyncPromise && Promise._flush && Promise._flush();\n        };\n        // collect results\n        cursorRequest.onsuccess = (event) => {\n            const cursor = (event.target as IDBRequest<I>).result;\n            if (!cursor) {\n                resolve(false);\n                // @ts-ignore\n                needsSyncPromise && Promise._flush && Promise._flush();\n                return; // end of results\n            }\n            const result = processValue(cursor[\"value\"], cursor.key, cursor);\n            // TODO: don't use object for result and assume it's jumpTo when not === true/false or undefined\n            const done = result?.done;\n            const jumpTo = result?.jumpTo;\n\n            if (done) {\n                resolve(true);\n                // @ts-ignore\n                needsSyncPromise && Promise._flush && Promise._flush();\n            } else if(jumpTo) {\n                cursor.continue(jumpTo);\n            } else {\n                cursor.continue();\n            }\n        };\n    }).catch(err => {\n        throw new StorageError(\"iterateCursor failed\", err);\n    });\n}\n\ntype Pred<T> = (value: T) => boolean\n\nexport async function fetchResults<T>(cursor: IDBRequest, isDone: Pred<T[]>): Promise<T[]> {\n    const results: T[] = [];\n    await iterateCursor<T>(cursor, (value) => {\n        results.push(value);\n        return {done: isDone(results)};\n    });\n    return results;\n}\n\ntype ToCursor = (store: IDBObjectStore) => IDBRequest\n\nexport async function select<T>(db: IDBDatabase, storeName: string, toCursor: ToCursor, isDone: Pred<T[]>): Promise<T[]> {\n    if (!isDone) {\n        isDone = () => false;\n    }\n    if (!toCursor) {\n        toCursor = store => store.openCursor();\n    }\n    const tx = db.transaction([storeName], \"readonly\");\n    const store = tx.objectStore(storeName);\n    const cursor = toCursor(store);\n    return await fetchResults(cursor, isDone);\n}\n\nexport async function findStoreValue<T>(db: IDBDatabase, storeName: string, toCursor: ToCursor, matchesValue: Pred<T>): Promise<T> {\n    if (!matchesValue) {\n        matchesValue = () => true;\n    }\n    if (!toCursor) {\n        toCursor = store => store.openCursor();\n    }\n\n    const tx = db.transaction([storeName], \"readwrite\");\n    const store = tx.objectStore(storeName);\n    const cursor = await reqAsPromise(toCursor(store));\n    let match;\n    const matched = await iterateCursor<T>(cursor, (value) => {\n        if (matchesValue(value)) {\n            match = value;\n            return DONE;\n        }\n        return NOT_DONE;\n    });\n    if (!matched) {\n        throw new StorageError(\"Value not found\");\n    }\n    return match;\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {iterateCursor, DONE, NOT_DONE, reqAsPromise} from \"./utils\";\nimport {StorageError} from \"../common\";\nimport {ILogItem} from \"../../../logging/types\";\nimport {IDBKey} from \"./Transaction\";\n\n// this is the part of the Transaction class API that is used here and in the Store subclass,\n// to make it easier to replace it with alternative implementations in schema.ts and unit tests\nexport interface ITransaction {\n    idbFactory: IDBFactory;\n    IDBKeyRange: typeof IDBKeyRange;\n    databaseName: string;\n    addWriteError(error: StorageError, refItem: ILogItem | undefined, operationName: string, keys: IDBKey[] | undefined);\n}\n\ntype Reducer<A,B> = (acc: B, val: A) => B\n\nexport type IDBQuery = IDBValidKey | IDBKeyRange | undefined | null\n\ninterface QueryTargetInterface<T> {\n    openCursor(range?: IDBQuery, direction?: IDBCursorDirection | undefined): IDBRequest<IDBCursorWithValue | null>;\n    openKeyCursor(range?: IDBQuery, direction?: IDBCursorDirection | undefined): IDBRequest<IDBCursor | null>;\n    supports(method: string): boolean;\n    keyPath: string | string[];\n    count(keyRange?: IDBKeyRange): IDBRequest<number>;\n    get(key: IDBValidKey | IDBKeyRange): IDBRequest<T | undefined>;\n    getKey(key: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey | undefined>;\n}\n\nexport class QueryTarget<T> {\n    protected _target: QueryTargetInterface<T>;\n    protected _transaction: ITransaction;\n\n    constructor(target: QueryTargetInterface<T>, transaction: ITransaction) {\n        this._target = target;\n        this._transaction = transaction;\n    }\n\n    get idbFactory(): IDBFactory {\n        return this._transaction.idbFactory;\n    }\n\n    get IDBKeyRange(): typeof IDBKeyRange {\n        return this._transaction.IDBKeyRange;\n    }\n\n    get databaseName(): string {\n        return this._transaction.databaseName;\n    }\n\n    _openCursor(range?: IDBQuery, direction?: IDBCursorDirection): IDBRequest<IDBCursorWithValue | null> {\n        if (range && direction) {\n            return this._target.openCursor(range, direction);\n        } else if (range) {\n            return this._target.openCursor(range);\n        } else if (direction) {\n            return this._target.openCursor(null, direction);\n        } else {\n            return this._target.openCursor();\n        }\n    }\n\n    supports(methodName: string): boolean {\n        return this._target.supports(methodName);\n    }\n\n    count(keyRange?: IDBKeyRange): Promise<number> {\n        return reqAsPromise(this._target.count(keyRange));\n    }\n\n    get(key: IDBValidKey | IDBKeyRange): Promise<T | undefined> {\n        return reqAsPromise(this._target.get(key));\n    }\n\n    getKey(key: IDBValidKey | IDBKeyRange): Promise<IDBValidKey | undefined> {\n        if (this._target.supports(\"getKey\")) {\n            return reqAsPromise(this._target.getKey(key));\n        } else {\n            return reqAsPromise(this._target.get(key)).then(value => {\n                if (value) {\n                    let keyPath = this._target.keyPath;\n                    if (typeof keyPath === \"string\") {\n                        keyPath = [keyPath];\n                    }\n                    return keyPath.reduce((obj, key) => obj[key], value);\n                }\n            });\n        }\n    }\n\n    reduce<B>(range: IDBQuery, reducer: Reducer<T,B>, initialValue: B): Promise<boolean> {\n        return this._reduce(range, reducer, initialValue, \"next\");\n    }\n\n    reduceReverse<B>(range: IDBQuery, reducer: Reducer<T,B>, initialValue: B): Promise<boolean> {\n        return this._reduce(range, reducer, initialValue, \"prev\");\n    }\n    \n    selectLimit(range: IDBQuery, amount: number): Promise<T[]> {\n        return this._selectLimit(range, amount, \"next\");\n    }\n\n    selectLimitReverse(range: IDBQuery, amount: number): Promise<T[]> {\n        return this._selectLimit(range, amount, \"prev\");\n    }\n\n    selectWhile(range: IDBQuery, predicate: (v: T) => boolean): Promise<T[]> {\n        return this._selectWhile(range, predicate, \"next\");\n    }\n\n    selectWhileReverse(range: IDBQuery, predicate: (v: T) => boolean): Promise<T[]> {\n        return this._selectWhile(range, predicate, \"prev\");\n    }\n\n    async selectAll(range?: IDBQuery, direction?: IDBCursorDirection): Promise<T[]> {\n        const cursor = this._openCursor(range, direction);\n        const results: T[] = [];\n        await iterateCursor<T>(cursor, (value) => {\n            results.push(value);\n            return NOT_DONE;\n        });\n        return results;\n    }\n\n    selectFirst(range: IDBQuery): Promise<T | undefined> {\n        return this._find(range, () => true, \"next\");\n    }\n\n    selectLast(range: IDBQuery): Promise<T | undefined> {\n        return this._find(range, () => true, \"prev\");\n    }\n\n    find(range: IDBQuery, predicate: (v: T) => boolean): Promise<T | undefined> {\n        return this._find(range, predicate, \"next\");\n    }\n\n    findReverse(range: IDBQuery, predicate: (v : T) => boolean): Promise<T | undefined> {\n        return this._find(range, predicate, \"prev\");\n    }\n\n    async findMaxKey(range: IDBQuery): Promise<IDBValidKey | undefined> {\n        const cursor = this._target.openKeyCursor(range, \"prev\");\n        let maxKey;\n        await iterateCursor(cursor, (_, key) => {\n            maxKey = key;\n            return DONE;\n        });\n        return maxKey;\n    }\n\n\n    async iterateValues(range: IDBQuery, callback: (val: T, key: IDBValidKey, cur: IDBCursorWithValue) => boolean): Promise<void>  {\n        const cursor = this._target.openCursor(range, \"next\");\n        await iterateCursor<T>(cursor, (value, key, cur) => {\n            return {done: callback(value, key, cur)};\n        });\n    }\n\n    async iterateKeys(range: IDBQuery, callback: (key: IDBValidKey, cur: IDBCursor) => boolean): Promise<void> {\n        const cursor = this._target.openKeyCursor(range, \"next\");\n        await iterateCursor(cursor, (_, key, cur) => {\n            return {done: callback(key, cur)};\n        });\n    }\n\n    /**\n     * Checks if a given set of keys exist.\n     * If the callback returns true, the search is halted and callback won't be called again.\n     */\n    async findExistingKeys(keys: IDBValidKey[], backwards: boolean, callback: (key: IDBValidKey, pk: IDBValidKey) => boolean): Promise<void> {\n        const compareKeys = (a, b) => backwards ? -this.idbFactory.cmp(a, b) : this.idbFactory.cmp(a, b);\n        const sortedKeys = keys.slice().sort(compareKeys);\n        const firstKey = sortedKeys[0];\n        const lastKey = sortedKeys[sortedKeys.length - 1];\n        const direction = backwards ? \"prev\" : \"next\";\n        const cursor = this._target.openKeyCursor(this.IDBKeyRange.bound(firstKey, lastKey), direction);\n        let index = 0;\n        await iterateCursor(cursor, (value, key, cursor) => {\n            while (index < sortedKeys.length && compareKeys(sortedKeys[index], key) < 0) {\n                index += 1;\n            }\n            let done = false;\n            if (sortedKeys[index] === key) {\n                const pk = cursor.primaryKey;\n                done = callback(key, pk);\n                index += 1;\n            }\n            if (done || index >= sortedKeys.length) {\n                return DONE;\n            } else {\n                return {\n                    done: false,\n                    jumpTo: sortedKeys[index],\n                }\n            }\n        });\n    }\n\n    _reduce<B>(range: IDBQuery, reducer: (reduced: B, value: T) => B, initialValue: B, direction: IDBCursorDirection): Promise<boolean> {\n        let reducedValue = initialValue;\n        const cursor = this._openCursor(range, direction);\n        return iterateCursor<T>(cursor, (value) => {\n            reducedValue = reducer(reducedValue, value);\n            return NOT_DONE;\n        });\n    }\n\n    _selectLimit(range: IDBQuery, amount: number, direction: IDBCursorDirection): Promise<T[]> {\n        return this._selectUntil(range, (results) => {\n            return results.length === amount;\n        }, direction);\n    }\n\n    async _selectUntil(range: IDBQuery, predicate: (vs: T[], v: T) => boolean, direction: IDBCursorDirection): Promise<T[]> {\n        const cursor = this._openCursor(range, direction);\n        const results: T[] = [];\n        await iterateCursor<T>(cursor, (value) => {\n            results.push(value);\n            return {done: predicate(results, value)};\n        });\n        return results;\n    }\n\n    // allows you to fetch one too much that won't get added when the predicate fails\n    async _selectWhile(range: IDBQuery, predicate: (v: T) => boolean, direction: IDBCursorDirection): Promise<T[]> {\n        const cursor = this._openCursor(range, direction);\n        const results: T[] = [];\n        await iterateCursor<T>(cursor, (value) => {\n            const passesPredicate = predicate(value);\n            if (passesPredicate) {\n                results.push(value);\n            }\n            return {done: !passesPredicate};\n        });\n        return results;\n    }\n\n    async iterateWhile(range: IDBQuery, predicate: (v: T) => boolean): Promise<void> {\n        const cursor = this._openCursor(range, \"next\");\n        await iterateCursor<T>(cursor, (value) => {\n            const passesPredicate = predicate(value);\n            return {done: !passesPredicate};\n        });\n    }\n\n    async _find(range: IDBQuery, predicate: (v: T) => boolean, direction: IDBCursorDirection): Promise<T | undefined> {\n        const cursor = this._openCursor(range, direction);\n        let result;\n        const found = await iterateCursor<T>(cursor, (value) => {\n            const found = predicate(value);\n            if (found) {\n                result = value;\n            }\n            return {done: found};\n        });\n        if (found) {\n            return result;\n        }\n    }\n}\n\nimport {createMockDatabase, createMockIDBFactory, getMockIDBKeyRange} from \"../../../mocks/Storage\";\nimport {txnAsPromise} from \"./utils\";\nimport {QueryTargetWrapper, Store} from \"./Store\";\n\nexport async function tests() {\n\n    class MockTransaction {\n        constructor(public readonly idbFactory: IDBFactory, readonly idbKeyRangeType: typeof IDBKeyRange) {}\n\n        get IDBKeyRange(): typeof IDBKeyRange {\n            return this.idbKeyRangeType;\n        }\n        get databaseName(): string { return \"mockdb\"; }\n        addWriteError(error: StorageError, refItem: ILogItem | undefined, operationName: string, keys: IDBKey[] | undefined) {}\n    }\n\n    interface TestEntry {\n        key: string\n    }\n\n    async function createTestStore(): Promise<Store<TestEntry>> {\n        const idbFactory = await createMockIDBFactory();\n        const idbKeyRangeType = await getMockIDBKeyRange();\n        const mockImpl = new MockTransaction(idbFactory, idbKeyRangeType);\n        const db = await createMockDatabase(\"findExistingKeys\", (db: IDBDatabase) => {\n            db.createObjectStore(\"test\", {keyPath: \"key\"});\n        }, idbFactory);\n        const txn = db.transaction([\"test\"], \"readwrite\");\n        return new Store<TestEntry>(txn.objectStore(\"test\"), mockImpl);\n    }\n\n    return {\n        \"findExistingKeys should not match on empty store\": async assert => {\n            const store = await createTestStore();\n            await store.findExistingKeys([\"2db1a709-d8f1-4c40-a835-f312badd277a\", \"fe7aa5c2-d4ed-4278-b3b0-f49d48d11df2\"], false, () => {\n                assert.fail(\"no key should match\");\n                return false;\n            });\n        },\n        \"findExistingKeys should not match any existing keys (in between sorting order)\": async assert => {\n            const store = await createTestStore();\n            store.add({key: \"43cd16eb-a6b4-4b9d-ab36-ab87d1b038c3\"});\n            store.add({key: \"b655e7c5-e02d-4823-a7af-4202b12de659\"});\n            await store.findExistingKeys([\"2db1a709-d8f1-4c40-a835-f312badd277a\", \"fe7aa5c2-d4ed-4278-b3b0-f49d48d11df2\"], false, () => {\n                assert.fail(\"no key should match\");\n                return false;\n            });\n        },\n        \"findExistingKeys should match only existing keys\": async assert => {\n            const store = await createTestStore();\n            store.add({key: \"2db1a709-d8f1-4c40-a835-f312badd277a\"});\n            store.add({key: \"43cd16eb-a6b4-4b9d-ab36-ab87d1b038c3\"});\n            store.add({key: \"fe7aa5c2-d4ed-4278-b3b0-f49d48d11df2\"});\n            const found: string[] = [];\n            await store.findExistingKeys([\n                \"2db1a709-d8f1-4c40-a835-f312badd277a\",\n                \"eac3ef5c-a48f-4e19-b41d-ebd1d84c53f2\",\n                \"fe7aa5c2-d4ed-4278-b3b0-f49d48d11df2\"\n            ], false, (key: IDBValidKey) => {\n                found.push(key as string);\n                return false;\n            });\n            assert.equal(found.length, 2);\n            assert.equal(found[0], \"2db1a709-d8f1-4c40-a835-f312badd277a\");\n            assert.equal(found[1], \"fe7aa5c2-d4ed-4278-b3b0-f49d48d11df2\");\n        },\n        \"findExistingKeys should match all if all exist\": async assert => {\n            const store = await createTestStore();\n            store.add({key: \"2db1a709-d8f1-4c40-a835-f312badd277a\"});\n            store.add({key: \"fe7aa5c2-d4ed-4278-b3b0-f49d48d11df2\"});\n            store.add({key: \"b655e7c5-e02d-4823-a7af-4202b12de659\"});\n            const found: string[] = [];\n            await store.findExistingKeys([\n                \"2db1a709-d8f1-4c40-a835-f312badd277a\",\n                \"b655e7c5-e02d-4823-a7af-4202b12de659\",\n                \"fe7aa5c2-d4ed-4278-b3b0-f49d48d11df2\"\n            ], false, (key: IDBValidKey) => {\n                found.push(key as string);\n                return false;\n            });\n            assert.equal(found.length, 3);\n            assert.equal(found[0], \"2db1a709-d8f1-4c40-a835-f312badd277a\");\n            assert.equal(found[1], \"b655e7c5-e02d-4823-a7af-4202b12de659\");\n            assert.equal(found[2], \"fe7aa5c2-d4ed-4278-b3b0-f49d48d11df2\");\n        },\n        \"findExistingKeys should stop matching when callback returns true\": async assert => {\n            const store = await createTestStore();\n            store.add({key: \"2db1a709-d8f1-4c40-a835-f312badd277a\"});\n            store.add({key: \"fe7aa5c2-d4ed-4278-b3b0-f49d48d11df2\"});\n            store.add({key: \"b655e7c5-e02d-4823-a7af-4202b12de659\"});\n            const found: string[] = [];\n            await store.findExistingKeys([\n                \"2db1a709-d8f1-4c40-a835-f312badd277a\",\n                \"b655e7c5-e02d-4823-a7af-4202b12de659\",\n                \"fe7aa5c2-d4ed-4278-b3b0-f49d48d11df2\"\n            ], false, (key: IDBValidKey) => {\n                found.push(key as string);\n                return true;\n            });\n            assert.equal(found.length, 1);\n            assert.equal(found[0], \"2db1a709-d8f1-4c40-a835-f312badd277a\");\n        },\n        \n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {QueryTarget, IDBQuery, ITransaction} from \"./QueryTarget\";\nimport {IDBRequestError, IDBRequestAttemptError} from \"./error\";\nimport {reqAsPromise} from \"./utils\";\nimport {Transaction, IDBKey} from \"./Transaction\";\nimport {ILogItem} from \"../../../logging/types\";\n\nconst LOG_REQUESTS = false;\n\nfunction logRequest(method: string, params: any[], source: any): void {\n    const storeName = source?.name;\n    const databaseName = source?.transaction?.db?.name;\n    console.info(`${databaseName}.${storeName}.${method}(${params.map(p => JSON.stringify(p)).join(\", \")})`);\n}\n\nexport class QueryTargetWrapper<T> {\n    private _qt: IDBIndex | IDBObjectStore;\n\n    constructor(qt: IDBIndex | IDBObjectStore) {\n        this._qt = qt;\n    }\n\n    get keyPath(): string | string[] {\n        return this._qtStore.keyPath;\n    }\n\n    get _qtStore(): IDBObjectStore {\n        if (\"objectStore\" in this._qt) {\n            return this._qt.objectStore;\n        }\n        return this._qt;\n    }\n\n    supports(methodName: string): boolean {\n        return !!this._qt[methodName];\n    }\n    \n    openKeyCursor(range?: IDBQuery, direction?: IDBCursorDirection | undefined): IDBRequest<IDBCursor | null> {\n        try {\n            // not supported on Edge 15\n            if (!this._qt.openKeyCursor) {\n                LOG_REQUESTS && logRequest(\"openCursor\", [range, direction], this._qt);\n                return this.openCursor(range, direction);\n            }\n            LOG_REQUESTS && logRequest(\"openKeyCursor\", [range, direction], this._qt);\n            return this._qt.openKeyCursor(range, direction)\n        } catch(err) {\n            throw new IDBRequestAttemptError(\"openKeyCursor\", this._qt, err, [range, direction]);\n        }\n    }\n    \n    openCursor(range?: IDBQuery, direction?: IDBCursorDirection | undefined): IDBRequest<IDBCursorWithValue | null> {\n        try {\n            LOG_REQUESTS && logRequest(\"openCursor\", [], this._qt);\n            return this._qt.openCursor(range, direction)\n        } catch(err) {\n            throw new IDBRequestAttemptError(\"openCursor\", this._qt, err, [range, direction]);\n        }\n    }\n\n    put(item: T, key?: IDBValidKey | undefined): IDBRequest<IDBValidKey> {\n        try {\n            LOG_REQUESTS && logRequest(\"put\", [item, key], this._qt);\n            return this._qtStore.put(item, key);\n        } catch(err) {\n            throw new IDBRequestAttemptError(\"put\", this._qt, err, [item, key]);\n        }\n    }\n\n    add(item: T, key?: IDBValidKey | undefined): IDBRequest<IDBValidKey> {\n        try {\n            LOG_REQUESTS && logRequest(\"add\", [item, key], this._qt);\n            return this._qtStore.add(item, key);\n        } catch(err) {\n            throw new IDBRequestAttemptError(\"add\", this._qt, err, [item, key]);\n        }\n    }\n\n    get(key: IDBValidKey | IDBKeyRange): IDBRequest<T | undefined> {\n        try {\n            LOG_REQUESTS && logRequest(\"get\", [key], this._qt);\n            return this._qt.get(key);\n        } catch(err) {\n            throw new IDBRequestAttemptError(\"get\", this._qt, err, [key]);\n        }\n    }\n    \n    getKey(key: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey | undefined> {\n        try {\n            LOG_REQUESTS && logRequest(\"getKey\", [key], this._qt);\n            return this._qt.getKey(key)\n        } catch(err) {\n            throw new IDBRequestAttemptError(\"getKey\", this._qt, err, [key]);\n        }\n    }\n\n    delete(key: IDBValidKey | IDBKeyRange): IDBRequest<undefined> {\n        try {\n            LOG_REQUESTS && logRequest(\"delete\", [key], this._qt);\n            return this._qtStore.delete(key);\n        } catch(err) {\n            throw new IDBRequestAttemptError(\"delete\", this._qt, err, [key]);\n        }\n    }\n\n    count(keyRange?: IDBKeyRange): IDBRequest<number> {\n        try {\n            return this._qt.count(keyRange);\n        } catch(err) {\n            throw new IDBRequestAttemptError(\"count\", this._qt, err, [keyRange]);\n        }\n    }\n\n    index(name: string): IDBIndex {\n        try {\n            return this._qtStore.index(name);\n        } catch(err) {\n            // TODO: map to different error? this is not a request\n            throw new IDBRequestAttemptError(\"index\", this._qt, err, [name]);\n        }\n    }\n\n    get indexNames(): string[] {\n        return Array.from(this._qtStore.indexNames);\n    }\n}\n\nexport class Store<T> extends QueryTarget<T> {\n    constructor(idbStore: IDBObjectStore, transaction: ITransaction) {\n        super(new QueryTargetWrapper<T>(idbStore), transaction);\n    }\n\n    get _idbStore(): QueryTargetWrapper<T> {\n        return (this._target as QueryTargetWrapper<T>);\n    }\n\n    index(indexName: string): QueryTarget<T> {\n        return new QueryTarget<T>(new QueryTargetWrapper<T>(this._idbStore.index(indexName)), this._transaction);\n    }\n\n    put(value: T, log?: ILogItem): void {\n        // If this request fails, the error will bubble up to the transaction and abort it,\n        // which is the behaviour we want. Therefore, it is ok to not create a promise for this\n        // request and await it.\n        // \n        // Perhaps at some later point, we will want to handle an error (like ConstraintError) for\n        // individual write requests. In that case, we should add a method that returns a promise (e.g. putAndObserve)\n        // and call preventDefault on the event to prevent it from aborting the transaction\n        // \n        // Note that this can still throw synchronously, like it does for TransactionInactiveError,\n        // see https://www.w3.org/TR/IndexedDB-2/#transaction-lifetime-concept\n        const request = this._idbStore.put(value);\n        this._prepareErrorLog(request, log, \"put\", undefined, value);\n    }\n\n    add(value: T, log?: ILogItem): void {\n        // ok to not monitor result of request, see comment in `put`.\n        const request = this._idbStore.add(value);\n        this._prepareErrorLog(request, log, \"add\", undefined, value);\n    }\n\n    async tryAdd(value: T, log: ILogItem): Promise<boolean> {\n        try {\n            await reqAsPromise(this._idbStore.add(value));\n            return true;\n        } catch (err) {\n            if (err instanceof IDBRequestError) {\n                log.log({l: \"could not write\", id: this._getKeys(value), e: err}, log.level.Warn);\n                err.preventTransactionAbort();\n                return false;\n            } else {\n                throw err;\n            }\n        }\n    }\n\n    delete(keyOrKeyRange: IDBValidKey | IDBKeyRange, log?: ILogItem): void {\n        // ok to not monitor result of request, see comment in `put`.\n        const request = this._idbStore.delete(keyOrKeyRange);\n        this._prepareErrorLog(request, log, \"delete\", keyOrKeyRange, undefined);\n    }\n\n    private _prepareErrorLog(request: IDBRequest, log: ILogItem | undefined, operationName: string, key: IDBKey | undefined, value: T | undefined) {\n        if (log) {\n            log.ensureRefId();\n        }\n        reqAsPromise(request).catch(err => {\n            let keys : IDBKey[] | undefined = undefined;\n            if (value) {\n                keys = this._getKeys(value);\n            } else if (key) {\n                keys = [key];\n            }\n            this._transaction.addWriteError(err, log, operationName, keys);\n        });\n    }\n\n    private _getKeys(value: T): IDBValidKey[] {\n        const keys: IDBValidKey[] = [];\n        const {keyPath} = this._idbStore;\n        try {\n            keys.push(this._readKeyPath(value, keyPath));\n        } catch (err) {\n            console.warn(\"could not read keyPath\", keyPath);\n        }\n        for (const indexName of this._idbStore.indexNames) {\n            try {\n                const index = this._idbStore.index(indexName);\n                keys.push(this._readKeyPath(value, index.keyPath));\n            } catch (err) {\n                console.warn(\"could not read index\", indexName);\n            }\n        }\n        return keys;\n    }\n\n    private _readKeyPath(value: T, keyPath: string[] | string): IDBValidKey {\n        if (Array.isArray(keyPath)) {\n            let field: any = value;\n            for (const part of keyPath) {\n                if (typeof field === \"object\") {\n                    field = field[part];\n                } else {\n                    break;\n                }\n            }\n            return field as IDBValidKey;\n        } else {\n            return value[keyPath] as IDBValidKey;\n        }\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function stringify(value: any): string {\n    return JSON.stringify(encodeValue(value));\n}\n\nexport function parse(value: string): any {\n    return decodeValue(JSON.parse(value));\n}\n\nfunction encodeValue(value: any): any {\n    if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n        // TypedArray\n        if (value.byteLength) {\n            return {_type: value.constructor.name, value: Array.from(value)};\n        }\n        let newObj = {};\n        for (const prop in value) {\n            if (value.hasOwnProperty(prop)) {\n                newObj[prop] = encodeValue(value[prop]);\n            }\n        }\n        return newObj;\n    } else {\n        return value;\n    }\n}\n\nfunction decodeValue(value: any): any {\n    if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n        if (typeof value._type === \"string\") {\n            switch (value._type) {\n                case \"Int8Array\": return Int8Array.from(value.value);\n                case \"Uint8Array\": return Uint8Array.from(value.value);\n                case \"Uint8ClampedArray\": return Uint8ClampedArray.from(value.value);\n                case \"Int16Array\": return Int16Array.from(value.value);\n                case \"Uint16Array\": return Uint16Array.from(value.value);\n                case \"Int32Array\": return Int32Array.from(value.value);\n                case \"Uint32Array\": return Uint32Array.from(value.value);\n                case \"Float32Array\": return Float32Array.from(value.value);\n                case \"Float64Array\": return Float64Array.from(value.value);\n                case \"BigInt64Array\": return BigInt64Array.from(value.value);\n                case \"BigUint64Array\": return BigUint64Array.from(value.value);\n                default:\n                    return value.value;\n            }\n        }\n        let newObj = {};\n        for (const prop in value) {\n            if (value.hasOwnProperty(prop)) {\n                newObj[prop] = decodeValue(value[prop]);\n            }\n        }\n        return newObj;\n    } else {\n        return value;\n    }\n}\n\nexport function tests() {\n    return {\n        \"Uint8Array and primitives\": assert => {\n            const value = {\n                foo: \"bar\",\n                bar: 5,\n                baz: false,\n                fuzz: new Uint8Array([3, 1, 2])\n            };\n            const serialized = stringify(value);\n            assert.strictEqual(typeof serialized, \"string\");\n            const deserialized = parse(serialized);\n            assert.strictEqual(deserialized.foo, \"bar\");\n            assert.strictEqual(deserialized.bar, 5);\n            assert.strictEqual(deserialized.baz, false);\n            assert(deserialized.fuzz instanceof Uint8Array);\n            assert.strictEqual(deserialized.fuzz.length, 3);\n            assert.strictEqual(deserialized.fuzz[0], 3);\n            assert.strictEqual(deserialized.fuzz[1], 1);\n            assert.strictEqual(deserialized.fuzz[2], 2);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {Store} from \"../Store\";\nimport {IDOMStorage} from \"../types\";\nimport {SESSION_E2EE_KEY_PREFIX} from \"../../../e2ee/common.js\";\nimport {parse, stringify} from \"../../../../utils/typedJSON\";\nimport type {ILogItem} from \"../../../../logging/types\";\n\nexport interface SessionEntry {\n    key: string;\n    value: any;\n}\n\nexport class SessionStore {\n    private _sessionStore: Store<SessionEntry>\n    private _localStorage: IDOMStorage;\n\n    constructor(sessionStore: Store<SessionEntry>, localStorage: IDOMStorage) {\n        this._sessionStore = sessionStore;\n        this._localStorage = localStorage;\n    }\n\n    private get _localStorageKeyPrefix(): string {\n        return `${this._sessionStore.databaseName}.session.`;\n    }\n\n    async get(key: string): Promise<any> {\n        const entry = await this._sessionStore.get(key);\n        if (entry) {\n            return entry.value;\n        }\n    }\n\n    _writeKeyToLocalStorage(key: string, value: any) {\n        // we backup to localStorage so when idb gets cleared for some reason, we don't lose our e2ee identity\n        try {\n            const lsKey = this._localStorageKeyPrefix + key;\n            const lsValue = stringify(value);\n            this._localStorage.setItem(lsKey, lsValue);\n        } catch (err) {\n            console.error(\"could not write to localStorage\", err);\n        }\n    }\n\n    writeE2EEIdentityToLocalStorage() {\n        this._sessionStore.iterateValues(undefined, (entry: SessionEntry, key: string) => {\n            if (key.startsWith(SESSION_E2EE_KEY_PREFIX)) {\n                this._writeKeyToLocalStorage(key, entry.value);\n            }\n            return false;\n        });\n    }\n\n    async tryRestoreE2EEIdentityFromLocalStorage(log: ILogItem): Promise<boolean> {\n        let success = false;\n        const lsPrefix = this._localStorageKeyPrefix;\n        const prefix = lsPrefix + SESSION_E2EE_KEY_PREFIX;\n        for(let i = 0; i < this._localStorage.length; i += 1) {\n            const lsKey = this._localStorage.key(i)!;\n            if (lsKey.startsWith(prefix)) {\n                const value = parse(this._localStorage.getItem(lsKey)!);\n                const key = lsKey.substr(lsPrefix.length);\n                // we check if we don't have this key already, as we don't want to override anything\n                const hasKey = (await this._sessionStore.getKey(key)) === key;\n                log.set(key, !hasKey);\n                if (!hasKey) {\n                    this._sessionStore.put({key, value});\n                    success = true;\n                }\n            }\n        }\n        return success;\n    }\n\n    set(key: string, value: any): void {\n        if (key.startsWith(SESSION_E2EE_KEY_PREFIX)) {\n            this._writeKeyToLocalStorage(key, value);\n        }\n        this._sessionStore.put({key, value});\n    }\n\n    add(key: string, value: any): void {\n        if (key.startsWith(SESSION_E2EE_KEY_PREFIX)) {\n            this._writeKeyToLocalStorage(key, value);\n        }\n        this._sessionStore.add({key, value});\n    }\n\n    remove(key: string): void {\n        if (key.startsWith(SESSION_E2EE_KEY_PREFIX)) {\n            this._localStorage.removeItem(this._localStorageKeyPrefix + key);\n        }\n        this._sessionStore.delete(key);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\nstore contains:\n\troomId\n\tname\n\tlastMessage\n\tunreadCount\n\tmentionCount\n\tisEncrypted\n\tisDirectMessage\n\tmembership\n\tinviteCount\n\tjoinCount\n*/\nimport {Store} from \"../Store\";\nimport {SummaryData} from \"../../../room/RoomSummary\";\n\n/** Used for both roomSummary and archivedRoomSummary stores */\nexport class RoomSummaryStore {\n    private _summaryStore: Store<SummaryData>;\n\n    constructor(summaryStore: Store<SummaryData>) {\n        this._summaryStore = summaryStore;\n    }\n\n    getAll(): Promise<SummaryData[]> {\n        return this._summaryStore.selectAll();\n    }\n\n    set(summary: SummaryData): void {\n        this._summaryStore.put(summary);\n    }\n\n    get(roomId: string): Promise<SummaryData | null> {\n        return this._summaryStore.get(roomId);\n    }\n\n    async has(roomId: string): Promise<boolean> {\n        const fetchedKey = await this._summaryStore.getKey(roomId);\n        return roomId === fetchedKey;\n    }\n\n    remove(roomId: string): void {\n        this._summaryStore.delete(roomId);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {Store} from \"../Store\";\nimport {MemberData} from \"./RoomMemberStore\";\n\n// TODO: Move to Invite when that's TypeScript.\nexport interface InviteData {\n    roomId: string;\n    isEncrypted: boolean;\n    isDirectMessage: boolean;\n    name?: string;\n    avatarUrl?: string;\n    avatarColorId: number;\n    canonicalAlias?: string;\n    timestamp: number;\n    joinRule: string;\n    inviter?: MemberData;\n}\n\nexport class InviteStore {\n    private _inviteStore: Store<InviteData>;\n\n    constructor(inviteStore: Store<InviteData>) {\n        this._inviteStore = inviteStore;\n    }\n\n    getAll(): Promise<InviteData[]> {\n        return this._inviteStore.selectAll();\n    }\n\n    set(invite: InviteData): void {\n        this._inviteStore.put(invite);\n    }\n\n    remove(roomId: string): void {\n        this._inviteStore.delete(roomId);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type {ILogItem, ISerializedItem} from \"./types\";\n\nexport enum LogLevel {\n    All = 1,\n    Debug,\n    Detail,\n    Info,\n    Warn,\n    Error,\n    Fatal,\n    Off\n}\n\nexport class LogFilter {\n    private _min?: LogLevel;\n    private _parentFilter?: LogFilter;\n\n    constructor(parentFilter?: LogFilter) {\n        this._parentFilter = parentFilter;\n    }\n\n    filter(item: ILogItem, children: ISerializedItem[] | null): boolean {\n        if (this._parentFilter) {\n            if (!this._parentFilter.filter(item, children)) {\n                return false;\n            }\n        }\n        // neither our children or us have a loglevel high enough, filter out.\n        if (this._min !== undefined && !Array.isArray(children) && item.logLevel < this._min) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /* methods to build the filter */\n    minLevel(logLevel: LogLevel): LogFilter {\n        this._min = logLevel;\n        return this;\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {LogLevel} from \"./LogFilter\";\nimport type {ILogger, ILogExport, ILogItem, LabelOrValues, LogCallback, LogItemValues} from \"./types\";\n\nfunction noop (): void {}\n\nexport class NullLogger implements ILogger {\n    public readonly item: ILogItem = new NullLogItem(this);\n\n    log(): void {}\n\n    run<T>(_, callback: LogCallback<T>): T {\n        return callback(this.item);    \n    }\n\n    wrapOrRun<T>(item: ILogItem | undefined, _, callback: LogCallback<T>): T {\n        if (item) {\n            return item.wrap(_, callback);\n        } else {\n            return this.run(_, callback);\n        }\n    }\n\n    runDetached(_, callback): ILogItem {\n        new Promise(r => r(callback(this.item))).then(noop, noop);\n        return this.item;\n    }\n\n    async export(): Promise<ILogExport | undefined> {\n        return undefined;\n    }\n\n    get level(): typeof LogLevel {\n        return LogLevel;\n    }\n}\n\nexport class NullLogItem implements ILogItem {\n    public readonly logger: NullLogger;\n    public readonly logLevel: LogLevel;\n    public children?: Array<ILogItem>;\n    public values: LogItemValues;\n    public error?: Error;\n\n    constructor(logger: NullLogger) {\n        this.logger = logger;\n    }\n\n    wrap<T>(_: LabelOrValues, callback: LogCallback<T>): T {\n        return callback(this);\n    }\n\n    log(): ILogItem {\n        return this;\n    }\n    set(): ILogItem { return this; }\n\n    runDetached(_: LabelOrValues, callback: LogCallback<unknown>): ILogItem {\n        new Promise(r => r(callback(this))).then(noop, noop);\n        return this;\n    }\n\n    wrapDetached(_: LabelOrValues, _callback: LogCallback<unknown>): void {\n        return this.refDetached();\n    }\n\n    refDetached(): void {}\n\n    ensureRefId(): void {}\n\n    get level(): typeof LogLevel {\n        return LogLevel;\n    }\n\n    get duration(): 0 {\n        return 0;\n    }\n\n    catch(err: Error): Error {\n        return err;\n    }\n\n    child(): ILogItem  {\n        return this;\n    }\n\n    finish(): void {}\n\n    serialize(): undefined {\n        return undefined;\n    }\n}\n\nexport const Instance = new NullLogger(); \n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {EventKey} from \"../../../room/timeline/EventKey\";\nimport { StorageError } from \"../../common\";\nimport { encodeUint32, decodeUint32 } from \"../utils\";\nimport {KeyLimits} from \"../../common\";\nimport {Store} from \"../Store\";\nimport {TimelineEvent, StateEvent} from \"../../types\";\nimport {ILogItem} from \"../../../../logging/types\";\n\ninterface Annotation {\n    count: number;\n    me: boolean;\n    firstTimestamp: number;\n}\n\ninterface TimelineEventEntry {\n    roomId: string;\n    fragmentId: number;\n    eventIndex: number;\n    event: TimelineEvent | StateEvent;\n    displayName?: string;\n    avatarUrl?: string;\n    annotations?: { [key : string]: Annotation };\n}\n\ntype TimelineEventStorageEntry = TimelineEventEntry & { key: string, eventIdKey: string };\n\nfunction encodeKey(roomId: string, fragmentId: number, eventIndex: number): string {\n    return `${roomId}|${encodeUint32(fragmentId)}|${encodeUint32(eventIndex)}`;\n}\n\nfunction decodeKey(key: string): { roomId: string, eventKey: EventKey } {\n    const [roomId, fragmentId, eventIndex] = key.split(\"|\");\n    return {roomId, eventKey: new EventKey(decodeUint32(fragmentId), decodeUint32(eventIndex))};\n}\n\nfunction encodeEventIdKey(roomId: string, eventId: string): string {\n    return `${roomId}|${eventId}`;\n}\n\nfunction decodeEventIdKey(eventIdKey: string): { roomId: string, eventId: string } {\n    const [roomId, eventId] = eventIdKey.split(\"|\");\n    return {roomId, eventId};\n}\n\nclass Range {\n    private _IDBKeyRange: typeof IDBKeyRange;\n    private _only?: EventKey;\n    private _lower?: EventKey;\n    private _upper?: EventKey;\n    private _lowerOpen: boolean;\n    private _upperOpen: boolean;\n\n    constructor(_IDBKeyRange: any, only?: EventKey, lower?: EventKey, upper?: EventKey, lowerOpen: boolean = false, upperOpen: boolean = false) {\n        this._IDBKeyRange = _IDBKeyRange;\n        this._only = only;\n        this._lower = lower;\n        this._upper = upper;\n        this._lowerOpen = lowerOpen;\n        this._upperOpen = upperOpen;\n    }\n\n    asIDBKeyRange(roomId: string): IDBKeyRange | undefined {\n        try {\n            // only\n            if (this._only) {\n                return this._IDBKeyRange.only(encodeKey(roomId, this._only.fragmentId, this._only.eventIndex));\n            }\n            // lowerBound\n            // also bound as we don't want to move into another roomId\n            if (this._lower && !this._upper) {\n                return this._IDBKeyRange.bound(\n                    encodeKey(roomId, this._lower.fragmentId, this._lower.eventIndex),\n                    encodeKey(roomId, this._lower.fragmentId, KeyLimits.maxStorageKey),\n                    this._lowerOpen,\n                    false\n                );\n            }\n            // upperBound\n            // also bound as we don't want to move into another roomId\n            if (!this._lower && this._upper) {\n                return this._IDBKeyRange.bound(\n                    encodeKey(roomId, this._upper.fragmentId, KeyLimits.minStorageKey),\n                    encodeKey(roomId, this._upper.fragmentId, this._upper.eventIndex),\n                    false,\n                    this._upperOpen\n                );\n            }\n            // bound\n            if (this._lower && this._upper) {\n                return this._IDBKeyRange.bound(\n                    encodeKey(roomId, this._lower.fragmentId, this._lower.eventIndex),\n                    encodeKey(roomId, this._upper.fragmentId, this._upper.eventIndex),\n                    this._lowerOpen,\n                    this._upperOpen\n                );\n            }\n        } catch(err) {\n            throw new StorageError(`IDBKeyRange failed with data: ` + JSON.stringify(this), err);\n        }\n    }\n}\n/*\n * @typedef   {Object} Gap\n * @property  {?string} prev_batch the pagination token for this backwards facing gap\n * @property  {?string} next_batch the pagination token for this forwards facing gap\n *\n * @typedef   {Object} Event\n * @property  {string} event_id the id of the event\n * @property  {string} type the\n * @property  {?string} state_key the state key of this state event\n *\n * @typedef   {Object} Entry\n * @property  {string} roomId\n * @property  {EventKey} eventKey\n * @property  {?Event} event if an event entry, the event\n * @property  {?Gap} gap if a gap entry, the gap\n*/\nexport class TimelineEventStore {\n    private _timelineStore: Store<TimelineEventStorageEntry>;\n\n    constructor(timelineStore: Store<TimelineEventStorageEntry>) {\n        this._timelineStore = timelineStore;\n    }\n\n    /** Creates a range that only includes the given key\n     *  @param eventKey the key\n     *  @return the created range\n     */\n    onlyRange(eventKey: EventKey): Range {\n        return new Range(this._timelineStore.IDBKeyRange, eventKey);\n    }\n\n    /** Creates a range that includes all keys before eventKey, and optionally also the key itself.\n     *  @param eventKey the key\n     *  @param [open=false] whether the key is included (false) or excluded (true) from the range at the upper end.\n     *  @return the created range\n     */\n    upperBoundRange(eventKey: EventKey, open=false): Range {\n        return new Range(this._timelineStore.IDBKeyRange, undefined, undefined, eventKey, undefined, open);\n    }\n\n    /** Creates a range that includes all keys after eventKey, and optionally also the key itself.\n     *  @param eventKey the key\n     *  @param [open=false] whether the key is included (false) or excluded (true) from the range at the lower end.\n     *  @return the created range\n     */\n    lowerBoundRange(eventKey: EventKey, open=false): Range {\n        return new Range(this._timelineStore.IDBKeyRange, undefined, eventKey, undefined, open);\n    }\n\n    /** Creates a range that includes all keys between `lower` and `upper`, and optionally the given keys as well.\n     *  @param lower the lower key\n     *  @param upper the upper key\n     *  @param [lowerOpen=false] whether the lower key is included (false) or excluded (true) from the range.\n     *  @param [upperOpen=false] whether the upper key is included (false) or excluded (true) from the range.\n     *  @return the created range\n     */\n    boundRange(lower: EventKey, upper: EventKey, lowerOpen=false, upperOpen=false): Range {\n        return new Range(this._timelineStore.IDBKeyRange, undefined, lower, upper, lowerOpen, upperOpen);\n    }\n\n    /** Looks up the last `amount` entries in the timeline for `roomId`.\n     *  @param roomId\n     *  @param fragmentId\n     *  @param amount\n     *  @return a promise resolving to an array with 0 or more entries, in ascending order.\n     */\n    async lastEvents(roomId: string, fragmentId: number, amount: number): Promise<TimelineEventEntry[]> {\n        const eventKey = EventKey.maxKey;\n        eventKey.fragmentId = fragmentId;\n        return this.eventsBefore(roomId, eventKey, amount);\n    }\n\n    /** Looks up the first `amount` entries in the timeline for `roomId`.\n     *  @param roomId\n     *  @param fragmentId\n     *  @param amount\n     *  @return a promise resolving to an array with 0 or more entries, in ascending order.\n     */\n    async firstEvents(roomId: string, fragmentId: number, amount: number): Promise<TimelineEventEntry[]> {\n        const eventKey = EventKey.minKey;\n        eventKey.fragmentId = fragmentId;\n        return this.eventsAfter(roomId, eventKey, amount);\n    }\n\n    /** Looks up `amount` entries after `eventKey` in the timeline for `roomId` within the same fragment.\n     *  The entry for `eventKey` is not included.\n     *  @param roomId\n     *  @param eventKey\n     *  @param amount\n     *  @return a promise resolving to an array with 0 or more entries, in ascending order.\n     */\n    eventsAfter(roomId: string, eventKey: EventKey, amount: number): Promise<TimelineEventEntry[]> {\n        const idbRange = this.lowerBoundRange(eventKey, true).asIDBKeyRange(roomId);\n        return this._timelineStore.selectLimit(idbRange, amount);\n    }\n\n    /** Looks up `amount` entries before `eventKey` in the timeline for `roomId` within the same fragment.\n     *  The entry for `eventKey` is not included.\n     *  @param roomId\n     *  @param eventKey\n     *  @param amount\n     *  @return a promise resolving to an array with 0 or more entries, in ascending order.\n     */\n    async eventsBefore(roomId: string, eventKey: EventKey, amount: number): Promise<TimelineEventEntry[]> {\n        const range = this.upperBoundRange(eventKey, true).asIDBKeyRange(roomId);\n        const events = await this._timelineStore.selectLimitReverse(range, amount);\n        events.reverse(); // because we fetched them backwards\n        return events;\n    }\n\n    async getEventKeysForIds(roomId: string, eventIds: string[]): Promise<Map<string, EventKey>> {\n        const byEventId = this._timelineStore.index(\"byEventId\");\n        const keys = eventIds.map(eventId => encodeEventIdKey(roomId, eventId));\n        const results = new Map();\n        await byEventId.findExistingKeys(keys, false, (indexKey, pk) => {\n            const {eventId} = decodeEventIdKey(indexKey as string);\n            const {eventKey} = decodeKey(pk as string);\n            results.set(eventId, eventKey);\n            return false;\n        });\n        return results;\n    }\n\n    /** Finds the first eventId that occurs in the store, if any.\n     *  For optimal performance, `eventIds` should be in chronological order.\n     *\n     *  The order in which results are returned might be different than `eventIds`.\n     *  Call the return value to obtain the next {id, event} pair.\n     *  @param roomId\n     *  @param eventIds\n     *  @return\n     */\n    // performance comment from above refers to the fact that there *might*\n    // be a correlation between event_id sorting order and chronology.\n    // In that case we could avoid running over all eventIds, as the reported order by findExistingKeys\n    // would match the order of eventIds. That's why findLast is also passed as backwards to keysExist.\n    // also passing them in chronological order makes sense as that's how we'll receive them almost always.\n    async findFirstOccurringEventId(roomId: string, eventIds: string[]): Promise<string | undefined> {\n        const byEventId = this._timelineStore.index(\"byEventId\");\n        const keys = eventIds.map(eventId => encodeEventIdKey(roomId, eventId));\n        const results = new Array(keys.length);\n        let firstFoundKey: string | undefined;\n\n        // find first result that is found and has no undefined results before it\n        function firstFoundAndPrecedingResolved(): string | undefined {\n            for(let i = 0; i < results.length; ++i) {\n                if (results[i] === undefined) {\n                    return;\n                } else if(results[i] === true) {\n                    return keys[i];\n                }\n            }\n        }\n\n        await byEventId.findExistingKeys(keys, false, (key, found) => {\n            // T[].search(T, number), but we want T[].search(R, number), so cast\n            const index = (keys as IDBValidKey[]).indexOf(key);\n            results[index] = found;\n            firstFoundKey = firstFoundAndPrecedingResolved();\n            return !!firstFoundKey;\n        });\n        return firstFoundKey && decodeEventIdKey(firstFoundKey).eventId;\n    }\n\n    /** Inserts a new entry into the store.\n     * \n     * If the event already exists in the store (either the eventKey or the event id\n     * are already known for the given roomId), this operation has no effect.\n     * \n     * Returns if the event was not yet known and the entry was written.\n     */\n    tryInsert(entry: TimelineEventEntry, log: ILogItem): Promise<boolean> {\n        (entry as TimelineEventStorageEntry).key = encodeKey(entry.roomId, entry.fragmentId, entry.eventIndex);\n        (entry as TimelineEventStorageEntry).eventIdKey = encodeEventIdKey(entry.roomId, entry.event.event_id);\n        return this._timelineStore.tryAdd(entry as TimelineEventStorageEntry, log);\n    }\n\n    /** Updates the entry into the store with the given [roomId, eventKey] combination.\n     *  If not yet present, will insert. Might be slower than add.\n     *  @param entry the entry to update.\n     *  @return nothing. To wait for the operation to finish, await the transaction it's part of.\n     */\n    update(entry: TimelineEventEntry): void {\n        this._timelineStore.put(entry as TimelineEventStorageEntry);\n    }\n\n    get(roomId: string, eventKey: EventKey): Promise<TimelineEventEntry | undefined> {\n        return this._timelineStore.get(encodeKey(roomId, eventKey.fragmentId, eventKey.eventIndex));\n    }\n\n    getByEventId(roomId: string, eventId: string): Promise<TimelineEventEntry | undefined> {\n        return this._timelineStore.index(\"byEventId\").get(encodeEventIdKey(roomId, eventId));\n    }\n\n    removeAllForRoom(roomId: string): void {\n        const minKey = encodeKey(roomId, KeyLimits.minStorageKey, KeyLimits.minStorageKey);\n        const maxKey = encodeKey(roomId, KeyLimits.maxStorageKey, KeyLimits.maxStorageKey);\n        const range = this._timelineStore.IDBKeyRange.bound(minKey, maxKey);\n        this._timelineStore.delete(range);\n    }\n}\n\nimport {createMockStorage} from \"../../../../mocks/Storage\";\nimport {createEvent, withTextBody} from \"../../../../mocks/event.js\";\nimport {createEventEntry} from \"../../../room/timeline/persistence/common.js\";\nimport {Instance as nullLogger} from \"../../../../logging/NullLogger\";\n\nexport function tests() {\n\n    const sortedIds = [\n        \"$2wZy1W-QdcwaAwz68nfz1oc-3SsZKVDy8d86ERP1Pm0\",\n        \"$4RWaZ5142grUgTnQyr_5qiPTOwzAOimt5MsXg6m1diM\",\n        \"$4izqHE2Wf5US_-e_za942pZ10CDNJjDncUMmhqBUVQw\",\n        \"$Oil2Afq2cBLqMAeJTAHjA3Is9T5Wmaa2ogVRlFJ_gzE\",\n        \"$Wyl-7u-YqnPJElkPufIRXRFTYP-eFxQ4iD-SmLQo2Rw\",\n        \"$b-eWaZtp22vL9mp0h7odbpphOZQ-rnp54qjyTQPARgo\",\n        \"$sS9rTv8u2m9o4RaMI2jGOnpMtb9t8_0euiQLhNFW380\",\n        \"$uZLkB9rzTKvJAK2QrQNX-prwQ2Niajdi0fvvRnyCtz8\",\n        \"$vGecIBZFex9_vlQf1E1LjtQXE3q5GwERIHMiy4mOWv0\",\n        \"$vdLgAnwjHj0cicU3MA4ynLHUBGOIFhvvksY3loqzjF\",\n    ];\n\n    const insertedIds = [\n        sortedIds[5],\n        sortedIds[3],\n        sortedIds[9],\n        sortedIds[7],\n        sortedIds[1],\n    ];\n\n    const checkedIds = [\n        sortedIds[2],\n        sortedIds[4],\n        sortedIds[3],\n        sortedIds[0],\n        sortedIds[8],\n        sortedIds[9],\n        sortedIds[6],\n    ];\n\n    const roomId = \"!fjsdf423423jksdfdsf:hs.tld\";\n\n    function createEventWithId(id) {\n        return withTextBody(\"hello\", createEvent(\"m.room.message\", id, \"@alice:hs.tld\"));\n    }\n\n    return {\n        \"getEventKeysForIds\": async assert => {\n            const storage = await createMockStorage();\n            const txn = await storage.readWriteTxn([storage.storeNames.timelineEvents]);\n            let eventKey = EventKey.defaultFragmentKey(109);\n            for (const insertedId of insertedIds) {\n                const entry = createEventEntry(eventKey.nextKey(), roomId, createEventWithId(insertedId));\n                assert(await txn.timelineEvents.tryInsert(entry, nullLogger.item));\n                eventKey = eventKey.nextKey();\n            }\n            const eventKeyMap = await txn.timelineEvents.getEventKeysForIds(roomId, checkedIds);\n            assert.equal(eventKeyMap.size, 2);\n            const eventKey1 = eventKeyMap.get(\"$Oil2Afq2cBLqMAeJTAHjA3Is9T5Wmaa2ogVRlFJ_gzE\")!;\n            assert.equal(eventKey1.fragmentId, 109);\n            assert.equal(eventKey1.eventIndex, 0x80000001);\n            const eventKey2 = eventKeyMap.get(\"$vdLgAnwjHj0cicU3MA4ynLHUBGOIFhvvksY3loqzjF\")!;\n            assert.equal(eventKey2.fragmentId, 109);\n            assert.equal(eventKey2.eventIndex, 0x80000002);\n        }\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport const MIN_UNICODE = \"\\u{0}\";\nexport const MAX_UNICODE = \"\\u{10FFFF}\";\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {MIN_UNICODE, MAX_UNICODE} from \"./common\";\nimport {Store} from \"../Store\";\n\nfunction encodeKey(roomId: string, targetEventId: string, relType: string, sourceEventId: string): string {\n    return `${roomId}|${targetEventId}|${relType}|${sourceEventId}`;\n}\n\ninterface RelationEntry {\n    roomId: string;\n    targetEventId: string;\n    sourceEventId: string;\n    relType: string;\n}\n\nfunction decodeKey(key: string): RelationEntry {\n    const [roomId, targetEventId, relType, sourceEventId] = key.split(\"|\");\n    return {roomId, targetEventId, relType, sourceEventId};\n}\n\nexport class TimelineRelationStore {\n    private _store: Store<{ key: string }>;\n\n    constructor(store: Store<{ key: string }>) {\n        this._store = store;\n    }\n\n    add(roomId: string, targetEventId: string, relType: string, sourceEventId: string): void {\n        this._store.add({key: encodeKey(roomId, targetEventId, relType, sourceEventId)});\n    }\n\n    remove(roomId: string, targetEventId: string, relType: string, sourceEventId: string): void {\n        this._store.delete(encodeKey(roomId, targetEventId, relType, sourceEventId));\n    }\n\n    removeAllForTarget(roomId: string, targetId: string): void {\n        const range = this._store.IDBKeyRange.bound(\n            encodeKey(roomId, targetId, MIN_UNICODE, MIN_UNICODE),\n            encodeKey(roomId, targetId, MAX_UNICODE, MAX_UNICODE),\n            true,\n            true\n        );\n        this._store.delete(range);\n    }\n\n    removeAllForRoom(roomId: string) {\n        const range = this._store.IDBKeyRange.bound(\n            encodeKey(roomId, MIN_UNICODE, MIN_UNICODE, MIN_UNICODE),\n            encodeKey(roomId, MAX_UNICODE, MAX_UNICODE, MAX_UNICODE),\n            true,\n            true\n        );\n        this._store.delete(range);\n    }\n\n    async getForTargetAndType(roomId: string, targetId: string, relType: string): Promise<RelationEntry[]> {\n        // exclude both keys as they are theoretical min and max,\n        // but we should't have a match for just the room id, or room id with max\n        const range = this._store.IDBKeyRange.bound(\n            encodeKey(roomId, targetId, relType, MIN_UNICODE),\n            encodeKey(roomId, targetId, relType, MAX_UNICODE),\n            true,\n            true\n        );\n        const items = await this._store.selectAll(range);\n        return items.map(i => decodeKey(i.key));\n    }\n\n    async getAllForTarget(roomId: string, targetId: string): Promise<RelationEntry[]> {\n        // exclude both keys as they are theoretical min and max,\n        // but we should't have a match for just the room id, or room id with max\n        const range = this._store.IDBKeyRange.bound(\n            encodeKey(roomId, targetId, MIN_UNICODE, MIN_UNICODE),\n            encodeKey(roomId, targetId, MAX_UNICODE, MAX_UNICODE),\n            true,\n            true\n        );\n        const items = await this._store.selectAll(range);\n        return items.map(i => decodeKey(i.key));\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {MAX_UNICODE} from \"./common\";\nimport {Store} from \"../Store\";\nimport {StateEvent} from \"../../types\";\n\nfunction encodeKey(roomId: string, eventType: string, stateKey: string) {\n     return `${roomId}|${eventType}|${stateKey}`;\n}\n\nexport interface RoomStateEntry {\n    roomId: string;\n    event: StateEvent;\n    key: string;\n}\n\nexport class RoomStateStore {\n    private _roomStateStore: Store<RoomStateEntry>;\n\n    constructor(idbStore: Store<RoomStateEntry>) {\n        this._roomStateStore = idbStore;\n    }\n\n    get(roomId: string, type: string, stateKey: string): Promise<RoomStateEntry | undefined> {\n        const key = encodeKey(roomId, type, stateKey);\n        return this._roomStateStore.get(key);\n    }\n\n    set(roomId: string, event: StateEvent): void {\n        const key = encodeKey(roomId, event.type, event.state_key);\n        const entry = {roomId, event, key};\n        this._roomStateStore.put(entry);\n    }\n\n    removeAllForRoom(roomId: string): void {\n        // exclude both keys as they are theoretical min and max,\n        // but we should't have a match for just the room id, or room id with max\n        const range = this._roomStateStore.IDBKeyRange.bound(roomId, `${roomId}|${MAX_UNICODE}`, true, true);\n        this._roomStateStore.delete(range);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {MAX_UNICODE} from \"./common\";\nimport {Store} from \"../Store\";\n\nfunction encodeKey(roomId: string, userId: string) {\n    return `${roomId}|${userId}`;\n}\n\nfunction decodeKey(key: string): { roomId: string, userId: string } {\n    const [roomId, userId] = key.split(\"|\");\n    return {roomId, userId};\n}\n\n// TODO: Move to RoomMember when that's TypeScript.\nexport interface MemberData {\n    roomId: string;\n    userId: string;\n    avatarUrl: string;\n    displayName: string;\n    membership: \"join\" | \"leave\" | \"invite\" | \"ban\";\n}\n\ntype MemberStorageEntry = MemberData & { key: string }\n\n// no historical members\nexport class RoomMemberStore {\n    private _roomMembersStore: Store<MemberStorageEntry>;\n\n    constructor(roomMembersStore: Store<MemberStorageEntry>) {\n        this._roomMembersStore = roomMembersStore;\n    }\n\n    get(roomId: string, userId: string): Promise<MemberStorageEntry | undefined> {\n        return this._roomMembersStore.get(encodeKey(roomId, userId));\n    }\n\n    set(member: MemberData): void {\n        // Object.assign would be more typesafe, but small objects \n        (member as MemberStorageEntry).key = encodeKey(member.roomId, member.userId);\n        this._roomMembersStore.put(member as MemberStorageEntry);\n    }\n\n    getAll(roomId: string): Promise<MemberData[]> {\n        const range = this._roomMembersStore.IDBKeyRange.lowerBound(encodeKey(roomId, \"\"));\n        return this._roomMembersStore.selectWhile(range, member => {\n            return member.roomId === roomId;\n        });\n    }\n\n    async getAllUserIds(roomId: string): Promise<string[]> {\n        const userIds: string[] = [];\n        const range = this._roomMembersStore.IDBKeyRange.lowerBound(encodeKey(roomId, \"\"));\n        await this._roomMembersStore.iterateKeys(range, key => {\n            const decodedKey = decodeKey(key as string);\n            // prevent running into the next room\n            if (decodedKey.roomId === roomId) {\n                userIds.push(decodedKey.userId);\n                return false;   // fetch more\n            }\n            return true; // done\n        });\n        return userIds;\n    }\n\n    removeAllForRoom(roomId: string): void {\n        // exclude both keys as they are theoretical min and max,\n        // but we should't have a match for just the room id, or room id with max\n        const range = this._roomMembersStore.IDBKeyRange.bound(roomId, `${roomId}|${MAX_UNICODE}`, true, true);\n        this._roomMembersStore.delete(range);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { StorageError } from \"../../common\";\nimport {KeyLimits} from \"../../common\";\nimport { encodeUint32 } from \"../utils\";\nimport {Store} from \"../Store\";\n\ninterface Fragment {\n    roomId: string;\n    id: number;\n    previousId: number | null;\n    nextId: number | null;\n    previousToken: string | null;\n    nextToken: string | null;\n}\n\ntype FragmentEntry = Fragment & { key: string }\n\nfunction encodeKey(roomId: string, fragmentId: number): string {\n    return `${roomId}|${encodeUint32(fragmentId)}`;\n}\n\nexport class TimelineFragmentStore {\n    private _store: Store<FragmentEntry>;\n\n    constructor(store: Store<FragmentEntry>) {\n        this._store = store;\n    }\n\n    _allRange(roomId: string): IDBKeyRange {\n        try {\n            return this._store.IDBKeyRange.bound(\n                encodeKey(roomId, KeyLimits.minStorageKey),\n                encodeKey(roomId, KeyLimits.maxStorageKey)\n            );\n        } catch (err) {\n            throw new StorageError(`error from IDBKeyRange with roomId ${roomId}`, err);\n        }\n    }\n\n    all(roomId: string): Promise<FragmentEntry[]> {\n        return this._store.selectAll(this._allRange(roomId));\n    }\n\n    /** Returns the fragment without a nextToken and without nextId,\n    if any, with the largest id if there are multiple (which should not happen) */\n    liveFragment(roomId: string): Promise<FragmentEntry | undefined> {\n        // why do we need this?\n        // Ok, take the case where you've got a /context fragment and a /sync fragment\n        // They are not connected. So, upon loading the persister, which one do we take? We can't sort them ...\n        // we assume that the one without a nextToken and without a nextId is a live one\n        // there should really be only one like this\n\n        // reverse because assuming live fragment has bigger id than non-live ones\n        return this._store.findReverse(this._allRange(roomId), fragment => {\n            return typeof fragment.nextId !== \"number\" && typeof fragment.nextToken !== \"string\";\n        });\n    }\n\n    // should generate an id an return it?\n    // depends if we want to do anything smart with fragment ids,\n    // like give them meaning depending on range. not for now probably ...\n    add(fragment: Fragment): void {\n        (fragment as FragmentEntry).key = encodeKey(fragment.roomId, fragment.id);\n        this._store.add(fragment as FragmentEntry);\n    }\n\n    update(fragment: FragmentEntry): void {\n        this._store.put(fragment);\n    }\n\n    get(roomId: string, fragmentId: number): Promise<FragmentEntry | undefined> {\n        return this._store.get(encodeKey(roomId, fragmentId));\n    }\n\n    removeAllForRoom(roomId: string): void {\n        this._store.delete(this._allRange(roomId));\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { encodeUint32, decodeUint32 } from \"../utils\";\nimport {KeyLimits} from \"../../common\";\nimport {Store} from \"../Store\";\nimport {Content} from \"../../types\";\n\ninterface PendingEntry {\n    roomId: string;\n    queueIndex: number;\n    eventType: string;\n    content: Content;\n    relatexTxnId: string | null;\n    relatedEventId: string | null;\n    txnId?: string;\n    needsEncryption: boolean;\n    needsUpload: boolean;\n    key: string;\n}\n\nfunction encodeKey(roomId: string, queueIndex: number): string {\n    return `${roomId}|${encodeUint32(queueIndex)}`;\n}\n\nfunction decodeKey(key: string): { roomId: string, queueIndex: number } {\n    const [roomId, encodedQueueIndex] = key.split(\"|\");\n    const queueIndex = decodeUint32(encodedQueueIndex);\n    return {roomId, queueIndex};\n}\n\nexport class PendingEventStore {\n    private _eventStore: Store<PendingEntry>;\n\n    constructor(eventStore: Store<PendingEntry>) {\n        this._eventStore = eventStore;\n    }\n\n    async getMaxQueueIndex(roomId: string): Promise<number | undefined> {\n        const range = this._eventStore.IDBKeyRange.bound(\n            encodeKey(roomId, KeyLimits.minStorageKey),\n            encodeKey(roomId, KeyLimits.maxStorageKey),\n            false,\n            false,\n        );\n        const maxKey = await this._eventStore.findMaxKey(range);\n        if (maxKey) {\n            return decodeKey(maxKey as string).queueIndex;\n        }\n    }\n\n    remove(roomId: string, queueIndex: number) {\n        const keyRange = this._eventStore.IDBKeyRange.only(encodeKey(roomId, queueIndex));\n        this._eventStore.delete(keyRange);\n    }\n\n    async exists(roomId: string, queueIndex: number): Promise<boolean> {\n        const keyRange = this._eventStore.IDBKeyRange.only(encodeKey(roomId, queueIndex));\n        const key = await this._eventStore.getKey(keyRange);\n        return !!key;\n    }\n    \n    add(pendingEvent: PendingEntry): void {\n        pendingEvent.key = encodeKey(pendingEvent.roomId, pendingEvent.queueIndex);\n        this._eventStore.add(pendingEvent);\n    }\n\n    update(pendingEvent: PendingEntry): void {\n        this._eventStore.put(pendingEvent);\n    }\n\n    getAll(): Promise<PendingEntry[]> {\n        return this._eventStore.selectAll();\n    }\n\n    removeAllForRoom(roomId: string): void {\n        const minKey = encodeKey(roomId, KeyLimits.minStorageKey);\n        const maxKey = encodeKey(roomId, KeyLimits.maxStorageKey);\n        const range = this._eventStore.IDBKeyRange.bound(minKey, maxKey);\n        this._eventStore.delete(range);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {Store} from \"../Store\";\n\ninterface UserIdentity {\n    userId: string;\n    roomIds: string[];\n    deviceTrackingStatus: number;\n}\n\nexport class UserIdentityStore {\n    private _store: Store<UserIdentity>;\n\n    constructor(store: Store<UserIdentity>) {\n        this._store = store;\n    }\n\n    get(userId: string): Promise<UserIdentity | undefined> {\n        return this._store.get(userId);\n    }\n\n    set(userIdentity: UserIdentity): void {\n        this._store.put(userIdentity);\n    }\n\n    remove(userId: string): void {\n        this._store.delete(userId);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {MAX_UNICODE, MIN_UNICODE} from \"./common\";\nimport {Store} from \"../Store\";\n\nexport interface DeviceIdentity {\n    userId: string;\n    deviceId: string;\n    ed25519Key: string;\n    curve25519Key: string;\n    algorithms: string[];\n    displayName: string;\n    key: string;\n}\n\nfunction encodeKey(userId: string, deviceId: string): string {\n    return `${userId}|${deviceId}`;\n}\n\nfunction decodeKey(key: string): { userId: string, deviceId: string } {\n    const [userId, deviceId] = key.split(\"|\");\n    return {userId, deviceId};\n}\n\nexport class DeviceIdentityStore {\n    private _store: Store<DeviceIdentity>;\n    \n    constructor(store: Store<DeviceIdentity>) {\n        this._store = store;\n    }\n\n    getAllForUserId(userId: string): Promise<DeviceIdentity[]> {\n        const range = this._store.IDBKeyRange.lowerBound(encodeKey(userId, \"\"));\n        return this._store.selectWhile(range, device => {\n            return device.userId === userId;\n        });\n    }\n\n    async getAllDeviceIds(userId: string): Promise<string[]> {\n        const deviceIds: string[] = [];\n        const range = this._store.IDBKeyRange.lowerBound(encodeKey(userId, \"\"));\n        await this._store.iterateKeys(range, key => {\n            const decodedKey = decodeKey(key as string);\n            // prevent running into the next room\n            if (decodedKey.userId === userId) {\n                deviceIds.push(decodedKey.deviceId);\n                return false;   // fetch more\n            }\n            return true; // done\n        });\n        return deviceIds;\n    }\n\n    get(userId: string, deviceId: string): Promise<DeviceIdentity | undefined> {\n        return this._store.get(encodeKey(userId, deviceId));\n    }\n\n    set(deviceIdentity: DeviceIdentity): void {\n        deviceIdentity.key = encodeKey(deviceIdentity.userId, deviceIdentity.deviceId);\n        this._store.put(deviceIdentity);\n    }\n\n    getByCurve25519Key(curve25519Key: string): Promise<DeviceIdentity | undefined> {\n        return this._store.index(\"byCurve25519Key\").get(curve25519Key);\n    }\n\n    remove(userId: string, deviceId: string): void {\n        this._store.delete(encodeKey(userId, deviceId));\n    }\n\n    removeAllForUser(userId: string): void {\n        // exclude both keys as they are theoretical min and max,\n        // but we should't have a match for just the room id, or room id with max\n        const range = this._store.IDBKeyRange.bound(encodeKey(userId, MIN_UNICODE), encodeKey(userId, MAX_UNICODE), true, true);\n        this._store.delete(range);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {Store} from \"../Store\";\n\nfunction encodeKey(senderKey: string, sessionId: string): string {\n    return `${senderKey}|${sessionId}`;\n}\n\nfunction decodeKey(key: string): { senderKey: string, sessionId: string } {\n    const [senderKey, sessionId] = key.split(\"|\");\n    return {senderKey, sessionId};\n}\n\ninterface OlmSession {\n    session: string;\n    sessionId: string;\n    senderKey: string;\n    lastUsed: number;\n}\n\ntype OlmSessionEntry = OlmSession & { key: string };\n\nexport class OlmSessionStore {\n    private _store: Store<OlmSessionEntry>;\n\n    constructor(store: Store<OlmSessionEntry>) {\n        this._store = store;\n    }\n\n    async getSessionIds(senderKey: string): Promise<string[]> {\n        const sessionIds: string[] = [];\n        const range = this._store.IDBKeyRange.lowerBound(encodeKey(senderKey, \"\"));\n        await this._store.iterateKeys(range, key => {\n            const decodedKey = decodeKey(key as string);\n            // prevent running into the next room\n            if (decodedKey.senderKey === senderKey) {\n                sessionIds.push(decodedKey.sessionId);\n                return false;   // fetch more\n            }\n            return true; // done\n        });\n        return sessionIds;\n    }\n\n    getAll(senderKey: string): Promise<OlmSession[]> {\n        const range = this._store.IDBKeyRange.lowerBound(encodeKey(senderKey, \"\"));\n        return this._store.selectWhile(range, session => {\n            return session.senderKey === senderKey;\n        });\n    }\n\n    get(senderKey: string, sessionId: string): Promise<OlmSession | undefined> {\n        return this._store.get(encodeKey(senderKey, sessionId));\n    }\n\n    set(session: OlmSession): void {\n        (session as OlmSessionEntry).key = encodeKey(session.senderKey, session.sessionId);\n        this._store.put(session as OlmSessionEntry);\n    }\n\n    remove(senderKey: string, sessionId: string): void {\n        this._store.delete(encodeKey(senderKey, sessionId));\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {MIN_UNICODE, MAX_UNICODE} from \"./common\";\nimport {Store} from \"../Store\";\n\nexport enum BackupStatus {\n    NotBackedUp = 0,\n    BackedUp = 1\n}\n\nexport enum KeySource {\n    DeviceMessage = 1,\n    Backup,\n    Outbound\n}\n\nexport interface InboundGroupSessionEntry {\n    roomId: string;\n    senderKey: string;\n    sessionId: string;\n    session?: string;\n    claimedKeys?: { [algorithm : string] : string };\n    eventIds?: string[];\n    backup: BackupStatus,\n    source: KeySource\n}\n\ntype InboundGroupSessionStorageEntry = InboundGroupSessionEntry & { key: string };\n\n\nfunction encodeKey(roomId: string, senderKey: string, sessionId: string): string {\n    return `${roomId}|${senderKey}|${sessionId}`;\n}\n\nexport class InboundGroupSessionStore {\n    private _store: Store<InboundGroupSessionStorageEntry>;\n\n    constructor(store: Store<InboundGroupSessionStorageEntry>) {\n        this._store = store;\n    }\n\n    async has(roomId: string, senderKey: string, sessionId: string): Promise<boolean> {\n        const key = encodeKey(roomId, senderKey, sessionId);\n        const fetchedKey = await this._store.getKey(key);\n        return key === fetchedKey;\n    }\n\n    get(roomId: string, senderKey: string, sessionId: string): Promise<InboundGroupSessionEntry | undefined> {\n        return this._store.get(encodeKey(roomId, senderKey, sessionId));\n    }\n\n    set(session: InboundGroupSessionEntry): void {\n        const storageEntry = session as InboundGroupSessionStorageEntry;\n        storageEntry.key = encodeKey(session.roomId, session.senderKey, session.sessionId);\n        this._store.put(storageEntry);\n    }\n\n    removeAllForRoom(roomId: string) {\n        const range = this._store.IDBKeyRange.bound(\n            encodeKey(roomId, MIN_UNICODE, MIN_UNICODE),\n            encodeKey(roomId, MAX_UNICODE, MAX_UNICODE)\n        );\n        this._store.delete(range);\n    }\n    countNonBackedUpSessions(): Promise<number> {\n        return this._store.index(\"byBackup\").count(this._store.IDBKeyRange.only(BackupStatus.NotBackedUp));\n    }\n\n    getFirstNonBackedUpSessions(amount: number): Promise<InboundGroupSessionEntry[]> {\n        return this._store.index(\"byBackup\").selectLimit(this._store.IDBKeyRange.only(BackupStatus.NotBackedUp), amount);\n    }\n\n    async markAsBackedUp(roomId: string, senderKey: string, sessionId: string): Promise<void> {\n        const entry = await this._store.get(encodeKey(roomId, senderKey, sessionId));\n        if (entry) {\n            entry.backup = BackupStatus.BackedUp;\n            this._store.put(entry);\n        }\n    }\n\n    async markAllAsNotBackedUp(): Promise<number> {\n        const backedUpKey = this._store.IDBKeyRange.only(BackupStatus.BackedUp);\n        let count = 0;\n        await this._store.index(\"byBackup\").iterateValues(backedUpKey, (val: InboundGroupSessionEntry, key: IDBValidKey, cur: IDBCursorWithValue) => {\n            val.backup = BackupStatus.NotBackedUp;\n            cur.update(val);\n            count += 1;\n            return false;\n        });\n        return count;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {Store} from \"../Store\";\n\ninterface OutboundSession {\n    roomId: string;\n    session: string;\n    createdAt: number;\n}\n\nexport class OutboundGroupSessionStore {\n    private _store: Store<OutboundSession>;\n\n    constructor(store: Store<OutboundSession>) {\n        this._store = store;\n    }\n\n    remove(roomId: string): void {\n        this._store.delete(roomId);\n    }\n\n    get(roomId: string): Promise<OutboundSession | undefined> {\n        return this._store.get(roomId);\n    }\n\n    set(session: OutboundSession): void {\n        this._store.put(session);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {MIN_UNICODE, MAX_UNICODE} from \"./common\";\nimport {Store} from \"../Store\";\n\nfunction encodeKey(roomId: string, sessionId: string, messageIndex: number | string): string {\n    return `${roomId}|${sessionId}|${messageIndex}`;\n}\n\ninterface GroupSessionDecryption {\n    eventId: string;\n    timestamp: number;\n}\n\ntype GroupSessionEntry = GroupSessionDecryption & { key: string }\n\nexport class GroupSessionDecryptionStore {\n    private _store: Store<GroupSessionEntry>;\n\n    constructor(store: Store<GroupSessionEntry>) {\n        this._store = store;\n    }\n\n    get(roomId: string, sessionId: string, messageIndex: number): Promise<GroupSessionDecryption | undefined> {\n        return this._store.get(encodeKey(roomId, sessionId, messageIndex));\n    }\n\n    set(roomId: string, sessionId: string, messageIndex: number, decryption: GroupSessionDecryption): void {\n        (decryption as GroupSessionEntry).key = encodeKey(roomId, sessionId, messageIndex);\n        this._store.put(decryption as GroupSessionEntry);\n    }\n    \n    removeAllForRoom(roomId: string): void {\n        const range = this._store.IDBKeyRange.bound(\n            encodeKey(roomId, MIN_UNICODE, MIN_UNICODE),\n            encodeKey(roomId, MAX_UNICODE, MAX_UNICODE)\n        );\n        this._store.delete(range);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {MIN_UNICODE, MAX_UNICODE} from \"./common\";\nimport {Store} from \"../Store\";\n\nexport function encodeScopeTypeKey(scope: string, type: string): string {\n    return `${scope}|${type}`;\n}\n\ninterface BaseOperation {\n    id: string;\n    scope: string;\n    userIds: string[];\n}\n\ntype OperationType = { type: \"share_room_key\"; roomKeyMessage: RoomKeyMessage; }\n\ntype Operation = BaseOperation & OperationType\n\ntype OperationEntry = Operation & { scopeTypeKey: string; }\n\ninterface RoomKeyMessage {\n    room_id: string;\n    session_id: string;\n    session_key: string;\n    algorithm: string;\n    chain_index: number;\n}\n\nexport class OperationStore {\n    private _store: Store<OperationEntry>;\n\n    constructor(store: Store<OperationEntry>) {\n        this._store = store;\n    }\n\n    getAll(): Promise<Operation[]> {\n        return this._store.selectAll();\n    }\n\n    async getAllByTypeAndScope(type: string, scope: string): Promise<Operation[]> {\n        const key = encodeScopeTypeKey(scope, type);\n        const results: Operation[] = [];\n        await this._store.index(\"byScopeAndType\").iterateWhile(key, value => {\n            if (value.scopeTypeKey !== key) {\n                return false;\n            }\n            results.push(value);\n            return true;\n        });\n        return results;\n    }\n\n    add(operation: Operation): void {\n        (operation as OperationEntry).scopeTypeKey = encodeScopeTypeKey(operation.scope, operation.type);\n        this._store.add(operation as OperationEntry);\n    }\n\n    update(operation: Operation): void {\n        this._store.put(operation as OperationEntry);\n    }\n\n    remove(id: string): void {\n        this._store.delete(id);\n    }\n\n    async removeAllForScope(scope: string): Promise<undefined> {\n        const range = this._store.IDBKeyRange.bound(\n            encodeScopeTypeKey(scope, MIN_UNICODE),\n            encodeScopeTypeKey(scope, MAX_UNICODE)\n        );\n        const index = this._store.index(\"byScopeAndType\");\n        await index.iterateValues(range, (_, __, cur) => {\n            cur.delete();\n            return true;\n        });\n        return;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {Store} from \"../Store\";\nimport {Content} from \"../../types\";\n\ninterface AccountDataEntry {\n    type: string;\n    content: Content;\n}\n\nexport class AccountDataStore {\n    private _store: Store<AccountDataEntry>;\n\n    constructor(store: Store<AccountDataEntry>) {\n        this._store = store;\n    }\n\n    async get(type: string): Promise<AccountDataEntry | undefined> {\n        return await this._store.get(type);\n    }\n\n    set(event: AccountDataEntry): void {\n        this._store.put(event);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {StoreNames} from \"../common\";\nimport {txnAsPromise} from \"./utils\";\nimport {StorageError} from \"../common\";\nimport {Store} from \"./Store\";\nimport {Storage} from \"./Storage\";\nimport {SessionStore} from \"./stores/SessionStore\";\nimport {RoomSummaryStore} from \"./stores/RoomSummaryStore\";\nimport {InviteStore} from \"./stores/InviteStore\";\nimport {TimelineEventStore} from \"./stores/TimelineEventStore\";\nimport {TimelineRelationStore} from \"./stores/TimelineRelationStore\";\nimport {RoomStateStore} from \"./stores/RoomStateStore\";\nimport {RoomMemberStore} from \"./stores/RoomMemberStore\";\nimport {TimelineFragmentStore} from \"./stores/TimelineFragmentStore\";\nimport {PendingEventStore} from \"./stores/PendingEventStore\";\nimport {UserIdentityStore} from \"./stores/UserIdentityStore\";\nimport {DeviceIdentityStore} from \"./stores/DeviceIdentityStore\";\nimport {OlmSessionStore} from \"./stores/OlmSessionStore\";\nimport {InboundGroupSessionStore} from \"./stores/InboundGroupSessionStore\";\nimport {OutboundGroupSessionStore} from \"./stores/OutboundGroupSessionStore\";\nimport {GroupSessionDecryptionStore} from \"./stores/GroupSessionDecryptionStore\";\nimport {OperationStore} from \"./stores/OperationStore\";\nimport {AccountDataStore} from \"./stores/AccountDataStore\";\nimport type {ILogger, ILogItem} from \"../../../logging/types\";\n\nexport type IDBKey = IDBValidKey | IDBKeyRange;\n\nclass WriteErrorInfo {\n    constructor(\n        public readonly error: StorageError,\n        public readonly refItem: ILogItem | undefined,\n        public readonly operationName: string,\n        public readonly keys: IDBKey[] | undefined,\n    ) {}\n}\n\nexport class Transaction {\n    private _txn: IDBTransaction;\n    private _allowedStoreNames: StoreNames[];\n    private _stores: { [storeName in StoreNames]?: any };\n    private _storage: Storage;\n    private _writeErrors: WriteErrorInfo[];\n\n    constructor(txn: IDBTransaction, allowedStoreNames: StoreNames[], storage: Storage) {\n        this._txn = txn;\n        this._allowedStoreNames = allowedStoreNames;\n        this._stores = {};\n        this._storage = storage;\n        this._writeErrors = [];\n    }\n\n    get idbFactory(): IDBFactory {\n        return this._storage.idbFactory;\n    }\n\n    get IDBKeyRange(): typeof IDBKeyRange {\n        return this._storage.IDBKeyRange;\n    }\n\n    get databaseName(): string {\n        return this._storage.databaseName;\n    }\n\n    get logger(): ILogger {\n        return this._storage.logger;\n    }\n\n    _idbStore(name: StoreNames): Store<any> {\n        if (!this._allowedStoreNames.includes(name)) {\n            // more specific error? this is a bug, so maybe not ...\n            throw new StorageError(`Invalid store for transaction: ${name}, only ${this._allowedStoreNames.join(\", \")} are allowed.`);\n        }\n        return new Store(this._txn.objectStore(name), this);\n    }\n\n    _store<T>(name: StoreNames, mapStore: (idbStore: Store<any>) => T): T {\n        if (!this._stores[name]) {\n            const idbStore = this._idbStore(name);\n            this._stores[name] = mapStore(idbStore);\n        }\n        return this._stores[name];\n    }\n\n    get session(): SessionStore {\n        return this._store(StoreNames.session, idbStore => new SessionStore(idbStore, this._storage.localStorage));\n    }\n\n    get roomSummary(): RoomSummaryStore {\n        return this._store(StoreNames.roomSummary, idbStore => new RoomSummaryStore(idbStore));\n    }\n    \n    get archivedRoomSummary(): RoomSummaryStore {\n        return this._store(StoreNames.archivedRoomSummary, idbStore => new RoomSummaryStore(idbStore));\n    }\n\n    get invites(): InviteStore {\n        return this._store(StoreNames.invites, idbStore => new InviteStore(idbStore));\n    }\n\n    get timelineFragments(): TimelineFragmentStore {\n        return this._store(StoreNames.timelineFragments, idbStore => new TimelineFragmentStore(idbStore));\n    }\n\n    get timelineEvents(): TimelineEventStore {\n        return this._store(StoreNames.timelineEvents, idbStore => new TimelineEventStore(idbStore));\n    }\n\n    get timelineRelations(): TimelineRelationStore {\n        return this._store(StoreNames.timelineRelations, idbStore => new TimelineRelationStore(idbStore));\n    }\n\n    get roomState(): RoomStateStore {\n        return this._store(StoreNames.roomState, idbStore => new RoomStateStore(idbStore));\n    }\n\n    get roomMembers(): RoomMemberStore {\n        return this._store(StoreNames.roomMembers, idbStore => new RoomMemberStore(idbStore));\n    }\n\n    get pendingEvents(): PendingEventStore {\n        return this._store(StoreNames.pendingEvents, idbStore => new PendingEventStore(idbStore));\n    }\n\n    get userIdentities(): UserIdentityStore {\n        return this._store(StoreNames.userIdentities, idbStore => new UserIdentityStore(idbStore));\n    }\n\n    get deviceIdentities(): DeviceIdentityStore {\n        return this._store(StoreNames.deviceIdentities, idbStore => new DeviceIdentityStore(idbStore));\n    }\n    \n    get olmSessions(): OlmSessionStore {\n        return this._store(StoreNames.olmSessions, idbStore => new OlmSessionStore(idbStore));\n    }\n    \n    get inboundGroupSessions(): InboundGroupSessionStore {\n        return this._store(StoreNames.inboundGroupSessions, idbStore => new InboundGroupSessionStore(idbStore));\n    }\n    \n    get outboundGroupSessions(): OutboundGroupSessionStore {\n        return this._store(StoreNames.outboundGroupSessions, idbStore => new OutboundGroupSessionStore(idbStore));\n    }\n\n    get groupSessionDecryptions(): GroupSessionDecryptionStore {\n        return this._store(StoreNames.groupSessionDecryptions, idbStore => new GroupSessionDecryptionStore(idbStore));\n    }\n\n    get operations(): OperationStore {\n        return this._store(StoreNames.operations, idbStore => new OperationStore(idbStore));\n    }\n\n    get accountData(): AccountDataStore {\n        return this._store(StoreNames.accountData, idbStore => new AccountDataStore(idbStore));\n    }\n\n    async complete(log?: ILogItem): Promise<void> {\n        try {\n            await txnAsPromise(this._txn);\n        } catch (err) {\n            if (this._writeErrors.length) {\n                this._logWriteErrors(log);\n                throw this._writeErrors[0].error;\n            }\n            throw err;\n        }\n    }\n\n    getCause(error: Error) {\n        if (error instanceof StorageError) {\n            if (error.errcode === \"AbortError\" && this._writeErrors.length) {\n                return this._writeErrors[0].error;\n            }\n        }\n        return error;\n    }\n\n    abort(log?: ILogItem): void {\n        // TODO: should we wrap the exception in a StorageError?\n        try {\n            this._txn.abort();\n        } catch (abortErr) {\n            log?.set(\"couldNotAbortTxn\", true);\n        }\n        if (this._writeErrors.length) {\n            this._logWriteErrors(log);\n        }\n    }\n\n    addWriteError(error: StorageError, refItem: ILogItem | undefined, operationName: string, keys: IDBKey[] | undefined) {\n        // don't log subsequent `AbortError`s\n        if (error.errcode !== \"AbortError\" || this._writeErrors.length === 0) {\n            this._writeErrors.push(new WriteErrorInfo(error, refItem, operationName, keys));\n        }\n    }\n\n    private _logWriteErrors(parentItem: ILogItem | undefined) {\n        const callback = errorGroupItem => {\n            // we don't have context when there is no parentItem, so at least log stores\n            if (!parentItem) {\n                errorGroupItem.set(\"allowedStoreNames\", this._allowedStoreNames);\n            }\n            for (const info of this._writeErrors) {\n                errorGroupItem.wrap({l: info.operationName, id: info.keys}, item => {\n                    if (info.refItem) {\n                        item.refDetached(info.refItem);\n                    }\n                    item.catch(info.error);\n                });\n            }\n        };\n        const label = `${this._writeErrors.length} storage write operation(s) failed`;\n        if (parentItem) {\n            parentItem.wrap(label, callback);\n        } else {\n            this.logger.run(label, callback);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {IDOMStorage} from \"./types\";\nimport {Transaction} from \"./Transaction\";\nimport { STORE_NAMES, StoreNames, StorageError } from \"../common\";\nimport { reqAsPromise } from \"./utils\";\nimport { ILogger } from \"../../../logging/types\";\n\nconst WEBKITEARLYCLOSETXNBUG_BOGUS_KEY = \"782rh281re38-boguskey\";\n\nexport class Storage {\n    private _db: IDBDatabase;\n    private _hasWebkitEarlyCloseTxnBug: boolean;\n\n    readonly logger: ILogger;\n    readonly idbFactory: IDBFactory\n    readonly IDBKeyRange: typeof IDBKeyRange;\n    readonly storeNames: typeof StoreNames;\n    readonly localStorage: IDOMStorage;\n\n    constructor(idbDatabase: IDBDatabase, idbFactory: IDBFactory, _IDBKeyRange: typeof IDBKeyRange, hasWebkitEarlyCloseTxnBug: boolean, localStorage: IDOMStorage, logger: ILogger) {\n        this._db = idbDatabase;\n        this.idbFactory = idbFactory;\n        this.IDBKeyRange = _IDBKeyRange;\n        this._hasWebkitEarlyCloseTxnBug = hasWebkitEarlyCloseTxnBug;\n        this.storeNames = StoreNames;\n        this.localStorage = localStorage;\n        this.logger = logger;\n    }\n\n    _validateStoreNames(storeNames: StoreNames[]): void {\n        const idx = storeNames.findIndex(name => !STORE_NAMES.includes(name));\n        if (idx !== -1) {\n            throw new StorageError(`Tried top, a transaction unknown store ${storeNames[idx]}`);\n        }\n    }\n\n    async readTxn(storeNames: StoreNames[]): Promise<Transaction> {\n        this._validateStoreNames(storeNames);\n        try {\n            const txn = this._db.transaction(storeNames, \"readonly\");\n            // https://bugs.webkit.org/show_bug.cgi?id=222746 workaround,\n            // await a bogus idb request on the new txn so it doesn't close early if we await a microtask first\n            if (this._hasWebkitEarlyCloseTxnBug) {\n                await reqAsPromise(txn.objectStore(storeNames[0]).get(WEBKITEARLYCLOSETXNBUG_BOGUS_KEY));\n            }\n            return new Transaction(txn, storeNames, this);\n        } catch(err) {\n            throw new StorageError(\"readTxn failed\", err);\n        }\n    }\n\n    async readWriteTxn(storeNames: StoreNames[]): Promise<Transaction> {\n        this._validateStoreNames(storeNames);\n        try {\n            const txn = this._db.transaction(storeNames, \"readwrite\");\n            // https://bugs.webkit.org/show_bug.cgi?id=222746 workaround,\n            // await a bogus idb request on the new txn so it doesn't close early if we await a microtask first\n            if (this._hasWebkitEarlyCloseTxnBug) {\n                await reqAsPromise(txn.objectStore(storeNames[0]).get(WEBKITEARLYCLOSETXNBUG_BOGUS_KEY));\n            }\n            return new Transaction(txn, storeNames, this);\n        } catch(err) {\n            throw new StorageError(\"readWriteTxn failed\", err);\n        }\n    }\n\n    close(): void {\n        this._db.close();\n    }\n\n    get databaseName(): string {\n        return this._db.name;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { iterateCursor, NOT_DONE, txnAsPromise } from \"./utils\";\nimport { STORE_NAMES, StoreNames } from \"../common\";\n\nexport type Export = { [storeName in StoreNames] : any[] }\n\nexport async function exportSession(db: IDBDatabase): Promise<Export> {\n    const txn = db.transaction(STORE_NAMES, \"readonly\");\n    const data = {};\n    await Promise.all(STORE_NAMES.map(async name => {\n        const results: any[] = data[name] = [];  // initialize in deterministic order\n        const store = txn.objectStore(name);\n        await iterateCursor<any>(store.openCursor(), (value) => {\n            results.push(value);\n            return NOT_DONE;\n        });\n    }));\n    return data as Export;\n}\n\nexport async function importSession(db: IDBDatabase, data: Export): Promise<void> {\n    const txn = db.transaction(STORE_NAMES, \"readwrite\");\n    for (const name of STORE_NAMES) {\n        const store = txn.objectStore(name);\n        for (const value of data[name]) {\n            store.add(value);\n        }\n    }\n    await txnAsPromise(txn);\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {verifyEd25519Signature, SIGNATURE_ALGORITHM} from \"./common.js\";\n\nconst TRACKING_STATUS_OUTDATED = 0;\nconst TRACKING_STATUS_UPTODATE = 1;\n\nexport function addRoomToIdentity(identity, userId, roomId) {\n    if (!identity) {\n        identity = {\n            userId: userId,\n            roomIds: [roomId],\n            deviceTrackingStatus: TRACKING_STATUS_OUTDATED,\n        };\n        return identity;\n    } else {\n        if (!identity.roomIds.includes(roomId)) {\n            identity.roomIds.push(roomId);\n            return identity;\n        }\n    }\n}\n\n// map 1 device from /keys/query response to DeviceIdentity\nfunction deviceKeysAsDeviceIdentity(deviceSection) {\n    const deviceId = deviceSection[\"device_id\"];\n    const userId = deviceSection[\"user_id\"];\n    return {\n        userId,\n        deviceId,\n        ed25519Key: deviceSection.keys[`ed25519:${deviceId}`],\n        curve25519Key: deviceSection.keys[`curve25519:${deviceId}`],\n        algorithms: deviceSection.algorithms,\n        displayName: deviceSection.unsigned?.device_display_name,\n    };\n}\n\nexport class DeviceTracker {\n    constructor({storage, getSyncToken, olmUtil, ownUserId, ownDeviceId}) {\n        this._storage = storage;\n        this._getSyncToken = getSyncToken;\n        this._identityChangedForRoom = null;\n        this._olmUtil = olmUtil;\n        this._ownUserId = ownUserId;\n        this._ownDeviceId = ownDeviceId;\n    }\n\n    async writeDeviceChanges(changed, txn, log) {\n        const {userIdentities} = txn;\n        // TODO: should we also look at left here to handle this?:\n        // the usual problem here is that you share a room with a user,\n        // go offline, the remote user leaves the room, changes their devices,\n        // then rejoins the room you share (or another room).\n        // At which point you come online, all of this happens in the gap, \n        // and you don't notice that they ever left, \n        // and so the client doesn't invalidate their device cache for the user\n        log.set(\"changed\", changed.length);\n        await Promise.all(changed.map(async userId => {\n            const user = await userIdentities.get(userId);\n            if (user) {\n                log.log({l: \"outdated\", id: userId});\n                user.deviceTrackingStatus = TRACKING_STATUS_OUTDATED;\n                userIdentities.set(user);\n            }\n        }));\n    }\n\n    writeMemberChanges(room, memberChanges, txn) {\n        return Promise.all(Array.from(memberChanges.values()).map(async memberChange => {\n            return this._applyMemberChange(memberChange, txn);\n        }));\n    }\n\n    async trackRoom(room, log) {\n        if (room.isTrackingMembers || !room.isEncrypted) {\n            return;\n        }\n        const memberList = await room.loadMemberList(log);\n        try {\n            const txn = await this._storage.readWriteTxn([\n                this._storage.storeNames.roomSummary,\n                this._storage.storeNames.userIdentities,\n            ]);\n            let isTrackingChanges;\n            try {\n                isTrackingChanges = room.writeIsTrackingMembers(true, txn);\n                const members = Array.from(memberList.members.values());\n                log.set(\"members\", members.length);\n                await this._writeJoinedMembers(members, txn);\n            } catch (err) {\n                txn.abort();\n                throw err;\n            }\n            await txn.complete();\n            room.applyIsTrackingMembersChanges(isTrackingChanges);\n        } finally {\n            memberList.release();\n        }\n    }\n\n    async _writeJoinedMembers(members, txn) {\n        await Promise.all(members.map(async member => {\n            if (member.membership === \"join\") {\n                await this._writeMember(member, txn);\n            }\n        }));\n    }\n\n    async _writeMember(member, txn) {\n        const {userIdentities} = txn;\n        const identity = await userIdentities.get(member.userId);\n        const updatedIdentity = addRoomToIdentity(identity, member.userId, member.roomId);\n        if (updatedIdentity) {\n            userIdentities.set(updatedIdentity);\n        }\n    }\n\n    async _removeRoomFromUserIdentity(roomId, userId, txn) {\n        const {userIdentities, deviceIdentities} = txn;\n        const identity = await userIdentities.get(userId);\n        if (identity) {\n            identity.roomIds = identity.roomIds.filter(id => id !== roomId);\n            // no more encrypted rooms with this user, remove\n            if (identity.roomIds.length === 0) {\n                userIdentities.remove(userId);\n                deviceIdentities.removeAllForUser(userId);\n            } else {\n                userIdentities.set(identity);\n            }\n        }\n    }\n\n    async _applyMemberChange(memberChange, txn) {\n        // TODO: depends whether we encrypt for invited users??\n        // add room\n        if (memberChange.hasJoined) {\n            await this._writeMember(memberChange.member, txn);\n        }\n        // remove room\n        else if (memberChange.hasLeft) {\n            const {roomId} = memberChange;\n            // if we left the room, remove room from all user identities in the room\n            if (memberChange.userId === this._ownUserId) {\n                const userIds = await txn.roomMembers.getAllUserIds(roomId);\n                await Promise.all(userIds.map(userId => {\n                    return this._removeRoomFromUserIdentity(roomId, userId, txn);\n                }));\n            } else {\n                await this._removeRoomFromUserIdentity(roomId, memberChange.userId, txn);\n            }\n        }\n    }\n\n    async _queryKeys(userIds, hsApi, log) {\n        // TODO: we need to handle the race here between /sync and /keys/query just like we need to do for the member list ...\n        // there are multiple requests going out for /keys/query though and only one for /members\n\n        const deviceKeyResponse = await hsApi.queryKeys({\n            \"timeout\": 10000,\n            \"device_keys\": userIds.reduce((deviceKeysMap, userId) => {\n                deviceKeysMap[userId] = [];\n                return deviceKeysMap;\n            }, {}),\n            \"token\": this._getSyncToken()\n        }, {log}).response();\n\n        const verifiedKeysPerUser = log.wrap(\"verify\", log => this._filterVerifiedDeviceKeys(deviceKeyResponse[\"device_keys\"], log));\n        const txn = await this._storage.readWriteTxn([\n            this._storage.storeNames.userIdentities,\n            this._storage.storeNames.deviceIdentities,\n        ]);\n        let deviceIdentities;\n        try {\n            const devicesIdentitiesPerUser = await Promise.all(verifiedKeysPerUser.map(async ({userId, verifiedKeys}) => {\n                const deviceIdentities = verifiedKeys.map(deviceKeysAsDeviceIdentity);\n                return await this._storeQueriedDevicesForUserId(userId, deviceIdentities, txn);\n            }));\n            deviceIdentities = devicesIdentitiesPerUser.reduce((all, devices) => all.concat(devices), []);\n            log.set(\"devices\", deviceIdentities.length);\n        } catch (err) {\n            txn.abort();\n            throw err;\n        }\n        await txn.complete();\n        return deviceIdentities;\n    }\n\n    async _storeQueriedDevicesForUserId(userId, deviceIdentities, txn) {\n        const knownDeviceIds = await txn.deviceIdentities.getAllDeviceIds(userId);\n        // delete any devices that we know off but are not in the response anymore.\n        // important this happens before checking if the ed25519 key changed,\n        // otherwise we would end up deleting existing devices with changed keys.\n        for (const deviceId of knownDeviceIds) {\n            if (deviceIdentities.every(di => di.deviceId !== deviceId)) {\n                txn.deviceIdentities.remove(userId, deviceId);\n            }\n        }\n\n        // all the device identities as we will have them in storage\n        const allDeviceIdentities = [];\n        const deviceIdentitiesToStore = [];\n        // filter out devices that have changed their ed25519 key since last time we queried them\n        deviceIdentities = await Promise.all(deviceIdentities.map(async deviceIdentity => {\n            if (knownDeviceIds.includes(deviceIdentity.deviceId)) {\n                const existingDevice = await txn.deviceIdentities.get(deviceIdentity.userId, deviceIdentity.deviceId);\n                if (existingDevice.ed25519Key !== deviceIdentity.ed25519Key) {\n                    allDeviceIdentities.push(existingDevice);\n                }\n            }\n            allDeviceIdentities.push(deviceIdentity);\n            deviceIdentitiesToStore.push(deviceIdentity);\n        }));\n        // store devices\n        for (const deviceIdentity of deviceIdentitiesToStore) {\n            txn.deviceIdentities.set(deviceIdentity);\n        }\n        // mark user identities as up to date\n        const identity = await txn.userIdentities.get(userId);\n        identity.deviceTrackingStatus = TRACKING_STATUS_UPTODATE;\n        txn.userIdentities.set(identity);\n\n        return allDeviceIdentities;\n    }\n\n    /**\n     * @return {Array<{userId, verifiedKeys: Array<DeviceSection>>}\n     */\n    _filterVerifiedDeviceKeys(keyQueryDeviceKeysResponse, parentLog) {\n        const curve25519Keys = new Set();\n        const verifiedKeys = Object.entries(keyQueryDeviceKeysResponse).map(([userId, keysByDevice]) => {\n            const verifiedEntries = Object.entries(keysByDevice).filter(([deviceId, deviceKeys]) => {\n                const deviceIdOnKeys = deviceKeys[\"device_id\"];\n                const userIdOnKeys = deviceKeys[\"user_id\"];\n                if (userIdOnKeys !== userId) {\n                    return false;\n                }\n                if (deviceIdOnKeys !== deviceId) {\n                    return false;\n                }\n                const ed25519Key = deviceKeys.keys?.[`ed25519:${deviceId}`];\n                const curve25519Key = deviceKeys.keys?.[`curve25519:${deviceId}`];\n                if (typeof ed25519Key !== \"string\" || typeof curve25519Key !== \"string\") {\n                    return false;\n                }\n                if (curve25519Keys.has(curve25519Key)) {\n                    parentLog.log({\n                        l: \"ignore device with duplicate curve25519 key\",\n                        keys: deviceKeys\n                    }, parentLog.level.Warn);\n                    return false;\n                }\n                curve25519Keys.add(curve25519Key);\n                const isValid = this._hasValidSignature(deviceKeys, parentLog);\n                if (!isValid) {\n                    parentLog.log({\n                        l: \"ignore device with invalid signature\",\n                        keys: deviceKeys\n                    }, parentLog.level.Warn);\n                }\n                return isValid;\n            });\n            const verifiedKeys = verifiedEntries.map(([, deviceKeys]) => deviceKeys);\n            return {userId, verifiedKeys};\n        });\n        return verifiedKeys;\n    }\n\n    _hasValidSignature(deviceSection, parentLog) {\n        const deviceId = deviceSection[\"device_id\"];\n        const userId = deviceSection[\"user_id\"];\n        const ed25519Key = deviceSection?.keys?.[`${SIGNATURE_ALGORITHM}:${deviceId}`];\n        return verifyEd25519Signature(this._olmUtil, userId, deviceId, ed25519Key, deviceSection, parentLog);\n    }\n\n    /**\n     * Gives all the device identities for a room that is already tracked.\n     * Assumes room is already tracked. Call `trackRoom` first if unsure.\n     * @param  {String} roomId [description]\n     * @return {[type]}        [description]\n     */\n    async devicesForTrackedRoom(roomId, hsApi, log) {\n        const txn = await this._storage.readTxn([\n            this._storage.storeNames.roomMembers,\n            this._storage.storeNames.userIdentities,\n        ]);\n\n        // because we don't have multiEntry support in IE11, we get a set of userIds that is pretty close to what we\n        // need as a good first filter (given that non-join memberships will be in there). After fetching the identities,\n        // we check which ones have the roomId for the room we're looking at.\n        \n        // So, this will also contain non-joined memberships\n        const userIds = await txn.roomMembers.getAllUserIds(roomId);\n\n        return await this._devicesForUserIds(roomId, userIds, txn, hsApi, log);\n    }\n\n    async devicesForRoomMembers(roomId, userIds, hsApi, log) {\n        const txn = await this._storage.readTxn([\n            this._storage.storeNames.userIdentities,\n        ]);\n        return await this._devicesForUserIds(roomId, userIds, txn, hsApi, log);\n    }\n\n    /**\n     * @param  {string} roomId  [description]\n     * @param  {Array<string>} userIds a set of user ids to try and find the identity for. Will be check to belong to roomId.\n     * @param  {Transaction} userIdentityTxn to read the user identities\n     * @param  {HomeServerApi} hsApi\n     * @return {Array<DeviceIdentity>}\n     */\n    async _devicesForUserIds(roomId, userIds, userIdentityTxn, hsApi, log) {\n        const allMemberIdentities = await Promise.all(userIds.map(userId => userIdentityTxn.userIdentities.get(userId)));\n        const identities = allMemberIdentities.filter(identity => {\n            // identity will be missing for any userIds that don't have \n            // membership join in any of your encrypted rooms\n            return identity && identity.roomIds.includes(roomId);\n        });\n        const upToDateIdentities = identities.filter(i => i.deviceTrackingStatus === TRACKING_STATUS_UPTODATE);\n        const outdatedIdentities = identities.filter(i => i.deviceTrackingStatus === TRACKING_STATUS_OUTDATED);\n        log.set(\"uptodate\", upToDateIdentities.length);\n        log.set(\"outdated\", outdatedIdentities.length);\n        let queriedDevices;\n        if (outdatedIdentities.length) {\n            // TODO: ignore the race between /sync and /keys/query for now,\n            // where users could get marked as outdated or added/removed from the room while\n            // querying keys\n            queriedDevices = await this._queryKeys(outdatedIdentities.map(i => i.userId), hsApi, log);\n        }\n\n        const deviceTxn = await this._storage.readTxn([\n            this._storage.storeNames.deviceIdentities,\n        ]);\n        const devicesPerUser = await Promise.all(upToDateIdentities.map(identity => {\n            return deviceTxn.deviceIdentities.getAllForUserId(identity.userId);\n        }));\n        let flattenedDevices = devicesPerUser.reduce((all, devicesForUser) => all.concat(devicesForUser), []);\n        if (queriedDevices && queriedDevices.length) {\n            flattenedDevices = flattenedDevices.concat(queriedDevices);\n        }\n        // filter out our own device\n        const devices = flattenedDevices.filter(device => {\n            const isOwnDevice = device.userId === this._ownUserId && device.deviceId === this._ownDeviceId;\n            return !isOwnDevice;\n        });\n        return devices;\n    }\n\n    async getDeviceByCurve25519Key(curve25519Key, txn) {\n        return await txn.deviceIdentities.getByCurve25519Key(curve25519Key);\n    }\n}\n","import {IDOMStorage} from \"./types\";\nimport {ITransaction} from \"./QueryTarget\";\nimport {iterateCursor, NOT_DONE, reqAsPromise} from \"./utils\";\nimport {RoomMember, EVENT_TYPE as MEMBER_EVENT_TYPE} from \"../../room/members/RoomMember.js\";\nimport {addRoomToIdentity} from \"../../e2ee/DeviceTracker.js\";\nimport {SESSION_E2EE_KEY_PREFIX} from \"../../e2ee/common.js\";\nimport {SummaryData} from \"../../room/RoomSummary\";\nimport {RoomMemberStore, MemberData} from \"./stores/RoomMemberStore\";\nimport {InboundGroupSessionStore, InboundGroupSessionEntry, BackupStatus, KeySource} from \"./stores/InboundGroupSessionStore\";\nimport {RoomStateEntry} from \"./stores/RoomStateStore\";\nimport {SessionStore} from \"./stores/SessionStore\";\nimport {Store} from \"./Store\";\nimport {encodeScopeTypeKey} from \"./stores/OperationStore\";\nimport {MAX_UNICODE} from \"./stores/common\";\nimport {ILogItem} from \"../../../logging/types\";\n\n\nexport type MigrationFunc = (db: IDBDatabase, txn: IDBTransaction, localStorage: IDOMStorage, log: ILogItem) => Promise<void> | void;\n// FUNCTIONS SHOULD ONLY BE APPENDED!!\n// the index in the array is the database version\nexport const schema: MigrationFunc[] = [\n    createInitialStores,\n    createMemberStore,\n    migrateSession,\n    createE2EEStores,\n    migrateEncryptionFlag,\n    createAccountDataStore,\n    createInviteStore,\n    createArchivedRoomSummaryStore,\n    migrateOperationScopeIndex,\n    createTimelineRelationsStore,\n    fixMissingRoomsInUserIdentities,\n    changeSSSSKeyPrefix,\n    backupAndRestoreE2EEAccountToLocalStorage,\n    clearAllStores,\n    addInboundSessionBackupIndex,\n    migrateBackupStatus\n];\n// TODO: how to deal with git merge conflicts of this array?\n\n// TypeScript note: for now, do not bother introducing interfaces / alias\n// for old schemas. Just take them as `any`. \n\nfunction createDatabaseNameHelper(db: IDBDatabase): ITransaction {\n    // the Store object gets passed in several things through the Transaction class (a wrapper around IDBTransaction),\n    // the only thing we should need here is the databaseName though, so we mock it out.\n    // ideally we should have an easier way to go from the idb primitive layer to the specific store classes where\n    // we implement logic, but for now we need this.\n    const databaseNameHelper: ITransaction = {\n        databaseName: db.name,\n        get idbFactory(): IDBFactory { throw new Error(\"unused\");},\n        get IDBKeyRange(): typeof IDBKeyRange { throw new Error(\"unused\");},\n        addWriteError() {},\n    };\n    return databaseNameHelper;\n}\n\n\n// how do we deal with schema updates vs existing data migration in a way that \n//v1\nfunction createInitialStores(db: IDBDatabase): void {\n    db.createObjectStore(\"session\", {keyPath: \"key\"});\n    // any way to make keys unique here? (just use put?)\n    db.createObjectStore(\"roomSummary\", {keyPath: \"roomId\"});\n\n    // need index to find live fragment? prooobably ok without for now\n    //key = room_id | fragment_id\n    db.createObjectStore(\"timelineFragments\", {keyPath: \"key\"});\n    //key = room_id | fragment_id | event_index\n    const timelineEvents = db.createObjectStore(\"timelineEvents\", {keyPath: \"key\"});\n    //eventIdKey = room_id | event_id\n    timelineEvents.createIndex(\"byEventId\", \"eventIdKey\", {unique: true});\n    //key = room_id | event.type | event.state_key,\n    db.createObjectStore(\"roomState\", {keyPath: \"key\"});\n    db.createObjectStore(\"pendingEvents\", {keyPath: \"key\"});\n}\n//v2\nasync function createMemberStore(db: IDBDatabase, txn: IDBTransaction): Promise<void> {\n    // Cast ok here because only \"set\" is used\n    const roomMembers = new RoomMemberStore(db.createObjectStore(\"roomMembers\", {keyPath: \"key\"}) as any);\n    // migrate existing member state events over\n    const roomState = txn.objectStore(\"roomState\");\n    await iterateCursor<RoomStateEntry>(roomState.openCursor(), entry => {\n        if (entry.event.type === MEMBER_EVENT_TYPE) {\n            roomState.delete(entry.key);\n            const member = RoomMember.fromMemberEvent(entry.roomId, entry.event);\n            if (member) {\n                roomMembers.set(member.serialize());\n            }\n        }\n        return NOT_DONE;\n    });\n}\n//v3\nasync function migrateSession(db: IDBDatabase, txn: IDBTransaction, localStorage: IDOMStorage): Promise<void> {\n    const session = txn.objectStore(\"session\");\n    try {\n        const PRE_MIGRATION_KEY = 1;\n        const entry = await reqAsPromise(session.get(PRE_MIGRATION_KEY));\n        if (entry) {\n            session.delete(PRE_MIGRATION_KEY);\n            const {syncToken, syncFilterId, serverVersions} = entry.value;\n            // Cast ok here because only \"set\" is used and we don't look into return\n            const store = new SessionStore(session as any, localStorage);\n            store.set(\"sync\", {token: syncToken, filterId: syncFilterId});\n            store.set(\"serverVersions\", serverVersions);\n        }\n    } catch (err) {\n        txn.abort();\n        console.error(\"could not migrate session\", err.stack);\n    }\n}\n//v4\nfunction createE2EEStores(db: IDBDatabase): void {\n    db.createObjectStore(\"userIdentities\", {keyPath: \"userId\"});\n    const deviceIdentities = db.createObjectStore(\"deviceIdentities\", {keyPath: \"key\"});\n    deviceIdentities.createIndex(\"byCurve25519Key\", \"curve25519Key\", {unique: true});\n    db.createObjectStore(\"olmSessions\", {keyPath: \"key\"});\n    db.createObjectStore(\"inboundGroupSessions\", {keyPath: \"key\"});\n    db.createObjectStore(\"outboundGroupSessions\", {keyPath: \"roomId\"});\n    db.createObjectStore(\"groupSessionDecryptions\", {keyPath: \"key\"});\n    const operations = db.createObjectStore(\"operations\", {keyPath: \"id\"});\n    operations.createIndex(\"byTypeAndScope\", \"typeScopeKey\", {unique: false});\n}\n\n// v5\nasync function migrateEncryptionFlag(db: IDBDatabase, txn: IDBTransaction): Promise<void> {\n    // migrate room summary isEncrypted -> encryption prop\n    const roomSummary = txn.objectStore(\"roomSummary\");\n    const roomState = txn.objectStore(\"roomState\");\n    const summaries: any[] = [];\n    await iterateCursor<any>(roomSummary.openCursor(), summary => {\n        summaries.push(summary);\n        return NOT_DONE;\n    });\n    for (const summary of summaries) {\n        const encryptionEntry = await reqAsPromise(roomState.get(`${summary.roomId}|m.room.encryption|`));\n        if (encryptionEntry) {\n            summary.encryption = encryptionEntry?.event?.content;\n            delete summary.isEncrypted;\n            roomSummary.put(summary);\n        }\n    }\n}\n\n// v6\nfunction createAccountDataStore(db: IDBDatabase): void {\n    db.createObjectStore(\"accountData\", {keyPath: \"type\"});\n}\n\n// v7\nfunction createInviteStore(db: IDBDatabase): void {\n    db.createObjectStore(\"invites\", {keyPath: \"roomId\"});\n}\n\n// v8\nfunction createArchivedRoomSummaryStore(db: IDBDatabase): void {\n    db.createObjectStore(\"archivedRoomSummary\", {keyPath: \"summary.roomId\"});\n}\n\n// v9\nasync function migrateOperationScopeIndex(db: IDBDatabase, txn: IDBTransaction): Promise<void> {\n    try {\n        const operations = txn.objectStore(\"operations\");\n        operations.deleteIndex(\"byTypeAndScope\");\n        await iterateCursor<any>(operations.openCursor(), (op, key, cur) => {\n            const {typeScopeKey} = op;\n            delete op.typeScopeKey;\n            const [type, scope] = typeScopeKey.split(\"|\");\n            op.scopeTypeKey = encodeScopeTypeKey(scope, type);\n            cur.update(op);\n            return NOT_DONE;\n        });\n        operations.createIndex(\"byScopeAndType\", \"scopeTypeKey\", {unique: false});\n    } catch (err) {\n        txn.abort();\n        console.error(\"could not migrate operations\", err.stack);\n    }\n}\n\n//v10\nfunction createTimelineRelationsStore(db: IDBDatabase) : void {\n    db.createObjectStore(\"timelineRelations\", {keyPath: \"key\"});\n}\n\n//v11 doesn't change the schema, but ensures all userIdentities have all the roomIds they should (see #470)\nasync function fixMissingRoomsInUserIdentities(db: IDBDatabase, txn: IDBTransaction, localStorage: IDOMStorage, log: ILogItem) {\n    const roomSummaryStore = txn.objectStore(\"roomSummary\");\n    const trackedRoomIds: string[] = [];\n    await iterateCursor<SummaryData>(roomSummaryStore.openCursor(), roomSummary => {\n        if (roomSummary.isTrackingMembers) {\n            trackedRoomIds.push(roomSummary.roomId);\n        }\n        return NOT_DONE;\n    });\n    const outboundGroupSessionsStore = txn.objectStore(\"outboundGroupSessions\");\n    const userIdentitiesStore: IDBObjectStore = txn.objectStore(\"userIdentities\");\n    const roomMemberStore = txn.objectStore(\"roomMembers\");\n    for (const roomId of trackedRoomIds) {\n        let foundMissing = false;\n        const joinedUserIds: string[] = [];\n        const memberRange = IDBKeyRange.bound(roomId, `${roomId}|${MAX_UNICODE}`, true, true);\n        await log.wrap({l: \"room\", id: roomId}, async log => {\n            await iterateCursor<MemberData>(roomMemberStore.openCursor(memberRange), member => {\n                if (member.membership === \"join\") {\n                    joinedUserIds.push(member.userId);\n                }\n                return NOT_DONE;\n            });\n            log.set(\"joinedUserIds\", joinedUserIds.length);\n            for (const userId of joinedUserIds) {\n                const identity = await reqAsPromise(userIdentitiesStore.get(userId));\n                const originalRoomCount = identity?.roomIds?.length;\n                const updatedIdentity = addRoomToIdentity(identity, userId, roomId);\n                if (updatedIdentity) {\n                    log.log({l: `fixing up`, id: userId,\n                        roomsBefore: originalRoomCount, roomsAfter: updatedIdentity.roomIds.length});\n                    userIdentitiesStore.put(updatedIdentity);\n                    foundMissing = true;\n                }\n            }\n            log.set(\"foundMissing\", foundMissing);\n            if (foundMissing) {\n                // clear outbound megolm session,\n                // so we'll create a new one on the next message that will be properly shared\n                outboundGroupSessionsStore.delete(roomId);\n            }\n        });\n    }\n}\n\n// v12 move ssssKey to e2ee:ssssKey so it will get backed up in the next step\nasync function changeSSSSKeyPrefix(db: IDBDatabase, txn: IDBTransaction) {\n    const session = txn.objectStore(\"session\");\n    const ssssKey = await reqAsPromise(session.get(\"ssssKey\"));\n    if (ssssKey) {\n        session.put({key: `${SESSION_E2EE_KEY_PREFIX}ssssKey`, value: ssssKey.value});\n    }\n}\n// v13\nasync function backupAndRestoreE2EEAccountToLocalStorage(db: IDBDatabase, txn: IDBTransaction, localStorage: IDOMStorage, log: ILogItem) {\n    const session = txn.objectStore(\"session\");\n    const sessionStore = new SessionStore(new Store(session, createDatabaseNameHelper(db)), localStorage);\n    // if we already have an e2ee identity, write a backup to local storage.\n    // further updates to e2ee keys in the session store will also write to local storage from 0.2.15 on,\n    // but here we make sure a backup is immediately created after installing the update and we don't wait until\n    // the olm account needs to change\n    sessionStore.writeE2EEIdentityToLocalStorage();\n    // and if we already have a backup, restore it now for any missing key in idb.\n    // this will restore the backup every time the idb database is dropped as it will\n    // run through all the migration steps when recreating it.\n    const restored = await sessionStore.tryRestoreE2EEIdentityFromLocalStorage(log);\n    log.set(\"restored\", restored);\n}\n// v14 clear all stores apart from e2ee keys because of possible timeline corruption in #515, will trigger initial sync\nasync function clearAllStores(db: IDBDatabase, txn: IDBTransaction) {\n    for (const storeName of db.objectStoreNames) {\n        const store = txn.objectStore(storeName);\n        switch (storeName) {\n            case \"inboundGroupSessions\":\n            case \"outboundGroupSessions\":\n            case \"olmSessions\":\n            case \"operations\":\n                continue;\n            case \"session\": {\n                await iterateCursor(store.openCursor(), (value, key, cursor) => {\n                    if (!(key as string).startsWith(SESSION_E2EE_KEY_PREFIX)) {\n                        cursor.delete();\n                    }\n                    return NOT_DONE;\n                })\n                break;\n            }\n            default: {\n                store.clear();\n                break;\n            }\n        }\n    }\n}\n\n// v15 add backup index to inboundGroupSessions\nasync function addInboundSessionBackupIndex(db: IDBDatabase, txn: IDBTransaction, localStorage: IDOMStorage, log: ILogItem): Promise<void> {\n    const inboundGroupSessions = txn.objectStore(\"inboundGroupSessions\");\n    inboundGroupSessions.createIndex(\"byBackup\", \"backup\", {unique: false});\n}\n\n\n// v16 migrates the backup and source fields of inbound group sessions\nasync function migrateBackupStatus(db: IDBDatabase, txn: IDBTransaction, localStorage: IDOMStorage, log: ILogItem): Promise<void> {\n    const inboundGroupSessions = txn.objectStore(\"inboundGroupSessions\");\n    let countWithSession = 0;\n    let countWithoutSession = 0;\n    await iterateCursor<InboundGroupSessionEntry>(inboundGroupSessions.openCursor(), (value, key, cursor) => {\n        if (value.session) {\n            value.backup = BackupStatus.NotBackedUp;\n            // we'll also have backup keys in here, we can't tell,\n            // but the worst thing that can happen is that we try\n            // to backup keys that were already in backup, which\n            // the server will ignore\n            value.source = KeySource.DeviceMessage;\n            cursor.update(value);\n            countWithSession += 1;\n        } else {\n            countWithoutSession += 1;\n        }\n        return NOT_DONE;\n    });\n    log.set(\"countWithoutSession\", countWithoutSession);\n    log.set(\"countWithSession\", countWithSession);\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\nimport {openDatabase, txnAsPromise, reqAsPromise} from \"./utils\";\n\n// filed as https://bugs.webkit.org/show_bug.cgi?id=222746\nexport async function detectWebkitEarlyCloseTxnBug(idbFactory: IDBFactory): Promise<boolean> {\n    const dbName = \"hydrogen_webkit_test_inactive_txn_bug\";\n    try {\n        const db = await openDatabase(dbName, db => {\n            db.createObjectStore(\"test\", {keyPath: \"key\"});\n        }, 1, idbFactory);\n        const readTxn = db.transaction([\"test\"], \"readonly\");\n        await reqAsPromise(readTxn.objectStore(\"test\").get(\"somekey\"));\n        // schedule a macro task in between the two txns\n        await new Promise(r => setTimeout(r, 0));\n        const writeTxn = db.transaction([\"test\"], \"readwrite\");\n        await Promise.resolve();\n        writeTxn.objectStore(\"test\").add({key: \"somekey\", value: \"foo\"});\n        await txnAsPromise(writeTxn);\n        db.close();\n    } catch (err) {\n        if (err.name === \"TransactionInactiveError\") {\n            return true;\n        }\n    }\n    return false;\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {IDOMStorage} from \"./types\";\nimport {Storage} from \"./Storage\";\nimport { openDatabase, reqAsPromise } from \"./utils\";\nimport { exportSession, importSession, Export } from \"./export\";\nimport { schema } from \"./schema\";\nimport { detectWebkitEarlyCloseTxnBug } from \"./quirks\";\nimport { ILogItem } from \"../../../logging/types\";\n\nconst sessionName = (sessionId: string) => `hydrogen_session_${sessionId}`;\nconst openDatabaseWithSessionId = function(sessionId: string, idbFactory: IDBFactory, localStorage: IDOMStorage, log: ILogItem) {\n    const create = (db, txn, oldVersion, version) => createStores(db, txn, oldVersion, version, localStorage, log);\n    return openDatabase(sessionName(sessionId), create, schema.length, idbFactory);\n}\n\ninterface ServiceWorkerHandler {\n    preventConcurrentSessionAccess: (sessionId: string) => Promise<void>;\n}\n\nasync function requestPersistedStorage(): Promise<boolean> {\n    // don't assume browser so we can run in node with fake-idb\n    const glob = this;\n    if (glob?.navigator?.storage?.persist) {\n        return await glob.navigator.storage.persist();\n    } else if (glob?.document.requestStorageAccess) {\n        try {\n            await glob.document.requestStorageAccess();\n            return true;\n        } catch (err) {\n            return false;\n        }\n    } else {\n        return false;\n    }\n}\n\nexport class StorageFactory {\n    private _serviceWorkerHandler: ServiceWorkerHandler;\n    private _idbFactory: IDBFactory;\n    private _IDBKeyRange: typeof IDBKeyRange;\n    private _localStorage: IDOMStorage;\n\n    constructor(serviceWorkerHandler: ServiceWorkerHandler, idbFactory: IDBFactory = window.indexedDB, _IDBKeyRange = window.IDBKeyRange, localStorage: IDOMStorage = window.localStorage) {\n        this._serviceWorkerHandler = serviceWorkerHandler;\n        this._idbFactory = idbFactory;\n        this._IDBKeyRange = _IDBKeyRange;\n        this._localStorage = localStorage;\n    }\n\n    async create(sessionId: string, log: ILogItem): Promise<Storage> {\n        await this._serviceWorkerHandler?.preventConcurrentSessionAccess(sessionId);\n        requestPersistedStorage().then(persisted => {\n            // Firefox lies here though, and returns true even if the user denied the request\n            if (!persisted) {\n                console.warn(\"no persisted storage, database can be evicted by browser\");\n            }\n        });\n\n        const hasWebkitEarlyCloseTxnBug = await detectWebkitEarlyCloseTxnBug(this._idbFactory);\n        const db = await openDatabaseWithSessionId(sessionId, this._idbFactory, this._localStorage, log);\n        return new Storage(db, this._idbFactory, this._IDBKeyRange, hasWebkitEarlyCloseTxnBug, this._localStorage, log.logger);\n    }\n\n    delete(sessionId: string): Promise<IDBDatabase> {\n        const databaseName = sessionName(sessionId);\n        const req = this._idbFactory.deleteDatabase(databaseName);\n        return reqAsPromise(req);\n    }\n\n    async export(sessionId: string, log: ILogItem): Promise<Export> {\n        const db = await openDatabaseWithSessionId(sessionId, this._idbFactory, this._localStorage, log);\n        return await exportSession(db);\n    }\n\n    async import(sessionId: string, data: Export, log: ILogItem): Promise<void> {\n        const db = await openDatabaseWithSessionId(sessionId, this._idbFactory, this._localStorage, log);\n        return await importSession(db, data);\n    }\n}\n\nasync function createStores(db: IDBDatabase, txn: IDBTransaction, oldVersion: number | null, version: number, localStorage: IDOMStorage, log: ILogItem): Promise<void> {\n    const startIdx = oldVersion || 0;\n    return log.wrap(\n        { l: \"storage migration\", oldVersion, version },\n        async (log) => {\n            for (let i = startIdx; i < version; ++i) {\n                const migrationFunc = schema[i];\n                await log.wrap(`v${i + 1}`, (log) => migrationFunc(db, txn, localStorage, log));\n            }\n        });\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {EventEntry} from \"../entries/EventEntry.js\";\nimport {REDACTION_TYPE, isRedacted} from \"../../common\";\nimport {ANNOTATION_RELATION_TYPE, getRelation} from \"../relations.js\";\nimport {redactEvent} from \"../common.js\";\n\nexport class RelationWriter {\n    constructor({roomId, ownUserId, fragmentIdComparer}) {\n        this._roomId = roomId;\n        this._ownUserId = ownUserId;\n        this._fragmentIdComparer = fragmentIdComparer;\n    }\n\n    // this needs to happen again after decryption too for edits\n    async writeRelation(sourceEntry, txn, log) {\n        const {relatedEventId} = sourceEntry;\n        if (relatedEventId) {\n            const relation = getRelation(sourceEntry.event);\n            if (relation && relation.rel_type) {\n                // we don't consider replies (which aren't relations in the MSC2674 sense)\n                txn.timelineRelations.add(this._roomId, relation.event_id, relation.rel_type, sourceEntry.id);\n            }\n            const target = await txn.timelineEvents.getByEventId(this._roomId, relatedEventId);\n            if (target) {\n                const updatedStorageEntries = await this._applyRelation(sourceEntry, target, txn, log);\n                if (updatedStorageEntries) {\n                    return updatedStorageEntries.map(e => {\n                        txn.timelineEvents.update(e);\n                        return new EventEntry(e, this._fragmentIdComparer);\n                    });\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param {Object} storageEntry the event object, as it will be stored in storage.\n     *        Will be modified (but not written to storage) in case this event is\n     *        a relation target for which we've previously received relations.\n     * @param {Direction} direction of the gap fill\n     * */\n    async writeGapRelation(storageEntry, direction, txn, log) {\n        const sourceEntry = new EventEntry(storageEntry, this._fragmentIdComparer);\n        const result = await this.writeRelation(sourceEntry, txn, log);\n        // when back-paginating, it can also happen that we've received relations\n        // for this event before, which now upon receiving the target need to be aggregated.\n        if (direction.isBackward && !isRedacted(storageEntry.event)) {\n            const relations = await txn.timelineRelations.getAllForTarget(this._roomId, sourceEntry.id);\n            if (relations.length) {\n                for (const r of relations) {\n                    const relationStorageEntry = await txn.timelineEvents.getByEventId(this._roomId, r.sourceEventId);\n                    if (relationStorageEntry) {\n                        const relationEntry = new EventEntry(relationStorageEntry, this._fragmentIdComparer);\n                        await this._applyRelation(relationEntry, storageEntry, txn, log);\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @param {EventEntry} sourceEntry\n     * @param {Object} targetStorageEntry event entry as stored in the timelineEvents store\n     * @return {[Object]} array of event storage entries that have been updated\n     * */\n    async _applyRelation(sourceEntry, targetStorageEntry, txn, log) {\n        if (sourceEntry.eventType === REDACTION_TYPE) {\n            return log.wrap(\"redact\", async log => {\n                const redactedEvent = targetStorageEntry.event;\n                const relation = getRelation(redactedEvent); // get this before redacting\n                const redacted = this._applyRedaction(sourceEntry.event, targetStorageEntry, txn, log);\n                if (redacted) {\n                    const updated = [targetStorageEntry];\n                    if (relation) {\n                        const relationTargetStorageEntry = await this._reaggregateRelation(redactedEvent, relation, txn, log);\n                        if (relationTargetStorageEntry) {\n                            updated.push(relationTargetStorageEntry);\n                        }\n                    }\n                    return updated;\n                }\n                return null;\n            });\n        } else {\n            const relation = getRelation(sourceEntry.event);\n            if (relation && !isRedacted(targetStorageEntry.event)) {\n                const relType = relation.rel_type;\n                if (relType === ANNOTATION_RELATION_TYPE) {\n                    const aggregated = log.wrap(\"react\", log => {\n                        return this._aggregateAnnotation(sourceEntry.event, targetStorageEntry, log);\n                    });\n                    if (aggregated) {\n                        return [targetStorageEntry];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    _applyRedaction(redactionEvent, redactedStorageEntry, txn, log) {\n        const redactedEvent = redactedStorageEntry.event;\n        log.set(\"redactionId\", redactionEvent.event_id);\n        log.set(\"id\", redactedEvent.event_id);\n\n        const relation = getRelation(redactedEvent);\n        if (relation && relation.rel_type) {\n            txn.timelineRelations.remove(this._roomId, relation.event_id, relation.rel_type, redactedEvent.event_id);\n        }\n        // check if we're the target of a relation and remove all relations then as well\n        txn.timelineRelations.removeAllForTarget(this._roomId, redactedEvent.event_id);\n\n        redactEvent(redactionEvent, redactedEvent);\n        delete redactedStorageEntry.annotations;\n\n        return true;\n    }\n\n    _aggregateAnnotation(annotationEvent, targetStorageEntry/*, log*/) {\n        // TODO: do we want to verify it is a m.reaction event somehow?\n        const relation = getRelation(annotationEvent);\n        if (!relation) {\n            return false;\n        }\n\n        let {annotations} = targetStorageEntry;\n        if (!annotations) {\n            targetStorageEntry.annotations = annotations = {};\n        }\n        let annotation = annotations[relation.key];\n        if (!annotation) {\n            annotations[relation.key] = annotation = {\n                count: 0,\n                me: false,\n                firstTimestamp: Number.MAX_SAFE_INTEGER\n            };\n        }\n        const sentByMe = annotationEvent.sender === this._ownUserId;\n\n        annotation.me = annotation.me || sentByMe;\n        annotation.count += 1;\n        annotation.firstTimestamp = Math.min(\n            annotation.firstTimestamp,\n            annotationEvent.origin_server_ts\n        );\n\n        return true;\n    }\n\n    async _reaggregateRelation(redactedRelationEvent, redactedRelation, txn, log) {\n        if (redactedRelation.rel_type === ANNOTATION_RELATION_TYPE) {\n            return log.wrap(\"reaggregate annotations\", log => this._reaggregateAnnotation(\n                redactedRelation.event_id,\n                redactedRelation.key,\n                txn, log\n            ));\n        }\n        return null;\n    }\n\n    async _reaggregateAnnotation(targetId, key, txn, log) {\n        const target = await txn.timelineEvents.getByEventId(this._roomId, targetId);\n        if (!target || !target.annotations) { // unknown or redacted event\n            return null;\n        }\n        log.set(\"id\", targetId);\n        const relations = await txn.timelineRelations.getForTargetAndType(this._roomId, targetId, ANNOTATION_RELATION_TYPE);\n        log.set(\"relations\", relations.length);\n        delete target.annotations[key];\n        if (isObjectEmpty(target.annotations)) {\n            delete target.annotations;\n        }\n        await Promise.all(relations.map(async relation => {\n            const annotation = await txn.timelineEvents.getByEventId(this._roomId, relation.sourceEventId);\n            if (!annotation) {\n                log.log({l: \"missing annotation\", id: relation.sourceEventId});\n            }\n            if (getRelation(annotation.event).key === key) {\n                this._aggregateAnnotation(annotation.event, target, log);\n            }\n        }));\n        return target;\n    }\n}\n\nfunction isObjectEmpty(obj) {\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\nimport {createMockStorage} from \"../../../../mocks/Storage\";\nimport {createEvent, withTextBody, withRedacts, withContent} from \"../../../../mocks/event.js\";\nimport {createAnnotation} from \"../relations.js\";\nimport {FragmentIdComparer} from \"../FragmentIdComparer.js\";\nimport {NullLogItem} from \"../../../../logging/NullLogger\";\n\nexport function tests() {\n    const fragmentIdComparer = new FragmentIdComparer([]);\n    const roomId = \"$abc\";\n    const alice = \"@alice:hs.tld\";\n    const bob = \"@bob:hs.tld\";\n\n    return {\n        \"apply redaction\": async assert => {\n            const event = withTextBody(\"Dogs > Cats\", createEvent(\"m.room.message\", \"!abc\", bob));\n            const reason = \"nonsense, cats are the best!\";\n            const redaction = withRedacts(event.event_id, reason, createEvent(\"m.room.redaction\", \"!def\", alice));\n            const redactionEntry = new EventEntry({fragmentId: 1, eventIndex: 3, event: redaction, roomId}, fragmentIdComparer);\n            const relationWriter = new RelationWriter({roomId, ownUserId: bob, fragmentIdComparer});\n\n            const storage = await createMockStorage();\n            const txn = await storage.readWriteTxn([storage.storeNames.timelineEvents, storage.storeNames.timelineRelations]);\n            txn.timelineEvents.tryInsert({fragmentId: 1, eventIndex: 2, event, roomId}, new NullLogItem());\n            const updatedEntries = await relationWriter.writeRelation(redactionEntry, txn, new NullLogItem());\n            await txn.complete();\n\n            assert.equal(updatedEntries.length, 1);\n            const redactedMessage = updatedEntries[0];\n            assert.equal(redactedMessage.id, \"!abc\");\n            assert.equal(redactedMessage.content.body, undefined);\n            assert.equal(redactedMessage.redactionReason, reason);\n            \n            const readTxn = await storage.readTxn([storage.storeNames.timelineEvents]);\n            const storedMessage = await readTxn.timelineEvents.getByEventId(roomId, \"!abc\");\n            await readTxn.complete();\n            assert.equal(storedMessage.event.content.body, undefined);\n            assert.equal(storedMessage.event.unsigned.redacted_because.content.reason, reason);\n        },\n        \"aggregate reaction\": async assert => {\n            const event = withTextBody(\"Dogs > Cats\", createEvent(\"m.room.message\", \"!abc\", bob));\n            const reaction = withContent(createAnnotation(event.event_id, \"🐶\"), createEvent(\"m.reaction\", \"!def\", alice));\n            reaction.origin_server_ts = 5;\n            const reactionEntry = new EventEntry({event: reaction, roomId}, fragmentIdComparer);\n            const relationWriter = new RelationWriter({roomId, ownUserId: alice, fragmentIdComparer});\n\n            const storage = await createMockStorage();\n            const txn = await storage.readWriteTxn([storage.storeNames.timelineEvents, storage.storeNames.timelineRelations]);\n            txn.timelineEvents.tryInsert({fragmentId: 1, eventIndex: 2, event, roomId}, new NullLogItem());\n            const updatedEntries = await relationWriter.writeRelation(reactionEntry, txn, new NullLogItem());\n            await txn.complete();\n\n            assert.equal(updatedEntries.length, 1);\n            const reactedMessage = updatedEntries[0];\n            assert.equal(reactedMessage.id, \"!abc\");\n            const annotation = reactedMessage.annotations[\"🐶\"];\n            assert.equal(annotation.me, true);\n            assert.equal(annotation.count, 1);\n            assert.equal(annotation.firstTimestamp, 5);\n            \n            const readTxn = await storage.readTxn([storage.storeNames.timelineEvents]);\n            const storedMessage = await readTxn.timelineEvents.getByEventId(roomId, \"!abc\");\n            await readTxn.complete();\n            assert(storedMessage.annotations[\"🐶\"]);\n        },\n        \"aggregate second reaction\": async assert => {\n            const event = withTextBody(\"Dogs > Cats\", createEvent(\"m.room.message\", \"!abc\", bob));\n            const reaction1 = withContent(createAnnotation(event.event_id, \"🐶\"), createEvent(\"m.reaction\", \"!def\", alice));\n            reaction1.origin_server_ts = 5;\n            const reaction1Entry = new EventEntry({event: reaction1, roomId}, fragmentIdComparer);\n            const reaction2 = withContent(createAnnotation(event.event_id, \"🐶\"), createEvent(\"m.reaction\", \"!hij\", bob));\n            reaction2.origin_server_ts = 10;\n            const reaction2Entry = new EventEntry({event: reaction2, roomId}, fragmentIdComparer);\n            const relationWriter = new RelationWriter({roomId, ownUserId: alice, fragmentIdComparer});\n\n            const storage = await createMockStorage();\n            const txn = await storage.readWriteTxn([storage.storeNames.timelineEvents, storage.storeNames.timelineRelations]);\n            txn.timelineEvents.tryInsert({fragmentId: 1, eventIndex: 2, event, roomId}, new NullLogItem());\n            await relationWriter.writeRelation(reaction1Entry, txn, new NullLogItem());\n            const updatedEntries = await relationWriter.writeRelation(reaction2Entry, txn, new NullLogItem());\n            await txn.complete();\n\n            assert.equal(updatedEntries.length, 1);\n\n            const reactedMessage = updatedEntries[0];\n            assert.equal(reactedMessage.id, \"!abc\");\n            const annotation = reactedMessage.annotations[\"🐶\"];\n            assert.equal(annotation.me, true);\n            assert.equal(annotation.count, 2);\n            assert.equal(annotation.firstTimestamp, 5);\n        },\n        \"redact second reaction\": async assert => {\n            const event = withTextBody(\"Dogs > Cats\", createEvent(\"m.room.message\", \"!abc\", bob));\n            const myReaction = withContent(createAnnotation(event.event_id, \"🐶\"), createEvent(\"m.reaction\", \"!def\", alice));\n            myReaction.origin_server_ts = 5;\n            const bobReaction = withContent(createAnnotation(event.event_id, \"🐶\"), createEvent(\"m.reaction\", \"!hij\", bob));\n            bobReaction.origin_server_ts = 10;\n            const myReactionRedaction = withRedacts(myReaction.event_id, \"\", createEvent(\"m.room.redaction\", \"!pol\", alice));\n\n            const myReactionEntry = new EventEntry({event: myReaction, roomId}, fragmentIdComparer);\n            const bobReactionEntry = new EventEntry({event: bobReaction, roomId}, fragmentIdComparer);\n            const myReactionRedactionEntry = new EventEntry({event: myReactionRedaction, roomId}, fragmentIdComparer);\n            const relationWriter = new RelationWriter({roomId, ownUserId: alice, fragmentIdComparer});\n\n            const storage = await createMockStorage();\n            const txn = await storage.readWriteTxn([storage.storeNames.timelineEvents, storage.storeNames.timelineRelations]);\n            txn.timelineEvents.tryInsert({fragmentId: 1, eventIndex: 2, event, roomId}, new NullLogItem());\n            txn.timelineEvents.tryInsert({fragmentId: 1, eventIndex: 3, event: myReaction, roomId}, new NullLogItem());\n            await relationWriter.writeRelation(myReactionEntry, txn, new NullLogItem());\n            txn.timelineEvents.tryInsert({fragmentId: 1, eventIndex: 4, event: bobReaction, roomId}, new NullLogItem());\n            await relationWriter.writeRelation(bobReactionEntry, txn, new NullLogItem());\n            const updatedEntries = await relationWriter.writeRelation(myReactionRedactionEntry, txn, new NullLogItem());\n            await txn.complete();\n\n            assert.equal(updatedEntries.length, 2);\n\n            const redactedReaction = updatedEntries[0];\n            assert.equal(redactedReaction.id, \"!def\");\n            const reaggregatedMessage = updatedEntries[1];\n            assert.equal(reaggregatedMessage.id, \"!abc\");\n            const annotation = reaggregatedMessage.annotations[\"🐶\"];\n            assert.equal(annotation.me, false);\n            assert.equal(annotation.count, 1);\n            assert.equal(annotation.firstTimestamp, 10);\n\n            const readTxn = await storage.readTxn([storage.storeNames.timelineEvents]);\n            const storedMessage = await readTxn.timelineEvents.getByEventId(roomId, \"!abc\");\n            await readTxn.complete();\n            assert.equal(storedMessage.annotations[\"🐶\"].count, 1);\n        },\n        \n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class Direction {\n    constructor(public readonly isForward: boolean) {\n    }\n\n    get isBackward(): boolean {\n        return !this.isForward;\n    }\n\n    asApiString(): string {\n        return this.isForward ? \"f\" : \"b\";\n    }\n\n    reverse(): Direction {\n        return this.isForward ? Direction.Backward : Direction.Forward\n    }\n\n    static get Forward(): Direction {\n        return _forward;\n    }\n\n    static get Backward(): Direction {\n        return _backward;\n    }\n}\n\nconst _forward = new Direction(true);\nconst _backward = new Direction(false);\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseEntry} from \"./BaseEntry\";\nimport {Direction} from \"../Direction\";\nimport {isValidFragmentId} from \"../common.js\";\nimport {KeyLimits} from \"../../../storage/common\";\n\nexport class FragmentBoundaryEntry extends BaseEntry {\n    constructor(fragment, isFragmentStart, fragmentIdComparer) {\n        super(fragmentIdComparer);\n        this._fragment = fragment;\n        // TODO: should isFragmentStart be Direction instead of bool?\n        this._isFragmentStart = isFragmentStart;\n    }\n\n    static start(fragment, fragmentIdComparer) {\n        return new FragmentBoundaryEntry(fragment, true, fragmentIdComparer);\n    }\n\n    static end(fragment, fragmentIdComparer) {\n        return new FragmentBoundaryEntry(fragment, false, fragmentIdComparer);\n    }\n    \n    get started() {\n        return this._isFragmentStart;\n    }\n\n    get hasEnded() {\n        return !this.started;\n    }\n\n    get fragment() {\n        return this._fragment;\n    }\n\n    get fragmentId() {\n        return this._fragment.id;\n    }\n\n    get entryIndex() {\n        if (this.started) {\n            return KeyLimits.minStorageKey;\n        } else {\n            return KeyLimits.maxStorageKey;\n        }\n    }\n\n    get isGap() {\n        return !!this.token && !this.edgeReached;\n    }\n\n    get token() {\n        if (this.started) {\n            return this.fragment.previousToken;\n        } else {\n            return this.fragment.nextToken;\n        }\n    }\n\n    set token(token) {\n        if (this.started) {\n            this.fragment.previousToken = token;\n        } else {\n            this.fragment.nextToken = token;\n        }\n    }\n\n    get edgeReached() {\n        if (this.started) {\n            return this.fragment.startReached;\n        } else {\n            return this.fragment.endReached;\n        }\n    }\n\n    set edgeReached(reached) {\n        \n        if (this.started) {\n            this.fragment.startReached = reached;\n        } else {\n            this.fragment.endReached = reached;\n        }\n    }\n\n    \n\n    get linkedFragmentId() {\n        if (this.started) {\n            return this.fragment.previousId;\n        } else {\n            return this.fragment.nextId;\n        }\n    }\n\n    set linkedFragmentId(id) {\n        if (this.started) {\n            this.fragment.previousId = id;\n        } else {\n            this.fragment.nextId = id;\n        }\n    }\n\n    get hasLinkedFragment() {\n        return isValidFragmentId(this.linkedFragmentId);\n    }\n\n    get direction() {\n        if (this.started) {\n            return Direction.Backward;\n        } else {\n            return Direction.Forward;\n        }\n    }\n\n    withUpdatedFragment(fragment) {\n        return new FragmentBoundaryEntry(fragment, this._isFragmentStart, this._fragmentIdComparer);\n    }\n\n    createNeighbourEntry(neighbour) {\n        return new FragmentBoundaryEntry(neighbour, !this._isFragmentStart, this._fragmentIdComparer);\n    }\n\n    addLocalRelation() {}\n    removeLocalRelation() {}\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {EventKey} from \"../EventKey\";\nimport {EventEntry} from \"../entries/EventEntry.js\";\nimport {FragmentBoundaryEntry} from \"../entries/FragmentBoundaryEntry.js\";\nimport {createEventEntry} from \"./common.js\";\nimport {EVENT_TYPE as MEMBER_EVENT_TYPE} from \"../../members/RoomMember.js\";\n\n// Synapse bug? where the m.room.create event appears twice in sync response\n// when first syncing the room\nfunction deduplicateEvents(events) {\n    const eventIds = new Set();\n    return events.filter(e => {\n        if (eventIds.has(e.event_id)) {\n            return false;\n        } else {\n            eventIds.add(e.event_id);\n            return true;\n        }\n    });\n}\n\nexport class SyncWriter {\n    constructor({roomId, fragmentIdComparer, memberWriter, relationWriter}) {\n        this._roomId = roomId;\n        this._memberWriter = memberWriter;\n        this._relationWriter = relationWriter;\n        this._fragmentIdComparer = fragmentIdComparer;\n        this._lastLiveKey = null;\n    }\n\n    async load(txn, log) {\n        const liveFragment = await txn.timelineFragments.liveFragment(this._roomId);\n        if (liveFragment) {\n            const [lastEvent] = await txn.timelineEvents.lastEvents(this._roomId, liveFragment.id, 1);\n            // fall back to the default event index in case the fragment was somehow written but no events\n            // we should only create fragments when really writing timeline events now\n            // (see https://github.com/vector-im/hydrogen-web/issues/112) but can't hurt to be extra robust.\n            const eventIndex = lastEvent ? lastEvent.eventIndex : EventKey.defaultLiveKey.eventIndex;\n            this._lastLiveKey = new EventKey(liveFragment.id, eventIndex);\n        }\n        // if there is no live fragment, we don't create it here because load gets a readonly txn.\n        // this is on purpose, load shouldn't modify the store\n        if (this._lastLiveKey) {\n            log.set(\"live key\", this._lastLiveKey.toString());\n        }\n    }\n\n    async _createLiveFragment(txn, previousToken) {\n        const liveFragment = await txn.timelineFragments.liveFragment(this._roomId);\n        if (!liveFragment) {\n            if (!previousToken) {\n                previousToken = null;\n            }\n            const fragment = {\n                roomId: this._roomId,\n                id: EventKey.defaultLiveKey.fragmentId,\n                previousId: null,\n                nextId: null,\n                previousToken: previousToken,\n                nextToken: null\n            };\n            txn.timelineFragments.add(fragment);\n            this._fragmentIdComparer.add(fragment);\n            return fragment;\n        } else {\n            return liveFragment;\n        }\n    }\n\n    async _replaceLiveFragment(oldFragmentId, newFragmentId, previousToken, txn) {\n        const oldFragment = await txn.timelineFragments.get(this._roomId, oldFragmentId);\n        if (!oldFragment) {\n            throw new Error(`old live fragment doesn't exist: ${oldFragmentId}`);\n        }\n        oldFragment.nextId = newFragmentId;\n        txn.timelineFragments.update(oldFragment);\n        const newFragment = {\n            roomId: this._roomId,\n            id: newFragmentId,\n            previousId: oldFragmentId,\n            nextId: null,\n            previousToken: previousToken,\n            nextToken: null\n        };\n        txn.timelineFragments.add(newFragment);\n        this._fragmentIdComparer.append(newFragmentId, oldFragmentId);\n        return {oldFragment, newFragment};\n    }\n\n    /**\n     * creates a new live fragment if the timeline is limited, or if no live fragment is created yet\n     * @param  {EventKey} currentKey current key so far, might be none if room hasn't synced yet\n     * @param  {Array<BaseEntrie>} entries    array to add fragment boundary entries when creating a new fragment\n     * @param  {Object} timeline   timeline part of the room sync response\n     * @param  {Transaction} txn        used to read and write from the fragment store\n     * @return {EventKey} the new event key to start writing events at\n     */\n    async _ensureLiveFragment(currentKey, entries, timeline, txn, log) {\n        if (!currentKey) {\n            // means we haven't synced this room yet (just joined or did initial sync)\n            \n            // as this is probably a limited sync, prev_batch should be there\n            // (but don't fail if it isn't, we won't be able to back-paginate though)\n            let liveFragment = await this._createLiveFragment(txn, timeline.prev_batch);\n            currentKey = new EventKey(liveFragment.id, EventKey.defaultLiveKey.eventIndex);\n            entries.push(FragmentBoundaryEntry.start(liveFragment, this._fragmentIdComparer));\n            log.log({l: \"live fragment\", first: true, id: currentKey.fragmentId});\n        } else if (timeline.limited) {\n            // replace live fragment for limited sync, *only* if we had a live fragment already\n            const oldFragmentId = currentKey.fragmentId;\n            currentKey = currentKey.nextFragmentKey();\n            const {oldFragment, newFragment} = await this._replaceLiveFragment(oldFragmentId, currentKey.fragmentId, timeline.prev_batch, txn);\n            entries.push(FragmentBoundaryEntry.end(oldFragment, this._fragmentIdComparer));\n            entries.push(FragmentBoundaryEntry.start(newFragment, this._fragmentIdComparer));\n            log.log({l: \"live fragment\", limited: true, id: currentKey.fragmentId});\n        }\n        return currentKey;\n    }\n\n    async _writeStateEvents(stateEvents, txn, log) {\n        let nonMemberStateEvents = 0;\n        for (const event of stateEvents) {\n            // member events are written prior by MemberWriter\n            if (event.type !== MEMBER_EVENT_TYPE) {\n                txn.roomState.set(this._roomId, event);\n                nonMemberStateEvents += 1;\n            }\n        }\n        log.set(\"stateEvents\", nonMemberStateEvents);\n    }\n\n    async _writeTimeline(timelineEvents, timeline, memberSync, currentKey, txn, log) {\n        const entries = [];\n        const updatedEntries = [];\n        if (timelineEvents?.length) {\n            // only create a fragment when we will really write an event\n            currentKey = await this._ensureLiveFragment(currentKey, entries, timeline, txn, log);\n            log.set(\"timelineEvents\", timelineEvents.length);\n            let timelineStateEventCount = 0;\n            for(const event of timelineEvents) {\n                // store event in timeline\n                currentKey = currentKey.nextKey();\n                const storageEntry = createEventEntry(currentKey, this._roomId, event);\n                let member = await memberSync.lookupMemberAtEvent(event.sender, event, txn);\n                if (member) {\n                    storageEntry.displayName = member.displayName;\n                    storageEntry.avatarUrl = member.avatarUrl;\n                }\n                const couldInsert = await txn.timelineEvents.tryInsert(storageEntry, log);\n                if (!couldInsert) {\n                    continue;\n                }\n                const entry = new EventEntry(storageEntry, this._fragmentIdComparer);\n                entries.push(entry);\n                const updatedRelationTargetEntries = await this._relationWriter.writeRelation(entry, txn, log);\n                if (updatedRelationTargetEntries) {\n                    updatedEntries.push(...updatedRelationTargetEntries);\n                }\n                // update state events after writing event, so for a member event,\n                // we only update the member info after having written the member event\n                // to the timeline, as we want that event to have the old profile info.\n                // member events are written prior by MemberWriter.\n                if (typeof event.state_key === \"string\" && event.type !== MEMBER_EVENT_TYPE) {\n                    timelineStateEventCount += 1;\n                    txn.roomState.set(this._roomId, event);\n                }\n            }\n            log.set(\"timelineStateEventCount\", timelineStateEventCount);\n        }\n        return {currentKey, entries, updatedEntries};\n    }\n\n    async _handleRejoinOverlap(timeline, txn, log) {\n        if (this._lastLiveKey) {\n            const {fragmentId} = this._lastLiveKey;\n            const [lastEvent] = await txn.timelineEvents.lastEvents(this._roomId, fragmentId, 1);\n            if (lastEvent) {\n                const lastEventId = lastEvent.event.event_id;\n                const {events} = timeline;\n                const index = events.findIndex(event => event.event_id === lastEventId);\n                if (index !== -1) {\n                    log.set(\"overlap_event_id\", lastEventId);\n                    return Object.assign({}, timeline, {\n                        limited: false,\n                        events: events.slice(index + 1),\n                    });\n                }\n            }\n        }\n        if (!timeline.limited) {\n            log.set(\"force_limited_without_overlap\", true);\n            return Object.assign({}, timeline, {limited: true});\n        }\n        return timeline;\n    }\n\n    /**\n     * @type {SyncWriterResult}\n     * @property {Array<BaseEntry>} entries new timeline entries written\n     * @property {EventKey} newLiveKey the advanced key to write events at\n     * \n     * @param  {Object}  roomResponse [description]\n     * @param  {boolean}  isRejoin whether the room was rejoined in the sync being processed\n     * @param  {Transaction}  txn     \n     * @return {SyncWriterResult}\n     */\n    async writeSync(roomResponse, isRejoin, hasFetchedMembers, txn, log) {\n        let {timeline} = roomResponse;\n        // we have rejoined the room after having synced it before,\n        // check for overlap with the last synced event\n        log.set(\"isRejoin\", isRejoin);\n        if (isRejoin) {\n            timeline = await this._handleRejoinOverlap(timeline, txn, log);\n        }\n        let timelineEvents;\n        if (Array.isArray(timeline?.events)) {\n            timelineEvents = deduplicateEvents(timeline.events);\n        }\n        const {state} = roomResponse;\n        let stateEvents;\n        if (Array.isArray(state?.events)) {\n            stateEvents = state.events;\n        }\n        const memberSync = this._memberWriter.prepareMemberSync(stateEvents, timelineEvents, hasFetchedMembers);\n        if (stateEvents) {\n            await this._writeStateEvents(stateEvents, txn, log);\n        }\n        const {currentKey, entries, updatedEntries} =\n            await this._writeTimeline(timelineEvents, timeline, memberSync, this._lastLiveKey, txn, log);\n        const memberChanges = await memberSync.write(txn);\n        return {entries, updatedEntries, newLiveKey: currentKey, memberChanges};\n    }\n\n    afterSync(newLiveKey) {\n        this._lastLiveKey = newLiveKey;\n    }\n\n    get lastMessageKey() {\n        return this._lastLiveKey;\n    }\n}\n\nimport {createMockStorage} from \"../../../../mocks/Storage\";\nimport {createEvent, withTextBody} from \"../../../../mocks/event.js\";\nimport {Instance as nullLogger} from \"../../../../logging/NullLogger\";\nexport function tests() {\n    const roomId = \"!abc:hs.tld\";\n    return {\n        \"calling timelineEvents.tryInsert with the same event id a second time fails\": async assert => {\n            const storage = await createMockStorage();\n            const txn = await storage.readWriteTxn([storage.storeNames.timelineEvents]);\n            const event = withTextBody(\"hello!\", createEvent(\"m.room.message\", \"$abc\", \"@alice:hs.tld\"));\n            const entry1 = createEventEntry(EventKey.defaultLiveKey, roomId, event);\n            assert.equal(await txn.timelineEvents.tryInsert(entry1, nullLogger.item), true);\n            const entry2 = createEventEntry(EventKey.defaultLiveKey.nextKey(), roomId, event);\n            assert.equal(await txn.timelineEvents.tryInsert(entry2, nullLogger.item), false);\n            // fake-indexeddb still aborts the transaction when preventDefault is called by tryInsert, so don't await as it will abort\n            // await txn.complete();\n        },\n        \"calling timelineEvents.tryInsert with the same event key a second time fails\": async assert => {\n            const storage = await createMockStorage();\n            const txn = await storage.readWriteTxn([storage.storeNames.timelineEvents]);\n            const event1 = withTextBody(\"hello!\", createEvent(\"m.room.message\", \"$abc\", \"@alice:hs.tld\"));\n            const entry1 = createEventEntry(EventKey.defaultLiveKey, roomId, event1);\n            assert.equal(await txn.timelineEvents.tryInsert(entry1, nullLogger.item), true);\n            const event2 = withTextBody(\"hello!\", createEvent(\"m.room.message\", \"$def\", \"@alice:hs.tld\"));\n            const entry2 = createEventEntry(EventKey.defaultLiveKey, roomId, event2);\n            assert.equal(await txn.timelineEvents.tryInsert(entry2, nullLogger.item), false);\n            // fake-indexeddb still aborts the transaction when preventDefault is called by tryInsert, so don't await as it will abort\n            // await txn.complete();\n        },\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\ntype FindCallback<T> = (value: T) => boolean;\n/**\n * Very simple least-recently-used cache implementation\n * that should be fast enough for very small cache sizes\n */\nexport class BaseLRUCache<T> {\n\n    public readonly limit: number;\n    protected _entries: T[];\n\n    constructor(limit: number) {\n        this.limit = limit;\n        this._entries = [];\n    }\n\n    get size() { return this._entries.length; }\n\n    protected _get(findEntryFn: FindCallback<T>) {\n        return this._getByIndexAndMoveUp(this._entries.findIndex(findEntryFn));\n    }\n\n    protected _getByIndexAndMoveUp(idx: number) {\n        if (idx !== -1) {\n            const entry = this._entries[idx];\n            // move to top\n            if (idx > 0) {\n                this._entries.splice(idx, 1);\n                this._entries.unshift(entry);\n            }\n            return entry;\n        }\n    }\n\n    protected _set(value: T, findEntryFn?: FindCallback<T>) {\n        let indexToRemove = findEntryFn ? this._entries.findIndex(findEntryFn) : -1;\n        this._entries.unshift(value);\n        if (indexToRemove === -1) {\n            if (this._entries.length > this.limit) {\n                indexToRemove = this._entries.length - 1;\n            }\n        } else {\n            // we added the entry at the start since we looked for the index\n            indexToRemove += 1;\n        }\n        if (indexToRemove !== -1) {\n            this.onEvictEntry(this._entries[indexToRemove]);\n            this._entries.splice(indexToRemove, 1);\n        }\n    }\n\n    protected onEvictEntry(entry: T) {}\n}\n\nexport class LRUCache<T, K> extends BaseLRUCache<T> {\n    private _keyFn: (T) => K;\n\n    constructor(limit, keyFn: (T) => K) {\n        super(limit);\n        this._keyFn = keyFn;\n    }\n\n    get(key: K): T | undefined {\n        return this._get(e => this._keyFn(e) === key);\n    }\n\n    set(value: T) {\n        const key = this._keyFn(value);\n        this._set(value, e => this._keyFn(e) === key);\n    }\n}\n\nexport function tests() {\n    interface NameTuple {\n        id: number;\n        name: string;\n    }\n\n    return {\n        \"can retrieve added entries\": assert => {\n            const cache = new LRUCache<NameTuple, number>(2, e => e.id);\n            cache.set({id: 1, name: \"Alice\"});\n            cache.set({id: 2, name: \"Bob\"});\n            assert.equal(cache.get(1)!.name, \"Alice\");\n            assert.equal(cache.get(2)!.name, \"Bob\");\n        },\n        \"first entry is evicted first\": assert => {\n            const cache = new LRUCache<NameTuple, number>(2, e => e.id);\n            cache.set({id: 1, name: \"Alice\"});\n            cache.set({id: 2, name: \"Bob\"});\n            cache.set({id: 3, name: \"Charly\"});\n            assert.equal(cache.get(1), undefined);\n            assert.equal(cache.get(2)!.name, \"Bob\");\n            assert.equal(cache.get(3)!.name, \"Charly\");\n            assert.equal(cache.size, 2);\n        },\n        \"second entry is evicted if first is requested\": assert => {\n            const cache = new LRUCache<NameTuple, number>(2, e => e.id);\n            cache.set({id: 1, name: \"Alice\"});\n            cache.set({id: 2, name: \"Bob\"});\n            cache.get(1);\n            cache.set({id: 3, name: \"Charly\"});\n            assert.equal(cache.get(1)!.name, \"Alice\");\n            assert.equal(cache.get(2), undefined);\n            assert.equal(cache.get(3)!.name, \"Charly\");\n            assert.equal(cache.size, 2);\n        },\n        \"setting an entry twice removes the first\": assert => {\n            const cache = new LRUCache<NameTuple, number>(2, e => e.id);\n            cache.set({id: 1, name: \"Alice\"});\n            cache.set({id: 2, name: \"Bob\"});\n            cache.set({id: 1, name: \"Al Ice\"});\n            cache.set({id: 3, name: \"Charly\"});\n            assert.equal(cache.get(1)!.name, \"Al Ice\");\n            assert.equal(cache.get(2), undefined);\n            assert.equal(cache.get(3)!.name, \"Charly\");\n            assert.equal(cache.size, 2);\n        },\n        \"evict callback is called\": assert => {\n            let evictions = 0;\n            class CustomCache extends LRUCache<NameTuple, number> {\n                onEvictEntry(entry) {\n                    assert.equal(entry.name, \"Alice\");\n                    evictions += 1;\n                }\n            }\n            const cache = new CustomCache(2, e => e.id);\n            cache.set({id: 1, name: \"Alice\"});\n            cache.set({id: 2, name: \"Bob\"});\n            cache.set({id: 3, name: \"Charly\"});\n            assert.equal(evictions, 1);\n        },\n        \"evict callback is called when replacing entry with same identity\": assert => {\n            let evictions = 0;\n            class CustomCache extends LRUCache<NameTuple, number> {\n                onEvictEntry(entry) {\n                    assert.equal(entry.name, \"Alice\");\n                    evictions += 1;\n                }\n            }\n            const cache = new CustomCache(2, e => e.id);\n            cache.set({id: 1, name: \"Alice\"});\n            cache.set({id: 1, name: \"Bob\"});\n            assert.equal(evictions, 1);\n        },\n        \n    };\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {MemberChange, RoomMember, EVENT_TYPE as MEMBER_EVENT_TYPE} from \"../../members/RoomMember.js\";\nimport {LRUCache} from \"../../../../utils/LRUCache\";\n\nexport class MemberWriter {\n    constructor(roomId) {\n        this._roomId = roomId;\n        this._cache = new LRUCache(5, member => member.userId);\n    }\n\n    prepareMemberSync(stateEvents, timelineEvents, hasFetchedMembers) {\n        return new MemberSync(this, stateEvents, timelineEvents, hasFetchedMembers);\n    }\n\n    async _writeMember(member, txn) {\n        let existingMember = this._cache.get(member.userId);\n        if (!existingMember) {\n            const memberData = await txn.roomMembers.get(this._roomId, member.userId);\n            if (memberData) {\n                existingMember = new RoomMember(memberData);\n            }\n        }\n        // either never heard of the member, or something changed\n        if (!existingMember || !existingMember.equals(member)) {\n            txn.roomMembers.set(member.serialize());\n            this._cache.set(member);\n            return new MemberChange(member, existingMember?.membership);\n        }\n    }\n\n    async lookupMember(userId, txn) {\n        let member = this._cache.get(userId);\n        if (!member) {\n            const memberData = await txn.roomMembers.get(this._roomId, userId);\n            if (memberData) {\n                member = new RoomMember(memberData);\n                this._cache.set(member);\n            }\n        }\n        return member;\n    }\n}\n\nclass MemberSync {\n    constructor(memberWriter, stateEvents, timelineEvents, hasFetchedMembers) {\n        this._memberWriter = memberWriter;\n        this._timelineEvents = timelineEvents;\n        this._hasFetchedMembers = hasFetchedMembers;\n        this._newStateMembers = null;\n        if (stateEvents) {\n            this._newStateMembers = this._stateEventsToMembers(stateEvents);\n        }\n    }\n\n    get _roomId() {\n        return this._memberWriter._roomId;\n    }\n\n    _stateEventsToMembers(stateEvents) {\n        let members;\n        for (const event of stateEvents) {\n            if (event.type === MEMBER_EVENT_TYPE) {\n                const member = RoomMember.fromMemberEvent(this._roomId, event);\n                if (member) {\n                    if (!members) {\n                        members = new Map();\n                    }\n                    members.set(member.userId, member);\n                }\n            }\n        }\n        return members;\n    }\n\n    _timelineEventsToMembers(timelineEvents) {\n        let members;\n        // iterate backwards to only add the last member in the timeline\n        for (let i = timelineEvents.length - 1; i >= 0; i--) {\n            const e = timelineEvents[i];\n            const userId = e.state_key;\n            if (e.type === MEMBER_EVENT_TYPE && !members?.has(userId)) {\n                const member = RoomMember.fromMemberEvent(this._roomId, e);\n                if (member) {\n                    if (!members) {\n                        members = new Map();\n                    }\n                    members.set(member.userId, member);\n                }\n            }\n        }\n        return members;\n    }\n\n    async lookupMemberAtEvent(userId, event, txn) {\n        let member;\n        if (this._timelineEvents) {\n            member = this._findPrecedingMemberEventInTimeline(userId, event);\n            if (member) {\n                return member;\n            }\n        }\n        member = this._newStateMembers?.get(userId);\n        if (member) {\n            return member;\n        }\n        return await this._memberWriter.lookupMember(userId, txn);\n    }\n\n    async write(txn) {\n        const memberChanges = new Map();\n        let newTimelineMembers;\n        if (this._timelineEvents) {\n            newTimelineMembers = this._timelineEventsToMembers(this._timelineEvents);\n        }\n        if (this._newStateMembers) {\n            for (const member of this._newStateMembers.values()) {\n                if (!newTimelineMembers?.has(member.userId)) {\n                    const memberChange = await this._memberWriter._writeMember(member, txn);\n                    if (memberChange) {\n                        // if the member event appeared only in the state section,\n                        // AND we haven't heard about it AND we haven't fetched all members yet (to avoid #470),\n                        // this may be a lazy loading member (if it's not in a gap, we are certain\n                        // it is a ll member, in a gap, we can't tell), so we pass in our own membership as\n                        // as the previous one so we won't consider it a join to not have false positives (to avoid #192).\n                        // see also MemberChange.hasJoined\n                        const maybeLazyLoadingMember = !this._hasFetchedMembers && !memberChange.previousMembership;\n                        if (maybeLazyLoadingMember) {\n                            memberChange.previousMembership = member.membership;\n                        }\n                        memberChanges.set(memberChange.userId, memberChange);\n                    }\n                }\n            }\n        }\n        if (newTimelineMembers) {\n            for (const member of newTimelineMembers.values()) {\n                const memberChange = await this._memberWriter._writeMember(member, txn);\n                if (memberChange) {\n                    memberChanges.set(memberChange.userId, memberChange);\n                }\n            }\n        }\n        return memberChanges;\n    }\n\n    // try to find the first member event before the given event,\n    // so we respect historical display names within the chunk of timeline\n    _findPrecedingMemberEventInTimeline(userId, event) {\n        let eventIndex = -1;\n        for (let i = this._timelineEvents.length - 1; i >= 0; i--) {\n            const e = this._timelineEvents[i];\n            if (e.event_id === event.event_id) {\n                eventIndex = i;\n                break;\n            }\n        }\n        for (let i = eventIndex - 1; i >= 0; i--) {\n            const e = this._timelineEvents[i];\n            if (e.type === MEMBER_EVENT_TYPE && e.state_key === userId) {\n                const member = RoomMember.fromMemberEvent(this._roomId, e);\n                if (member) {\n                    return member;\n                }\n            }\n        }\n    }\n}\n\nexport function tests() {\n\n    let idCounter = 0;\n\n    function createMemberEvent(membership, userId, displayName, avatarUrl) {\n        idCounter += 1;\n        return {\n            content: {\n                membership,\n                \"displayname\": displayName,\n                \"avatar_url\": avatarUrl\n            },\n            event_id: `$${idCounter}`,\n            sender: userId,\n            \"state_key\": userId,\n            type: \"m.room.member\"\n        };\n    }\n\n    function createStorage(initialMembers = []) {\n        const members = new Map();\n        for (const m of initialMembers) {\n            members.set(m.userId, m);\n        }\n        return {\n            members,\n            roomMembers: {\n                async get(_, userId) {\n                    return members.get(userId);\n                },\n                set(member) {\n                    members.set(member.userId, member);\n                }\n            }\n        }\n    }\n\n    function member(...args) {\n        return RoomMember.fromMemberEvent(roomId, createMemberEvent.apply(null, args));\n    }\n\n    const roomId = \"abc\";\n    const alice = \"@alice:hs.tld\";\n    const avatar = \"mxc://hs.tld/def\";\n\n    return {\n        \"new join\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage();\n            const memberSync = writer.prepareMemberSync([], [createMemberEvent(\"join\", alice)], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert(change.hasJoined);\n            assert.equal(txn.members.get(alice).membership, \"join\");\n        },\n        \"accept invite\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage([member(\"invite\", alice)]);\n            const memberSync = writer.prepareMemberSync([], [createMemberEvent(\"join\", alice)], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert.equal(change.previousMembership, \"invite\");\n            assert(change.hasJoined);\n            assert.equal(txn.members.get(alice).membership, \"join\");\n        },\n        \"change display name\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage([member(\"join\", alice, \"Alice\")]);\n            const memberSync = writer.prepareMemberSync([], [createMemberEvent(\"join\", alice, \"Alies\")], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert(!change.hasJoined);\n            assert.equal(change.member.displayName, \"Alies\");\n            assert.equal(txn.members.get(alice).displayName, \"Alies\");\n        },\n        \"set avatar\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage([member(\"join\", alice, \"Alice\")]);\n            const memberSync = writer.prepareMemberSync([], [createMemberEvent(\"join\", alice, \"Alice\", avatar)], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert(!change.hasJoined);\n            assert.equal(change.member.avatarUrl, avatar);\n            assert.equal(txn.members.get(alice).avatarUrl, avatar);\n        },\n        \"ignore redundant member event in timeline\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage([member(\"join\", alice, \"Alice\", avatar)]);\n            const memberSync = writer.prepareMemberSync([], [createMemberEvent(\"join\", alice, \"Alice\", avatar)], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 0);\n        },\n        \"ignore redundant member event in state\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage([member(\"join\", alice, \"Alice\", avatar)]);\n            const memberSync = writer.prepareMemberSync([createMemberEvent(\"join\", alice, \"Alice\", avatar)], [], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 0);\n        },\n        \"leave\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage([member(\"join\", alice, \"Alice\")]);\n            const memberSync = writer.prepareMemberSync([], [createMemberEvent(\"leave\", alice, \"Alice\")], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert(change.hasLeft);\n            assert(!change.hasJoined);\n        },\n        \"ban\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage([member(\"join\", alice, \"Alice\")]);\n            const memberSync = writer.prepareMemberSync([], [createMemberEvent(\"ban\", alice, \"Alice\")], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert(change.hasLeft);\n            assert(!change.hasJoined);\n        },\n        \"reject invite\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage([member(\"invite\", alice, \"Alice\")]);\n            const memberSync = writer.prepareMemberSync([], [createMemberEvent(\"leave\", alice, \"Alice\")], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert(!change.hasLeft);\n            assert(!change.hasJoined);\n        },\n        \"lazy loaded member we already know about doens't return change\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage([member(\"join\", alice, \"Alice\")]);\n            const memberSync = writer.prepareMemberSync([createMemberEvent(\"join\", alice, \"Alice\")], [], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 0);\n        },\n        \"lazy loaded member we already know about changes display name\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage([member(\"join\", alice, \"Alice\")]);\n            const memberSync = writer.prepareMemberSync([createMemberEvent(\"join\", alice, \"Alies\")], [], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert(!change.hasJoined);\n            assert.equal(change.member.displayName, \"Alies\");\n        },\n        \"unknown lazy loaded member returns change, but not considered a join\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage();\n            const memberSync = writer.prepareMemberSync([createMemberEvent(\"join\", alice, \"Alice\")], [], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert(!change.hasJoined);\n            assert(!change.hasLeft);\n            assert.equal(change.member.membership, \"join\");\n            assert.equal(txn.members.get(alice).displayName, \"Alice\");\n        },\n        \"new join through both timeline and state\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage();\n            const aliceJoin = createMemberEvent(\"join\", alice, \"Alice\");\n            const memberSync = writer.prepareMemberSync([aliceJoin], [aliceJoin], false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert(change.hasJoined);\n            assert(!change.hasLeft);\n        },\n        \"change display name in timeline with lazy loaded member in state\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage();\n            const memberSync = writer.prepareMemberSync(\n                [createMemberEvent(\"join\", alice, \"Alice\")],\n                [createMemberEvent(\"join\", alice, \"Alies\")],\n                false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert(change.hasJoined);\n            assert(!change.hasLeft);\n            assert.equal(change.member.displayName, \"Alies\");\n        },\n        \"lookupMemberAtEvent returns closest member in the past\": async assert => {\n            const event1 = createMemberEvent(\"join\", alice, \"Alice\");\n            const event2 = createMemberEvent(\"join\", alice, \"Alies\");\n            const event3 = createMemberEvent(\"join\", alice, \"Alys\");\n            const events = [event1, event2, event3];\n            // we write first because the MemberWriter assumes it is called before\n            // the SyncWriter does any lookups\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage();\n            const memberSync = await writer.prepareMemberSync([], events, false);\n            let member = await memberSync.lookupMemberAtEvent(event1.sender, event1, txn);\n            assert.equal(member, undefined);\n            member = await memberSync.lookupMemberAtEvent(event2.sender, event2, txn);\n            assert.equal(member.displayName, \"Alice\");\n            member = await memberSync.lookupMemberAtEvent(event3.sender, event3, txn);\n            assert.equal(member.displayName, \"Alies\");\n\n            assert.equal(txn.members.size, 0);\n            const changes = await memberSync.write(txn);\n            assert.equal(txn.members.size, 1);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert(change.hasJoined);\n        },\n        \"lookupMemberAtEvent falls back on state event\": async assert => {\n            const event1 = createMemberEvent(\"join\", alice, \"Alice\");\n            const event2 = createMemberEvent(\"join\", alice, \"Alies\");\n            // we write first because the MemberWriter assumes it is called before\n            // the SyncWriter does any lookups\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage();\n            const memberSync = await writer.prepareMemberSync([event1], [event2], false);\n            const member = await memberSync.lookupMemberAtEvent(event2.sender, event2, txn);\n            assert.equal(member.displayName, \"Alice\");\n\n            assert.equal(txn.members.size, 0);\n            const changes = await memberSync.write(txn);\n            assert.equal(txn.members.size, 1);\n            assert.equal(changes.size, 1);\n            const change = changes.get(alice);\n            assert(change.hasJoined);\n        },\n        \"write works without event arrays\": async assert => {\n            const writer = new MemberWriter(roomId);\n            const txn = createStorage();\n            const memberSync = await writer.prepareMemberSync(undefined, undefined, false);\n            const changes = await memberSync.write(txn);\n            assert.equal(changes.size, 0);\n        },\n    };\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {EventKey} from \"../EventKey\";\nimport {EventEntry} from \"../entries/EventEntry.js\";\nimport {createEventEntry, directionalAppend} from \"./common.js\";\nimport {RoomMember, EVENT_TYPE as MEMBER_EVENT_TYPE} from \"../../members/RoomMember.js\";\n\nexport class GapWriter {\n    constructor({roomId, storage, fragmentIdComparer, relationWriter}) {\n        this._roomId = roomId;\n        this._storage = storage;\n        this._fragmentIdComparer = fragmentIdComparer;\n        this._relationWriter = relationWriter;\n    }\n\n    async _findOverlappingEvents(fragmentEntry, events, txn, log) {\n        const eventIds = events.map(e => e.event_id);\n        const existingEventKeyMap = await txn.timelineEvents.getEventKeysForIds(this._roomId, eventIds);\n        log.set(\"existingEvents\", existingEventKeyMap.size);\n        const nonOverlappingEvents = events.filter(e => !existingEventKeyMap.has(e.event_id));\n        log.set(\"nonOverlappingEvents\", nonOverlappingEvents.length);\n        let neighbourFragmentEntry;\n        if (fragmentEntry.hasLinkedFragment) {\n            log.set(\"linkedFragmentId\", fragmentEntry.linkedFragmentId);\n            for (const eventKey of existingEventKeyMap.values()) {\n                if (eventKey.fragmentId === fragmentEntry.linkedFragmentId) {\n                    log.set(\"foundLinkedFragment\", true);\n                    const neighbourFragment = await txn.timelineFragments.get(this._roomId, fragmentEntry.linkedFragmentId);\n                    neighbourFragmentEntry = fragmentEntry.createNeighbourEntry(neighbourFragment);\n                    break;\n                }\n            }\n        }\n        return {nonOverlappingEvents, neighbourFragmentEntry};\n    }\n\n    async _findFragmentEdgeEventKey(fragmentEntry, txn) {\n        const {fragmentId, direction} = fragmentEntry;\n        const event = await this._findFragmentEdgeEvent(fragmentId, direction, txn);\n        if (event) {\n            return new EventKey(event.fragmentId, event.eventIndex);\n        } else {\n            // no events yet in the fragment ... odd, but let's not fail and take the default key\n            return EventKey.defaultFragmentKey(fragmentEntry.fragmentId);\n        }\n    }\n\n    async _findFragmentEdgeEvent(fragmentId, direction, txn) {\n        if (direction.isBackward) {\n            const [firstEvent] = await txn.timelineEvents.firstEvents(this._roomId, fragmentId, 1);\n            return firstEvent;\n        } else {\n            const [lastEvent] = await txn.timelineEvents.lastEvents(this._roomId, fragmentId, 1);\n            return lastEvent;\n        }\n    }\n\n    async _storeEvents(events, startKey, direction, state, txn, log) {\n        const entries = [];\n        const updatedEntries = [];\n        // events is in reverse chronological order for backwards pagination,\n        // e.g. order is moving away from the `from` point.\n        let key = startKey;\n        for (let i = 0; i < events.length; ++i) {\n            const event = events[i];\n            key = key.nextKeyForDirection(direction);\n            const eventStorageEntry = createEventEntry(key, this._roomId, event);\n            const member = this._findMember(event.sender, state, events, i, direction);\n            if (member) {\n                eventStorageEntry.displayName = member.displayName;\n                eventStorageEntry.avatarUrl = member.avatarUrl;\n            }\n            // this will modify eventStorageEntry if it is a relation target\n            const updatedRelationTargetEntries = await this._relationWriter.writeGapRelation(eventStorageEntry, direction, txn, log);\n            if (updatedRelationTargetEntries) {\n                updatedEntries.push(...updatedRelationTargetEntries);\n            }\n            if (await txn.timelineEvents.tryInsert(eventStorageEntry, log)) {\n                const eventEntry = new EventEntry(eventStorageEntry, this._fragmentIdComparer);\n                directionalAppend(entries, eventEntry, direction);\n            }\n        }\n        return {entries, updatedEntries};\n    }\n\n    _findMember(userId, state, events, index, direction) {\n        function isOurUser(event) {\n            return event.type === MEMBER_EVENT_TYPE && event.state_key === userId;\n        }\n        // older messages are at a higher index in the array when going backwards\n        const inc = direction.isBackward ? 1 : -1;\n        for (let i = index + inc; i >= 0 && i < events.length; i += inc) {\n            const event = events[i];\n            if (isOurUser(event)) {\n                return RoomMember.fromMemberEvent(this._roomId, event);\n            }\n        }\n        // look into newer events, but using prev_content if found.\n        // We do this before looking into `state` because it is not well specified\n        // in the spec whether the events in there represent state before or after `chunk`.\n        // So we look both directions first in chunk to make sure it doesn't matter.\n        for (let i = index; i >= 0 && i < events.length; i -= inc) {\n            const event = events[i];\n            if (isOurUser(event)) {\n                return RoomMember.fromReplacingMemberEvent(this._roomId, event);\n            }\n        }\n        // assuming the member hasn't changed within the chunk, just take it from state if it's there.\n        // Don't assume state is set though, as it can be empty at the top of the timeline in some circumstances \n        const stateMemberEvent = state?.find(isOurUser);\n        if (stateMemberEvent) {\n            return RoomMember.fromMemberEvent(this._roomId, stateMemberEvent);\n        }\n    }\n\n    async _updateFragments(fragmentEntry, neighbourFragmentEntry, end, entries, txn, log) {\n        const {direction} = fragmentEntry;\n        const changedFragments = [];\n        directionalAppend(entries, fragmentEntry, direction);\n        // set `end` as token, and if we found an event in the step before, link up the fragments in the fragment entry\n        if (neighbourFragmentEntry) {\n            // if neighbourFragmentEntry was found, it means the events were overlapping,\n            // so no pagination should happen anymore.\n            log.set(\"closedGapWith\", neighbourFragmentEntry.fragmentId);\n            neighbourFragmentEntry.token = null;\n            fragmentEntry.token = null;\n\n            txn.timelineFragments.update(neighbourFragmentEntry.fragment);\n            directionalAppend(entries, neighbourFragmentEntry, direction);\n\n            // fragments that need to be changed in the fragmentIdComparer here\n            // after txn succeeds\n            changedFragments.push(fragmentEntry.fragment);\n            changedFragments.push(neighbourFragmentEntry.fragment);\n        } else {\n            fragmentEntry.token = end;\n        }\n        txn.timelineFragments.update(fragmentEntry.fragment);\n\n        return changedFragments;\n    }\n\n    async writeFragmentFill(fragmentEntry, response, txn, log) {\n        const {fragmentId, direction} = fragmentEntry;\n        // chunk is in reverse-chronological order when backwards\n        const {chunk, start, state} = response;\n        let {end} = response;\n\n        if (!Array.isArray(chunk)) {\n            throw new Error(\"Invalid chunk in response\");\n        }\n        if (typeof end !== \"string\") {\n            throw new Error(\"Invalid end token in response\");\n        }\n\n        // make sure we have the latest fragment from the store\n        const fragment = await txn.timelineFragments.get(this._roomId, fragmentId);\n        if (!fragment) {\n            throw new Error(`Unknown fragment: ${fragmentId}`);\n        }\n        fragmentEntry = fragmentEntry.withUpdatedFragment(fragment);\n        // check that the request was done with the token we are aware of (extra care to avoid timeline corruption)\n        if (fragmentEntry.token !== start) {\n            throw new Error(\"start is not equal to prev_batch or next_batch\");\n        }\n\n        // begin (or end) of timeline reached\n        if (chunk.length === 0) {\n            fragmentEntry.edgeReached = true;\n            await txn.timelineFragments.update(fragmentEntry.fragment);\n            return {entries: [fragmentEntry], updatedEntries: [], fragments: []};\n        }\n\n        // find last event in fragment so we get the eventIndex to begin creating keys at\n        let lastKey = await this._findFragmentEdgeEventKey(fragmentEntry, txn);\n        log.set(\"lastKey\", lastKey.toString());\n        // find out if any event in chunk is already present using findFirstOrLastOccurringEventId\n        const {\n            nonOverlappingEvents,\n            neighbourFragmentEntry\n        } = await this._findOverlappingEvents(fragmentEntry, chunk, txn, log);\n        // create entries for all events in chunk, add them to entries\n        const {entries, updatedEntries} = await this._storeEvents(nonOverlappingEvents, lastKey, direction, state, txn, log);\n        const fragments = await this._updateFragments(fragmentEntry, neighbourFragmentEntry, end, entries, txn, log);\n    \n        return {entries, updatedEntries, fragments};\n    }\n}\n\nimport {FragmentIdComparer} from \"../FragmentIdComparer.js\";\nimport {RelationWriter} from \"./RelationWriter.js\";\nimport {createMockStorage} from \"../../../../mocks/Storage\";\nimport {FragmentBoundaryEntry} from \"../entries/FragmentBoundaryEntry.js\";\nimport {NullLogItem} from \"../../../../logging/NullLogger\";\nimport {TimelineMock, eventIds, eventId} from \"../../../../mocks/TimelineMock.ts\";\nimport {SyncWriter} from \"./SyncWriter.js\";\nimport {MemberWriter} from \"./MemberWriter.js\";\nimport {KeyLimits} from \"../../../storage/common\";\n\nexport function tests() {\n    const roomId = \"!room:hs.tdl\";\n    const alice = \"alice@hs.tdl\";\n    const logger = new NullLogItem();\n\n    async function createGapFillTxn(storage) {\n        return storage.readWriteTxn([\n            storage.storeNames.roomMembers,\n            storage.storeNames.pendingEvents,\n            storage.storeNames.timelineEvents,\n            storage.storeNames.timelineRelations,\n            storage.storeNames.timelineFragments,\n        ]);\n    }\n\n    async function setup() {\n        const storage = await createMockStorage();\n        const txn = await createGapFillTxn(storage);\n        const fragmentIdComparer = new FragmentIdComparer([]);\n        const relationWriter = new RelationWriter({\n            roomId, fragmentIdComparer, ownUserId: alice,\n        });\n        const gapWriter = new GapWriter({\n            roomId, storage, fragmentIdComparer, relationWriter\n        });\n        const memberWriter = new MemberWriter(roomId);\n        const syncWriter = new SyncWriter({\n            roomId,\n            fragmentIdComparer,\n            memberWriter,\n            relationWriter\n        });\n        return { storage, txn, fragmentIdComparer, gapWriter, syncWriter, timelineMock: new TimelineMock() };\n    }\n\n    async function syncAndWrite(mocks, { previous, limit } = {}) {\n        const {txn, timelineMock, syncWriter, fragmentIdComparer} = mocks;\n        const syncResponse = timelineMock.sync(previous?.next_batch, limit);\n        const {newLiveKey} = await syncWriter.writeSync(syncResponse, false, false, txn, logger);\n        syncWriter.afterSync(newLiveKey);\n        return {\n            syncResponse,\n            fragmentEntry: newLiveKey ? FragmentBoundaryEntry.start(\n                await txn.timelineFragments.get(roomId, newLiveKey.fragmentId),\n                fragmentIdComparer,\n            ) : null,\n        };\n    }\n\n    async function backfillAndWrite(mocks, fragmentEntry, limit) {\n        const {txn, timelineMock, gapWriter} = mocks;\n        const messageResponse = timelineMock.messages(fragmentEntry.token, undefined, fragmentEntry.direction.asApiString(), limit);\n        await gapWriter.writeFragmentFill(fragmentEntry, messageResponse, txn, logger);\n    }\n\n    async function allFragmentEvents(mocks, fragmentId) {\n        const {txn} = mocks;\n        const entries = await txn.timelineEvents.eventsAfter(roomId, new EventKey(fragmentId, KeyLimits.minStorageKey));\n        return entries.map(e => e.event);\n    }\n\n    async function fetchFragment(mocks, fragmentId) {\n        const {txn} = mocks;\n        return txn.timelineFragments.get(roomId, fragmentId);\n    }\n\n    function assertFilledLink(assert, fragment1, fragment2) {\n        assert.equal(fragment1.nextId, fragment2.id);\n        assert.equal(fragment2.previousId, fragment1.id);\n        assert.equal(fragment1.nextToken, null);\n        assert.equal(fragment2.previousToken, null);\n    }\n\n    function assertGapLink(assert, fragment1, fragment2) {\n        assert.equal(fragment1.nextId, fragment2.id);\n        assert.equal(fragment2.previousId, fragment1.id);\n        assert.notEqual(fragment2.previousToken, null);\n    }\n\n    return {\n        \"Backfilling after one sync\": async assert => {\n            const mocks = await setup();\n            const { timelineMock } = mocks;\n            timelineMock.append(30);\n            const {fragmentEntry} = await syncAndWrite(mocks);\n            await backfillAndWrite(mocks, fragmentEntry, 10);\n            const events = await allFragmentEvents(mocks, fragmentEntry.fragmentId);\n            assert.deepEqual(events.map(e => e.event_id), eventIds(10, 30));\n            await mocks.txn.complete();\n        },\n        \"Backfilling a fragment that is expected to close a gap, and does\": async assert => {\n            const mocks = await setup();\n            const { timelineMock } = mocks;\n            timelineMock.append(10);\n            const {syncResponse, fragmentEntry: firstFragmentEntry} = await syncAndWrite(mocks, { limit: 10 });\n            timelineMock.append(15);\n            const {fragmentEntry: secondFragmentEntry} = await syncAndWrite(mocks, { previous: syncResponse, limit: 10 });\n            await backfillAndWrite(mocks, secondFragmentEntry, 10);\n\n            const firstFragment = await fetchFragment(mocks, firstFragmentEntry.fragmentId);\n            const secondFragment = await fetchFragment(mocks, secondFragmentEntry.fragmentId);\n            assertFilledLink(assert, firstFragment, secondFragment)\n            const firstEvents = await allFragmentEvents(mocks, firstFragmentEntry.fragmentId);\n            assert.deepEqual(firstEvents.map(e => e.event_id), eventIds(0, 10));\n            const secondEvents = await allFragmentEvents(mocks, secondFragmentEntry.fragmentId);\n            assert.deepEqual(secondEvents.map(e => e.event_id), eventIds(10, 25));\n            await mocks.txn.complete();\n        },\n        \"Backfilling a fragment that is expected to close a gap, but doesn't yet\": async assert => {\n            const mocks = await setup();\n            const { timelineMock } = mocks;\n            timelineMock.append(10);\n            const {syncResponse, fragmentEntry: firstFragmentEntry} = await syncAndWrite(mocks, { limit: 10 });\n            timelineMock.append(20);\n            const {fragmentEntry: secondFragmentEntry} = await syncAndWrite(mocks, { previous: syncResponse, limit: 10 });\n            await backfillAndWrite(mocks, secondFragmentEntry, 10);\n\n            const firstFragment = await fetchFragment(mocks, firstFragmentEntry.fragmentId);\n            const secondFragment = await fetchFragment(mocks, secondFragmentEntry.fragmentId);\n            assertGapLink(assert, firstFragment, secondFragment)\n            const firstEvents = await allFragmentEvents(mocks, firstFragmentEntry.fragmentId);\n            assert.deepEqual(firstEvents.map(e => e.event_id), eventIds(0, 10));\n            const secondEvents = await allFragmentEvents(mocks, secondFragmentEntry.fragmentId);\n            assert.deepEqual(secondEvents.map(e => e.event_id), eventIds(10, 30));\n            await mocks.txn.complete();\n        },\n        \"Receiving a sync with the same events as the current fragment does not create infinite link\": async assert => {\n            const mocks = await setup();\n            const { txn, timelineMock } = mocks;\n            timelineMock.append(10);\n            const {syncResponse, fragmentEntry: fragmentEntry} = await syncAndWrite(mocks, { limit: 10 });\n            // Mess with the saved token to receive old events in backfill\n            fragmentEntry.token = syncResponse.next_batch;\n            txn.timelineFragments.update(fragmentEntry.fragment);\n            await backfillAndWrite(mocks, fragmentEntry, 10);\n\n            const fragment = await fetchFragment(mocks, fragmentEntry.fragmentId);\n            assert.notEqual(fragment.nextId, fragment.id);\n            assert.notEqual(fragment.previousId, fragment.id);\n            await mocks.txn.complete();\n        },\n        \"An event received by sync does not interrupt backfilling\": async assert => {\n            const mocks = await setup();\n            const { timelineMock } = mocks;\n            timelineMock.append(10);\n            const {syncResponse, fragmentEntry: firstFragmentEntry} = await syncAndWrite(mocks, { limit: 10 });\n            timelineMock.append(11);\n            const {fragmentEntry: secondFragmentEntry} = await syncAndWrite(mocks, { previous: syncResponse, limit: 10 });\n            timelineMock.insertAfter(eventId(9), 5);\n            await backfillAndWrite(mocks, secondFragmentEntry, 10);\n\n            const firstEvents = await allFragmentEvents(mocks, firstFragmentEntry.fragmentId);\n            assert.deepEqual(firstEvents.map(e => e.event_id), eventIds(0, 10));\n            const secondEvents = await allFragmentEvents(mocks, secondFragmentEntry.fragmentId);\n            assert.deepEqual(secondEvents.map(e => e.event_id), [...eventIds(21,26), ...eventIds(10, 21)]);\n            const firstFragment = await fetchFragment(mocks, firstFragmentEntry.fragmentId);\n            const secondFragment = await fetchFragment(mocks, secondFragmentEntry.fragmentId);\n            assertFilledLink(assert, firstFragment, secondFragment)\n            await mocks.txn.complete();\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservable} from \"../BaseObservable\";\n\nexport interface IListObserver<T> {\n    onReset(list: BaseObservableList<T>): void;\n    onAdd(index: number, value:T, list: BaseObservableList<T>): void;\n    onUpdate(index: number, value: T, params: any, list: BaseObservableList<T>): void;\n    onRemove(index: number, value: T, list: BaseObservableList<T>): void\n    onMove(from: number, to: number, value: T, list: BaseObservableList<T>): void\n}\n\nexport function defaultObserverWith<T>(overrides: { [key in keyof IListObserver<T>]?: IListObserver<T>[key] }): IListObserver<T> {\n    const defaults = {\n        onReset(){},\n        onAdd(){},\n        onUpdate(){},\n        onRemove(){},\n        onMove(){},\n    }\n    return Object.assign(defaults, overrides);\n}\n\nexport abstract class BaseObservableList<T> extends BaseObservable<IListObserver<T>> implements Iterable<T> {\n    emitReset() {\n        for(let h of this._handlers) {\n            h.onReset(this);\n        }\n    }\n    // we need batch events, mostly on index based collection though?\n    // maybe we should get started without?\n    emitAdd(index: number, value: T): void {\n        for(let h of this._handlers) {\n            h.onAdd(index, value, this);\n        }\n    }\n\n    emitUpdate(index: number, value: T, params?: any): void {\n        for(let h of this._handlers) {\n            h.onUpdate(index, value, params, this);\n        }\n    }\n\n    emitRemove(index: number, value: T): void {\n        for(let h of this._handlers) {\n            h.onRemove(index, value, this);\n        }\n    }\n\n    // toIdx assumes the item has already\n    // been removed from its fromIdx\n    emitMove(fromIdx: number, toIdx: number, value: T): void {\n        for(let h of this._handlers) {\n            h.onMove(fromIdx, toIdx, value, this);\n        }\n    }\n\n    abstract [Symbol.iterator](): Iterator<T>;\n    abstract get length(): number;\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * @license\n * Based off baseSortedIndex function in Lodash <https://lodash.com/>\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\nexport function sortedIndex<T>(array: T[], value: T, comparator: (x:T, y:T) => number): number {\n    let low = 0;\n    let high = array.length;\n\n    while (low < high) {\n        let mid = (low + high) >>> 1;\n        let cmpResult = comparator(value, array[mid]);\n\n        if (cmpResult > 0) {\n            low = mid + 1;\n        } else if (cmpResult < 0) {\n            high = mid;\n        } else {\n            low = high = mid;\n        }\n    }\n    return high;\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservable} from \"../BaseObservable\";\n\nexport class BaseObservableMap extends BaseObservable {\n    emitReset() {\n        for(let h of this._handlers) {\n            h.onReset();\n        }\n    }\n    // we need batch events, mostly on index based collection though?\n    // maybe we should get started without?\n    emitAdd(key, value) {\n        for(let h of this._handlers) {\n            h.onAdd(key, value);\n        }\n    }\n\n    emitUpdate(key, value, ...params) {\n        for(let h of this._handlers) {\n            h.onUpdate(key, value, ...params);\n        }\n    }\n\n    emitRemove(key, value) {\n        for(let h of this._handlers) {\n            h.onRemove(key, value);\n        }\n    }\n\n    [Symbol.iterator]() {\n        throw new Error(\"unimplemented\");\n    }\n\n    get size() {\n        throw new Error(\"unimplemented\");\n    }\n\n    // eslint-disable-next-line no-unused-vars\n    get(key) {\n        throw new Error(\"unimplemented\");\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableMap} from \"./BaseObservableMap.js\";\n\nexport class ObservableMap extends BaseObservableMap {\n    constructor(initialValues) {\n        super();\n        this._values = new Map(initialValues);\n    }\n\n    update(key, params) {\n        const value = this._values.get(key);\n        if (value !== undefined) {\n            // could be the same value, so it's already updated\n            // but we don't assume this here\n            this._values.set(key, value);\n            this.emitUpdate(key, value, params);\n            return true;\n        }\n        return false;   // or return existing value?\n    }\n\n    add(key, value) {\n        if (!this._values.has(key)) {\n            this._values.set(key, value);\n            this.emitAdd(key, value);\n            return true;\n        }\n        return false;   // or return existing value?\n    }\n\n    remove(key) {\n        const value = this._values.get(key);\n        if (value !== undefined) {\n            this._values.delete(key);\n            this.emitRemove(key, value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    set(key, value) {\n        if (this._values.has(key)) {\n            // We set the value here because update only supports inline updates\n            this._values.set(key, value);\n            return this.update(key);\n        }    \n        else {\n            return this.add(key, value);\n        }\n    }\n\n    reset() {\n        this._values.clear();\n        this.emitReset();\n    }\n\n    get(key) {\n        return this._values.get(key);\n    }\n\n    get size() {\n        return this._values.size;\n    }\n\n    [Symbol.iterator]() {\n        return this._values.entries();\n    }\n\n    values() {\n        return this._values.values();\n    }\n\n    keys() {\n        return this._values.keys();\n    }\n}\n\nexport function tests() {\n    return {\n        test_initial_values(assert) {\n            const map = new ObservableMap([\n                [\"a\", 5],\n                [\"b\", 10]\n            ]);\n            assert.equal(map.size, 2);\n            assert.equal(map.get(\"a\"), 5);\n            assert.equal(map.get(\"b\"), 10);\n        },\n\n        test_add(assert) {\n            let fired = 0;\n            const map = new ObservableMap();\n            map.subscribe({\n                onAdd(key, value) {\n                    fired += 1;\n                    assert.equal(key, 1);\n                    assert.deepEqual(value, {value: 5}); \n                }\n            });\n            map.add(1, {value: 5});\n            assert.equal(map.size, 1);\n            assert.equal(fired, 1);\n        },\n\n        test_update(assert) {\n            let fired = 0;\n            const map = new ObservableMap();\n            const value = {number: 5};\n            map.add(1, value);\n            map.subscribe({\n                onUpdate(key, value, params) {\n                    fired += 1;\n                    assert.equal(key, 1);\n                    assert.deepEqual(value, {number: 6}); \n                    assert.equal(params, \"test\");\n                }\n            });\n            value.number = 6;\n            map.update(1, \"test\");\n            assert.equal(fired, 1);\n        },\n\n        test_update_unknown(assert) {\n            let fired = 0;\n            const map = new ObservableMap();\n            map.subscribe({\n                onUpdate() { fired += 1; }\n            });\n            const result = map.update(1);\n            assert.equal(fired, 0);\n            assert.equal(result, false);\n        },\n\n        test_set(assert) {\n            let add_fired = 0, update_fired = 0;\n            const map = new ObservableMap();\n            map.subscribe({\n                onAdd(key, value) {\n                    add_fired += 1;\n                    assert.equal(key, 1);\n                    assert.deepEqual(value, {value: 5}); \n                },\n                onUpdate(key, value/*, params*/) {\n                    update_fired += 1;\n                    assert.equal(key, 1);\n                    assert.deepEqual(value, {value: 7}); \n                }\n            });\n            // Add\n            map.set(1, {value: 5});\n            assert.equal(map.size, 1);\n            assert.equal(add_fired, 1);\n            // Update\n            map.set(1, {value: 7});\n            assert.equal(map.size, 1);\n            assert.equal(update_fired, 1);\n        },\n\n        test_remove(assert) {\n            let fired = 0;\n            const map = new ObservableMap();\n            const value = {value: 5};\n            map.add(1, value);\n            map.subscribe({\n                onRemove(key, value) {\n                    fired += 1;\n                    assert.equal(key, 1);\n                    assert.deepEqual(value, {value: 5}); \n                }\n            });\n            map.remove(1);\n            assert.equal(map.size, 0);\n            assert.equal(fired, 1);\n        },\n\n        test_iterate(assert) {\n            const results = [];\n            const map = new ObservableMap();\n            map.add(1, {number: 5});\n            map.add(2, {number: 6});\n            map.add(3, {number: 7});\n            for (let e of map) {\n                results.push(e);\n            }\n            assert.equal(results.length, 3);\n            assert.equal(results.find(([key]) => key === 1)[1].number, 5);\n            assert.equal(results.find(([key]) => key === 2)[1].number, 6);\n            assert.equal(results.find(([key]) => key === 3)[1].number, 7);\n        },\n        test_size(assert) {\n            const map = new ObservableMap();\n            map.add(1, {number: 5});\n            map.add(2, {number: 6});\n            assert.equal(map.size, 2);\n        },\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableList} from \"./BaseObservableList\";\nimport {sortedIndex} from \"../../utils/sortedIndex\";\n\n/*\n\nwhen a value changes, it sorting order can change. It would still be at the old index prior to firing an onUpdate event.\nSo how do you know where it was before it changed, if not by going over all values?\n\nhow to make this fast?\n\nseems hard to solve with an array, because you need to map the key to it's previous location somehow, to efficiently find it,\nand move it.\n\nI wonder if we could do better with a binary search tree (BST).\nThe tree has a value with {key, value}. There is a plain Map mapping keys to this tuple,\nfor easy lookup. Now how do we find the index of this tuple in the BST?\n\neither we store in every node the amount of nodes on the left and right, or we decend into the part\nof the tree preceding the node we want to know about. Updating the counts upwards would probably be fine as this is log2 of\nthe size of the container.\n\nto be able to go from a key to an index, the value would have the have a link with the tree node though\n\nso key -> Map<key,value> -> value -> node -> *parentNode -> rootNode\nwith a node containing {value, leftCount, rightCount, leftNode, rightNode, parentNode}\n*/\n\n// does not assume whether or not the values are reference\n// types modified outside of the collection (and affecting sort order) or not\n\n// no duplicates allowed for now\nexport class SortedMapList extends BaseObservableList {\n    constructor(sourceMap, comparator) {\n        super();\n        this._sourceMap = sourceMap;\n        this._comparator = (a, b) => comparator(a.value, b.value);\n        this._sortedPairs = null;\n        this._mapSubscription = null;\n    }\n    \n    onAdd(key, value) {\n        const pair = {key, value};\n        const idx = sortedIndex(this._sortedPairs, pair, this._comparator);\n        this._sortedPairs.splice(idx, 0, pair);\n        this.emitAdd(idx, value);\n    }\n\n    onRemove(key, value) {\n        const pair = {key, value};\n        const idx = sortedIndex(this._sortedPairs, pair, this._comparator);\n        // assert key === this._sortedPairs[idx].key;\n        this._sortedPairs.splice(idx, 1);\n        this.emitRemove(idx, value);\n    }\n\n    onUpdate(key, value, params) {\n        // if an update is emitted while calling source.subscribe() from onSubscribeFirst, ignore it\n        if (!this._sortedPairs) {\n            return;\n        }\n        // TODO: suboptimal for performance, see above for idea with BST to speed this up if we need to\n        const oldIdx = this._sortedPairs.findIndex(p => p.key === key);\n        // neccesary to remove pair from array before\n        // doing sortedIndex as it relies on being sorted\n        this._sortedPairs.splice(oldIdx, 1);\n        const pair = {key, value};\n        const newIdx = sortedIndex(this._sortedPairs, pair, this._comparator);\n        this._sortedPairs.splice(newIdx, 0, pair);\n        if (oldIdx !== newIdx) {\n            this.emitMove(oldIdx, newIdx, value);\n        }\n        this.emitUpdate(newIdx, value, params);\n    }\n\n    onReset() {\n        this._sortedPairs = [];\n        this.emitReset();\n    }\n\n    onSubscribeFirst() {\n        this._mapSubscription = this._sourceMap.subscribe(this);\n        this._sortedPairs = new Array(this._sourceMap.size);\n        let i = 0;\n        for (let [key, value] of this._sourceMap) {\n            this._sortedPairs[i] = {key, value};\n            ++i;\n        }\n        this._sortedPairs.sort(this._comparator);\n        super.onSubscribeFirst();\n    }\n\n    onUnsubscribeLast() {\n        super.onUnsubscribeLast();\n        this._sortedPairs = null;\n        this._mapSubscription = this._mapSubscription();\n    }\n\n    get(index) {\n        return this._sortedPairs[index].value;\n    }\n\n    get length() {\n        return this._sourceMap.size;\n    }\n\n    [Symbol.iterator]() {\n        const it = this._sortedPairs.values();\n        return {\n            next() {\n                const v = it.next();\n                if (v.value) {\n                    v.value = v.value.value;\n                }\n                return v;\n            }\n        }\n    }\n}\n\nimport {ObservableMap} from \"../map/ObservableMap.js\";\n\nexport function tests() {\n    return {\n        test_sortIndex(assert) {\n            const a = [1, 5, 6, 8];\n            const cmp = (a, b) => a - b;\n            let idx = sortedIndex(a, 0, cmp);\n            assert.equal(idx, 0);\n            idx = sortedIndex(a, 3, cmp);\n            assert.equal(idx, 1);\n            idx = sortedIndex(a, 5, cmp);\n            assert.equal(idx, 1);\n            idx = sortedIndex(a, 8, cmp);\n            assert.equal(idx, 3);\n        },\n\n        test_sortIndex_reverse(assert) {\n            let idx = sortedIndex([8, 6, 5, 1], 6, (a, b) => b - a);\n            assert.equal(idx, 1);\n        },\n\n        test_sortIndex_comparator_Array_compatible(assert) {\n            const a = [5, 1, 8, 2];\n            const cmp = (a, b) => a - b;\n            a.sort(cmp);\n            assert.deepEqual(a, [1, 2, 5, 8]);\n            let idx = sortedIndex(a, 2, cmp);\n            assert.equal(idx, 1);\n        },\n\n        test_initial_values(assert) {\n            const map = new ObservableMap([\n                [\"a\", 50],\n                [\"b\", 6],\n                [\"c\", -5],\n            ]);\n            const list = new SortedMapList(map, (a, b) => a - b);\n            list.subscribe({}); //needed to populate iterator\n            assert.deepEqual(Array.from(list), [-5, 6, 50]);\n            assert.equal(list.length, 3);\n        },\n\n        test_add(assert) {\n            const map = new ObservableMap([[\"a\", 50], [\"b\", 6], [\"c\", -5]]);\n            const list = new SortedMapList(map, (a, b) => a - b);\n            let fired = 0;\n            list.subscribe({\n                onAdd(idx, value) {\n                    fired++;\n                    assert.equal(idx, 2);\n                    assert.equal(value, 20);\n                }\n            });\n            map.add(\"d\", 20);\n            assert.equal(fired, 1);\n            assert.equal(list.length, 4);\n        },\n\n        test_remove(assert) {\n            const map = new ObservableMap([[\"a\", 50], [\"b\", 6], [\"c\", -5]]);\n            const list = new SortedMapList(map, (a, b) => a - b);\n            let fired = 0;\n            list.subscribe({\n                onRemove(idx, value) {\n                    fired++;\n                    assert.equal(idx, 2);\n                    assert.equal(value, 50);\n                }\n            });\n            map.remove(\"a\");\n            assert.equal(fired, 1);\n            assert.equal(list.length, 2);\n        },\n\n        test_move_reference(assert) {\n            const a = {number: 3};\n            const map = new ObservableMap([\n                [\"a\", a],\n                [\"b\", {number: 11}],\n                [\"c\", {number: 1}],\n            ]);\n            const list = new SortedMapList(map, (a, b) => a.number - b.number);\n            let updateFired = 0, moveFired = 0;\n            list.subscribe({\n                onUpdate(idx, value, param) {\n                    updateFired++;\n                    assert.equal(idx, 2);\n                    assert.equal(value, a);\n                    assert.equal(param, \"number\");\n                },\n\n                onMove(oldIdx, newIdx, value) {\n                    moveFired++;\n                    assert.equal(oldIdx, 1);\n                    assert.equal(newIdx, 2);\n                    assert.equal(value, a);\n                }\n            });\n            a.number = 111;\n            map.update(\"a\", \"number\");\n            assert.equal(moveFired, 1);\n            assert.equal(updateFired, 1);\n        },\n\n        test_update_without_move(assert) {\n            const a = {number: 3};\n            const map = new ObservableMap([\n                [\"a\", a],\n                [\"b\", {number: 11}],\n                [\"c\", {number: 1}],\n            ]);\n            const list = new SortedMapList(map, (a, b) => a.number - b.number);\n            let updateFired = 0, moveFired = 0;\n            list.subscribe({\n                onUpdate(idx, value, param) {\n                    updateFired++;\n                    assert.equal(idx, 1);\n                    assert.equal(value, a);\n                    assert.equal(param, \"number\");\n                },\n\n                onMove() {\n                    moveFired++;\n                }\n            });\n            assert.deepEqual(Array.from(list).map(v => v.number), [1, 3, 11]);\n            // asume some part of a that doesn't affect\n            // sorting order has changed here\n            map.update(\"a\", \"number\");\n            assert.equal(moveFired, 0);\n            assert.equal(updateFired, 1);\n            assert.deepEqual(Array.from(list).map(v => v.number), [1, 3, 11]);\n        },\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableMap} from \"./BaseObservableMap.js\";\n\nexport class FilteredMap extends BaseObservableMap {\n    constructor(source, filter) {\n        super();\n        this._source = source;\n        this._filter = filter;\n        /** @type {Map<string, bool>} */\n        this._included = null;\n        this._subscription = null;\n    }\n\n    setFilter(filter) {\n        this._filter = filter;\n        if (this._subscription) {\n            this._reapplyFilter();\n        }\n    }\n\n    /**\n     * reapply the filter\n     */\n    _reapplyFilter(silent = false) {\n        if (this._filter) {\n            const oldIncluded = this._included;\n            this._included = this._included || new Map();\n            for (const [key, value] of this._source) {\n                const isIncluded = this._filter(value, key);\n                this._included.set(key, isIncluded);\n                if (!silent) {\n                    const wasIncluded = oldIncluded ? oldIncluded.get(key) : true;\n                    this._emitForUpdate(wasIncluded, isIncluded, key, value);\n                }\n            }\n        } else { // no filter\n            // did we have a filter before?\n            if (this._included && !silent) {\n                // add any non-included items again\n                for (const [key, value] of this._source) {\n                    if (!this._included.get(key)) {\n                        this.emitAdd(key, value);\n                    }\n                }\n            }\n            this._included = null;\n        }\n    }\n\n    onAdd(key, value) {\n        if (this._filter) {\n            const included = this._filter(value, key);\n            this._included.set(key, included);\n            if (!included) {\n                return;\n            }\n        }\n        this.emitAdd(key, value);\n    }\n\n    onRemove(key, value) {\n        const wasIncluded = !this._filter || this._included.get(key);\n        this._included.delete(key);\n        if (wasIncluded) {\n            this.emitRemove(key, value);\n        }\n    }\n\n    onUpdate(key, value, params) {\n        // if an update is emitted while calling source.subscribe() from onSubscribeFirst, ignore it\n        if (!this._included) {\n            return;\n        }\n        if (this._filter) {\n            const wasIncluded = this._included.get(key);\n            const isIncluded = this._filter(value, key);\n            this._included.set(key, isIncluded);\n            this._emitForUpdate(wasIncluded, isIncluded, key, value, params);\n        } else {\n            this.emitUpdate(key, value, params);\n        }\n    }\n\n    _emitForUpdate(wasIncluded, isIncluded, key, value, params = null) {\n        if (wasIncluded && !isIncluded) {\n            this.emitRemove(key, value);\n        } else if (!wasIncluded && isIncluded) {\n            this.emitAdd(key, value);\n        } else if (wasIncluded && isIncluded) {\n            this.emitUpdate(key, value, params);\n        }\n    }\n\n    onSubscribeFirst() {\n        this._subscription = this._source.subscribe(this);\n        this._reapplyFilter(true);\n        super.onSubscribeFirst();\n    }\n\n    onUnsubscribeLast() {\n        super.onUnsubscribeLast();\n        this._included = null;\n        this._subscription = this._subscription();\n    }\n\n    onReset() {\n        this._reapplyFilter();\n        this.emitReset();\n    }\n\n    [Symbol.iterator]() {\n        return new FilterIterator(this._source, this._included);\n    }\n\n    get size() {\n        let count = 0;\n        this._included.forEach(included => {\n            if (included) {\n                count += 1;\n            }\n        });\n        return count;\n    }\n\n    get(key) {\n        const value = this._source.get(key);\n        if (value && this._filter(value, key)) {\n            return value;\n        }\n    }\n}\n\nclass FilterIterator {\n    constructor(map, _included) {\n        this._included = _included;\n        this._sourceIterator = map[Symbol.iterator]();\n    }\n\n    next() {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const sourceResult = this._sourceIterator.next();\n            if (sourceResult.done) {\n                return sourceResult;\n            }\n            const key = sourceResult.value[0];\n            if (this._included.get(key)) {\n                return sourceResult;\n            }\n        }\n    }\n}\n\nimport {ObservableMap} from \"./ObservableMap.js\";\nexport function tests() {\n    return {\n        \"filter preloaded list\": assert => {\n            const source = new ObservableMap();\n            source.add(\"one\", 1);\n            source.add(\"two\", 2);\n            source.add(\"three\", 3);\n            const oddNumbers = new FilteredMap(source, x => x % 2 !== 0);\n            // can only iterate after subscribing\n            oddNumbers.subscribe({});\n            assert.equal(oddNumbers.size, 2);\n            const it = oddNumbers[Symbol.iterator]();\n            assert.deepEqual(it.next().value, [\"one\", 1]);\n            assert.deepEqual(it.next().value, [\"three\", 3]);\n            assert.equal(it.next().done, true);\n        },\n        // \"filter added values\": assert => {\n\n        // },\n        // \"filter removed values\": assert => {\n\n        // },\n        // \"filter changed values\": assert => {\n\n        // },\n\n        \"emits must trigger once\": assert => {\n            const source = new ObservableMap();\n            let count_add = 0, count_update = 0, count_remove = 0;\n            source.add(\"num1\", 1);\n            source.add(\"num2\", 2);\n            source.add(\"num3\", 3);\n            const oddMap = new FilteredMap(source, x => x % 2 !== 0);\n            oddMap.subscribe({\n                onAdd() {\n                    count_add += 1;\n                },\n                onRemove() {\n                    count_remove += 1;\n                },\n                onUpdate() {\n                    count_update += 1;\n                }\n            });\n            source.set(\"num3\", 4);\n            source.set(\"num3\", 5);\n            source.set(\"num3\", 7);\n            assert.strictEqual(count_add, 1);\n            assert.strictEqual(count_update, 1);\n            assert.strictEqual(count_remove, 1);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableMap} from \"./BaseObservableMap.js\";\n/*\nso a mapped value can emit updates on it's own with this._emitSpontaneousUpdate that is passed in the mapping function\nhow should the mapped value be notified of an update though? and can it then decide to not propagate the update?\n*/\nexport class MappedMap extends BaseObservableMap {\n    constructor(source, mapper, updater) {\n        super();\n        this._source = source;\n        this._mapper = mapper;\n        this._updater = updater;\n        this._mappedValues = new Map();\n    }\n\n    _emitSpontaneousUpdate(key, params) {\n        const value = this._mappedValues.get(key);\n        if (value) {\n            this.emitUpdate(key, value, params);\n        }\n    }\n\n    onAdd(key, value) {\n        const emitSpontaneousUpdate = this._emitSpontaneousUpdate.bind(this, key);\n        const mappedValue = this._mapper(value, emitSpontaneousUpdate);\n        this._mappedValues.set(key, mappedValue);\n        this.emitAdd(key, mappedValue);\n    }\n\n    onRemove(key/*, _value*/) {\n        const mappedValue = this._mappedValues.get(key);\n        if (this._mappedValues.delete(key)) {\n            this.emitRemove(key, mappedValue);\n        }\n    }\n\n    onUpdate(key, value, params) {\n        // if an update is emitted while calling source.subscribe() from onSubscribeFirst, ignore it\n        if (!this._mappedValues) {\n            return;\n        }\n        const mappedValue = this._mappedValues.get(key);\n        if (mappedValue !== undefined) {\n            this._updater?.(mappedValue, params, value);\n            // TODO: map params somehow if needed?\n            this.emitUpdate(key, mappedValue, params);\n        }\n    }\n\n    onSubscribeFirst() {\n        this._subscription = this._source.subscribe(this);\n        for (let [key, value] of this._source) {\n            const emitSpontaneousUpdate = this._emitSpontaneousUpdate.bind(this, key);\n            const mappedValue = this._mapper(value, emitSpontaneousUpdate);\n            this._mappedValues.set(key, mappedValue);\n        }\n        super.onSubscribeFirst();\n    }\n\n    onUnsubscribeLast() {\n        super.onUnsubscribeLast();\n        this._subscription = this._subscription();\n        this._mappedValues.clear();\n    }\n\n    onReset() {\n        this._mappedValues.clear();\n        this.emitReset();\n    }\n\n    [Symbol.iterator]() {\n        return this._mappedValues.entries();\n    }\n\n    get size() {\n        return this._mappedValues.size;\n    }\n\n    get(key) {\n        return this._mappedValues.get(key);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableMap} from \"./BaseObservableMap.js\";\n\nexport class JoinedMap extends BaseObservableMap {\n    constructor(sources) {\n        super();\n        this._sources = sources;\n        this._subscriptions = null;\n    }\n\n    onAdd(source, key, value) {\n        if (!this._isKeyAtSourceOccluded(source, key)) {\n            const occludingValue = this._getValueFromOccludedSources(source, key);\n            if (occludingValue !== undefined) {\n                // adding a value that will occlude another one should\n                // first emit a remove\n                this.emitRemove(key, occludingValue);\n            }\n            this.emitAdd(key, value);\n        }\n    }\n\n    onRemove(source, key, value) {\n        if (!this._isKeyAtSourceOccluded(source, key)) {\n            this.emitRemove(key, value);\n            const occludedValue = this._getValueFromOccludedSources(source, key);\n            if (occludedValue !== undefined) {\n                // removing a value that so far occluded another one should\n                // emit an add for the occluded value after the removal\n                this.emitAdd(key, occludedValue);\n            }\n        }\n    }\n\n    onUpdate(source, key, value, params) {\n        // if an update is emitted while calling source.subscribe() from onSubscribeFirst, ignore it\n        if (!this._subscriptions) {\n            return;\n        }\n        if (!this._isKeyAtSourceOccluded(source, key)) {\n            this.emitUpdate(key, value, params);\n        }\n    }\n\n    onReset() {\n        this.emitReset();\n    }\n\n    onSubscribeFirst() {\n        this._subscriptions = this._sources.map(source => new SourceSubscriptionHandler(source, this).subscribe());\n        super.onSubscribeFirst();\n    }\n\n    _isKeyAtSourceOccluded(source, key) {\n        // sources that come first in the sources array can\n        // hide the keys in later sources, to prevent events\n        // being emitted for the same key and different values,\n        // so check the key is not present in earlier sources\n        const index = this._sources.indexOf(source);\n        for (let i = 0; i < index; i += 1) {\n            if (this._sources[i].get(key) !== undefined) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // get the value that the given source and key occlude, if any\n    _getValueFromOccludedSources(source, key) {\n        // sources that come first in the sources array can\n        // hide the keys in later sources, to prevent events\n        // being emitted for the same key and different values,\n        // so check the key is not present in earlier sources\n        const index = this._sources.indexOf(source);\n        for (let i = index + 1; i < this._sources.length; i += 1) {\n            const source = this._sources[i];\n            const occludedValue = source.get(key);\n            if (occludedValue !== undefined) {\n                return occludedValue;\n            }\n        }\n        return undefined;\n    }\n\n    onUnsubscribeLast() {\n        super.onUnsubscribeLast();\n        for (const s of this._subscriptions) {\n            s.dispose();\n        }\n    }\n\n    [Symbol.iterator]() {\n        return new JoinedIterator(this._sources);\n    }\n\n    get size() {\n        return this._sources.reduce((sum, s) => sum + s.size, 0);\n    }\n\n    get(key) {\n        for (const s of this._sources) {\n            const value = s.get(key);\n            if (value) {\n                return value;\n            }\n        }\n        return null;\n    }\n}\n\nclass JoinedIterator {\n    constructor(sources) {\n        this._sources = sources;\n        this._sourceIndex = -1;\n        this._currentIterator = null;\n        this._encounteredKeys = new Set();\n    }\n\n    next() {\n        let result;\n        while (!result) {\n            if (!this._currentIterator) {\n                this._sourceIndex += 1;\n                if (this._sources.length <= this._sourceIndex) {\n                    return {done: true};\n                }\n                this._currentIterator = this._sources[this._sourceIndex][Symbol.iterator]();\n            }\n            const sourceResult = this._currentIterator.next();\n            if (sourceResult.done) {\n                this._currentIterator = null;\n                continue;\n            } else {\n                const key = sourceResult.value[0];\n                if (!this._encounteredKeys.has(key)) {\n                    this._encounteredKeys.add(key);\n                    result = sourceResult;\n                }\n            }\n        }\n        return result;\n    }\n}\n\nclass SourceSubscriptionHandler {\n    constructor(source, joinedMap) {\n        this._source = source;\n        this._joinedMap = joinedMap;\n        this._subscription = null;\n    }\n\n    subscribe() {\n        this._subscription = this._source.subscribe(this);\n        return this;\n    }\n\n    dispose() {\n        this._subscription = this._subscription();\n    }\n\n    onAdd(key, value) {\n        this._joinedMap.onAdd(this._source, key, value);\n    }\n\n    onRemove(key, value) {\n        this._joinedMap.onRemove(this._source, key, value);\n    }\n\n    onUpdate(key, value, params) {\n        this._joinedMap.onUpdate(this._source, key, value, params);\n    }\n\n    onReset() {\n        this._joinedMap.onReset(this._source);\n    }\n}\n\n\nimport { ObservableMap } from \"./ObservableMap.js\";\n\nexport function tests() {\n\n    function observeMap(map) {\n        const events = [];\n        map.subscribe({\n            onAdd(key, value) { events.push({type: \"add\", key, value}); },\n            onRemove(key, value) { events.push({type: \"remove\", key, value}); },\n            onUpdate(key, value, params) { events.push({type: \"update\", key, value, params}); }\n        });\n        return events;\n    }\n\n    return {\n        \"joined iterator\": assert => {\n            const firstKV = [\"a\", 1];\n            const secondKV = [\"b\", 2];\n            const thirdKV = [\"c\", 3];\n            const it = new JoinedIterator([[firstKV, secondKV], [thirdKV]]);\n            assert.equal(it.next().value, firstKV);\n            assert.equal(it.next().value, secondKV);\n            assert.equal(it.next().value, thirdKV);\n            assert.equal(it.next().done, true);\n        },\n        \"prevent key collision during iteration\": assert => {\n            const first = new ObservableMap();\n            const second = new ObservableMap();\n            const join = new JoinedMap([first, second]);\n            second.add(\"a\", 2);\n            second.add(\"b\", 3);\n            first.add(\"a\", 1);\n            const it = join[Symbol.iterator]();\n            assert.deepEqual(it.next().value, [\"a\", 1]);\n            assert.deepEqual(it.next().value, [\"b\", 3]);\n            assert.equal(it.next().done, true);\n        },\n        \"adding occluded key doesn't emit add\": assert => {\n            const first = new ObservableMap();\n            const second = new ObservableMap();\n            const join = new JoinedMap([first, second]);\n            const events = observeMap(join);\n            first.add(\"a\", 1);\n            second.add(\"a\", 2);\n            assert.equal(events.length, 1);\n            assert.equal(events[0].type, \"add\");\n            assert.equal(events[0].key, \"a\");\n            assert.equal(events[0].value, 1);\n        },\n        \"updating occluded key doesn't emit update\": assert => {\n            const first = new ObservableMap();\n            const second = new ObservableMap();\n            const join = new JoinedMap([first, second]);\n            first.add(\"a\", 1);\n            second.add(\"a\", 2);\n            const events = observeMap(join);\n            second.update(\"a\", 3);\n            assert.equal(events.length, 0);\n        },\n        \"removal of occluding key emits add after remove\": assert => {\n            const first = new ObservableMap();\n            const second = new ObservableMap();\n            const join = new JoinedMap([first, second]);\n            first.add(\"a\", 1);\n            second.add(\"a\", 2);\n            const events = observeMap(join);\n            first.remove(\"a\");\n            assert.equal(events.length, 2);\n            assert.equal(events[0].type, \"remove\");\n            assert.equal(events[0].key, \"a\");\n            assert.equal(events[0].value, 1);\n            assert.equal(events[1].type, \"add\");\n            assert.equal(events[1].key, \"a\");\n            assert.equal(events[1].value, 2);\n        },\n        \"adding occluding key emits remove first\": assert => {\n            const first = new ObservableMap();\n            const second = new ObservableMap();\n            const join = new JoinedMap([first, second]);\n            second.add(\"a\", 2);\n            const events = observeMap(join);\n            first.add(\"a\", 1);\n            assert.equal(events.length, 2);\n            assert.equal(events[0].type, \"remove\");\n            assert.equal(events[0].key, \"a\");\n            assert.equal(events[0].value, 2);\n            assert.equal(events[1].type, \"add\");\n            assert.equal(events[1].key, \"a\");\n            assert.equal(events[1].value, 1);\n        }\n    };\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableList} from \"./BaseObservableList\";\n\nexport class ObservableArray<T> extends BaseObservableList<T> {\n    private _items: T[];\n\n    constructor(initialValues: T[] = []) {\n        super();\n        this._items = initialValues;\n    }\n\n    append(item: T): void {\n        this._items.push(item);\n        this.emitAdd(this._items.length - 1, item);\n    }\n\n    remove(idx: number): void {\n        const [item] = this._items.splice(idx, 1);\n        this.emitRemove(idx, item);\n    }\n\n    insertMany(idx: number, items: T[]): void {\n        for(let item of items) {\n            this.insert(idx, item);\n            idx += 1;\n        }\n    }\n\n    insert(idx: number, item: T): void {\n        this._items.splice(idx, 0, item);\n        this.emitAdd(idx, item);\n    }\n\n    move(fromIdx: number, toIdx: number): void {\n        if (fromIdx < this._items.length && toIdx < this._items.length) {\n            const [item] = this._items.splice(fromIdx, 1);\n            this._items.splice(toIdx, 0, item);\n            this.emitMove(fromIdx, toIdx, item);\n        }\n    }\n\n    update(idx: number, item: T, params: any = null): void {\n        if (idx < this._items.length) {\n            this._items[idx] = item;\n            this.emitUpdate(idx, item, params);\n        }\n    }\n\n    get array(): Readonly<T[]> {\n        return this._items;\n    }\n\n    at(idx: number): T | undefined {\n        if (this._items && idx >= 0 && idx < this._items.length) {\n            return this._items[idx];\n        }\n    }\n\n    get length(): number {\n        return this._items.length;\n    }\n\n    [Symbol.iterator]() {\n        return this._items.values();\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {BaseObservableList} from \"./BaseObservableList\";\n\n/* inline update of item in collection backed by array, without replacing the preexising item */\nexport function findAndUpdateInArray<T>(predicate: (value: T) => boolean, array: T[], observable: BaseObservableList<T>, updater: (value: T) => any | false) {\n    const index = array.findIndex(predicate);\n    if (index !== -1) {\n        const value = array[index];\n        // allow bailing out of sending an emit if updater determined its not needed\n        const params = updater(value);\n        if (params !== false) {\n            observable.emitUpdate(index, value, params);\n        }\n        // found\n        return true;\n    }\n    return false;\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableList} from \"./BaseObservableList\";\nimport {sortedIndex} from \"../../utils/sortedIndex\";\nimport {findAndUpdateInArray} from \"./common\";\n\nexport class SortedArray<T> extends BaseObservableList<T> {\n    private _comparator: (left: T, right: T) => number;\n    private _items: T[] = [];\n\n    constructor(comparator: (left: T, right: T) => number) {\n        super();\n        this._comparator = comparator;\n    }\n\n    setManyUnsorted(items: T[]): void {\n        this.setManySorted(items);\n    }\n\n    setManySorted(items: T[]): void {\n        // TODO: we can make this way faster by only looking up the first and last key,\n        // and merging whatever is inbetween with items\n        // if items is not sorted, 💩🌀 will follow!\n        // should we check?\n        // Also, once bulk events are supported in collections,\n        // we can do a bulk add event here probably if there are no updates\n        // BAD CODE!\n        for(let item of items) {\n            this.set(item);\n        }\n    }\n\n    findAndUpdate(predicate: (value: T) => boolean, updater: (value: T) => any | false): boolean {\n        return findAndUpdateInArray(predicate, this._items, this, updater);\n    }\n\n    getAndUpdate(item: T, updater: (existing: T, item: T) => any, updateParams: any = null): void {\n        const idx = this.indexOf(item);\n        if (idx !== -1) {\n            const existingItem = this._items[idx];\n            const newItem = updater(existingItem, item);\n            this._items[idx] = newItem;\n            this.emitUpdate(idx, newItem, updateParams);\n        }\n    }\n\n    update(item: T, updateParams: any = null): void {\n        const idx = this.indexOf(item);\n        if (idx !== -1) {\n            this._items[idx] = item;\n            this.emitUpdate(idx, item, updateParams);\n        }\n    }\n\n    indexOf(item: T): number {\n        const idx = sortedIndex(this._items, item, this._comparator);\n        if (idx < this._items.length && this._comparator(this._items[idx], item) === 0) {\n            return idx;\n        } else {\n            return -1;\n        }\n    }\n\n    _getNext(item: T): T | undefined {\n        let idx = sortedIndex(this._items, item, this._comparator);\n        while(idx < this._items.length && this._comparator(this._items[idx], item) <= 0) {\n            idx += 1;\n        }\n        return this.get(idx);\n    }\n\n    set(item: T, updateParams: any = null): void {\n        const idx = sortedIndex(this._items, item, this._comparator);\n        if (idx >= this._items.length || this._comparator(this._items[idx], item) !== 0) {\n            this._items.splice(idx, 0, item);\n            this.emitAdd(idx, item)\n        } else {\n            this._items[idx] = item;\n            this.emitUpdate(idx, item, updateParams);\n        }\n    }\n\n    get(idx: number): T | undefined {\n        return this._items[idx];\n    }\n\n    remove(idx: number): void {\n        const item = this._items[idx];\n        this._items.splice(idx, 1);\n        this.emitRemove(idx, item);\n    }\n\n    get array(): T[] {\n        return this._items;\n    }\n\n    get length(): number {\n        return this._items.length;\n    }\n\n    [Symbol.iterator]() {\n        return new Iterator(this);\n    }\n}\n\n// iterator that works even if the current value is removed while iterating\nclass Iterator<T> {\n    private _sortedArray: SortedArray<T> | null\n    private _current: T | null | undefined\n\n    constructor(sortedArray: SortedArray<T>) {\n        this._sortedArray = sortedArray;\n        this._current = null;\n    }\n\n    next() {\n        if (this._sortedArray) {\n            if (this._current) {\n                this._current = this._sortedArray._getNext(this._current);\n            } else {\n                this._current = this._sortedArray.get(0);\n            }\n            if (this._current) {\n                return {value: this._current};\n            } else {\n                // cause done below\n                this._sortedArray = null;\n            }\n        }\n        if (!this._sortedArray) {\n            return {done: true};\n        }\n    }\n}\n\nexport function tests() {\n    return {\n        \"setManyUnsorted\": assert => {\n            const sa = new SortedArray<string>((a, b) => a.localeCompare(b));\n            sa.setManyUnsorted([\"b\", \"a\", \"c\"]);\n            assert.equal(sa.length, 3);\n            assert.equal(sa.get(0), \"a\");\n            assert.equal(sa.get(1), \"b\");\n            assert.equal(sa.get(2), \"c\");\n        }, \n        \"_getNext\": assert => {\n            const sa = new SortedArray<string>((a, b) => a.localeCompare(b));\n            sa.setManyUnsorted([\"b\", \"a\", \"f\"]);\n            assert.equal(sa._getNext(\"a\"), \"b\");\n            assert.equal(sa._getNext(\"b\"), \"f\");\n            // also finds the next if the value is not in the collection\n            assert.equal(sa._getNext(\"c\"), \"f\");\n            assert.equal(sa._getNext(\"f\"), undefined);\n        },\n        \"iterator with removals\": assert => {\n            const queue = new SortedArray<{idx: number}>((a, b) => a.idx - b.idx);\n            queue.setManyUnsorted([{idx: 5}, {idx: 3}, {idx: 1}, {idx: 4}, {idx: 2}]);\n            const it = queue[Symbol.iterator]();\n            assert.equal(it.next().value.idx, 1);\n            assert.equal(it.next().value.idx, 2);\n            queue.remove(1);\n            assert.equal(it.next().value.idx, 3);\n            queue.remove(1);\n            assert.equal(it.next().value.idx, 4);\n            queue.remove(1);\n            assert.equal(it.next().value.idx, 5);\n            queue.remove(1);\n            assert.equal(it.next().done, true);\n            // check done persists\n            assert.equal(it.next().done, true);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableList} from \"./BaseObservableList\";\nimport {findAndUpdateInArray} from \"./common\";\n\nexport type Mapper<F,T> = (value: F) => T\nexport type Updater<F,T> = (mappedValue: T, params: any, value: F) => void;\n\nexport class BaseMappedList<F,T,R = T> extends BaseObservableList<T> {\n    protected _sourceList: BaseObservableList<F>;\n    protected _sourceUnsubscribe: (() => void) | null = null;\n    _mapper: Mapper<F,R>;\n    _updater?: Updater<F,T>;\n    _removeCallback?: (value: T) => void;\n    _mappedValues: T[] | null = null;\n\n    constructor(sourceList: BaseObservableList<F>, mapper: Mapper<F,R>, updater?: Updater<F,T>, removeCallback?: (value: T) => void) {\n        super();\n        this._sourceList = sourceList;\n        this._mapper = mapper;\n        this._updater = updater;\n        this._removeCallback = removeCallback;\n    }\n\n    findAndUpdate(predicate: (value: T) => boolean, updater: (value: T) => any | false) {\n        return findAndUpdateInArray(predicate, this._mappedValues!, this, updater);\n    }\n\n    get length() {\n        return this._mappedValues!.length;\n    }\n\n    [Symbol.iterator]() {\n        return this._mappedValues!.values();\n    }\n}\n\nexport function runAdd<F,T,R>(list: BaseMappedList<F,T,R>, index: number, mappedValue: T): void {\n    list._mappedValues!.splice(index, 0, mappedValue);\n    list.emitAdd(index, mappedValue);\n}\n\nexport function runUpdate<F,T,R>(list: BaseMappedList<F,T,R>, index: number, value: F, params: any): void {\n    const mappedValue = list._mappedValues![index];\n    if (list._updater) {\n        list._updater(mappedValue, params, value);\n    }\n    list.emitUpdate(index, mappedValue, params);\n}\n\nexport function runRemove<F,T,R>(list: BaseMappedList<F,T,R>, index: number): void {\n    const mappedValue = list._mappedValues![index];\n    list._mappedValues!.splice(index, 1);\n    if (list._removeCallback) {\n        list._removeCallback(mappedValue);\n    }\n    list.emitRemove(index, mappedValue);\n}\n\nexport function runMove<F,T,R>(list: BaseMappedList<F,T,R>, fromIdx: number, toIdx: number): void {\n    const mappedValue = list._mappedValues![fromIdx];\n    list._mappedValues!.splice(fromIdx, 1);\n    list._mappedValues!.splice(toIdx, 0, mappedValue);\n    list.emitMove(fromIdx, toIdx, mappedValue);\n}\n\nexport function runReset<F,T,R>(list: BaseMappedList<F,T,R>): void {\n    list._mappedValues = [];\n    list.emitReset();\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {IListObserver} from \"./BaseObservableList\";\nimport {BaseMappedList, Mapper, Updater, runAdd, runUpdate, runRemove, runMove, runReset} from \"./BaseMappedList\";\n\nexport class AsyncMappedList<F,T> extends BaseMappedList<F,T,Promise<T>> implements IListObserver<F> {\n    private _eventQueue: AsyncEvent<F>[] | null = null;\n    private _flushing: boolean = false;\n\n    onSubscribeFirst(): void {\n        this._sourceUnsubscribe = this._sourceList.subscribe(this);\n        this._eventQueue = [];\n        this._mappedValues = [];\n        let idx = 0;\n        for (const item of this._sourceList) {\n            this._eventQueue.push(new AddEvent(idx, item));\n            idx += 1;\n        }\n        this._flush();\n    }\n\n    async _flush(): Promise<void> {\n        if (this._flushing) {\n            return;\n        }\n        this._flushing = true;\n        try {\n            while (this._eventQueue!.length) {\n                const event = this._eventQueue!.shift();\n                await event!.run(this);\n            }\n        } finally {\n            this._flushing = false;\n        }\n    }\n\n    onReset(): void {\n        if (this._eventQueue) {\n            this._eventQueue.push(new ResetEvent());\n            this._flush();\n        }\n    }\n\n    onAdd(index: number, value: F): void {\n        if (this._eventQueue) {\n            this._eventQueue.push(new AddEvent(index, value));\n            this._flush();\n        }\n    }\n\n    onUpdate(index: number, value: F, params: any): void {\n        if (this._eventQueue) {\n            this._eventQueue.push(new UpdateEvent(index, value, params));\n            this._flush();\n        }\n    }\n\n    onRemove(index: number): void {\n        if (this._eventQueue) {\n            this._eventQueue.push(new RemoveEvent(index));\n            this._flush();\n        }\n    }\n\n    onMove(fromIdx: number, toIdx: number): void {\n        if (this._eventQueue) {\n            this._eventQueue.push(new MoveEvent(fromIdx, toIdx));\n            this._flush();\n        }\n    }\n\n    onUnsubscribeLast(): void {\n        this._sourceUnsubscribe!();\n        this._eventQueue = null;\n        this._mappedValues = null;\n    }\n}\n\ntype AsyncEvent<F> = AddEvent<F> | UpdateEvent<F> | RemoveEvent<F> | MoveEvent<F> | ResetEvent<F>\n\nclass AddEvent<F> {\n    constructor(public index: number, public value: F) {}\n\n    async run<T>(list: AsyncMappedList<F,T>): Promise<void> {\n        const mappedValue = await list._mapper(this.value);\n        runAdd(list, this.index, mappedValue);\n    }\n}\n\nclass UpdateEvent<F> {\n    constructor(public index: number, public value: F, public params: any) {}\n\n    async run<T>(list: AsyncMappedList<F,T>): Promise<void> {\n        runUpdate(list, this.index, this.value, this.params);\n    }\n}\n\nclass RemoveEvent<F> {\n    constructor(public index: number) {}\n\n    async run<T>(list: AsyncMappedList<F,T>): Promise<void> {\n        runRemove(list, this.index);\n    }\n}\n\nclass MoveEvent<F> {\n    constructor(public fromIdx: number, public toIdx: number) {}\n\n    async run<T>(list: AsyncMappedList<F,T>): Promise<void> {\n        runMove(list, this.fromIdx, this.toIdx);\n    }\n}\n\nclass ResetEvent<F> {\n    async run<T>(list: AsyncMappedList<F,T>): Promise<void> {\n        runReset(list);\n    }\n}\n\nimport {ObservableArray} from \"./ObservableArray\";\nimport {ListObserver} from \"../../mocks/ListObserver.js\";\n\nexport function tests() {\n    return {\n        \"events are emitted in order\": async assert => {\n            const double = n => n * n;\n            const source = new ObservableArray<number>();\n            const mapper = new AsyncMappedList(source, async n => {\n                await new Promise(r => setTimeout(r, n));\n                return {n: double(n)};\n            }, (o, params, n) => {\n                o.n = double(n);\n            });\n            const observer = new ListObserver();\n            mapper.subscribe(observer);\n            source.append(2); // will sleep this amount, so second append would take less time\n            source.append(1);\n            source.update(0, 7, \"lucky seven\")\n            source.remove(0);\n            {\n                const {type, index, value} = await observer.next();\n                assert.equal(mapper.length, 1);\n                assert.equal(type, \"add\");\n                assert.equal(index, 0);\n                assert.equal(value.n, 4);\n            }\n            {\n                const {type, index, value} = await observer.next();\n                assert.equal(mapper.length, 2);\n                assert.equal(type, \"add\");\n                assert.equal(index, 1);\n                assert.equal(value.n, 1);\n            }\n            {\n                const {type, index, value, params} = await observer.next();\n                assert.equal(mapper.length, 2);\n                assert.equal(type, \"update\");\n                assert.equal(index, 0);\n                assert.equal(value.n, 49);\n                assert.equal(params, \"lucky seven\");\n            }\n            {\n                const {type, index, value} = await observer.next();\n                assert.equal(mapper.length, 1);\n                assert.equal(type, \"remove\");\n                assert.equal(index, 0);\n                assert.equal(value.n, 49);\n            }\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableList, IListObserver} from \"./BaseObservableList\";\n\nexport class ConcatList<T> extends BaseObservableList<T> implements IListObserver<T> {\n    protected _sourceLists: BaseObservableList<T>[];\n    protected _sourceUnsubscribes: (() => void)[] | null = null;\n\n    constructor(...sourceLists: BaseObservableList<T>[]) {\n        super();\n        this._sourceLists = sourceLists;\n    }\n\n    _offsetForSource(sourceList: BaseObservableList<T>): number {\n        const listIdx = this._sourceLists.indexOf(sourceList);\n        let offset = 0;\n        for (let i = 0; i < listIdx; ++i) {\n            offset += this._sourceLists[i].length;\n        }\n        return offset;\n    }\n\n    onSubscribeFirst(): void {\n        this._sourceUnsubscribes = this._sourceLists.map(sourceList => sourceList.subscribe(this));\n    }\n\n    onUnsubscribeLast(): void {\n        for (const sourceUnsubscribe of this._sourceUnsubscribes!) {\n            sourceUnsubscribe();\n        }\n    }\n\n    onReset(): void {\n        // TODO: not ideal if other source lists are large\n        // but working impl for now\n        // reset, and \n        this.emitReset();\n        let idx = 0;\n        for(const item of this) {\n            this.emitAdd(idx, item);\n            idx += 1;\n        }\n    }\n\n    onAdd(index: number, value: T, sourceList: BaseObservableList<T>): void {\n        this.emitAdd(this._offsetForSource(sourceList) + index, value);\n    }\n\n    onUpdate(index: number, value: T, params: any, sourceList: BaseObservableList<T>): void {\n        // if an update is emitted while calling source.subscribe() from onSubscribeFirst, ignore it\n        // as we are not supposed to call `length` on any uninitialized list\n        if (!this._sourceUnsubscribes) {\n            return;\n        }\n        this.emitUpdate(this._offsetForSource(sourceList) + index, value, params);\n    }\n\n    onRemove(index: number, value: T, sourceList: BaseObservableList<T>): void {\n        this.emitRemove(this._offsetForSource(sourceList) + index, value);\n    }\n\n    onMove(fromIdx: number, toIdx: number, value: T, sourceList: BaseObservableList<T>): void {\n        const offset = this._offsetForSource(sourceList);\n        this.emitMove(offset + fromIdx, offset + toIdx, value);\n    }\n\n    get length(): number {\n        let len = 0;\n        for (let i = 0; i < this._sourceLists.length; ++i) {\n            len += this._sourceLists[i].length;\n        }\n        return len;\n    }\n\n    [Symbol.iterator]() {\n        let sourceListIdx = 0;\n        let it = this._sourceLists[0][Symbol.iterator]();\n        return {\n            next: () => {\n                let result = it.next();\n                while (result.done) {\n                    sourceListIdx += 1;\n                    if (sourceListIdx >= this._sourceLists.length) {\n                        return result;  //done\n                    }\n                    it = this._sourceLists[sourceListIdx][Symbol.iterator]();\n                    result = it.next();\n                }\n                return result;\n            }\n        }\n    }\n}\n\nimport {ObservableArray} from \"./ObservableArray\";\nimport {defaultObserverWith} from \"./BaseObservableList\";\nexport async function tests() {\n    return {\n        test_length(assert) {\n            const all = new ConcatList(\n                new ObservableArray([1, 2, 3]),\n                new ObservableArray([11, 12, 13])\n            );\n            assert.equal(all.length, 6);\n        },\n        test_iterator(assert) {\n            const all = new ConcatList(\n                new ObservableArray([1, 2, 3]),\n                new ObservableArray([11, 12, 13])\n            );\n            const it = all[Symbol.iterator]();\n            assert.equal(it.next().value, 1);\n            assert.equal(it.next().value, 2);\n            assert.equal(it.next().value, 3);\n            assert.equal(it.next().value, 11);\n            assert.equal(it.next().value, 12);\n            assert.equal(it.next().value, 13);\n            assert(it.next().done);\n        },\n        test_add(assert) {\n            const list1 = new ObservableArray([1, 2, 3]);\n            const list2 = new ObservableArray([11, 12, 13]);\n            const all = new ConcatList(list1, list2);\n            let fired = false;\n            all.subscribe(defaultObserverWith({\n                onAdd(index, value) {\n                    fired = true;\n                    assert.equal(index, 4);\n                    assert.equal(value, 11.5);\n                }\n            }));\n            list2.insert(1, 11.5);\n            assert(fired);\n        },\n        test_update(assert) {\n            const list1 = new ObservableArray([1, 2, 3]);\n            const list2 = new ObservableArray([11, 12, 13]);\n            const all = new ConcatList(list1, list2);\n            let fired = false;\n            all.subscribe(defaultObserverWith({\n                onUpdate(index, value) {\n                    fired = true;\n                    assert.equal(index, 4);\n                    assert.equal(value, 10);\n                }\n            }));\n            list2.emitUpdate(1, 10);\n            assert(fired);\n        },\n    };\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {SortedMapList} from \"./list/SortedMapList.js\";\nimport {FilteredMap} from \"./map/FilteredMap.js\";\nimport {MappedMap} from \"./map/MappedMap.js\";\nimport {JoinedMap} from \"./map/JoinedMap.js\";\nimport {BaseObservableMap} from \"./map/BaseObservableMap.js\";\n// re-export \"root\" (of chain) collections\nexport { ObservableArray } from \"./list/ObservableArray\";\nexport { SortedArray } from \"./list/SortedArray\";\nexport { MappedList } from \"./list/MappedList\";\nexport { AsyncMappedList } from \"./list/AsyncMappedList\";\nexport { ConcatList } from \"./list/ConcatList\";\nexport { ObservableMap } from \"./map/ObservableMap.js\";\n\n// avoid circular dependency between these classes\n// and BaseObservableMap (as they extend it)\nObject.assign(BaseObservableMap.prototype, {\n    sortValues(comparator) {\n        return new SortedMapList(this, comparator);\n    },\n\n    mapValues(mapper, updater) {\n        return new MappedMap(this, mapper, updater);\n    },\n\n    filterValues(filter) {\n        return new FilteredMap(this, filter);\n    },\n\n    join(...otherMaps) {\n        return new JoinedMap([this].concat(otherMaps));\n    }\n});\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport interface IDisposable {\n    dispose(): void;\n}\n\ntype Disposable = IDisposable | (() => void);\n\nfunction disposeValue(value: Disposable): void {\n    if (typeof value === \"function\") {\n        value();\n    } else {\n        value.dispose();\n    }\n}\n\nfunction isDisposable(value: Disposable): boolean {\n    return value && (typeof value === \"function\" || typeof value.dispose === \"function\");\n}\n\nexport class Disposables {\n    private _disposables: Disposable[] | null = [];\n\n    track(disposable: Disposable): Disposable {\n        if (!isDisposable(disposable)) {\n            throw new Error(\"Not a disposable\");\n        }\n        if (this.isDisposed) {\n            console.warn(\"Disposables already disposed, disposing new value\");\n            disposeValue(disposable);\n            return disposable;\n        }\n        this._disposables!.push(disposable);\n        return disposable;\n    }\n\n    untrack(disposable: Disposable): null {\n        if (this.isDisposed) {\n            console.warn(\"Disposables already disposed, cannot untrack\");\n            return null;\n        }\n        const idx = this._disposables!.indexOf(disposable);\n        if (idx >= 0) {\n            this._disposables!.splice(idx, 1);\n        }\n        return null;\n    }\n\n    dispose(): void {\n        if (this._disposables) {\n            for (const d of this._disposables) {\n                disposeValue(d);\n            }\n            this._disposables = null;\n        }\n    }\n\n    get isDisposed(): boolean {\n        return this._disposables === null;\n    }\n\n    disposeTracked(value: Disposable): null {\n        if (value === undefined || value === null || this.isDisposed) {\n            return null;\n        }\n        const idx = this._disposables!.indexOf(value);\n        if (idx !== -1) {\n            const [foundValue] = this._disposables!.splice(idx, 1);\n            disposeValue(foundValue);\n        } else {\n            console.warn(\"disposable not found, did it leak?\", value);\n        }\n        return null;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {directionalConcat, directionalAppend} from \"./common.js\";\nimport {Direction} from \"../Direction\";\nimport {EventEntry} from \"../entries/EventEntry.js\";\nimport {FragmentBoundaryEntry} from \"../entries/FragmentBoundaryEntry.js\";\n\nclass ReaderRequest {\n    constructor(fn, log) {\n        this.decryptRequest = null;\n        this._promise = fn(this, log);\n    }\n\n    complete() {\n        return this._promise;\n    }\n\n    dispose() {\n        if (this.decryptRequest) {\n            this.decryptRequest.dispose();\n            this.decryptRequest = null;\n        }\n    }\n}\n\n/**\n * Raw because it doesn't do decryption and in the future it should not read relations either.\n * It is just about reading entries and following fragment links\n */\nasync function readRawTimelineEntriesWithTxn(roomId, eventKey, direction, amount, fragmentIdComparer, txn) {\n    let entries = [];\n    const timelineStore = txn.timelineEvents;\n    const fragmentStore = txn.timelineFragments;\n\n    while (entries.length < amount && eventKey) {\n        let eventsWithinFragment;\n        if (direction.isForward) {\n            // TODO: should we pass amount - entries.length here?\n            eventsWithinFragment = await timelineStore.eventsAfter(roomId, eventKey, amount);\n        } else {\n            eventsWithinFragment = await timelineStore.eventsBefore(roomId, eventKey, amount);\n        }\n        let eventEntries = eventsWithinFragment.map(e => new EventEntry(e, fragmentIdComparer));\n        entries = directionalConcat(entries, eventEntries, direction);\n        // prepend or append eventsWithinFragment to entries, and wrap them in EventEntry\n\n        if (entries.length < amount) {\n            const fragment = await fragmentStore.get(roomId, eventKey.fragmentId);\n            // TODO: why does the first fragment not need to be added? (the next *is* added below)\n            // it looks like this would be fine when loading in the sync island\n            // (as the live fragment should be added already) but not for permalinks when we support them\n            // \n            // fragmentIdComparer.addFragment(fragment);\n            let fragmentEntry = new FragmentBoundaryEntry(fragment, direction.isBackward, fragmentIdComparer);\n            // append or prepend fragmentEntry, reuse func from GapWriter?\n            directionalAppend(entries, fragmentEntry, direction);\n            // only continue loading if the fragment boundary can't be backfilled\n            if (!fragmentEntry.token && fragmentEntry.hasLinkedFragment) {\n                const nextFragment = await fragmentStore.get(roomId, fragmentEntry.linkedFragmentId);\n                fragmentIdComparer.add(nextFragment);\n                const nextFragmentEntry = new FragmentBoundaryEntry(nextFragment, direction.isForward, fragmentIdComparer);\n                directionalAppend(entries, nextFragmentEntry, direction);\n                eventKey = nextFragmentEntry.asEventKey();\n            } else {\n                eventKey = null;\n            }\n        }\n    }\n    return entries;\n}\n\nexport class TimelineReader {\n    constructor({roomId, storage, fragmentIdComparer}) {\n        this._roomId = roomId;\n        this._storage = storage;\n        this._fragmentIdComparer = fragmentIdComparer;\n        this._decryptEntries = null;\n    }\n\n    enableEncryption(decryptEntries) {\n        this._decryptEntries = decryptEntries;\n    }\n\n    get readTxnStores() {\n        const stores = [\n            this._storage.storeNames.timelineEvents,\n            this._storage.storeNames.timelineFragments,\n        ];\n        if (this._decryptEntries) {\n            stores.push(this._storage.storeNames.inboundGroupSessions);\n        }\n        return stores;\n    }\n\n    readFrom(eventKey, direction, amount, log) {\n        return new ReaderRequest(async (r, log) => {\n            const txn = await this._storage.readTxn(this.readTxnStores);\n            return await this._readFrom(eventKey, direction, amount, r, txn, log);\n        }, log);\n    }\n\n    readFromEnd(amount, existingTxn = null, log) {\n        return new ReaderRequest(async (r, log) => {\n            const txn = existingTxn || await this._storage.readTxn(this.readTxnStores);\n            const liveFragment = await txn.timelineFragments.liveFragment(this._roomId);\n            let entries;\n            // room hasn't been synced yet\n            if (!liveFragment) {\n                entries = [];\n            } else {\n                this._fragmentIdComparer.add(liveFragment);\n                const liveFragmentEntry = FragmentBoundaryEntry.end(liveFragment, this._fragmentIdComparer);\n                const eventKey = liveFragmentEntry.asEventKey();\n                entries = await this._readFrom(eventKey, Direction.Backward, amount, r, txn, log);\n                entries.unshift(liveFragmentEntry);\n            }\n            return entries;\n        }, log);\n    }\n\n    async readById(id, log) {\n        let stores = [this._storage.storeNames.timelineEvents];\n        if (this._decryptEntries) {\n            stores.push(this._storage.storeNames.inboundGroupSessions);\n        }\n        const txn = await this._storage.readTxn(stores); // todo: can we just use this.readTxnStores here? probably\n        const storageEntry = await txn.timelineEvents.getByEventId(this._roomId, id);\n        if (storageEntry) {\n            const entry = new EventEntry(storageEntry, this._fragmentIdComparer);\n            if (this._decryptEntries) {\n                const request = this._decryptEntries([entry], txn, log);\n                await request.complete();\n            }\n            return entry;\n        }\n    }\n\n    async _readFrom(eventKey, direction, amount, r, txn, log) {\n        const entries = await readRawTimelineEntriesWithTxn(this._roomId, eventKey, direction, amount, this._fragmentIdComparer, txn);\n        if (this._decryptEntries) {\n            r.decryptRequest = this._decryptEntries(entries, txn, log);\n            try {\n                await r.decryptRequest.complete();\n            } finally {\n                r.decryptRequest = null;\n            }\n        }\n        return entries;\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {EventEntry} from \"./EventEntry.js\";\n\n// EventEntry but without the two properties that are populated via SyncWriter\n// Useful if you want to create an EventEntry that is ephemeral\n\nexport class NonPersistedEventEntry extends EventEntry {\n    get fragmentId() {\n        throw new Error(\"Cannot access fragmentId for non-persisted EventEntry\");\n    }\n\n    get entryIndex() {\n        throw new Error(\"Cannot access entryIndex for non-persisted EventEntry\");\n    }\n\n    get isNonPersisted() {\n        return true;\n    }\n\n    // overridden here because we reuse addLocalRelation() for updating this entry\n    // we don't want the RedactedTile created using this entry to ever show \"is being redacted\"\n    get isRedacting() {\n        return false;\n    }\n\n    get isRedacted() {\n        return super.isRedacting;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class User {\n    constructor(userId) {\n        this._userId = userId;\n    }\n\n    get id() {\n        return this._userId;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {SortedArray, AsyncMappedList, ConcatList, ObservableArray} from \"../../../observable/index.js\";\nimport {Disposables} from \"../../../utils/Disposables\";\nimport {Direction} from \"./Direction\";\nimport {TimelineReader} from \"./persistence/TimelineReader.js\";\nimport {PendingEventEntry} from \"./entries/PendingEventEntry.js\";\nimport {RoomMember} from \"../members/RoomMember.js\";\nimport {getRelation, ANNOTATION_RELATION_TYPE} from \"./relations.js\";\nimport {REDACTION_TYPE} from \"../common\";\nimport {NonPersistedEventEntry} from \"./entries/NonPersistedEventEntry.js\";\nimport {DecryptionSource} from \"../../e2ee/common.js\";\nimport {EVENT_TYPE as MEMBER_EVENT_TYPE} from \"../members/RoomMember.js\";\n\nexport class Timeline {\n    constructor({roomId, storage, closeCallback, fragmentIdComparer, pendingEvents, clock, powerLevelsObservable, hsApi}) {\n        this._roomId = roomId;\n        this._storage = storage;\n        this._closeCallback = closeCallback;\n        this._fragmentIdComparer = fragmentIdComparer;\n        this._disposables = new Disposables();\n        this._pendingEvents = pendingEvents;\n        this._clock = clock;\n        // constructing this early avoid some problem while sync and openTimeline race\n        this._remoteEntries = new SortedArray((a, b) => a.compare(b));\n        this._ownMember = null;\n        this._timelineReader = new TimelineReader({\n            roomId: this._roomId,\n            storage: this._storage,\n            fragmentIdComparer: this._fragmentIdComparer\n        });\n        this._readerRequest = null;\n        this._allEntries = null;\n        /** Stores event entries that we had to fetch from hs/storage for reply previews (because they were not in timeline) */ \n        this._contextEntriesNotInTimeline = new Map();\n        /** Only used to decrypt non-persisted context entries fetched from the homeserver */\n        this._decryptEntries = null;\n        this._hsApi = hsApi;\n        this.initializePowerLevels(powerLevelsObservable);\n    }\n\n    initializePowerLevels(observable) {\n        if (observable) {\n            this._powerLevels = observable.get();\n            this._disposables.track(observable.subscribe(powerLevels => this._powerLevels = powerLevels));\n        }\n    }\n\n    /** @package */\n    async load(user, membership, log) {\n        const txn = await this._storage.readTxn(this._timelineReader.readTxnStores.concat(\n            this._storage.storeNames.roomMembers,\n            this._storage.storeNames.roomState\n        ));\n        const memberData = await txn.roomMembers.get(this._roomId, user.id);\n        if (memberData) {\n            this._ownMember = new RoomMember(memberData);\n        } else {\n            // this should never happen, as our own join into the room would have\n            // made us receive our own member event, but just to be on the safe side and not crash,\n            // fall back to bare user id\n            this._ownMember = RoomMember.fromUserId(this._roomId, user.id, membership);\n        }\n        // it should be fine to not update the local entries,\n        // as they should only populate once the view subscribes to it\n        // if they are populated already, the sender profile would be empty\n\n        // choose good amount here between showing messages initially and\n        // not spending too much time decrypting messages before showing the timeline.\n        // more messages should be loaded automatically until the viewport is full by the view if needed.\n        const readerRequest = this._disposables.track(this._timelineReader.readFromEnd(20, txn, log));\n        try {\n            const entries = await readerRequest.complete();\n            this._loadContextEntriesWhereNeeded(entries);\n            this._setupEntries(entries);\n        } finally {\n            this._disposables.disposeTracked(readerRequest);\n        }\n        // txn should be assumed to have finished here, as decryption will close it.\n    }\n\n    _setupEntries(timelineEntries) {\n        this._remoteEntries.setManySorted(timelineEntries);\n        if (this._pendingEvents) {\n            this._localEntries = new AsyncMappedList(this._pendingEvents,\n                pe => this._mapPendingEventToEntry(pe),\n                (pee, params) => {\n                    // is sending but redacted, who do we detect that here to remove the relation?\n                    pee.notifyUpdate(params);\n                },\n                pee => this._applyAndEmitLocalRelationChange(pee, target => target.removeLocalRelation(pee))\n            );\n        } else {\n            this._localEntries = new ObservableArray();\n        }\n        this._allEntries = new ConcatList(this._remoteEntries, this._localEntries);\n    }\n\n    async _mapPendingEventToEntry(pe) {\n        // we load the redaction target for pending events,\n        // so if we are redacting a relation, we can pass the redaction\n        // to the relation target and the removal of the relation can\n        // be taken into account for local echo.\n        let redactingEntry;\n        if (pe.eventType === REDACTION_TYPE) {\n            redactingEntry = await this._getOrLoadEntry(pe.relatedTxnId, pe.relatedEventId);\n        }\n        const pee = new PendingEventEntry({\n            pendingEvent: pe, member: this._ownMember,\n            clock: this._clock, redactingEntry\n        });\n        this._loadContextEntriesWhereNeeded([pee]);\n        this._applyAndEmitLocalRelationChange(pee, target => target.addLocalRelation(pee));\n        return pee;\n    }\n\n    _applyAndEmitLocalRelationChange(pee, updater) {\n        // this is the contract of findAndUpdate, used in _findAndUpdateRelatedEntry\n        const updateOrFalse = e => {\n            const params = updater(e);\n            return params ? params : false;\n        };\n        this._findAndUpdateEntryById(pee.pendingEvent.relatedTxnId, pee.relatedEventId, updateOrFalse);\n        // also look for a relation target to update with this redaction\n        if (pee.redactingEntry) {\n            // redactingEntry might be a PendingEventEntry or an EventEntry, so don't assume pendingEvent\n            const relatedTxnId = pee.redactingEntry.pendingEvent?.relatedTxnId;\n            this._findAndUpdateEntryById(relatedTxnId, pee.redactingEntry.relatedEventId, updateOrFalse);\n            pee.redactingEntry.contextForEntries?.forEach(e => this._emitUpdateForEntry(e, \"contextEntry\"));\n        }\n    }\n\n    _findAndUpdateEntryById(txnId, eventId, updateOrFalse) {\n        let found = false;\n        // first, look in local entries based on txn id\n        if (txnId) {\n            found = this._localEntries.findAndUpdate(\n                e => e.id === txnId,\n                updateOrFalse,\n            );\n        }\n        // if not found here, look in remote entries based on event id\n        if (!found && eventId) {\n            this._remoteEntries.findAndUpdate(\n                e => e.id === eventId,\n                updateOrFalse\n            );\n        }\n    }\n\n    async getOwnAnnotationEntry(targetId, key) {\n        const txn = await this._storage.readWriteTxn([\n            this._storage.storeNames.timelineEvents,\n            this._storage.storeNames.timelineRelations,\n        ]);\n        const relations = await txn.timelineRelations.getForTargetAndType(this._roomId, targetId, ANNOTATION_RELATION_TYPE);\n        for (const relation of relations) {\n            const annotation = await txn.timelineEvents.getByEventId(this._roomId, relation.sourceEventId);\n            if (annotation && annotation.event.sender === this._ownMember.userId && getRelation(annotation.event).key === key) {\n                const eventEntry = new EventEntry(annotation, this._fragmentIdComparer);\n                this._addLocalRelationsToNewRemoteEntries([eventEntry]);\n                return eventEntry;\n            }\n        }\n        return null;\n    }\n\n    /** @package */\n    updateOwnMember(member) {\n        this._ownMember = member;\n    }\n\n    _addLocalRelationsToNewRemoteEntries(entries) {\n        // because it is not safe to iterate a derived observable collection\n        // before it has any subscriptions, we bail out if this isn't\n        // the case yet. This can happen when sync adds or replaces entries\n        // before load has finished and the view has subscribed to the timeline.\n        // \n        // Once the subscription is setup, MappedList will set up the local\n        // relations as needed with _applyAndEmitLocalRelationChange,\n        // so we're not missing anything by bailing out.\n        //\n        // _localEntries can also not yet exist\n        if (!this._localEntries?.hasSubscriptions) {\n            return;\n        }\n        // find any local relations to this new remote event\n        for (const pee of this._localEntries) {\n            // this will work because we set relatedEventId when removing remote echos\n            if (pee.relatedEventId) {\n                const relationTarget = entries.find(e => e.id === pee.relatedEventId);\n                // no need to emit here as this entry is about to be added\n                relationTarget?.addLocalRelation(pee);\n            }\n            if (pee.redactingEntry) {\n                const eventId = pee.redactingEntry.relatedEventId;\n                const relationTarget = entries.find(e => e.id === eventId);\n                relationTarget?.addLocalRelation(pee);\n            }\n        }\n    }\n\n    // used in replaceEntries\n    static _entryUpdater(existingEntry, entry) {\n        // ensure other entries for which this existingEntry is a context point to the new entry instead of existingEntry\n        existingEntry.contextForEntries?.forEach(event => event.setContextEntry(entry));\n        entry.updateFrom(existingEntry);\n        return entry;\n    }\n\n    /** @package */\n    replaceEntries(entries) {\n        this._addLocalRelationsToNewRemoteEntries(entries);\n        for (const entry of entries) {\n            try {\n                this._remoteEntries.getAndUpdate(entry, Timeline._entryUpdater);\n                const oldEntry = this._contextEntriesNotInTimeline.get(entry.id)\n                if (oldEntry) {\n                    Timeline._entryUpdater(oldEntry, entry);\n                    this._contextEntriesNotInTimeline.set(entry.id, entry);\n                }\n                // Since this entry changed, all dependent entries should be updated\n                entry.contextForEntries?.forEach(e => this._emitUpdateForEntry(e, \"contextEntry\"));\n            } catch (err) {\n                if (err.name === \"CompareError\") {\n                    // see FragmentIdComparer, if the replacing entry is on a fragment\n                    // that is currently not loaded into the FragmentIdComparer, it will\n                    // throw a CompareError, and it means that the event is not loaded \n                    // in the timeline (like when receiving a relation for an event\n                    // that is not loaded in memory) so we can just drop this error as\n                    // replacing an event that is not already loaded is a no-op.\n                    continue;\n                } else {\n                    // don't swallow other errors\n                    throw err;\n                }\n            }\n        }\n    }\n\n    /** @package */\n    addEntries(newEntries) {\n        this._addLocalRelationsToNewRemoteEntries(newEntries);\n        this._updateEntriesFetchedFromHomeserver(newEntries);\n        this._moveEntryToRemoteEntries(newEntries);\n        this._loadContextEntriesWhereNeeded(newEntries);\n        this._remoteEntries.setManySorted(newEntries);\n    }\n\n    /**\n     * Update entries based on newly received events.\n     * This is specific to events that are not in the timeline but had to be fetched from the homeserver\n     * because they are context-events for other events in the timeline (i.e fetched from hs so that we\n     * can render things like reply previews)\n     */\n    _updateEntriesFetchedFromHomeserver(entries) {\n        /**\n         * Updates for entries in timeline is handled by remoteEntries observable collection\n         * Updates for entries not in timeline but fetched from storage is handled in this.replaceEntries()\n         * This code is specific to entries fetched from HomeServer i.e NonPersistedEventEntry\n         */\n        for (const entry of entries) {\n            const relatedEntry = this._contextEntriesNotInTimeline.get(entry.relatedEventId);\n            if (relatedEntry?.isNonPersisted && relatedEntry?.addLocalRelation(entry)) {\n                // update other entries for which this entry is a context entry\n                relatedEntry.contextForEntries?.forEach(e => this._emitUpdateForEntry(e, \"contextEntry\"));\n            }\n        }\n    }\n\n    /**\n     * If an event we had to fetch from hs/storage is now in the timeline (for eg, due to gap fill),\n     * remove the event from _contextEntriesNotInTimeline since it is now in remoteEntries\n     */\n    _moveEntryToRemoteEntries(entries) {\n        for (const entry of entries) {\n            const fetchedEntry = this._contextEntriesNotInTimeline.get(entry.id);\n            if (fetchedEntry) {\n                fetchedEntry.contextForEntries.forEach(e => {\n                    e.setContextEntry(entry);\n                    this._emitUpdateForEntry(e, \"contextEntry\");\n                });\n                this._contextEntriesNotInTimeline.delete(entry.id);\n            }\n        }\n    }\n\n    _emitUpdateForEntry(entry, param) {\n        const txnId = entry.isPending ? entry.id : null;\n        const eventId = entry.isPending ? null : entry.id;\n        this._findAndUpdateEntryById(txnId, eventId, () => param);\n    }\n\n    /**\n     * For each entry in entries, this method associates a context-entry (if needed) to it.\n     * The context-entry is fetched using the following strategies (in the same order as given):\n     * - timeline\n     * - storage\n     * - homeserver\n     * @param {EventEntry[]} entries \n     */\n    async _loadContextEntriesWhereNeeded(entries) {\n        for (const entry of entries) {\n            if (!entry.contextEventId) {\n                continue;\n            }\n            const id = entry.contextEventId;\n            // before looking into remoteEntries, check the entries\n            // that about to be added first\n            let contextEvent = entries.find(e => e.id === id);\n            if (!contextEvent) {\n                contextEvent = this._findLoadedEventById(id);\n            }\n            if (contextEvent) {\n                entry.setContextEntry(contextEvent);\n                // we don't emit an update here, as the add or update\n                // that the callee will emit hasn't been emitted yet.\n            } else {\n                // we don't await here, which is not ideal,\n                // but one of our callers, addEntries, is not async\n                // so there is not much point.\n                // Also, we want to run the entry fetching in parallel.\n                this._loadContextEntryNotInTimeline(entry);\n            }\n        }\n    }\n\n    async _loadContextEntryNotInTimeline(entry) {\n        const id = entry.contextEventId;\n        let contextEvent = await this._getEventFromStorage(id);\n        if (!contextEvent) {\n            contextEvent = await this._getEventFromHomeserver(id);\n        }\n        if (contextEvent) {\n            // this entry was created from storage/hs, so it's not tracked by remoteEntries\n            // we track them here so that we can update reply previews later\n            this._contextEntriesNotInTimeline.set(id, contextEvent);\n            entry.setContextEntry(contextEvent);\n            // here, we awaited something, so from now on we do have to emit\n            // an update if we set the context entry.\n            this._emitUpdateForEntry(entry, \"contextEntry\");\n        }\n    }\n\n    /**\n     * Fetches an entry with the given event-id from localEntries, remoteEntries or contextEntriesNotInTimeline.\n     * @param {string} eventId event-id of the entry\n     * @returns entry if found, undefined otherwise\n     */\n    _findLoadedEventById(eventId) {\n        return this.getByEventId(eventId) ?? this._contextEntriesNotInTimeline.get(eventId);\n    }\n\n    async _getEventFromStorage(eventId) {\n        const entry = await this._timelineReader.readById(eventId);\n        return entry;\n    }\n\n    async _getEventFromHomeserver(eventId) {\n        const response = await this._hsApi.context(this._roomId, eventId, 0).response();\n        const sender = response.event.sender;\n        const member = response.state.find(e => e.type === MEMBER_EVENT_TYPE && e.user_id === sender);\n        const entry = {\n            event: response.event,\n            displayName: member.content.displayname,\n            avatarUrl: member.content.avatar_url\n        };\n        const eventEntry = new NonPersistedEventEntry(entry, this._fragmentIdComparer);\n        if (this._decryptEntries) {\n            const request = this._decryptEntries([eventEntry]);\n            await request.complete();\n        }\n        return eventEntry;\n    }\n\n    // tries to prepend `amount` entries to the `entries` list.\n    /**\n     * [loadAtTop description]\n     * @param  {[type]} amount [description]\n     * @return {boolean} true if the top of the timeline has been reached\n     * \n     */\n    async loadAtTop(amount) {\n        if (this._disposables.isDisposed) {\n            return true;\n        }\n        const firstEventEntry = this._remoteEntries.array.find(e => !!e.eventType);\n        if (!firstEventEntry) {\n            return true;\n        }\n        const readerRequest = this._disposables.track(this._timelineReader.readFrom(\n            firstEventEntry.asEventKey(),\n            Direction.Backward,\n            amount\n        ));\n        try {\n            const entries = await readerRequest.complete();\n            this.addEntries(entries);\n            return entries.length < amount;\n        } finally {\n            this._disposables.disposeTracked(readerRequest);\n        }\n    }\n\n    async _getOrLoadEntry(txnId, eventId) {\n        if (txnId) {\n            // also look for redacting relation in pending events, in case the target is already being sent\n            for (const p of this._localEntries) {\n                if (p.id === txnId) {\n                    return p;\n                }\n            }\n        }\n        if (eventId) {\n            return this.getByEventId(eventId) ?? await this._getEventFromStorage(eventId);\n        }\n        return null;\n    }\n\n    getByEventId(eventId) {\n        for (let i = 0; i < this._remoteEntries.length; i += 1) {\n            const entry = this._remoteEntries.get(i);\n            if (entry.id === eventId) {\n                return entry;\n            }\n        }\n        return null;\n    }\n\n    /** @public */\n    get entries() {\n        return this._allEntries;\n    }\n\n    /**\n     * @internal\n     * @return {Array<EventEntry>} remote event entries, should not be modified\n     */\n    get remoteEntries() {\n        return this._remoteEntries.array;\n    }\n\n    /** @public */\n    dispose() {\n        if (this._closeCallback) {\n            this._disposables.dispose();\n            this._closeCallback();\n            this._closeCallback = null;\n        }\n    }\n\n    /** @internal */\n    enableEncryption(decryptEntries) {\n        this._decryptEntries = decryptEntries;\n        this._timelineReader.enableEncryption(decryptEntries);\n    }\n\n    get powerLevels() {\n        return this._powerLevels;\n    }\n\n    get me() {\n        return this._ownMember;\n    }\n}\n\nimport {FragmentIdComparer} from \"./FragmentIdComparer.js\";\nimport {poll} from \"../../../mocks/poll.js\";\nimport {Clock as MockClock} from \"../../../mocks/Clock.js\";\nimport {createMockStorage} from \"../../../mocks/Storage\";\nimport {ListObserver} from \"../../../mocks/ListObserver.js\";\nimport {createEvent, withTextBody, withContent, withSender, withRedacts, withReply} from \"../../../mocks/event.js\";\nimport {NullLogItem} from \"../../../logging/NullLogger\";\nimport {EventEntry} from \"./entries/EventEntry.js\";\nimport {User} from \"../../User.js\";\nimport {PendingEvent} from \"../sending/PendingEvent.js\";\nimport {createAnnotation} from \"./relations.js\";\nimport {redactEvent} from \"./common.js\";\n\nexport function tests() {\n    const fragmentIdComparer = new FragmentIdComparer([]);\n    const roomId = \"$abc\";\n    const alice = \"@alice:hs.tld\";\n    const bob = \"@bob:hs.tld\";\n    const hsApi = {\n        context() {\n            const result = {\n                event: withTextBody(\"foo\", createEvent(\"m.room.message\", \"event_id_1\", alice)),\n                state: [{\n                    type: MEMBER_EVENT_TYPE,\n                    user_id: alice,\n                    content: {\n                        displayName: \"\",\n                        avatarUrl: \"\"\n                    }\n                }]\n            };\n            return { response: () => result };\n        }\n    };\n\n    function getIndexFromIterable(it, n) {\n        let i = 0;\n        for (const item of it) {\n            if (i === n) {\n                return item;\n            }\n            i += 1;\n        }\n        throw new Error(\"not enough items in iterable\");\n    }\n\n    return {\n        \"adding or replacing entries before subscribing to entries does not lose local relations\": async assert => {\n            const pendingEvents = new ObservableArray();\n            const timeline = new Timeline({roomId, storage: await createMockStorage(),\n                closeCallback: () => {}, fragmentIdComparer, pendingEvents, clock: new MockClock()});\n            // 1. load timeline\n            await timeline.load(new User(alice), \"join\", new NullLogItem());\n            // 2. test replaceEntries and addEntries don't fail\n            const event1 = withTextBody(\"hi!\", withSender(bob, createEvent(\"m.room.message\", \"!abc\")));\n            const entry1 = new EventEntry({event: event1, fragmentId: 1, eventIndex: 1}, fragmentIdComparer);\n            timeline.replaceEntries([entry1]);\n            const event2 = withTextBody(\"hi bob!\", withSender(alice, createEvent(\"m.room.message\", \"!def\")));\n            const entry2 = new EventEntry({event: event2, fragmentId: 1, eventIndex: 2}, fragmentIdComparer);\n            timeline.addEntries([entry2]);\n            // 3. add local relation (redaction)\n            pendingEvents.append(new PendingEvent({data: {\n                roomId,\n                queueIndex: 1,\n                eventType: \"m.room.redaction\",\n                txnId: \"t123\",\n                content: {},\n                relatedEventId: event2.event_id\n            }}));\n            // 4. subscribe (it's now safe to iterate timeline.entries) \n            timeline.entries.subscribe(new ListObserver());\n            // 5. check the local relation got correctly aggregated\n            const locallyRedacted = await poll(() => Array.from(timeline.entries)[0].isRedacting);\n            assert.equal(locallyRedacted, true);\n        },\n        \"add and remove local reaction, and cancel again\": async assert => {\n            // 1. setup timeline with message\n            const pendingEvents = new ObservableArray();\n            const timeline = new Timeline({roomId, storage: await createMockStorage(),\n                closeCallback: () => {}, fragmentIdComparer, pendingEvents, clock: new MockClock()});\n            await timeline.load(new User(bob), \"join\", new NullLogItem());\n            timeline.entries.subscribe(new ListObserver());\n            const event = withTextBody(\"hi bob!\", withSender(alice, createEvent(\"m.room.message\", \"!abc\")));\n            timeline.addEntries([new EventEntry({event, fragmentId: 1, eventIndex: 2}, fragmentIdComparer)]);\n            let entry = getIndexFromIterable(timeline.entries, 0);\n            // 2. add local reaction\n            pendingEvents.append(new PendingEvent({data: {\n                roomId,\n                queueIndex: 1,\n                eventType: \"m.reaction\",\n                txnId: \"t123\",\n                content: entry.annotate(\"👋\"),\n                relatedEventId: entry.id\n            }}));\n            await poll(() => timeline.entries.length === 2);\n            assert.equal(entry.pendingAnnotations.get(\"👋\").count, 1);\n            const reactionEntry = getIndexFromIterable(timeline.entries, 1);\n            // 3. add redaction to timeline\n            pendingEvents.append(new PendingEvent({data: {\n                roomId,\n                queueIndex: 2,\n                eventType: \"m.room.redaction\",\n                txnId: \"t456\",\n                content: {},\n                relatedTxnId: reactionEntry.id\n            }}));\n            // TODO: await nextUpdate here with ListObserver, to ensure entry emits an update when pendingAnnotations changes\n            await poll(() => timeline.entries.length === 3);\n            assert.equal(entry.pendingAnnotations.get(\"👋\").count, 0);\n            // 4. cancel redaction\n            pendingEvents.remove(1);\n            await poll(() => timeline.entries.length === 2);\n            assert.equal(entry.pendingAnnotations.get(\"👋\").count, 1);\n            // 5. cancel reaction\n            pendingEvents.remove(0);\n            await poll(() => timeline.entries.length === 1);\n            assert(!entry.pendingAnnotations);\n        },\n        \"getOwnAnnotationEntry\": async assert => {\n            const messageId = \"!abc\";\n            const reactionId = \"!def\";\n            // 1. put event and reaction into storage\n            const storage = await createMockStorage();\n            const txn = await storage.readWriteTxn([storage.storeNames.timelineEvents, storage.storeNames.timelineRelations]);\n            txn.timelineEvents.tryInsert({\n                event: withContent(createAnnotation(messageId, \"👋\"), createEvent(\"m.reaction\", reactionId, bob)),\n                fragmentId: 1, eventIndex: 1, roomId\n            }, new NullLogItem());\n            txn.timelineRelations.add(roomId, messageId, ANNOTATION_RELATION_TYPE, reactionId);\n            await txn.complete();\n            // 2. setup the timeline\n            const timeline = new Timeline({roomId, storage, closeCallback: () => {},\n                fragmentIdComparer, pendingEvents: new ObservableArray(), clock: new MockClock()});\n            await timeline.load(new User(bob), \"join\", new NullLogItem());\n            // 3. get the own annotation out\n            const reactionEntry = await timeline.getOwnAnnotationEntry(messageId, \"👋\");\n            assert.equal(reactionEntry.id, reactionId);\n            assert.equal(reactionEntry.relation.key, \"👋\");\n        },\n        \"remote reaction\": async assert => {\n            const messageEntry = new EventEntry({\n                event: withTextBody(\"hi bob!\", createEvent(\"m.room.message\", \"!abc\", alice)),\n                fragmentId: 1, eventIndex: 2, roomId,\n                annotations: { // aggregated like RelationWriter would\n                    \"👋\": {count: 1, me: true, firstTimestamp: 0}\n                },\n            }, fragmentIdComparer);\n            // 2. setup timeline\n            const pendingEvents = new ObservableArray();\n            const timeline = new Timeline({roomId, storage: await createMockStorage(),\n                closeCallback: () => {}, fragmentIdComparer, pendingEvents, clock: new MockClock()});\n            await timeline.load(new User(bob), \"join\", new NullLogItem());\n            timeline.entries.subscribe(new ListObserver());\n            // 3. add message to timeline\n            timeline.addEntries([messageEntry]);\n            const entry = getIndexFromIterable(timeline.entries, 0);\n            assert.equal(entry, messageEntry);\n            assert.equal(entry.annotations[\"👋\"].count, 1);\n        },\n        \"remove remote reaction\": async assert => {\n            // 1. setup timeline\n            const pendingEvents = new ObservableArray();\n            const timeline = new Timeline({roomId, storage: await createMockStorage(),\n                closeCallback: () => { }, fragmentIdComparer, pendingEvents, clock: new MockClock()});\n            await timeline.load(new User(bob), \"join\", new NullLogItem());\n            timeline.entries.subscribe(new ListObserver());\n            // 2. add message and reaction to timeline\n            const messageEntry = new EventEntry({\n                event: withTextBody(\"hi bob!\", createEvent(\"m.room.message\", \"!abc\", alice)),\n                fragmentId: 1, eventIndex: 2, roomId,\n            }, fragmentIdComparer);\n            const reactionEntry = new EventEntry({\n                event: withContent(createAnnotation(messageEntry.id, \"👋\"), createEvent(\"m.reaction\", \"!def\", bob)),\n                fragmentId: 1, eventIndex: 3, roomId\n            }, fragmentIdComparer);\n            timeline.addEntries([messageEntry, reactionEntry]);\n            // 3. redact reaction\n            pendingEvents.append(new PendingEvent({data: {\n                roomId,\n                queueIndex: 1,\n                eventType: \"m.room.redaction\",\n                txnId: \"t123\",\n                content: {},\n                relatedEventId: reactionEntry.id\n            }}));\n            await poll(() => timeline.entries.length >= 3);\n            assert.equal(messageEntry.pendingAnnotations.get(\"👋\").count, -1);\n        },\n        \"local reaction gets applied after remote echo is added to timeline\": async assert => {\n            const messageEntry = new EventEntry({event: withTextBody(\"hi bob!\", withSender(alice, createEvent(\"m.room.message\", \"!abc\"))),\n                fragmentId: 1, eventIndex: 2}, fragmentIdComparer);\n            // 1. setup timeline\n            const pendingEvents = new ObservableArray();\n            const timeline = new Timeline({roomId, storage: await createMockStorage(),\n                closeCallback: () => {}, fragmentIdComparer, pendingEvents, clock: new MockClock()});\n            await timeline.load(new User(bob), \"join\", new NullLogItem());\n            timeline.entries.subscribe(new ListObserver());\n            // 2. add local reaction\n            pendingEvents.append(new PendingEvent({data: {\n                roomId,\n                queueIndex: 1,\n                eventType: \"m.reaction\",\n                txnId: \"t123\",\n                content: messageEntry.annotate(\"👋\"),\n                relatedEventId: messageEntry.id\n            }}));\n            await poll(() => timeline.entries.length === 1);\n            // 3. add remote reaction target\n            timeline.addEntries([messageEntry]);\n            await poll(() => timeline.entries.length === 2);\n            const entry = getIndexFromIterable(timeline.entries, 0);\n            assert.equal(entry, messageEntry);\n            assert.equal(entry.pendingAnnotations.get(\"👋\").count, 1);\n        },\n        \"local reaction removal gets applied after remote echo is added to timeline with reaction not loaded\": async assert => {\n            const messageId = \"!abc\";\n            const reactionId = \"!def\";\n            // 1. put reaction in storage\n            const storage = await createMockStorage();\n            const txn = await storage.readWriteTxn([storage.storeNames.timelineEvents, storage.storeNames.timelineRelations]);\n            txn.timelineEvents.tryInsert({\n                event: withContent(createAnnotation(messageId, \"👋\"), createEvent(\"m.reaction\", reactionId, bob)),\n                fragmentId: 1, eventIndex: 3, roomId\n            }, new NullLogItem());\n            await txn.complete();\n            // 2. setup timeline\n            const pendingEvents = new ObservableArray();\n            const timeline = new Timeline({roomId, storage, closeCallback: () => {},\n                fragmentIdComparer, pendingEvents, clock: new MockClock()});\n            await timeline.load(new User(bob), \"join\", new NullLogItem());\n            timeline.entries.subscribe(new ListObserver());\n            // 3. add local redaction for reaction\n            pendingEvents.append(new PendingEvent({data: {\n                roomId,\n                queueIndex: 1,\n                eventType: \"m.room.redaction\",\n                txnId: \"t123\",\n                content: {},\n                relatedEventId: reactionId\n            }}));\n            await poll(() => timeline.entries.length === 1);\n            // 4. add reaction target\n            timeline.addEntries([new EventEntry({\n                event: withTextBody(\"hi bob!\", createEvent(\"m.room.message\", messageId, alice)),\n                fragmentId: 1, eventIndex: 2}, fragmentIdComparer)\n            ]);\n            await poll(() => timeline.entries.length === 2);\n            // 5. check that redaction was linked to reaction target\n            const entry = getIndexFromIterable(timeline.entries, 0);\n            assert.equal(entry.pendingAnnotations.get(\"👋\").count, -1);\n        },\n        \"decrypted entry preserves content when receiving other update without decryption\": async assert => {\n            // 1. create encrypted and decrypted entry\n            const encryptedEntry = new EventEntry({\n                event: withContent({ciphertext: \"abc\"}, createEvent(\"m.room.encrypted\", \"!abc\", alice)),\n                    fragmentId: 1, eventIndex: 1, roomId\n            }, fragmentIdComparer);\n            const decryptedEntry = encryptedEntry.clone();\n            decryptedEntry.setDecryptionResult({\n                event: withTextBody(\"hi bob!\", createEvent(\"m.room.message\", encryptedEntry.id, encryptedEntry.sender))\n            });\n            // 2. setup the timeline\n            const timeline = new Timeline({roomId, storage: await createMockStorage(), closeCallback: () => {},\n                fragmentIdComparer, pendingEvents: new ObservableArray(), clock: new MockClock()});\n            await timeline.load(new User(alice), \"join\", new NullLogItem());\n            timeline.addEntries([decryptedEntry]);\n            const observer = new ListObserver();\n            timeline.entries.subscribe(observer);\n            // 3. replace the entry with one that is not decrypted\n            //    (as would happen when receiving a reaction,\n            //    as it does not rerun the decryption)\n            //    and check that the decrypted content is preserved\n            timeline.replaceEntries([encryptedEntry]);\n            const {value, type} = await observer.next();\n            assert.equal(type, \"update\");\n            assert.equal(value.eventType, \"m.room.message\");\n            assert.equal(value.content.body, \"hi bob!\");\n        },\n\n        \"context entry is fetched from remoteEntries\": async assert => {\n            const timeline = new Timeline({roomId, storage: await createMockStorage(), closeCallback: () => {},\n                fragmentIdComparer, pendingEvents: new ObservableArray(), clock: new MockClock()});\n            const entryA = new EventEntry({ event: withTextBody(\"foo\", createEvent(\"m.room.message\", \"event_id_1\", alice)) });\n            const entryB = new EventEntry({ event: withReply(\"event_id_1\", createEvent(\"m.room.message\", \"event_id_2\", bob)), eventIndex: 2 });\n            await timeline.load(new User(alice), \"join\", new NullLogItem());\n            timeline.entries.subscribe({\n                onAdd() {},\n            });\n            timeline.addEntries([entryA, entryB]);\n            assert.deepEqual(entryB.contextEntry, entryA);\n        },\n\n        \"context entry is fetched from storage\": async assert => {\n            const storage = await createMockStorage();\n            const txn = await storage.readWriteTxn([storage.storeNames.timelineEvents, storage.storeNames.timelineRelations]);\n            txn.timelineEvents.tryInsert({ event: withTextBody(\"foo\", createEvent(\"m.room.message\", \"event_id_1\", alice)), fragmentId: 1, eventIndex: 1, roomId });\n            await txn.complete();\n            const timeline = new Timeline({roomId, storage, closeCallback: () => {},\n                fragmentIdComparer, pendingEvents: new ObservableArray(), clock: new MockClock()});\n            const entryB = new EventEntry({ event: withReply(\"event_id_1\", createEvent(\"m.room.message\", \"event_id_2\", bob)), eventIndex: 2 });\n            await timeline.load(new User(alice), \"join\", new NullLogItem());\n            timeline.entries.subscribe({ onAdd: () => null, onUpdate: () => null });\n            timeline.addEntries([entryB]);\n            await poll(() => entryB.contextEntry);\n            assert.strictEqual(entryB.contextEntry.id, \"event_id_1\");\n        },\n\n        \"context entry is fetched from hs\": async assert => {\n            const timeline = new Timeline({roomId, storage: await createMockStorage(), closeCallback: () => {},\n                fragmentIdComparer, pendingEvents: new ObservableArray(), clock: new MockClock(), hsApi});\n            const entryB = new EventEntry({ event: withReply(\"event_id_1\", createEvent(\"m.room.message\", \"event_id_2\", bob)), eventIndex: 2 });\n            await timeline.load(new User(alice), \"join\", new NullLogItem());\n            timeline.entries.subscribe({ onAdd: () => null, onUpdate: () => null });\n            timeline.addEntries([entryB]);\n            await poll(() => entryB.contextEntry);\n            assert.strictEqual(entryB.contextEntry.id, \"event_id_1\");\n        },\n\n        \"context entry has a list of entries to which it forms the context\": async assert => {\n            const timeline = new Timeline({roomId, storage: await createMockStorage(), closeCallback: () => {},\n                fragmentIdComparer, pendingEvents: new ObservableArray(), clock: new MockClock()});\n            const entryA = new EventEntry({ event: withTextBody(\"foo\", createEvent(\"m.room.message\", \"event_id_1\", alice)), eventIndex: 1 });\n            const entryB = new EventEntry({ event: withReply(\"event_id_1\", createEvent(\"m.room.message\", \"event_id_2\", bob)), eventIndex: 2 });\n            const entryC = new EventEntry({ event: withReply(\"event_id_1\", createEvent(\"m.room.message\", \"event_id_3\", bob)), eventIndex: 3 });\n            await timeline.load(new User(alice), \"join\", new NullLogItem());\n            timeline.entries.subscribe({ onAdd: () => null, onUpdate: () => null });\n            timeline.addEntries([entryA, entryB, entryC]);\n            await poll(() => entryA.contextForEntries.length === 2);\n            assert.deepEqual(entryA.contextForEntries, [entryB, entryC]);\n        },\n\n        \"context entry in contextEntryNotInTimeline gets updated based on incoming redaction\": async assert => {\n            const timeline = new Timeline({roomId, storage: await createMockStorage(), closeCallback: () => {},\n                fragmentIdComparer, pendingEvents: new ObservableArray(), clock: new MockClock(), hsApi});\n            const entryB = new EventEntry({ event: withReply(\"event_id_1\", createEvent(\"m.room.message\", \"event_id_2\", bob)), eventIndex: 2 });\n            await timeline.load(new User(alice), \"join\", new NullLogItem());\n            timeline.entries.subscribe({ onAdd: () => null, onUpdate: () => null });\n            timeline.addEntries([entryB]);\n            await poll(() => entryB.contextEntry);\n            const redactingEntry = new EventEntry({ event: withRedacts(\"event_id_1\", \"foo\", createEvent(\"m.room.redaction\", \"event_id_3\", alice)), eventIndex: 3 });\n            timeline.addEntries([redactingEntry]);\n            assert.strictEqual(entryB.contextEntry.isRedacted, true);\n        },\n\n        \"redaction of context entry triggers updates in other entries\": async assert => {\n            const timeline = new Timeline({roomId, storage: await createMockStorage(), closeCallback: () => {},\n                fragmentIdComparer, pendingEvents: new ObservableArray(), clock: new MockClock(), hsApi});\n            const entryA = new EventEntry({ event: withTextBody(\"foo\", createEvent(\"m.room.message\", \"event_id_1\", alice)), eventIndex: 1, fragmentId: 1 });\n            const entryB = new EventEntry({ event: withReply(\"event_id_1\", createEvent(\"m.room.message\", \"event_id_2\", bob)), eventIndex: 2, fragmentId: 1 });\n            const entryC = new EventEntry({ event: withReply(\"event_id_1\", createEvent(\"m.room.message\", \"event_id_3\", bob)), eventIndex: 3, fragmentId: 1 });\n            await timeline.load(new User(alice), \"join\", new NullLogItem());\n            const bin = [];\n            timeline.entries.subscribe({\n                onUpdate: (index, e) => {\n                    bin.push(e.id);\n                },\n                onAdd: () => null,\n            });\n            timeline.addEntries([entryA, entryB, entryC]);\n            const eventAClone = JSON.parse(JSON.stringify(entryA.event));\n            redactEvent(withRedacts(\"event_id_1\", \"foo\", createEvent(\"m.room.redaction\", \"event_id_4\", alice)), eventAClone);\n            const redactedEntry = new EventEntry({ event: eventAClone, eventIndex: 1, fragmentId: 1 });\n            timeline.replaceEntries([redactedEntry]);\n            assert.strictEqual(bin.includes(\"event_id_2\"), true);\n            assert.strictEqual(bin.includes(\"event_id_3\"), true);\n        },\n\n        \"context entries fetched from storage/hs are moved to remoteEntries\": async assert => {\n            const timeline = new Timeline({roomId, storage: await createMockStorage(), closeCallback: () => {},\n                fragmentIdComparer, pendingEvents: new ObservableArray(), clock: new MockClock(), hsApi});\n            const entryA = new EventEntry({ event: withTextBody(\"foo\", createEvent(\"m.room.message\", \"event_id_1\", alice)), eventIndex: 1 });\n            const entryB = new EventEntry({ event: withReply(\"event_id_1\", createEvent(\"m.room.message\", \"event_id_2\", bob)), eventIndex: 2 });\n            await timeline.load(new User(alice), \"join\", new NullLogItem());\n            timeline.entries.subscribe({ onAdd: () => null, onUpdate: () => null });\n            timeline.addEntries([entryB]);\n            await poll(() => entryB.contextEntry);\n            assert.strictEqual(timeline._contextEntriesNotInTimeline.has(entryA.id), true);\n            timeline.addEntries([entryA]);\n            assert.strictEqual(timeline._contextEntriesNotInTimeline.has(entryA.id), false);\n            const movedEntry = timeline.remoteEntries[0];\n            assert.deepEqual(movedEntry, entryA);\n            assert.deepEqual(movedEntry.contextForEntries[0], entryB);\n            assert.deepEqual(entryB.contextEntry, movedEntry);\n        }\n    };\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {RoomMember} from \"./RoomMember.js\";\n\nasync function loadMembers({roomId, storage}) {\n    const txn = await storage.readTxn([\n        storage.storeNames.roomMembers,\n    ]);\n    const memberDatas = await txn.roomMembers.getAll(roomId);\n    return memberDatas.map(d => new RoomMember(d));\n}\n\nasync function fetchMembers({summary, syncToken, roomId, hsApi, storage, setChangedMembersMap}, log) {\n    // if any members are changed by sync while we're fetching members,\n    // they will end up here, so we check not to override them\n    const changedMembersDuringSync = new Map();\n    setChangedMembersMap(changedMembersDuringSync);\n    \n    const memberResponse = await hsApi.members(roomId, {at: syncToken}, {log}).response();\n\n    const txn = await storage.readWriteTxn([\n        storage.storeNames.roomSummary,\n        storage.storeNames.roomMembers,\n    ]);\n\n    let summaryChanges;\n    let members;\n    \n    try {\n        summaryChanges = summary.writeHasFetchedMembers(true, txn);\n        const {roomMembers} = txn;\n        const memberEvents = memberResponse.chunk;\n        if (!Array.isArray(memberEvents)) {\n            throw new Error(\"malformed\");\n        }\n        log.set(\"members\", memberEvents.length);\n        members = await Promise.all(memberEvents.map(async memberEvent => {\n            const userId = memberEvent?.state_key;\n            if (!userId) {\n                throw new Error(\"malformed\");\n            }\n            // this member was changed during a sync that happened while calling /members\n            // and thus is more recent, so don't overwrite\n            const changedMember = changedMembersDuringSync.get(userId);\n            if (changedMember) {\n                return changedMember;\n            } else {\n                const member = RoomMember.fromMemberEvent(roomId, memberEvent);\n                if (member) {\n                    roomMembers.set(member.serialize());\n                }\n                return member;\n            }\n        }));\n    } catch (err) {\n        // abort txn on any error\n        txn.abort();\n        throw err;\n    } finally {\n        // important this gets cleared\n        // or otherwise Room remains in \"fetching-members\" mode\n        setChangedMembersMap(null);\n    }\n    await txn.complete();\n    summary.applyChanges(summaryChanges);\n    return members;\n}\n\nexport async function fetchOrLoadMembers(options, logger) {\n    const {summary} = options;\n    if (!summary.data.hasFetchedMembers) {\n        // we only want to log if we fetch members, so start or continue the optional log operation here\n        return logger.wrapOrRun(options.log, \"fetchMembers\", log => fetchMembers(options, log));\n    } else {\n        return loadMembers(options);\n    }\n}\n\nexport async function fetchOrLoadMember(options, logger) {\n    const member = await loadMember(options);\n    const {summary} = options;\n    if (!summary.data.hasFetchedMembers && !member) {\n        // We haven't fetched the memberlist yet; so ping the hs to see if this member does exist\n        return logger.wrapOrRun(options.log, \"fetchMember\", log => fetchMember(options, log));\n    }\n    return member;\n}\n\nasync function loadMember({roomId, userId, storage}) {\n    const txn = await storage.readTxn([storage.storeNames.roomMembers,]);\n    const member = await txn.roomMembers.get(roomId, userId);\n    return member? new RoomMember(member) : null;\n}\n\nasync function fetchMember({roomId, userId, hsApi, storage}, log) {\n    let memberData;\n    try {\n        memberData = await hsApi.state(roomId, \"m.room.member\", userId, { log }).response();\n    }\n    catch (error) {\n        if (error.name === \"HomeServerError\" && error.errcode === \"M_NOT_FOUND\") {\n            return null;\n        }\n        throw error;\n    }\n    const member = new RoomMember({\n        roomId,\n        userId,\n        membership: memberData.membership,\n        avatarUrl: memberData.avatar_url,\n        displayName: memberData.displayname,\n    });\n    const txn = await storage.readWriteTxn([storage.storeNames.roomMembers]);\n    try {\n        txn.roomMembers.set(member.serialize());\n    }\n    catch(e) {\n        txn.abort();\n        throw e;\n    }\n    await txn.complete();\n    return member;\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class RetainedValue {\n    private readonly _freeCallback: () => void;\n    private _retentionCount: number = 1;\n\n    constructor(freeCallback: () => void) {\n        this._freeCallback = freeCallback;\n    }\n\n    retain(): void {\n        this._retentionCount += 1;\n    }\n\n    release(): void {\n        this._retentionCount -= 1;\n        if (this._retentionCount === 0) {\n            this._freeCallback();\n        }\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ObservableMap} from \"../../../observable/map/ObservableMap.js\";\nimport {RetainedValue} from \"../../../utils/RetainedValue\";\n\nexport class MemberList extends RetainedValue {\n    constructor({members, closeCallback}) {\n        super(closeCallback);\n        this._members = new ObservableMap();\n        for (const member of members) {\n            this._members.add(member.userId, member);\n        }\n    }\n\n    afterSync(memberChanges) {\n        for (const [userId, memberChange] of memberChanges.entries()) {\n            this._members.set(userId, memberChange.member);\n        }\n    }\n\n    get members() {\n        return this._members;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {RoomMember} from \"./RoomMember.js\";\n\nexport function calculateRoomName(sortedMembers, summaryData, log) {\n    const countWithoutMe = summaryData.joinCount + summaryData.inviteCount - 1;\n    if (sortedMembers.length >= countWithoutMe) {\n        if (sortedMembers.length > 1) {\n            const lastMember = sortedMembers[sortedMembers.length - 1];\n            const firstMembers = sortedMembers.slice(0, sortedMembers.length - 1);\n            return firstMembers.map(m => m.name).join(\", \") + \" and \" + lastMember.name;\n        } else {\n            const otherMember = sortedMembers[0];\n            if (otherMember) {\n                return otherMember.name;\n            } else {\n                log.log({l: \"could get get other member name\", length: sortedMembers.length, otherMember: !!otherMember, otherMemberMembership: otherMember?.membership});\n                return \"Unknown DM Name\";\n            }\n        }\n    } else if (sortedMembers.length < countWithoutMe) {\n        return sortedMembers.map(m => m.name).join(\", \") + ` and ${countWithoutMe} others`;\n    } else {\n        // Empty Room\n        return null;\n    }\n}\n\nexport class Heroes {\n    constructor(roomId) {\n        this._roomId = roomId;\n        this._members = new Map();\n    }\n\n    /**\n     * @param  {string[]} newHeroes      array of user ids\n     * @param  {Map<string, MemberChange>} memberChanges map of changed memberships\n     * @param  {Transaction} txn\n     * @return {Promise}\n     */\n    async calculateChanges(newHeroes, memberChanges, txn) {\n        const updatedHeroMembers = new Map();\n        const removedUserIds = [];\n        // remove non-present members\n        for (const existingUserId of this._members.keys()) {\n            if (newHeroes.indexOf(existingUserId) === -1) {\n                removedUserIds.push(existingUserId);\n            }\n        }\n        // update heroes with synced member changes\n        for (const [userId, memberChange] of memberChanges.entries()) {\n            if (this._members.has(userId) || newHeroes.indexOf(userId) !== -1) {\n                updatedHeroMembers.set(userId, memberChange.member);\n            }\n        }\n        // load member for new heroes from storage\n        for (const userId of newHeroes) {\n            if (!this._members.has(userId) && !updatedHeroMembers.has(userId)) {\n                const memberData = await txn.roomMembers.get(this._roomId, userId);\n                if (memberData) {\n                    const member = new RoomMember(memberData);\n                    updatedHeroMembers.set(member.userId, member);\n                }\n            }\n        }\n        return {updatedHeroMembers: updatedHeroMembers.values(), removedUserIds};\n    }\n\n    applyChanges({updatedHeroMembers, removedUserIds}, summaryData, log) {\n        for (const userId of removedUserIds) {\n            this._members.delete(userId);\n        }\n        for (const member of updatedHeroMembers) {\n            this._members.set(member.userId, member);\n        }\n        const sortedMembers = Array.from(this._members.values()).sort((a, b) => a.name.localeCompare(b.name));\n        this._roomName = calculateRoomName(sortedMembers, summaryData, log);\n    }\n\n    get roomName() {\n        return this._roomName;\n    }\n\n    get roomAvatarUrl() {\n        if (this._members.size === 1) {\n            for (const member of this._members.values()) {\n                return member.avatarUrl;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * In DM rooms, we want the room's color to be\n     * the same as the other user's color. Thus, if the room\n     * only has one hero, we use their ID, instead\n     * of the room's, to get the avatar color.\n     *\n     * @returns {?string} the ID of the single hero.\n     */\n    get roomAvatarColorId() {\n        if (this._members.size === 1) {\n            for (const member of this._members.keys()) {\n                return member\n            }\n        }\n        return null;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableValue} from \"../../observable/ObservableValue\";\n\nexport class ObservedEventMap {\n    constructor(notifyEmpty) {\n        this._map = new Map();\n        this._notifyEmpty = notifyEmpty;\n    }\n\n    observe(eventId, eventEntry = null) {\n        let observable = this._map.get(eventId);\n        if (!observable) {\n            observable = new ObservedEvent(this, eventEntry, eventId);\n            this._map.set(eventId, observable);\n        }\n        return observable;\n    }\n\n    updateEvents(eventEntries) {\n        for (let i = 0; i < eventEntries.length; i += 1) {\n            const entry = eventEntries[i];\n            const observable = this._map.get(entry.id);\n            observable?.update(entry);\n        }\n    }\n\n    _remove(id) {\n        this._map.delete(id);\n        if (this._map.size === 0) {\n            this._notifyEmpty();\n        }\n    }\n}\n\nclass ObservedEvent extends BaseObservableValue {\n    constructor(eventMap, entry, id) {\n        super();\n        this._eventMap = eventMap;\n        this._entry = entry;\n        this._id = id;\n        // remove subscription in microtask after creating it\n        // otherwise ObservedEvents would easily never get\n        // removed if you never subscribe\n        Promise.resolve().then(() => {\n            if (!this.hasSubscriptions) {\n                this._eventMap._remove(this._id);\n                this._eventMap = null;\n            }\n        });\n    }\n\n    subscribe(handler) {\n        if (!this._eventMap) {\n            throw new Error(\"ObservedEvent expired, subscribe right after calling room.observeEvent()\");\n        }\n        return super.subscribe(handler);\n    }\n\n    onUnsubscribeLast() {\n        this._eventMap._remove(this._id);\n        this._eventMap = null;\n        super.onUnsubscribeLast();\n    }\n\n    update(entry) {\n        // entries are mostly updated in-place,\n        // apart from when they are created,\n        // but doesn't hurt to reassign\n        this._entry = entry;\n        this.emit(this._entry);\n    }\n\n    get() {\n        return this._entry;\n    }\n}\n","// these are helper functions if you can't assume you always have a log item (e.g. some code paths call with one set, others don't)\n// if you know you always have a log item, better to use the methods on the log item than these utility functions.\n\nimport {Instance as NullLoggerInstance} from \"./NullLogger\";\nimport type {FilterCreator, ILogItem, LabelOrValues, LogCallback} from \"./types\";\nimport {LogLevel} from \"./LogFilter\";\n\nexport function wrapOrRunNullLogger<T>(logItem: ILogItem | undefined, labelOrValues: LabelOrValues, callback: LogCallback<T>, logLevel?: LogLevel, filterCreator?: FilterCreator): T | Promise<T> {\n    if (logItem) {\n        return logItem.wrap(labelOrValues, callback, logLevel, filterCreator);\n    } else {\n        return NullLoggerInstance.run(null, callback);\n    }\n}\n\nexport function ensureLogItem(logItem: ILogItem): ILogItem {\n    return logItem || NullLoggerInstance.item;\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport const EVENT_TYPE = \"m.room.power_levels\";\n\nexport class PowerLevels {\n    constructor({powerLevelEvent, createEvent, ownUserId, membership}) {\n        this._plEvent = powerLevelEvent;\n        this._createEvent = createEvent;\n        this._ownUserId = ownUserId;\n        this._membership = membership;\n    }\n\n    canRedactFromSender(userId) {\n        if (userId === this._ownUserId && this._membership === \"join\") {\n            return true;\n        } else {\n            return this.canRedact;\n        }\n    }\n\n    canSendType(eventType) {\n        return this._myLevel >= this._getEventTypeLevel(eventType);\n    }\n\n    get canRedact() {\n        return this._myLevel >= this._getActionLevel(\"redact\");\n    }\n\n    get _myLevel() {\n        if (this._membership !== \"join\") {\n            return Number.MIN_SAFE_INTEGER;\n        }\n        return this.getUserLevel(this._ownUserId);\n    }\n\n    getUserLevel(userId) {\n        if (this._plEvent) {\n            let userLevel = this._plEvent.content?.users?.[userId];\n            if (typeof userLevel !== \"number\") {\n                userLevel = this._plEvent.content?.users_default;\n            }\n            if (typeof userLevel === \"number\") {\n                return userLevel;\n            }\n        } else if (this._createEvent) {\n            if (userId === this._createEvent.content?.creator) {\n                return 100;\n            }\n        }\n        return 0;\n    }\n\n    /** @param {string} action either \"invite\", \"kick\", \"ban\" or \"redact\". */\n    _getActionLevel(action) {\n        const level = this._plEvent?.content[action];\n        if (typeof level === \"number\") {\n            return level;\n        } else {\n            return 50;\n        }\n    }\n\n    _getEventTypeLevel(eventType) {\n        const level = this._plEvent?.content.events?.[eventType];\n        if (typeof level === \"number\") {\n            return level;\n        } else {\n            const level = this._plEvent?.content.events_default;\n            if (typeof level === \"number\") {\n                return level;\n            } else {\n                return 0;\n            }\n        }\n    }\n}\n\nexport function tests() {\n    const alice = \"@alice:hs.tld\";\n    const bob = \"@bob:hs.tld\";\n    const charly = \"@charly:hs.tld\";\n    const createEvent = {content: {creator: alice}};\n    const redactPowerLevelEvent = {content: {\n        redact: 50,\n        users: {\n            [alice]: 50\n        },\n        users_default: 0\n    }};\n    const eventsPowerLevelEvent = {content: {\n        events_default: 5,\n        events: {\n            \"m.room.message\": 45,\n            \"m.room.topic\": 50,\n        },\n        users: {\n            [alice]: 50,\n            [bob]: 10\n        },\n        users_default: 0\n    }};\n\n    return {\n        \"redact somebody else event with power level event\": assert => {\n            const pl1 = new PowerLevels({powerLevelEvent: redactPowerLevelEvent, ownUserId: alice, membership: \"join\"});\n            assert.equal(pl1.canRedact, true);\n            const pl2 = new PowerLevels({powerLevelEvent: redactPowerLevelEvent, ownUserId: bob, membership: \"join\"});\n            assert.equal(pl2.canRedact, false);\n        },\n        \"redact somebody else event with create event\": assert => {\n            const pl1 = new PowerLevels({createEvent, ownUserId: alice, membership: \"join\"});\n            assert.equal(pl1.canRedact, true);\n            const pl2 = new PowerLevels({createEvent, ownUserId: bob, membership: \"join\"});\n            assert.equal(pl2.canRedact, false);\n        },\n        \"redact own event\": assert => {\n            const pl = new PowerLevels({ownUserId: alice, membership: \"join\"});\n            assert.equal(pl.canRedactFromSender(alice), true);\n            assert.equal(pl.canRedactFromSender(bob), false);\n        },\n        \"can send event without power levels\": assert => {\n            const pl = new PowerLevels({createEvent, ownUserId: charly, membership: \"join\"});\n            assert.equal(pl.canSendType(\"m.room.message\"), true);\n        },\n        \"can't send any event below events_default\": assert => {\n            const pl = new PowerLevels({powerLevelEvent: eventsPowerLevelEvent, ownUserId: charly, membership: \"join\"});\n            assert.equal(pl.canSendType(\"m.foo\"), false);\n        },\n        \"can't send event below events[type]\": assert => {\n            const pl = new PowerLevels({powerLevelEvent: eventsPowerLevelEvent, ownUserId: bob, membership: \"join\"});\n            assert.equal(pl.canSendType(\"m.foo\"), true);\n            assert.equal(pl.canSendType(\"m.room.message\"), false);\n        },\n        \"can send event above or at events[type]\": assert => {\n            const pl = new PowerLevels({powerLevelEvent: eventsPowerLevelEvent, ownUserId: alice, membership: \"join\"});\n            assert.equal(pl.canSendType(\"m.room.message\"), true);\n            assert.equal(pl.canSendType(\"m.room.topic\"), true);\n        },\n        \"can't redact or send in non-joined room'\": assert => {\n            const pl = new PowerLevels({createEvent, ownUserId: alice, membership: \"leave\"});\n            assert.equal(pl.canRedact, false);\n            assert.equal(pl.canRedactFromSender(alice), false);\n            assert.equal(pl.canSendType(\"m.room.message\"), false);\n        },\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {EventEmitter} from \"../../utils/EventEmitter\";\nimport {RoomSummary} from \"./RoomSummary.js\";\nimport {GapWriter} from \"./timeline/persistence/GapWriter.js\";\nimport {RelationWriter} from \"./timeline/persistence/RelationWriter.js\";\nimport {Timeline} from \"./timeline/Timeline.js\";\nimport {FragmentIdComparer} from \"./timeline/FragmentIdComparer.js\";\nimport {WrappedError} from \"../error.js\"\nimport {fetchOrLoadMembers, fetchOrLoadMember} from \"./members/load.js\";\nimport {MemberList} from \"./members/MemberList.js\";\nimport {Heroes} from \"./members/Heroes.js\";\nimport {EventEntry} from \"./timeline/entries/EventEntry.js\";\nimport {ObservedEventMap} from \"./ObservedEventMap.js\";\nimport {DecryptionSource} from \"../e2ee/common.js\";\nimport {ensureLogItem} from \"../../logging/utils\";\nimport {PowerLevels} from \"./PowerLevels.js\";\nimport {RetainedObservableValue} from \"../../observable/ObservableValue\";\nimport {TimelineReader} from \"./timeline/persistence/TimelineReader\";\n\nconst EVENT_ENCRYPTED_TYPE = \"m.room.encrypted\";\n\nexport class BaseRoom extends EventEmitter {\n    constructor({roomId, storage, hsApi, mediaRepository, emitCollectionChange, user, createRoomEncryption, getSyncToken, platform}) {\n        super();\n        this._roomId = roomId;\n        this._storage = storage;\n        this._hsApi = hsApi;\n        this._mediaRepository = mediaRepository;\n        this._summary = new RoomSummary(roomId);\n        this._fragmentIdComparer = new FragmentIdComparer([]);\n        this._emitCollectionChange = emitCollectionChange;\n        this._timeline = null;\n        this._user = user;\n        this._changedMembersDuringSync = null;\n        this._memberList = null;\n        this._createRoomEncryption = createRoomEncryption;\n        this._roomEncryption = null;\n        this._getSyncToken = getSyncToken;\n        this._platform = platform;\n        this._observedEvents = null;\n        this._powerLevels = null;\n        this._powerLevelLoading = null;\n        this._observedMembers = null;\n    }\n\n    async _eventIdsToEntries(eventIds, txn) {\n        const retryEntries = [];\n        await Promise.all(eventIds.map(async eventId => {\n            const storageEntry = await txn.timelineEvents.getByEventId(this._roomId, eventId);\n            if (storageEntry) {\n                retryEntries.push(new EventEntry(storageEntry, this._fragmentIdComparer));\n            }\n        }));\n        return retryEntries;\n    }\n\n    _getAdditionalTimelineRetryEntries(otherRetryEntries, roomKeys) {\n        let retryTimelineEntries = this._roomEncryption.filterUndecryptedEventEntriesForKeys(this._timeline.remoteEntries, roomKeys);\n        // filter out any entries already in retryEntries so we don't decrypt them twice\n        const existingIds = otherRetryEntries.reduce((ids, e) => {ids.add(e.id); return ids;}, new Set());\n        retryTimelineEntries = retryTimelineEntries.filter(e => !existingIds.has(e.id));\n        return retryTimelineEntries;\n    }\n\n    /**\n     * Used for retrying decryption from other sources than sync, like key backup.\n     * @internal\n     * @param  {RoomKey} roomKey\n     * @param  {Array<string>} eventIds any event ids that should be retried. There might be more in the timeline though for this key.\n     * @return {Promise}\n     */\n    async notifyRoomKey(roomKey, eventIds, log) {\n        if (!this._roomEncryption) {\n            return;\n        }\n        const txn = await this._storage.readTxn([\n            this._storage.storeNames.timelineEvents,\n            this._storage.storeNames.inboundGroupSessions,\n        ]);\n        let retryEntries = await this._eventIdsToEntries(eventIds, txn);\n        if (this._timeline) {\n            const retryTimelineEntries = this._getAdditionalTimelineRetryEntries(retryEntries, [roomKey]);\n            retryEntries = retryEntries.concat(retryTimelineEntries);\n        }\n        if (retryEntries.length) {\n            const decryptRequest = this._decryptEntries(DecryptionSource.Retry, retryEntries, txn, log);\n            // this will close txn while awaiting decryption\n            await decryptRequest.complete();\n\n            this._timeline?.replaceEntries(retryEntries);\n            // we would ideally write the room summary in the same txn as the groupSessionDecryptions in the\n            // _decryptEntries entries and could even know which events have been decrypted for the first\n            // time from DecryptionChanges.write and only pass those to the summary. As timeline changes\n            // are not essential to the room summary, it's fine to write this in a separate txn for now.\n            const changes = this._summary.data.applyTimelineEntries(retryEntries, false, false);\n            if (await this._summary.writeAndApplyData(changes, this._storage)) {\n                this._emitUpdate();\n            }\n        }\n    }\n\n    _setEncryption(roomEncryption) {\n        if (roomEncryption && !this._roomEncryption) {\n            this._roomEncryption = roomEncryption;\n            if (this._timeline) {\n                this._timeline.enableEncryption(this._decryptEntries.bind(this, DecryptionSource.Timeline));\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Used for decrypting when loading/filling the timeline, and retrying decryption,\n     * not during sync, where it is split up during the multiple phases.\n     */\n    _decryptEntries(source, entries, inboundSessionTxn, log = null) {\n        const request = new DecryptionRequest(async (r, log) => {\n            if (!inboundSessionTxn) {\n                inboundSessionTxn = await this._storage.readTxn([this._storage.storeNames.inboundGroupSessions]);\n            }\n            if (r.cancelled) return;\n            const events = entries.filter(entry => {\n                return entry.eventType === EVENT_ENCRYPTED_TYPE;\n            }).map(entry => entry.event);\n            r.preparation = await this._roomEncryption.prepareDecryptAll(events, null, source, inboundSessionTxn);\n            if (r.cancelled) return;\n            const changes = await r.preparation.decrypt();\n            r.preparation = null;\n            if (r.cancelled) return;\n            const stores = [this._storage.storeNames.groupSessionDecryptions];\n            const isTimelineOpen = this._isTimelineOpen;\n            if (isTimelineOpen) {\n                // read to fetch devices if timeline is open\n                stores.push(this._storage.storeNames.deviceIdentities);\n            }\n            const writeTxn = await this._storage.readWriteTxn(stores);\n            let decryption;\n            try {\n                decryption = await changes.write(writeTxn, log);\n                if (isTimelineOpen) {\n                    await decryption.verifySenders(writeTxn);\n                }\n            } catch (err) {\n                writeTxn.abort();\n                throw err;\n            }\n            await writeTxn.complete();\n            // TODO: log decryption errors here\n            decryption.applyToEntries(entries);\n            if (this._observedEvents) {\n                this._observedEvents.updateEvents(entries);\n            }\n        }, ensureLogItem(log));\n        return request;\n    }\n\n    // TODO: move this to Room\n    async _getSyncRetryDecryptEntries(newKeys, roomEncryption, txn) {\n        const entriesPerKey = await Promise.all(newKeys.map(async key => {\n            const retryEventIds = await roomEncryption.getEventIdsForMissingKey(key, txn);\n            if (retryEventIds) {\n                return this._eventIdsToEntries(retryEventIds, txn);\n            }\n        }));\n        let retryEntries = entriesPerKey.reduce((allEntries, entries) => entries ? allEntries.concat(entries) : allEntries, []);\n        // If we have the timeline open, see if there are more entries for the new keys\n        // as we only store missing session information for synced events, not backfilled.\n        // We want to decrypt all events we can though if the user is looking\n        // at them when the timeline is open\n        if (this._timeline) {\n            const retryTimelineEntries = this._getAdditionalTimelineRetryEntries(retryEntries, newKeys);\n            // make copies so we don't modify the original entry in writeSync, before the afterSync stage\n            const retryTimelineEntriesCopies = retryTimelineEntries.map(e => e.clone());\n            // add to other retry entries\n            retryEntries = retryEntries.concat(retryTimelineEntriesCopies);\n        }\n        return retryEntries;\n    }\n\n    /** @package */\n    async load(summary, txn, log) {\n        log.set(\"id\", this.id);\n        try {\n            // if called from sync, there is no summary yet\n            if (summary) {\n                this._summary.load(summary);\n            }\n            if (this._summary.data.encryption) {\n                const roomEncryption = this._createRoomEncryption(this, this._summary.data.encryption);\n                this._setEncryption(roomEncryption);\n            }\n            // need to load members for name?\n            if (this._summary.data.needsHeroes) {\n                this._heroes = new Heroes(this._roomId);\n                const changes = await this._heroes.calculateChanges(this._summary.data.heroes, [], txn);\n                this._heroes.applyChanges(changes, this._summary.data, log);\n            }\n        } catch (err) {\n            throw new WrappedError(`Could not load room ${this._roomId}`, err);\n        }\n    }\n\n    async observeMember(userId) {\n        if (!this._observedMembers) {\n            this._observedMembers = new Map();\n        }\n        const mapMember = this._observedMembers.get(userId);\n        if (mapMember) {\n            // Hit, we're already observing this member\n            return mapMember;\n        }\n        // Miss, load from storage/hs and set in map\n        const member = await fetchOrLoadMember({\n            summary: this._summary,\n            roomId: this._roomId,\n            userId,\n            storage: this._storage,\n            hsApi: this._hsApi\n        }, this._platform.logger);\n        if (!member) {\n            return null;\n        }\n        const observableMember = new RetainedObservableValue(member, () => this._observedMembers.delete(userId));\n        this._observedMembers.set(userId, observableMember);\n        return observableMember;\n    }\n\n\n    /** @public */\n    async loadMemberList(log = null) {\n        if (this._memberList) {\n            // TODO: also await fetchOrLoadMembers promise here\n            this._memberList.retain();\n            return this._memberList;\n        } else {\n            const members = await fetchOrLoadMembers({\n                summary: this._summary,\n                roomId: this._roomId,\n                hsApi: this._hsApi,\n                storage: this._storage,\n                syncToken: this._getSyncToken(),\n                // to handle race between /members and /sync\n                setChangedMembersMap: map => this._changedMembersDuringSync = map,\n                log,\n            }, this._platform.logger);\n            this._memberList = new MemberList({\n                members,\n                closeCallback: () => { this._memberList = null; }\n            });\n            return this._memberList;\n        }\n    } \n\n    /** @public */\n    fillGap(fragmentEntry, amount, log = null) {\n        // TODO move some/all of this out of BaseRoom\n        return this._platform.logger.wrapOrRun(log, \"fillGap\", async log => {\n            log.set(\"id\", this.id);\n            log.set(\"fragment\", fragmentEntry.fragmentId);\n            log.set(\"dir\", fragmentEntry.direction.asApiString());\n            if (fragmentEntry.edgeReached) {\n                log.set(\"edgeReached\", true);\n                return;\n            }\n            const response = await this._hsApi.messages(this._roomId, {\n                from: fragmentEntry.token,\n                dir: fragmentEntry.direction.asApiString(),\n                limit: amount,\n                filter: {\n                    lazy_load_members: true,\n                    include_redundant_members: true,\n                }\n            }, {log}).response();\n\n            const txn = await this._storage.readWriteTxn([\n                this._storage.storeNames.pendingEvents,\n                this._storage.storeNames.timelineEvents,\n                this._storage.storeNames.timelineRelations,\n                this._storage.storeNames.timelineFragments,\n            ]);\n            let extraGapFillChanges;\n            let gapResult;\n            try {\n                // detect remote echos of pending messages in the gap\n                extraGapFillChanges = await this._writeGapFill(response.chunk, txn, log);\n                // write new events into gap\n                const relationWriter = new RelationWriter({\n                    roomId: this._roomId,\n                    fragmentIdComparer: this._fragmentIdComparer,\n                    ownUserId: this._user.id,\n                });\n                const gapWriter = new GapWriter({\n                    roomId: this._roomId,\n                    storage: this._storage,\n                    fragmentIdComparer: this._fragmentIdComparer,\n                    relationWriter\n                });\n                gapResult = await gapWriter.writeFragmentFill(fragmentEntry, response, txn, log);\n            } catch (err) {\n                txn.abort();\n                throw err;\n            }\n            await txn.complete();\n            if (this._roomEncryption) {\n                const decryptRequest = this._decryptEntries(DecryptionSource.Timeline, gapResult.entries, null, log);\n                await decryptRequest.complete();\n            }\n            // once txn is committed, update in-memory state & emit events\n            for (const fragment of gapResult.fragments) {\n                this._fragmentIdComparer.add(fragment);\n            }\n            if (extraGapFillChanges) {\n                this._applyGapFill(extraGapFillChanges);\n            }\n            if (this._timeline) {\n                // these should not be added if not already there\n                this._timeline.replaceEntries(gapResult.updatedEntries);\n                this._timeline.addEntries(gapResult.entries);\n            }\n        });\n    }\n\n    /**\n    allow sub classes to integrate in the gap fill lifecycle.\n    JoinedRoom uses this update remote echos.\n    */\n    // eslint-disable-next-line no-unused-vars\n    async _writeGapFill(chunk, txn, log) {}\n    _applyGapFill() {}\n\n    /** @public */\n    get name() {\n        if (this._heroes) {\n            return this._heroes.roomName;\n        }\n        const summaryData = this._summary.data;\n        if (summaryData.name) {\n            return summaryData.name;\n        }\n        if (summaryData.canonicalAlias) {\n            return summaryData.canonicalAlias;\n        }\n        return null;\n    }\n\n    /** @public */\n    get id() {\n        return this._roomId;\n    }\n\n    get avatarUrl() {\n        if (this._summary.data.avatarUrl) {\n            return this._summary.data.avatarUrl;\n        } else if (this._heroes) {\n            return this._heroes.roomAvatarUrl;\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve the identifier that should be used to color\n     * this room's avatar. By default this is the room's\n     * ID, but DM rooms should be the same color as their\n     * user's avatar.\n     */\n    get avatarColorId() {\n        return this._roomId;\n    }\n\n    get lastMessageTimestamp() {\n        return this._summary.data.lastMessageTimestamp;\n    }\n\n    get isLowPriority() {\n        const tags = this._summary.data.tags;\n        return !!(tags && tags['m.lowpriority']);\n    }\n\n    get isEncrypted() {\n        return !!this._summary.data.encryption;\n    }\n\n    get isJoined() {\n        return this.membership === \"join\";\n    }\n\n    get isLeft() {\n        return this.membership === \"leave\";\n    }\n\n    get canonicalAlias() {\n        return this._summary.data.canonicalAlias;\n    }\n\n    get joinedMemberCount() {\n        return this._summary.data.joinCount;\n    }\n\n    get mediaRepository() {\n        return this._mediaRepository;\n    }\n\n    get membership() {\n        return this._summary.data.membership;\n    }\n\n    isDirectMessageForUserId(userId) {\n        if (this._summary.data.dmUserId === userId) {\n            return true;\n        } else {\n            // fall back to considering any room a DM containing heroes (e.g. no name) and 2 members,\n            // on of which the userId we're looking for.\n            // We need this because we're not yet processing m.direct account data correctly.\n            const {heroes, joinCount, inviteCount} = this._summary.data;\n            if (heroes && heroes.includes(userId) && (joinCount + inviteCount) === 2) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    async _loadPowerLevels() {\n        const txn = await this._storage.readTxn([this._storage.storeNames.roomState]);\n        const powerLevelsState = await txn.roomState.get(this._roomId, \"m.room.power_levels\", \"\");\n        if (powerLevelsState) {\n            return new PowerLevels({\n                powerLevelEvent: powerLevelsState.event,\n                ownUserId: this._user.id,\n                membership: this.membership\n            });\n        }\n        const createState = await txn.roomState.get(this._roomId, \"m.room.create\", \"\");\n        if (createState) {\n            return new PowerLevels({\n                createEvent: createState.event,\n                ownUserId: this._user.id,\n                membership: this.membership\n            });\n        } else {\n            const membership = this.membership;\n            return new PowerLevels({ownUserId: this._user.id, membership});\n        }\n    }\n\n    /**\n     * Get the PowerLevels of the room.\n     * Always subscribe to the value returned by this method.\n     * @returns {RetainedObservableValue} PowerLevels of the room\n     */\n    async observePowerLevels() {\n        if (this._powerLevelLoading) { await this._powerLevelLoading; }\n        let observable = this._powerLevels;\n        if (!observable) {\n            this._powerLevelLoading = this._loadPowerLevels();\n            const powerLevels = await this._powerLevelLoading;\n            observable = new RetainedObservableValue(powerLevels, () => { this._powerLevels = null; });\n            this._powerLevels = observable;\n            this._powerLevelLoading = null;\n        }\n        return observable;\n    }\n\n    enableKeyBackup(keyBackup) {\n        this._roomEncryption?.enableKeyBackup(keyBackup);\n        // TODO: do we really want to do this every time you open the app?\n        if (this._timeline && keyBackup) {\n            this._platform.logger.run(\"enableKeyBackup\", log => {\n                return this._roomEncryption.restoreMissingSessionsFromBackup(this._timeline.remoteEntries, log);\n            });\n        }\n    }\n\n    get _isTimelineOpen() {\n        return !!this._timeline;\n    }\n\n    _emitUpdate() {\n        // once for event emitter listeners\n        this.emit(\"change\");\n        // and once for collection listeners\n        this._emitCollectionChange(this);\n    }\n\n    /** @public */\n    openTimeline(log = null) {\n        return this._platform.logger.wrapOrRun(log, \"open timeline\", async log => {\n            log.set(\"id\", this.id);\n            if (this._timeline) {\n                throw new Error(\"not dealing with load race here for now\");\n            }\n            this._timeline = new Timeline({\n                roomId: this.id,\n                storage: this._storage,\n                fragmentIdComparer: this._fragmentIdComparer,\n                pendingEvents: this._getPendingEvents(),\n                closeCallback: () => {\n                    this._timeline = null;\n                    if (this._roomEncryption) {\n                        this._roomEncryption.notifyTimelineClosed();\n                    }\n                },\n                clock: this._platform.clock,\n                logger: this._platform.logger,\n                powerLevelsObservable: await this.observePowerLevels(),\n                hsApi: this._hsApi\n            });\n            try {\n                if (this._roomEncryption) {\n                    this._timeline.enableEncryption(this._decryptEntries.bind(this, DecryptionSource.Timeline));\n                }\n                await this._timeline.load(this._user, this.membership, log);\n            } catch (err) {\n                // this also clears this._timeline in the closeCallback\n                this._timeline.dispose();\n                throw err;\n            }\n            return this._timeline;\n        });\n    }\n\n    /* allow subclasses to provide an observable list with pending events when opening the timeline */\n    _getPendingEvents() { return null; }\n\n    observeEvent(eventId) {\n        if (!this._observedEvents) {\n            this._observedEvents = new ObservedEventMap(() => {\n                this._observedEvents = null;\n            });\n        }\n        let entry = null;\n        if (this._timeline) {\n            entry = this._timeline.getByEventId(eventId);\n        }\n        const observable = this._observedEvents.observe(eventId, entry);\n        if (!entry) {\n            // update in the background\n            this._readEventById(eventId).then(entry => {\n                observable.update(entry);\n            }).catch(err => {\n                console.warn(`could not load event ${eventId} from storage`, err);\n            });\n        }\n        return observable;\n    }\n\n    async _readEventById(eventId) {\n        const reader = new TimelineReader({ roomId: this._roomId, storage: this._storage, fragmentIdComparer: this._fragmentIdComparer });\n        const entry = await reader.readById(eventId);\n        return entry;\n    }\n\n    dispose() {\n        this._roomEncryption?.dispose();\n        this._timeline?.dispose();\n    }\n}\n\nclass DecryptionRequest {\n    constructor(decryptFn, log) {\n        this._cancelled = false;\n        this.preparation = null;\n        this._promise = log.wrap(\"decryptEntries\", log => decryptFn(this, log));\n    }\n\n    complete() {\n        return this._promise;\n    }\n\n    get cancelled() {\n        return this._cancelled;\n    }\n\n    dispose() {\n        this._cancelled = true;\n        if (this.preparation) {\n            this.preparation.dispose();\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function makeTxnId() {\n    const n = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\n    const str = n.toString(16);\n    return \"t\" + \"0\".repeat(14 - str.length) + str;\n}\n\nexport function isTxnId(txnId) {\n\treturn txnId.startsWith(\"t\") && txnId.length === 15;\n}\n\nexport function tests() {\n\treturn {\n\t\t\"isTxnId succeeds on result of makeTxnId\": assert => {\n\t\t\tassert(isTxnId(makeTxnId()));\n\t\t},\n\t\t\"isTxnId fails on event id\": assert => {\n\t\t\tassert(!isTxnId(\"$yS_n5n3cIO2aTtek0_2ZSlv-7g4YYR2zKrk2mFCW_rm\"));\n\t\t},\n\t}\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {SortedArray} from \"../../../observable/list/SortedArray\";\nimport {ConnectionError} from \"../../error.js\";\nimport {PendingEvent, SendStatus} from \"./PendingEvent.js\";\nimport {makeTxnId, isTxnId} from \"../../common.js\";\nimport {REDACTION_TYPE} from \"../common\";\nimport {getRelationFromContent, getRelationTarget, setRelationTarget, REACTION_TYPE, ANNOTATION_RELATION_TYPE} from \"../timeline/relations.js\";\n\nexport class SendQueue {\n    constructor({roomId, storage, hsApi, pendingEvents}) {\n        pendingEvents = pendingEvents || [];\n        this._roomId = roomId;\n        this._storage = storage;\n        this._hsApi = hsApi;\n        this._pendingEvents = new SortedArray((a, b) => a.queueIndex - b.queueIndex);\n        this._pendingEvents.setManyUnsorted(pendingEvents.map(data => this._createPendingEvent(data)));\n        this._isSending = false;\n        this._offline = false;\n        this._roomEncryption = null;\n        this._currentQueueIndex = 0;\n    }\n\n    _createPendingEvent(data, attachments = null) {\n        const pendingEvent = new PendingEvent({\n            data,\n            remove: () => this._removeEvent(pendingEvent),\n            emitUpdate: params => this._pendingEvents.update(pendingEvent, params),\n            attachments\n        });\n        return pendingEvent;\n    }\n\n    enableEncryption(roomEncryption) {\n        this._roomEncryption = roomEncryption;\n    }\n\n    _sendLoop(log) {\n        this._isSending = true;\n        this._sendLoopLogItem = log.runDetached(\"send queue flush\", async log => {\n            try {\n                for (const pendingEvent of this._pendingEvents) {\n                    await log.wrap(\"send event\", async log => {\n                        log.set(\"queueIndex\", pendingEvent.queueIndex);\n                        try {\n                            this._currentQueueIndex = pendingEvent.queueIndex;\n                            await this._sendEvent(pendingEvent, log);\n                        } catch(err) {\n                            if (err instanceof ConnectionError) {\n                                this._offline = true;\n                                log.set(\"offline\", true);\n                                pendingEvent.setWaiting();\n                            } else {\n                                log.catch(err);\n                                const isPermanentError = err.name === \"HomeServerError\" && (\n                                    err.statusCode === 400 ||   // bad request, must be a bug on our end\n                                    err.statusCode === 403 ||   // forbidden\n                                    err.statusCode === 404      // not found\n                                );\n                                if (isPermanentError) {\n                                    log.set(\"remove\", true);\n                                    await pendingEvent.abort();\n                                } else {\n                                    pendingEvent.setError(err);\n                                }\n                            }\n                        } finally {\n                            this._currentQueueIndex = 0;\n                        }\n                    });\n                }\n            } finally {\n                this._isSending = false;\n                this._sendLoopLogItem = null;\n            }\n        });\n    }\n\n    async _sendEvent(pendingEvent, log) {\n        if (pendingEvent.needsUpload) {\n            await log.wrap(\"upload attachments\", log => pendingEvent.uploadAttachments(this._hsApi, log));\n            await this._tryUpdateEvent(pendingEvent);\n        }\n        if (pendingEvent.needsEncryption) {\n            pendingEvent.setEncrypting();\n            const encryptionContent = pendingEvent.contentForEncryption;\n            const {type, content} = await log.wrap(\"encrypt\", log => this._roomEncryption.encrypt(\n                pendingEvent.eventType, encryptionContent, this._hsApi, log));\n            pendingEvent.setEncrypted(type, content);\n            await this._tryUpdateEvent(pendingEvent);\n        }\n        if (pendingEvent.needsSending) {\n            await pendingEvent.send(this._hsApi, log);\n            // we now have a remoteId, but this pending event may be removed at any point in the future\n            // (or past, so can't assume it still exists) once the remote echo comes in.\n            // So if we have any related events that need to resolve the relatedTxnId to a related event id,\n            // they need to do so now.\n            // We ensure this by writing the new remote id for the pending event and all related events\n            // with unresolved relatedTxnId in the queue in one transaction.\n            const txn = await this._storage.readWriteTxn([this._storage.storeNames.pendingEvents]);\n            try {\n                await this._tryUpdateEventWithTxn(pendingEvent, txn);\n                await this._resolveRemoteIdInPendingRelations(\n                    pendingEvent.txnId, pendingEvent.remoteId, txn);\n            } catch (err) {\n                txn.abort();\n                throw err;\n            }\n            await txn.complete();\n        }\n    }\n\n    async _resolveRemoteIdInPendingRelations(txnId, remoteId, txn) {\n        const relatedEventWithoutRemoteId = this._pendingEvents.array.filter(pe => {\n            return pe.relatedTxnId === txnId && pe.relatedEventId !== remoteId;\n        });\n        for (const relatedPE of relatedEventWithoutRemoteId) {\n            relatedPE.setRelatedEventId(remoteId);\n            await this._tryUpdateEventWithTxn(relatedPE, txn);\n        }\n        return relatedEventWithoutRemoteId;\n    }\n\n    async removeRemoteEchos(events, txn, parentLog) {\n        const removed = [];\n        for (const event of events) {\n            const txnId = event.unsigned && event.unsigned.transaction_id;\n            let idx;\n            if (txnId) {\n                idx = this._pendingEvents.array.findIndex(pe => pe.txnId === txnId);\n            } else {\n                idx = this._pendingEvents.array.findIndex(pe => pe.remoteId === event.event_id);\n            }\n            if (idx !== -1) {\n                const pendingEvent = this._pendingEvents.get(idx);\n                const remoteId = event.event_id;\n                parentLog.log({l: \"removeRemoteEcho\", queueIndex: pendingEvent.queueIndex, remoteId, txnId});\n                txn.pendingEvents.remove(pendingEvent.roomId, pendingEvent.queueIndex);\n                removed.push(pendingEvent);\n                await this._resolveRemoteIdInPendingRelations(txnId, remoteId, txn);\n            }\n        }\n        return removed;\n    }\n\n    async _removeEvent(pendingEvent) {\n        let hasEvent = this._pendingEvents.array.indexOf(pendingEvent) !== -1;\n        if (hasEvent) {\n            const txn = await this._storage.readWriteTxn([this._storage.storeNames.pendingEvents]);\n            try {\n                txn.pendingEvents.remove(pendingEvent.roomId, pendingEvent.queueIndex);\n            } catch (err) {\n                txn.abort();\n            }\n            await txn.complete();\n            // lookup index after async txn is complete,\n            // to make sure we're not racing with anything\n            const idx = this._pendingEvents.array.indexOf(pendingEvent);\n            if (idx !== -1) {\n                this._pendingEvents.remove(idx);\n            }\n        }\n        pendingEvent.dispose();\n    }\n\n    emitRemovals(pendingEvents) {\n        for (const pendingEvent of pendingEvents) {\n            const idx = this._pendingEvents.array.indexOf(pendingEvent);\n            if (idx !== -1) {\n                this._pendingEvents.remove(idx);\n            }\n            pendingEvent.dispose();\n        }\n    }\n\n    resumeSending(parentLog) {\n        this._offline = false;\n        if (this._pendingEvents.length) {\n            parentLog.wrap(\"resumeSending\", log => {\n                log.set(\"id\", this._roomId);\n                log.set(\"pendingEvents\", this._pendingEvents.length);\n                if (!this._isSending) {\n                    this._sendLoop(log);\n                }\n                if (this._sendLoopLogItem) {\n                    log.refDetached(this._sendLoopLogItem);\n                }\n            });\n        }\n    }\n\n    async enqueueEvent(eventType, content, attachments, log) {\n        const relation = getRelationFromContent(content);\n        let relatedTxnId = null;\n        if (relation) {\n            const relationTarget = getRelationTarget(relation);\n            if (isTxnId(relationTarget)) {\n                relatedTxnId = relationTarget;\n                setRelationTarget(relation, null);\n            }\n            if (relation.rel_type === ANNOTATION_RELATION_TYPE) {\n                // Here we know the shape of the relation, and can use event_id safely\n                const isAlreadyAnnotating = this._pendingEvents.array.some(pe => {\n                    const r = getRelationFromContent(pe.content);\n                    return pe.eventType === eventType && r && r.key === relation.key &&\n                        (pe.relatedTxnId === relatedTxnId || r.event_id === relation.event_id);\n                });\n                if (isAlreadyAnnotating) {\n                    log.set(\"already_annotating\", true);\n                    return;\n                }\n            }\n        }\n        await this._enqueueEvent(eventType, content, attachments, relatedTxnId, null, log);\n    }\n\n    async _enqueueEvent(eventType, content, attachments, relatedTxnId, relatedEventId, log) {\n        const pendingEvent = await this._createAndStoreEvent(eventType, content, relatedTxnId, relatedEventId, attachments);\n        this._pendingEvents.set(pendingEvent);\n        log.set(\"queueIndex\", pendingEvent.queueIndex);\n        log.set(\"pendingEvents\", this._pendingEvents.length);\n        if (!this._isSending && !this._offline) {\n            this._sendLoop(log);\n        }\n        if (this._sendLoopLogItem) {\n            log.refDetached(this._sendLoopLogItem);\n        }\n    }\n\n    async enqueueRedaction(eventIdOrTxnId, reason, log) {\n        const isAlreadyRedacting = this._pendingEvents.array.some(pe => {\n            return pe.eventType === REDACTION_TYPE &&\n                (pe.relatedTxnId === eventIdOrTxnId || pe.relatedEventId === eventIdOrTxnId);\n        });\n        if (isAlreadyRedacting) {\n            log.set(\"already_redacting\", true);\n            return;\n        }\n        let relatedTxnId;\n        let relatedEventId;\n        if (isTxnId(eventIdOrTxnId)) {\n            relatedTxnId = eventIdOrTxnId;\n            const txnId = eventIdOrTxnId;\n            const pe = this._pendingEvents.array.find(pe => pe.txnId === txnId);\n            if (pe && !pe.remoteId && pe.status !== SendStatus.Sending) {\n                // haven't started sending this event yet,\n                // just remove it from the queue\n                log.set(\"remove\", relatedTxnId);\n                await pe.abort();\n                return;\n            } else if (pe) {\n                relatedEventId = pe.remoteId;\n            } else {\n                // we don't have the pending event anymore,\n                // the remote echo must have arrived in the meantime.\n                // we could look for it in the timeline, but for now\n                // we don't do anything as this race is quite unlikely\n                // and a bit complicated to fix.\n                return;\n            }\n        } else {\n            relatedEventId = eventIdOrTxnId;\n            const pe = this._pendingEvents.array.find(pe => pe.remoteId === relatedEventId);\n            if (pe) {\n                // also set the txn id just in case that an event id was passed\n                // for relating to a pending event that is still waiting for the remote echo\n                relatedTxnId = pe.txnId;\n            }\n        }\n        log.set(\"relatedTxnId\", relatedTxnId);\n        log.set(\"relatedEventId\", relatedEventId);\n        await this._enqueueEvent(REDACTION_TYPE, {reason}, null, relatedTxnId, relatedEventId, log);\n    }\n\n    get pendingEvents() {\n        return this._pendingEvents;\n    }\n\n    async _tryUpdateEvent(pendingEvent) {\n        const txn = await this._storage.readWriteTxn([this._storage.storeNames.pendingEvents]);\n        try {\n            this._tryUpdateEventWithTxn(pendingEvent, txn);\n        } catch (err) {\n            txn.abort();\n            throw err;\n        }\n        await txn.complete();\n    }\n\n    async _tryUpdateEventWithTxn(pendingEvent, txn) {\n        // pendingEvent might have been removed already here\n        // by a racing remote echo, so check first so we don't recreate it\n        if (await txn.pendingEvents.exists(pendingEvent.roomId, pendingEvent.queueIndex)) {\n            txn.pendingEvents.update(pendingEvent.data);\n        }\n    }\n\n    async _createAndStoreEvent(eventType, content, relatedTxnId, relatedEventId, attachments) {\n        const txn = await this._storage.readWriteTxn([this._storage.storeNames.pendingEvents]);\n        let pendingEvent;\n        try {\n            const pendingEventsStore = txn.pendingEvents;\n            const maxStorageQueueIndex = await pendingEventsStore.getMaxQueueIndex(this._roomId) || 0;\n            // don't use the queueIndex of the pendingEvent currently waiting for /send to return\n            // if the remote echo already removed the pendingEvent in storage, as the send loop\n            // wouldn't be able to detect the remote echo already arrived and end up overwriting the new event\n            const maxQueueIndex = Math.max(maxStorageQueueIndex, this._currentQueueIndex);\n            const queueIndex = maxQueueIndex + 1;\n            const needsEncryption = eventType !== REDACTION_TYPE &&\n                eventType !== REACTION_TYPE &&\n                !!this._roomEncryption;\n            pendingEvent = this._createPendingEvent({\n                roomId: this._roomId,\n                queueIndex,\n                eventType,\n                content,\n                relatedTxnId,\n                relatedEventId,\n                txnId: makeTxnId(),\n                needsEncryption,\n                needsUpload: !!attachments\n            }, attachments);\n            pendingEventsStore.add(pendingEvent.data);\n        } catch (err) {\n            txn.abort();\n            throw err;\n        }\n        await txn.complete();\n        return pendingEvent;\n    }\n\n    dispose() {\n        for (const pe of this._pendingEvents) {\n            pe.dispose();\n        }\n    }\n}\n\nimport {HomeServer as MockHomeServer} from \"../../../mocks/HomeServer.js\";\nimport {createMockStorage} from \"../../../mocks/Storage\";\nimport {ListObserver} from \"../../../mocks/ListObserver.js\";\nimport {NullLogger, NullLogItem} from \"../../../logging/NullLogger\";\nimport {createEvent, withTextBody, withTxnId} from \"../../../mocks/event.js\";\nimport {poll} from \"../../../mocks/poll.js\";\nimport {createAnnotation} from \"../timeline/relations.js\";\n\nexport function tests() {\n    const logger = new NullLogger();\n    return {\n        \"enqueue second message when remote echo of first arrives before /send returns\": async assert => {\n            const storage = await createMockStorage();\n            const hs = new MockHomeServer();\n            // 1. enqueue and start send event 1\n            const queue = new SendQueue({roomId: \"!abc\", storage, hsApi: hs.api});\n            const event1 = withTextBody(\"message 1\", createEvent(\"m.room.message\", \"$123\"));\n            await logger.run(\"event1\", log => queue.enqueueEvent(event1.type, event1.content, null, log));\n            assert.equal(queue.pendingEvents.length, 1);\n            const sendRequest1 = hs.requests.send[0];\n            // 2. receive remote echo, before /send has returned\n            const remoteEcho = withTxnId(sendRequest1.arguments[2], event1);\n            const txn = await storage.readWriteTxn([storage.storeNames.pendingEvents]);\n            const removal = await logger.run(\"remote echo\", log => queue.removeRemoteEchos([remoteEcho], txn, log));\n            await txn.complete();\n            assert.equal(removal.length, 1);\n            queue.emitRemovals(removal);\n            assert.equal(queue.pendingEvents.length, 0);\n            // 3. now enqueue event 2\n            const event2 = withTextBody(\"message 2\", createEvent(\"m.room.message\", \"$456\"));\n            await logger.run(\"event2\", log => queue.enqueueEvent(event2.type, event2.content, null, log));\n            // even though the first pending event has been removed by the remote echo,\n            // the second should get the next index, as the send loop is still blocking on the first one\n            assert.equal(Array.from(queue.pendingEvents)[0].queueIndex, 2);\n            // 4. send for event 1 comes back\n            sendRequest1.respond({event_id: event1.event_id});\n            // 5. now expect second send request for event 2\n            const sendRequest2 = await poll(() => hs.requests.send[1]);\n            sendRequest2.respond({event_id: event2.event_id});\n            await poll(() => !queue._isSending);\n        },\n        \"redaction of pending event that hasn't started sending yet aborts it\": async assert => {\n            const queue = new SendQueue({\n                roomId: \"!abc\",\n                storage: await createMockStorage(),\n                hsApi: new MockHomeServer().api\n            });\n            // first, enqueue a message that will be attempted to send, but we don't respond\n            await queue.enqueueEvent(\"m.room.message\", {body: \"hello!\"}, null, new NullLogItem());\n\n            const observer = new ListObserver();\n            queue.pendingEvents.subscribe(observer);\n            await queue.enqueueEvent(\"m.room.message\", {body: \"...world\"}, null, new NullLogItem());\n            let txnId;\n            {\n                const {type, index, value} = await observer.next();\n                assert.equal(type, \"add\");\n                assert.equal(index, 1);\n                assert.equal(typeof value.txnId, \"string\");\n                txnId = value.txnId;\n            }\n            await queue.enqueueRedaction(txnId, null, new NullLogItem());\n            {\n                const {type, value, index} = await observer.next();\n                assert.equal(type, \"remove\");\n                assert.equal(index, 1);\n                assert.equal(txnId, value.txnId);\n            }\n        },\n        \"duplicate redaction gets dropped\": async assert => {\n            const queue = new SendQueue({\n                roomId: \"!abc\",\n                storage: await createMockStorage(),\n                hsApi: new MockHomeServer().api\n            });\n            assert.equal(queue.pendingEvents.length, 0);\n            await queue.enqueueRedaction(\"!event\", null, new NullLogItem());\n            assert.equal(queue.pendingEvents.length, 1);\n            await queue.enqueueRedaction(\"!event\", null, new NullLogItem());\n            assert.equal(queue.pendingEvents.length, 1);\n        },\n        \"duplicate reaction gets dropped\": async assert => {\n            const queue = new SendQueue({\n                roomId: \"!abc\",\n                storage: await createMockStorage(),\n                hsApi: new MockHomeServer().api\n            });\n            assert.equal(queue.pendingEvents.length, 0);\n            await queue.enqueueEvent(\"m.reaction\", createAnnotation(\"!target\", \"🚀\"), null, new NullLogItem());\n            assert.equal(queue.pendingEvents.length, 1);\n            await queue.enqueueEvent(\"m.reaction\", createAnnotation(\"!target\", \"👋\"), null, new NullLogItem());\n            assert.equal(queue.pendingEvents.length, 2);\n            await queue.enqueueEvent(\"m.reaction\", createAnnotation(\"!target\", \"🚀\"), null, new NullLogItem());\n            assert.equal(queue.pendingEvents.length, 2);\n        },\n        \n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {encryptAttachment} from \"../e2ee/attachment.js\";\n\nexport class AttachmentUpload {\n    constructor({filename, blob, platform}) {\n        this._filename = filename;\n        // need to keep around for local preview while uploading\n        this._unencryptedBlob = blob;\n        this._transferredBlob = this._unencryptedBlob;\n        this._platform = platform;\n        this._mxcUrl = null;\n        this._encryptionInfo = null;\n        this._uploadRequest = null;\n        this._aborted = false;\n        this._error = null;\n        this._sentBytes = 0;\n    }\n\n    /** important to call after encrypt() if encryption is needed */\n    get size() {\n        return this._transferredBlob.size;\n    }\n\n    get sentBytes() {\n        return this._sentBytes;\n    }\n\n    abort() {\n        this._uploadRequest?.abort();\n    }\n\n    get localPreview() {\n        return this._unencryptedBlob;\n    }\n\n    /** @internal */\n    async encrypt() {\n        if (this._encryptionInfo) {\n            throw new Error(\"already encrypted\");\n        }\n        const {info, blob} = await encryptAttachment(this._platform, this._transferredBlob);\n        this._transferredBlob = blob;\n        this._encryptionInfo = info;\n    }\n\n    /** @internal */\n    async upload(hsApi, progressCallback, log) {\n        this._uploadRequest = hsApi.uploadAttachment(this._transferredBlob, this._filename, {\n            uploadProgress: sentBytes => {\n                this._sentBytes = sentBytes;\n                progressCallback();\n            },\n            log\n        });\n        const {content_uri} = await this._uploadRequest.response();\n        this._mxcUrl = content_uri;\n    }\n\n    /** @internal */\n    applyToContent(urlPath, content) {\n        if (!this._mxcUrl) {\n            throw new Error(\"upload has not finished\");\n        }\n        let prefix = urlPath.substr(0, urlPath.lastIndexOf(\"url\"));\n        setPath(`${prefix}info.size`, content, this._transferredBlob.size);\n        setPath(`${prefix}info.mimetype`, content, this._unencryptedBlob.mimeType);\n        if (this._encryptionInfo) {\n            setPath(`${prefix}file`, content, Object.assign(this._encryptionInfo, {\n                mimetype: this._unencryptedBlob.mimeType,\n                url: this._mxcUrl\n            }));\n        } else {\n            setPath(`${prefix}url`, content, this._mxcUrl);\n        }\n    }\n\n    dispose() {\n        this._unencryptedBlob.dispose();\n        this._transferredBlob.dispose();\n    }\n}\n\nfunction setPath(path, content, value) {\n    const parts = path.split(\".\");\n    let obj = content;\n    for (let i = 0; i < (parts.length - 1); i += 1) {\n        const key = parts[i];\n        if (!obj[key]) {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    const propKey = parts[parts.length - 1];\n    obj[propKey] = value;\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseRoom} from \"./BaseRoom.js\";\nimport {SyncWriter} from \"./timeline/persistence/SyncWriter.js\";\nimport {MemberWriter} from \"./timeline/persistence/MemberWriter.js\";\nimport {RelationWriter} from \"./timeline/persistence/RelationWriter.js\";\nimport {SendQueue} from \"./sending/SendQueue.js\";\nimport {WrappedError} from \"../error.js\"\nimport {Heroes} from \"./members/Heroes.js\";\nimport {AttachmentUpload} from \"./AttachmentUpload.js\";\nimport {DecryptionSource} from \"../e2ee/common.js\";\nimport {PowerLevels, EVENT_TYPE as POWERLEVELS_EVENT_TYPE } from \"./PowerLevels.js\";\n\nconst EVENT_ENCRYPTED_TYPE = \"m.room.encrypted\";\n\nexport class Room extends BaseRoom {\n    constructor(options) {\n        super(options);\n        // TODO: pass pendingEvents to start like pendingOperations?\n        const {pendingEvents} = options;\n        const relationWriter = new RelationWriter({\n            roomId: this.id,\n            fragmentIdComparer: this._fragmentIdComparer,\n            ownUserId: this._user.id\n        });\n        this._syncWriter = new SyncWriter({\n            roomId: this.id,\n            fragmentIdComparer: this._fragmentIdComparer,\n            relationWriter,\n            memberWriter: new MemberWriter(this.id)\n        });\n        this._sendQueue = new SendQueue({roomId: this.id, storage: this._storage, hsApi: this._hsApi, pendingEvents});\n    }\n\n    _setEncryption(roomEncryption) {\n        if (super._setEncryption(roomEncryption)) {\n            this._sendQueue.enableEncryption(this._roomEncryption);\n            return true;\n        }\n        return false;\n    }\n\n    async prepareSync(roomResponse, membership, newKeys, txn, log) {\n        log.set(\"id\", this.id);\n        if (newKeys) {\n            log.set(\"newKeys\", newKeys.length);\n        }\n        let summaryChanges = this._summary.data.applySyncResponse(roomResponse, membership, this._user.id);\n        let roomEncryption = this._roomEncryption;\n        // encryption is enabled in this sync\n        if (!roomEncryption && summaryChanges.encryption) {\n            log.set(\"enableEncryption\", true);\n            roomEncryption = this._createRoomEncryption(this, summaryChanges.encryption);\n        }\n\n        let retryEntries;\n        let decryptPreparation;\n        if (roomEncryption) {\n            let eventsToDecrypt = roomResponse?.timeline?.events || [];\n            // when new keys arrive, also see if any older events can now be retried to decrypt\n            if (newKeys) {\n                // TODO: if a key is considered by roomEncryption.prepareDecryptAll to use for decryption,\n                // key.eventIds will be set. We could somehow try to reuse that work, but retrying also needs\n                // to happen if a key is not needed to decrypt this sync or there are indeed no encrypted messages\n                // in this sync at all.\n                retryEntries = await this._getSyncRetryDecryptEntries(newKeys, roomEncryption, txn);\n                if (retryEntries.length) {\n                    log.set(\"retry\", retryEntries.length);\n                    eventsToDecrypt = eventsToDecrypt.concat(retryEntries.map(entry => entry.event));\n                }\n            }\n            eventsToDecrypt = eventsToDecrypt.filter(event => {\n                return event?.type === EVENT_ENCRYPTED_TYPE;\n            });\n            if (eventsToDecrypt.length) {\n                decryptPreparation = await roomEncryption.prepareDecryptAll(\n                    eventsToDecrypt, newKeys, DecryptionSource.Sync, txn);\n            }\n        }\n\n        return {\n            roomEncryption,\n            summaryChanges,\n            decryptPreparation,\n            decryptChanges: null,\n            retryEntries\n        };\n    }\n\n    async afterPrepareSync(preparation, parentLog) {\n        if (preparation.decryptPreparation) {\n            await parentLog.wrap(\"decrypt\", async log => {\n                log.set(\"id\", this.id);\n                preparation.decryptChanges = await preparation.decryptPreparation.decrypt();\n                preparation.decryptPreparation = null;\n            }, parentLog.level.Detail);\n        }\n    }\n\n    /** @package */\n    async writeSync(roomResponse, isInitialSync, {summaryChanges, decryptChanges, roomEncryption, retryEntries}, txn, log) {\n        log.set(\"id\", this.id);\n        const isRejoin = summaryChanges.isNewJoin(this._summary.data);\n        if (isRejoin) {\n            // remove all room state before calling syncWriter,\n            // so no old state sticks around\n            txn.roomState.removeAllForRoom(this.id);\n            txn.roomMembers.removeAllForRoom(this.id);\n        }\n        const {entries: newEntries, updatedEntries, newLiveKey, memberChanges} =\n            await log.wrap(\"syncWriter\", log => this._syncWriter.writeSync(\n                roomResponse, isRejoin, summaryChanges.hasFetchedMembers, txn, log), log.level.Detail);\n        if (decryptChanges) {\n            const decryption = await log.wrap(\"decryptChanges\", log => decryptChanges.write(txn, log));\n            log.set(\"decryptionResults\", decryption.results.size);\n            log.set(\"decryptionErrors\", decryption.errors.size);\n            if (this._isTimelineOpen) {\n                await decryption.verifySenders(txn);\n            }\n            decryption.applyToEntries(newEntries);\n            if (retryEntries?.length) {\n                decryption.applyToEntries(retryEntries);\n                updatedEntries.push(...retryEntries);\n            }\n        }\n        log.set(\"newEntries\", newEntries.length);\n        log.set(\"updatedEntries\", updatedEntries.length);\n        let shouldFlushKeyShares = false;\n        // pass member changes to device tracker\n        if (roomEncryption && this.isTrackingMembers && memberChanges?.size) {\n            shouldFlushKeyShares = await roomEncryption.writeMemberChanges(memberChanges, txn, log);\n            log.set(\"shouldFlushKeyShares\", shouldFlushKeyShares);\n        }\n        const allEntries = newEntries.concat(updatedEntries);\n        // also apply (decrypted) timeline entries to the summary changes\n        summaryChanges = summaryChanges.applyTimelineEntries(\n            allEntries, isInitialSync, !this._isTimelineOpen, this._user.id);\n        \n        // if we've have left the room, remove the summary\n        if (summaryChanges.membership !== \"join\") {\n            txn.roomSummary.remove(this.id);\n        } else {\n            // write summary changes, and unset if nothing was actually changed\n            summaryChanges = this._summary.writeData(summaryChanges, txn);\n        }\n        if (summaryChanges) {\n            log.set(\"summaryChanges\", summaryChanges.diff(this._summary.data));\n        }\n        // fetch new members while we have txn open,\n        // but don't make any in-memory changes yet\n        let heroChanges;\n        // if any hero changes their display name, the summary in the room response\n        // is also updated, which will trigger a RoomSummary update\n        // and make summaryChanges non-falsy here\n        if (summaryChanges?.needsHeroes) {\n            // room name disappeared, open heroes\n            if (!this._heroes) {\n                this._heroes = new Heroes(this._roomId);\n            }\n            heroChanges = await this._heroes.calculateChanges(summaryChanges.heroes, memberChanges, txn);\n        }\n        let removedPendingEvents;\n        if (Array.isArray(roomResponse.timeline?.events)) {\n            removedPendingEvents = await this._sendQueue.removeRemoteEchos(roomResponse.timeline.events, txn, log);\n        }\n        const powerLevelsEvent = this._getPowerLevelsEvent(roomResponse);\n        return {\n            summaryChanges,\n            roomEncryption,\n            newEntries,\n            updatedEntries,\n            newLiveKey,\n            removedPendingEvents,\n            memberChanges,\n            heroChanges,\n            powerLevelsEvent,\n            shouldFlushKeyShares,\n        };\n    }\n\n    /**\n     * @package\n     * Called with the changes returned from `writeSync` to apply them and emit changes.\n     * No storage or network operations should be done here.\n     */\n    afterSync(changes, log) {\n        const {\n            summaryChanges, newEntries, updatedEntries, newLiveKey,\n            removedPendingEvents, memberChanges, powerLevelsEvent,\n            heroChanges, roomEncryption\n        } = changes;\n        log.set(\"id\", this.id);\n        this._syncWriter.afterSync(newLiveKey);\n        this._setEncryption(roomEncryption);\n        if (memberChanges.size) {\n            if (this._changedMembersDuringSync) {\n                for (const [userId, memberChange] of memberChanges.entries()) {\n                    this._changedMembersDuringSync.set(userId, memberChange.member);\n                }\n            }\n            if (this._memberList) {\n                this._memberList.afterSync(memberChanges);\n            }\n            if (this._observedMembers) {\n                this._updateObservedMembers(memberChanges);\n            }\n            if (this._timeline) {\n                for (const [userId, memberChange] of memberChanges.entries()) {\n                    if (userId === this._user.id) {\n                        this._timeline.updateOwnMember(memberChange.member);\n                        break;\n                    }\n                }\n            }\n        }\n        let emitChange = false;\n        if (summaryChanges) {\n            this._summary.applyChanges(summaryChanges);\n            if (!this._summary.data.needsHeroes) {\n                this._heroes = null;\n            }\n            emitChange = true;\n        }\n        if (this._heroes && heroChanges) {\n            const oldName = this.name;\n            this._heroes.applyChanges(heroChanges, this._summary.data, log);\n            if (oldName !== this.name) {\n                emitChange = true;\n            }\n        }\n        if (powerLevelsEvent) {\n            this._updatePowerLevels(powerLevelsEvent);\n        }\n        if (emitChange) {\n            this._emitUpdate();\n        }\n        if (this._timeline) {\n            // these should not be added if not already there\n            this._timeline.replaceEntries(updatedEntries);\n            this._timeline.addEntries(newEntries);\n        }\n        if (this._observedEvents) {\n            this._observedEvents.updateEvents(updatedEntries);\n            this._observedEvents.updateEvents(newEntries);\n        }\n        if (removedPendingEvents) {\n            this._sendQueue.emitRemovals(removedPendingEvents);\n        }\n    }\n\n    _updateObservedMembers(memberChanges) {\n        for (const [userId, memberChange] of memberChanges) {\n            const observableMember = this._observedMembers.get(userId);\n            if (observableMember) {\n                observableMember.set(memberChange.member);\n            }\n        }\n    }\n\n    _getPowerLevelsEvent(roomResponse) {\n        const isPowerlevelEvent = event => event.state_key === \"\" && event.type === POWERLEVELS_EVENT_TYPE;\n        const powerLevelEvent = roomResponse.timeline?.events.find(isPowerlevelEvent) ?? roomResponse.state?.events.find(isPowerlevelEvent);\n        return powerLevelEvent;\n    }\n\n    _updatePowerLevels(powerLevelEvent) {\n        if (this._powerLevels) {\n            const newPowerLevels = new PowerLevels({\n                powerLevelEvent,\n                ownUserId: this._user.id,\n                membership: this.membership,\n            });\n            this._powerLevels.set(newPowerLevels);\n        }\n    }\n\n    needsAfterSyncCompleted({shouldFlushKeyShares}) {\n        return shouldFlushKeyShares;\n    }\n\n    /**\n     * Only called if the result of writeSync had `needsAfterSyncCompleted` set.\n     * Can be used to do longer running operations that resulted from the last sync,\n     * like network operations.\n     */\n    async afterSyncCompleted(changes, log) {\n        log.set(\"id\", this.id);\n        if (this._roomEncryption) {\n            await this._roomEncryption.flushPendingRoomKeyShares(this._hsApi, null, log);\n        }\n    }\n\n    /** @package */\n    start(pendingOperations, parentLog) {\n        if (this._roomEncryption) {\n            const roomKeyShares = pendingOperations?.get(\"share_room_key\");\n            if (roomKeyShares) {\n                // if we got interrupted last time sending keys to newly joined members\n                parentLog.wrapDetached(\"flush room keys\", log => {\n                    log.set(\"id\", this.id);\n                    return this._roomEncryption.flushPendingRoomKeyShares(this._hsApi, roomKeyShares, log);\n                });\n            }\n        }\n        \n        this._sendQueue.resumeSending(parentLog);\n    }\n\n    /** @package */\n    async load(summary, txn, log) {\n        try {\n            await super.load(summary, txn, log);\n            await this._syncWriter.load(txn, log);\n        } catch (err) {\n            throw new WrappedError(`Could not load room ${this._roomId}`, err);\n        }\n    }\n\n    async _writeGapFill(gapChunk, txn, log) {\n        const removedPendingEvents = await this._sendQueue.removeRemoteEchos(gapChunk, txn, log);\n        return removedPendingEvents;\n    }\n\n    _applyGapFill(removedPendingEvents) {\n        this._sendQueue.emitRemovals(removedPendingEvents);\n    }\n\n    /** @public */\n    sendEvent(eventType, content, attachments, log = null) {\n        return this._platform.logger.wrapOrRun(log, \"send\", log => {\n            log.set(\"id\", this.id);\n            return this._sendQueue.enqueueEvent(eventType, content, attachments, log);\n        });\n    }\n\n    /** @public */\n    sendRedaction(eventIdOrTxnId, reason, log = null) {\n        return this._platform.logger.wrapOrRun(log, \"redact\", log => {\n            log.set(\"id\", this.id);\n            return this._sendQueue.enqueueRedaction(eventIdOrTxnId, reason, log);\n        });\n    }\n\n    /** @public */\n    async ensureMessageKeyIsShared(log = null) {\n        if (!this._roomEncryption) {\n            return;\n        }\n        return this._platform.logger.wrapOrRun(log, \"ensureMessageKeyIsShared\", log => {\n            log.set(\"id\", this.id);\n            return this._roomEncryption.ensureMessageKeyIsShared(this._hsApi, log);\n        });\n    }\n\n    get avatarColorId() {\n        return this._heroes?.roomAvatarColorId || this._roomId;\n    }\n\n    get isUnread() {\n        return this._summary.data.isUnread;\n    }\n\n    get notificationCount() {\n        return this._summary.data.notificationCount;\n    }\n    \n    get highlightCount() {\n        return this._summary.data.highlightCount;\n    }\n\n    get isTrackingMembers() {\n        return this._summary.data.isTrackingMembers;\n    }\n\n    async _getLastEventId() {\n        const lastKey = this._syncWriter.lastMessageKey;\n        if (lastKey) {\n            const txn = await this._storage.readTxn([\n                this._storage.storeNames.timelineEvents,\n            ]);\n            const eventEntry = await txn.timelineEvents.get(this._roomId, lastKey);\n            return eventEntry?.event?.event_id;\n        }\n    }\n\n    async clearUnread(log = null) {\n        if (this.isUnread || this.notificationCount) {\n            return await this._platform.logger.wrapOrRun(log, \"clearUnread\", async log => {\n                log.set(\"id\", this.id);\n                const txn = await this._storage.readWriteTxn([\n                    this._storage.storeNames.roomSummary,\n                ]);\n                let data;\n                try {\n                    data = this._summary.writeClearUnread(txn);\n                } catch (err) {\n                    txn.abort();\n                    throw err;\n                }\n                await txn.complete();\n                this._summary.applyChanges(data);\n                this._emitUpdate();\n                \n                try {\n                    const lastEventId = await this._getLastEventId();\n                    if (lastEventId) {\n                        await this._hsApi.receipt(this._roomId, \"m.read\", lastEventId);\n                    }\n                } catch (err) {\n                    // ignore ConnectionError\n                    if (err.name !== \"ConnectionError\") {\n                        throw err;\n                    }\n                }\n            });\n        }\n    }\n\n    leave(log = null) {\n        return this._platform.logger.wrapOrRun(log, \"leave room\", async log => {\n            log.set(\"id\", this.id);\n            await this._hsApi.leave(this.id, {log}).response();\n        });\n    }\n\n    /* called by BaseRoom to pass pendingEvents when opening the timeline */\n    _getPendingEvents() {\n        return this._sendQueue.pendingEvents;\n    }\n\n    /** @package */\n    writeIsTrackingMembers(value, txn) {\n        return this._summary.writeIsTrackingMembers(value, txn);\n    }\n\n    /** @package */\n    applyIsTrackingMembersChanges(changes) {\n        this._summary.applyChanges(changes);\n    }\n\n    createAttachment(blob, filename) {\n        return new AttachmentUpload({blob, filename, platform: this._platform});\n    }\n\n    dispose() {\n        super.dispose();\n        this._sendQueue.dispose();\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {reduceStateEvents} from \"./RoomSummary.js\";\nimport {BaseRoom} from \"./BaseRoom.js\";\nimport {RoomMember, EVENT_TYPE as MEMBER_EVENT_TYPE} from \"./members/RoomMember.js\";\n\nexport class ArchivedRoom extends BaseRoom {\n    constructor(options) {\n        super(options);\n        // archived rooms are reference counted,\n        // as they are not kept in memory when not needed\n        this._releaseCallback = options.releaseCallback;\n        this._forgetCallback = options.forgetCallback;\n        this._retentionCount = 1;\n        /**\n        Some details from our own member event when being kicked or banned.\n        We can't get this from the member store, because we don't store the reason field there.\n        */\n        this._kickDetails = null;\n        this._kickedBy = null;\n    }\n\n    retain() {\n        this._retentionCount += 1;\n    }\n\n    release() {\n        this._retentionCount -= 1;\n        if (this._retentionCount === 0) {\n            this._releaseCallback();\n        }\n    }\n\n    async _getKickAuthor(sender, txn) {\n        const senderMember = await txn.roomMembers.get(this.id, sender);\n        if (senderMember) {\n            return new RoomMember(senderMember);\n        } else {\n            return RoomMember.fromUserId(this.id, sender, \"join\");\n        }\n    }\n    \n    async load(archivedRoomSummary, txn, log) {\n        const {summary, kickDetails} = archivedRoomSummary;\n        this._kickDetails = kickDetails;\n        if (this._kickDetails) {\n            this._kickedBy = await this._getKickAuthor(this._kickDetails.sender, txn);\n        }\n        return super.load(summary, txn, log);\n    }\n\n    /** @package */\n    async writeSync(joinedSummaryData, roomResponse, membership, txn, log) {\n        log.set(\"id\", this.id);\n        if (membership === \"leave\") {\n            const newKickDetails = findKickDetails(roomResponse, this._user.id);\n            if (newKickDetails || joinedSummaryData) {\n                const kickDetails = newKickDetails || this._kickDetails;\n                let kickedBy;\n                if (newKickDetails) {\n                    kickedBy = await this._getKickAuthor(newKickDetails.sender, txn);\n                }\n                const summaryData = joinedSummaryData || this._summary.data;\n                txn.archivedRoomSummary.set({\n                    summary: summaryData.serialize(),\n                    kickDetails,\n                });\n                return {kickDetails, kickedBy, summaryData};\n            }\n        } else if (membership === \"join\") {\n            txn.archivedRoomSummary.remove(this.id);\n        }\n        // always return object\n        return {};\n    }\n\n    /**\n     * @package\n     * Called with the changes returned from `writeSync` to apply them and emit changes.\n     * No storage or network operations should be done here.\n     */\n    afterSync({summaryData, kickDetails, kickedBy}, log) {\n        log.set(\"id\", this.id);\n        if (summaryData) {\n            this._summary.applyChanges(summaryData);\n        }\n        if (kickDetails) {\n            this._kickDetails = kickDetails;\n        }\n        if (kickedBy) {\n            this._kickedBy = kickedBy;\n        }\n        this._emitUpdate();\n    }\n\n    get isKicked() {\n        return this._kickDetails?.membership === \"leave\";\n    }\n\n    get isBanned() {\n        return this._kickDetails?.membership === \"ban\";\n    }\n\n    get kickedBy() {\n        return this._kickedBy;\n    }\n\n    get kickReason() {\n        return this._kickDetails?.reason;\n    }\n\n    isArchived() {\n        return true;\n    }\n\n    forget(log = null) {\n        return this._platform.logger.wrapOrRun(log, \"forget room\", async log => {\n            log.set(\"id\", this.id);\n            await this._hsApi.forget(this.id, {log}).response();\n            const storeNames = this._storage.storeNames;\n            const txn = await this._storage.readWriteTxn([\n                storeNames.roomState,\n                storeNames.archivedRoomSummary,\n                storeNames.roomMembers,\n                storeNames.timelineEvents,\n                storeNames.timelineFragments,\n                storeNames.timelineRelations,\n                storeNames.pendingEvents,\n                storeNames.inboundGroupSessions,\n                storeNames.groupSessionDecryptions,\n                storeNames.operations,\n            ]);\n\n            txn.roomState.removeAllForRoom(this.id);\n            txn.archivedRoomSummary.remove(this.id);\n            txn.roomMembers.removeAllForRoom(this.id);\n            txn.timelineEvents.removeAllForRoom(this.id);\n            txn.timelineFragments.removeAllForRoom(this.id);\n            txn.timelineRelations.removeAllForRoom(this.id);\n            txn.pendingEvents.removeAllForRoom(this.id);\n            txn.inboundGroupSessions.removeAllForRoom(this.id);\n            txn.groupSessionDecryptions.removeAllForRoom(this.id);\n            await txn.operations.removeAllForScope(this.id);\n\n            await txn.complete();\n\n            this._retentionCount = 0;\n            this._releaseCallback();\n            \n            this._forgetCallback(this.id);\n        });\n    }\n\n    join(log = null) {\n        return this._platform.logger.wrapOrRun(log, \"rejoin archived room\", async log => {\n            await this._hsApi.join(this.id, {log}).response();\n        });\n    }\n}\n\nfunction findKickDetails(roomResponse, ownUserId) {\n    const kickEvent = reduceStateEvents(roomResponse, (kickEvent, event) => {\n        if (event.type === MEMBER_EVENT_TYPE) {\n            // did we get kicked?\n            if (event.state_key === ownUserId && event.sender !== event.state_key) {\n                kickEvent = event;\n            }\n        }\n        return kickEvent;\n    }, null);\n    if (kickEvent) {\n        return {\n            // this is different from the room membership in the sync section, which can only be leave\n            membership: kickEvent.content?.membership, // could be leave or ban\n            reason: kickEvent.content?.reason,\n            sender: kickEvent.sender,\n        };\n    }\n}\n\nexport function tests() {\n    function createMemberEvent(sender, target, membership, reason) {\n        return {\n            sender,\n            state_key: target,\n            type: \"m.room.member\",\n            content: { reason, membership }\n        };\n    }\n    const bob = \"@bob:hs.tld\";\n    const alice = \"@alice:hs.tld\";\n\n    return {\n        \"ban/kick sets kickDetails from state event\": assert => {\n            const reason = \"Bye!\";\n            const leaveEvent = createMemberEvent(alice, bob, \"ban\", reason);\n            const kickDetails = findKickDetails({state: {events: [leaveEvent]}}, bob);\n            assert.equal(kickDetails.membership, \"ban\");\n            assert.equal(kickDetails.reason, reason);\n            assert.equal(kickDetails.sender, alice);\n        },\n        \"ban/kick sets kickDetails from timeline state event, taking precedence over state\": assert => {\n            const reason = \"Bye!\";\n            const inviteEvent = createMemberEvent(alice, bob, \"invite\");\n            const leaveEvent = createMemberEvent(alice, bob, \"ban\", reason);\n            const kickDetails = findKickDetails({\n                state: { events: [inviteEvent] },\n                timeline: {events: [leaveEvent] }\n            }, bob);\n            assert.equal(kickDetails.membership, \"ban\");\n            assert.equal(kickDetails.reason, reason);\n            assert.equal(kickDetails.sender, alice);\n        },\n        \"leaving without being kicked doesn't produce kickDetails\": assert => {\n            const leaveEvent = createMemberEvent(bob, bob, \"leave\");\n            const kickDetails = findKickDetails({state: {events: [leaveEvent]}}, bob);\n            assert.equal(kickDetails, null);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type {HomeServerApi} from \"./net/HomeServerApi\";\nimport type {ILogItem} from \"../logging/types\";\n\nexport async function loadProfiles(userIds: string[], hsApi: HomeServerApi, log: ILogItem): Promise<Profile[]> {\n    const profiles = await Promise.all(userIds.map(async userId => {\n        const response = await hsApi.profile(userId, {log}).response();\n        return new Profile(userId, response.displayname as string, response.avatar_url as string);\n    }));\n    profiles.sort((a, b) => a.name.localeCompare(b.name));\n    return profiles;\n}\n\nexport interface IProfile {\n    get userId(): string;\n    get displayName(): string | undefined;\n    get avatarUrl(): string | undefined;\n    get name(): string;\n}\n\nexport class Profile implements IProfile {\n    constructor(\n        public readonly userId: string,\n        public readonly displayName: string,\n        public readonly avatarUrl: string | undefined\n    ) {}\n\n    get name() { return this.displayName || this.userId; }\n}\n\nexport class UserIdProfile implements IProfile {\n    constructor(public readonly userId: string) {}\n    get displayName() { return undefined; }\n    get name() { return this.userId; }\n    get avatarUrl() { return undefined; }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {calculateRoomName} from \"./members/Heroes\";\nimport {createRoomEncryptionEvent} from \"../e2ee/common\";\nimport {MediaRepository} from \"../net/MediaRepository\";\nimport {EventEmitter} from \"../../utils/EventEmitter\";\nimport {AttachmentUpload} from \"./AttachmentUpload\";\nimport {loadProfiles, Profile, UserIdProfile} from \"../profile\";\nimport {RoomType} from \"./common\";\n\nimport type {HomeServerApi} from \"../net/HomeServerApi\";\nimport type {ILogItem} from \"../../logging/types\";\nimport type {Platform} from \"../../platform/web/Platform\";\nimport type {IBlobHandle} from \"../../platform/types/types\";\nimport type {User} from \"../User\";\nimport type {Storage} from \"../storage/idb/Storage\";\n\ntype CreateRoomPayload = {\n    is_direct?: boolean;\n    preset?: string;\n    name?: string;\n    topic?: string;\n    invite?: string[];\n    room_alias_name?: string;\n    creation_content?: {\"m.federate\": boolean};\n    initial_state: {type: string; state_key: string; content: Record<string, any>}[]\n}\n\ntype ImageInfo = {\n    w: number;\n    h: number;\n    mimetype: string;\n    size: number;\n}\n\ntype Avatar = {\n    info: ImageInfo;\n    blob: IBlobHandle;\n    name: string;\n}\n\ntype Options = {\n    type: RoomType;\n    isEncrypted?: boolean;\n    isFederationDisabled?: boolean;\n    name?: string;\n    topic?: string;\n    invites?: string[];\n    avatar?: Avatar;\n    alias?: string;\n}\n\nfunction defaultE2EEStatusForType(type: RoomType): boolean {\n    switch (type) {\n        case RoomType.DirectMessage:\n        case RoomType.Private:\n            return true;\n        case RoomType.Public:\n            return false;\n    }\n}\n\nfunction presetForType(type: RoomType): string {\n    switch (type) {\n        case RoomType.DirectMessage:\n            return \"trusted_private_chat\";\n        case RoomType.Private:\n            return \"private_chat\";\n        case RoomType.Public:\n            return \"public_chat\";\n    }\n}\n\nexport class RoomBeingCreated extends EventEmitter<{change: never}> {\n    private _roomId?: string;\n    private profiles: Profile[] = [];\n\n    public readonly isEncrypted: boolean;\n    private _calculatedName: string;\n    private _error?: Error;\n    private _isCancelled = false;\n\n    constructor(\n        public readonly id: string,\n        private readonly options: Options,\n        private readonly updateCallback: (self: RoomBeingCreated, params: string | undefined) => void,\n        public readonly mediaRepository: MediaRepository,\n        public readonly platform: Platform,\n        log: ILogItem\n    ) {\n        super();\n        this.isEncrypted = options.isEncrypted === undefined ? defaultE2EEStatusForType(options.type) : options.isEncrypted;\n        if (options.name) {\n            this._calculatedName = options.name;\n        } else {\n            const summaryData = {\n                joinCount: 1, // ourselves\n                inviteCount: (options.invites?.length || 0)\n            };\n            const userIdProfiles = (options.invites || []).map(userId => new UserIdProfile(userId));\n            this._calculatedName = calculateRoomName(userIdProfiles, summaryData, log);\n        }\n    }\n\n    /** @internal */\n    async create(hsApi: HomeServerApi, log: ILogItem): Promise<void> {\n        try {\n            let avatarEventContent;\n            if (this.options.avatar) {\n                const {avatar} = this.options;\n                const attachment = new AttachmentUpload({filename: avatar.name, blob: avatar.blob, platform: this.platform});\n                await attachment.upload(hsApi, () => {}, log);\n                avatarEventContent = {\n                    info: avatar.info\n                };\n                attachment.applyToContent(\"url\", avatarEventContent);\n            }\n            const createOptions: CreateRoomPayload = {\n                is_direct: this.options.type === RoomType.DirectMessage,\n                preset: presetForType(this.options.type),\n                initial_state: []\n            };\n            if (this.options.name) {\n                createOptions.name = this.options.name;\n            }\n            if (this.options.topic) {\n                createOptions.topic = this.options.topic;\n            }\n            if (this.options.invites) {\n                createOptions.invite = this.options.invites;\n            }\n            if (this.options.alias) {\n                createOptions.room_alias_name = this.options.alias;\n            }\n            if (this.options.isFederationDisabled === true) {\n                createOptions.creation_content = {\n                    \"m.federate\": false\n                };\n            }\n            if (this.isEncrypted) {\n                createOptions.initial_state.push(createRoomEncryptionEvent());\n            }\n            if (avatarEventContent) {\n                createOptions.initial_state.push({\n                    type: \"m.room.avatar\",\n                    state_key: \"\",\n                    content: avatarEventContent\n                });\n            }\n            const response = await hsApi.createRoom(createOptions, {log}).response();\n            this._roomId = response[\"room_id\"];\n        } catch (err) {\n            this._error = err;\n        }\n        this.emitChange();\n    }\n\n    /** requests the profiles of the invitees if needed to give an accurate\n     * estimated room name in case an explicit room name is not set.\n     * The room is being created in the background whether this is called\n     * or not, and this just gives a more accurate name while that request\n     * is running. */\n    /** @internal */\n    async loadProfiles(hsApi: HomeServerApi, log: ILogItem): Promise<void> {\n        try {\n            // only load profiles if we need it for the room name and avatar\n            if (!this.options.name && this.options.invites) {\n                this.profiles = await loadProfiles(this.options.invites, hsApi, log);\n                const summaryData = {\n                    joinCount: 1, // ourselves\n                    inviteCount: this.options.invites.length\n                };\n                this._calculatedName = calculateRoomName(this.profiles, summaryData, log);\n                this.emitChange();\n            }\n        } catch (err) {} // swallow error, loading profiles is not essential\n    }\n\n    private emitChange(params?: string) {\n        this.updateCallback(this, params);\n        this.emit(\"change\");\n    }\n\n    get avatarColorId(): string { return this.options.invites?.[0] ?? this._roomId ?? this.id; }\n    get avatarUrl(): string | undefined { return this.profiles?.[0]?.avatarUrl; }\n    get avatarBlobUrl(): string | undefined { return this.options.avatar?.blob?.url; }\n    get roomId(): string | undefined { return this._roomId; }\n    get name() { return this._calculatedName; }\n    get isBeingCreated(): boolean { return true; }\n    get error(): Error | undefined { return this._error; }\n\n    cancel() {\n        if (!this._isCancelled) {\n            this.dispose();\n            this._isCancelled = true;\n            this.emitChange(\"isCancelled\");\n        }\n    }\n    // called from Session when updateCallback is invoked to remove it from the collection\n    get isCancelled() { return this._isCancelled; }\n\n    /** @internal */\n    dispose() {\n        if (this.options.avatar) {\n            this.options.avatar.blob.dispose();\n        }\n    }\n\n    async adjustDirectMessageMapIfNeeded(user: User, storage: Storage, hsApi: HomeServerApi, log: ILogItem): Promise<void> {\n        if (!this.options.invites || this.options.type !== RoomType.DirectMessage) {\n            return;\n        }\n        const userId = this.options.invites[0];\n        const DM_MAP_TYPE = \"m.direct\";\n        await log.wrap(\"set \" + DM_MAP_TYPE, async log => {\n            try {\n                const txn = await storage.readWriteTxn([storage.storeNames.accountData]);\n                let mapEntry;\n                try {\n                    mapEntry = await txn.accountData.get(DM_MAP_TYPE);\n                    if (!mapEntry) {\n                        mapEntry = {type: DM_MAP_TYPE, content: {}};\n                    }\n                    const map = mapEntry.content;\n                    let userRooms = map[userId];\n                    if (!userRooms) {\n                        map[userId] = userRooms = [];\n                    }\n                    // this is a new room id so no need to check if it's already there\n                    userRooms.push(this._roomId);\n                    txn.accountData.set(mapEntry);\n                    await txn.complete();\n                } catch (err) {\n                    txn.abort();\n                    throw err;\n                }\n                await hsApi.setAccountData(user.id, DM_MAP_TYPE, mapEntry.content, {log}).response();\n            } catch (err) {\n                // we can't really do anything else but logging here\n                log.catch(err);\n            }\n        });\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {EventEmitter} from \"../../utils/EventEmitter\";\nimport {SummaryData, processStateEvent} from \"./RoomSummary.js\";\nimport {Heroes} from \"./members/Heroes.js\";\nimport {MemberChange, RoomMember, EVENT_TYPE as MEMBER_EVENT_TYPE} from \"./members/RoomMember.js\";\n\nexport class Invite extends EventEmitter {\n    constructor({roomId, user, hsApi, mediaRepository, emitCollectionRemove, emitCollectionUpdate, platform}) {\n        super();\n        this._roomId = roomId;\n        this._user = user;\n        this._hsApi = hsApi;\n        this._emitCollectionRemove = emitCollectionRemove;\n        this._emitCollectionUpdate = emitCollectionUpdate;\n        this._mediaRepository = mediaRepository;\n        this._platform = platform;\n        this._inviteData = null;\n        this._accepting = false;\n        this._rejecting = false;\n        this._accepted = false;\n        this._rejected = false;\n    }\n\n    get isInvite() {\n        return true;\n    }\n\n    get id() {\n        return this._roomId;\n    }\n\n    get name() {\n        return this._inviteData.name || this._inviteData.canonicalAlias;\n    }\n\n    get isDirectMessage() {\n        return this._inviteData.isDirectMessage;\n    }\n\n    get avatarUrl() {\n        return this._inviteData.avatarUrl;\n    }\n\n    /** @see BaseRoom.avatarColorId */\n    get avatarColorId() {\n        return this._inviteData.avatarColorId || this.id;\n    }\n\n    get timestamp() {\n        return this._inviteData.timestamp;\n    }\n\n    get isEncrypted() {\n        return this._inviteData.isEncrypted;\n    }\n\n    get inviter() {\n        return this._inviter;\n    }\n\n    isDirectMessageForUserId(userId) {\n        return this.isDirectMessage && this._inviter.userId === userId;\n    }\n\n    get isPublic() {\n        return this._inviteData.joinRule === \"public\";\n    }\n\n    get canonicalAlias() {\n        return this._inviteData.canonicalAlias;\n    }\n\n    async accept(log = null) {\n        await this._platform.logger.wrapOrRun(log, \"acceptInvite\", async log => {\n            this._accepting = true;\n            this._emitChange(\"accepting\");\n            await this._hsApi.join(this._roomId, {log}).response();\n        });\n    }\n\n    async reject(log = null) {\n        await this._platform.logger.wrapOrRun(log, \"rejectInvite\", async log => {\n            this._rejecting = true;\n            this._emitChange(\"rejecting\");\n            await this._hsApi.leave(this._roomId, {log}).response();\n        });\n    }\n\n    get accepting() {\n        return this._accepting;\n    }\n\n    get accepted() {\n        return this._accepted;\n    }\n\n    get rejecting() {\n        return this._rejecting;\n    }\n\n    get rejected() {\n        return this._rejected;\n    }\n\n    get mediaRepository() {\n        return this._mediaRepository;\n    }\n\n    _emitChange(params) {\n        this.emit(\"change\");\n        this._emitCollectionUpdate(this, params);\n    }\n\n    load(inviteData, log) {\n        log.set(\"id\", this.id);\n        this._inviteData = inviteData;\n        this._inviter = inviteData.inviter ? new RoomMember(inviteData.inviter) : null;\n    }\n\n    async writeSync(membership, roomResponse, txn, log) {\n        if (membership === \"invite\") {\n            log.set(\"id\", this.id);\n            log.set(\"add\", true);\n            const inviteState = roomResponse[\"invite_state\"]?.events;\n            if (!Array.isArray(inviteState)) {\n                return null;\n            }\n            const summaryData = this._createSummaryData(inviteState);\n            let heroes;\n            if (!summaryData.name && !summaryData.canonicalAlias) {\n                heroes = await this._createHeroes(inviteState, log);\n            }\n            const myInvite = this._getMyInvite(inviteState);\n            if (!myInvite) {\n                return null;\n            }\n            const inviter = this._getInviter(myInvite, inviteState);\n            const inviteData = this._createData(inviteState, myInvite, inviter, summaryData, heroes);\n            txn.invites.set(inviteData);\n            return {inviteData, inviter};\n        } else {\n            log.set(\"id\", this.id);\n            log.set(\"membership\", membership);\n            txn.invites.remove(this.id);\n            return {removed: true, membership};\n        }\n    }\n\n    afterSync(changes, log) {\n        log.set(\"id\", this.id);\n        if (changes) {\n            if (changes.removed) {\n                this._accepting = false;\n                this._rejecting = false;\n                if (changes.membership === \"join\") {\n                    this._accepted = true;\n                } else {\n                    this._rejected = true;\n                }\n                this.emit(\"change\");\n            } else {\n                // no emit change, adding to the collection is done by sync\n                this._inviteData = changes.inviteData;\n                this._inviter = changes.inviter;\n            }\n        }\n    }\n\n    _createData(inviteState, myInvite, inviter, summaryData, heroes) {\n        const name = heroes ? heroes.roomName : summaryData.name;\n        const avatarUrl = heroes ? heroes.roomAvatarUrl : summaryData.avatarUrl;\n        const avatarColorId = heroes?.roomAvatarColorId || this.id;\n        return {\n            roomId: this.id,\n            isEncrypted: !!summaryData.encryption,\n            isDirectMessage: summaryData.isDirectMessage,\n//            type: \n            name,\n            avatarUrl,\n            avatarColorId,\n            canonicalAlias: summaryData.canonicalAlias,\n            timestamp: this._platform.clock.now(),\n            joinRule: this._getJoinRule(inviteState),\n            inviter: inviter?.serialize(),\n        };\n    }\n\n    _createSummaryData(inviteState) {\n        return inviteState.reduce((data, event) => processStateEvent(data, event, this._user.id), new SummaryData(null, this.id));\n    }\n\n    async _createHeroes(inviteState, log) {\n        const members = inviteState.filter(e => e.type === MEMBER_EVENT_TYPE);\n        const otherMembers = members.filter(e => e.state_key !== this._user.id);\n        const memberChanges = otherMembers.reduce((map, e) => {\n            const member = RoomMember.fromMemberEvent(this.id, e);\n            map.set(member.userId, new MemberChange(member, null));\n            return map;\n        }, new Map());\n        const otherUserIds = otherMembers.map(e => e.state_key);\n        const heroes = new Heroes(this.id);\n        const changes = await heroes.calculateChanges(otherUserIds, memberChanges, null);\n        // we don't get an actual lazy-loading m.heroes summary on invites,\n        // so just count the members by hand\n        const countSummary = new SummaryData(null, this.id);\n        countSummary.joinCount = members.reduce((sum, e) => sum + (e.content?.membership === \"join\" ? 1 : 0), 0);\n        countSummary.inviteCount = members.reduce((sum, e) => sum + (e.content?.membership === \"invite\" ? 1 : 0), 0);\n        heroes.applyChanges(changes, countSummary, log);\n        return heroes;\n    }\n\n    _getMyInvite(inviteState) {\n        return inviteState.find(e => e.type === MEMBER_EVENT_TYPE && e.state_key === this._user.id);\n    }\n\n    _getInviter(myInvite, inviteState) {\n        const inviterMemberEvent = inviteState.find(e => e.type === MEMBER_EVENT_TYPE && e.state_key === myInvite.sender);\n        if (inviterMemberEvent) {\n            return RoomMember.fromMemberEvent(this.id, inviterMemberEvent);\n        }\n    }\n\n    _getJoinRule(inviteState) {\n        const event = inviteState.find(e => e.type === \"m.room.join_rules\");\n        if (event) {\n            return event.content?.join_rule;\n        }\n        return null;\n    }\n}\n\nimport {NullLogItem} from \"../../logging/NullLogger\";\nimport {Clock as MockClock} from \"../../mocks/Clock.js\";\nimport {default as roomInviteFixture} from \"../../fixtures/matrix/invites/room.js\";\nimport {default as dmInviteFixture} from \"../../fixtures/matrix/invites/dm.js\";\n\nexport function tests() {\n\n    function createStorage() {\n        const invitesMap = new Map();\n        return {\n            invitesMap,\n            invites: {\n                set(invite) {\n                    invitesMap.set(invite.roomId, invite);\n                },\n                remove(roomId) {\n                    invitesMap.delete(roomId);\n                }\n            }\n        }\n    }\n\n    const roomId = \"!123:hs.tld\";\n    const aliceAvatarUrl = \"mxc://hs.tld/def456\";\n    const roomAvatarUrl = \"mxc://hs.tld/roomavatar\";\n\n    return {\n        \"invite for room has correct fields\": async assert => {\n            const invite = new Invite({\n                roomId,\n                platform: {clock: new MockClock(1001)},\n                user: {id: \"@bob:hs.tld\"}\n            });\n            const txn = createStorage();\n            const changes = await invite.writeSync(\"invite\", roomInviteFixture, txn, new NullLogItem());\n            assert.equal(txn.invitesMap.get(roomId).roomId, roomId);\n            invite.afterSync(changes, new NullLogItem());\n            assert.equal(invite.name, \"Invite example\");\n            assert.equal(invite.avatarUrl, roomAvatarUrl);\n            assert.equal(invite.isPublic, false);\n            assert.equal(invite.timestamp, 1001);\n            assert.equal(invite.isEncrypted, false);\n            assert.equal(invite.isDirectMessage, false);\n            assert(invite.inviter);\n            assert.equal(invite.inviter.userId, \"@alice:hs.tld\");\n            assert.equal(invite.inviter.displayName, \"Alice\");\n            assert.equal(invite.inviter.avatarUrl, aliceAvatarUrl);\n        },\n        \"invite for encrypted DM has correct fields\": async assert => {\n            const invite = new Invite({\n                roomId,\n                platform: {clock: new MockClock(1003)},\n                user: {id: \"@bob:hs.tld\"}\n            });\n            const txn = createStorage();\n            const changes = await invite.writeSync(\"invite\", dmInviteFixture, txn, new NullLogItem());\n            assert.equal(txn.invitesMap.get(roomId).roomId, roomId);\n            invite.afterSync(changes, new NullLogItem());\n            assert.equal(invite.name, \"Alice\");\n            assert.equal(invite.avatarUrl, aliceAvatarUrl);\n            assert.equal(invite.timestamp, 1003);\n            assert.equal(invite.isEncrypted, true);\n            assert.equal(invite.isDirectMessage, true);\n            assert(invite.inviter);\n            assert.equal(invite.inviter.userId, \"@alice:hs.tld\");\n            assert.equal(invite.inviter.displayName, \"Alice\");\n            assert.equal(invite.inviter.avatarUrl, aliceAvatarUrl);\n        },\n        \"load persisted invite has correct fields\": async assert => {\n            const writeInvite = new Invite({\n                roomId,\n                platform: {clock: new MockClock(1003)},\n                user: {id: \"@bob:hs.tld\"}\n            });\n            const txn = createStorage();\n            await writeInvite.writeSync(\"invite\", dmInviteFixture, txn, new NullLogItem());\n            const invite = new Invite({roomId});\n            invite.load(txn.invitesMap.get(roomId), new NullLogItem());\n            assert.equal(invite.name, \"Alice\");\n            assert.equal(invite.avatarUrl, aliceAvatarUrl);\n            assert.equal(invite.timestamp, 1003);\n            assert.equal(invite.isEncrypted, true);\n            assert.equal(invite.isDirectMessage, true);\n            assert(invite.inviter);\n            assert.equal(invite.inviter.userId, \"@alice:hs.tld\");\n            assert.equal(invite.inviter.displayName, \"Alice\");\n            assert.equal(invite.inviter.avatarUrl, aliceAvatarUrl);\n        },\n        \"syncing join sets accepted\": async assert => {\n            let changeEmitCount = 0;\n            const invite = new Invite({\n                roomId,\n                platform: {clock: new MockClock(1003)},\n                user: {id: \"@bob:hs.tld\"},\n            });\n            invite.on(\"change\", () => { changeEmitCount += 1; });\n            const txn = createStorage();\n            const changes = await invite.writeSync(\"invite\", dmInviteFixture, txn, new NullLogItem());\n            assert.equal(txn.invitesMap.get(roomId).roomId, roomId);\n            invite.afterSync(changes, new NullLogItem());\n            const joinChanges = await invite.writeSync(\"join\", null, txn, new NullLogItem());\n            assert.strictEqual(changeEmitCount, 0);\n            invite.afterSync(joinChanges, new NullLogItem());\n            assert.strictEqual(changeEmitCount, 1);\n            assert.equal(txn.invitesMap.get(roomId), undefined);\n            assert.equal(invite.rejected, false);\n            assert.equal(invite.accepted, true);\n        }\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type {HomeServerApi} from \"../net/HomeServerApi.js\";\nimport type {ILogItem} from \"../../logging/types\";\n\nexport interface IPusherDescription {\n    kind: \"http\" | \"email\" | \"null\";\n    lang: string;\n    device_display_name: string;\n    app_display_name: string;\n    app_id: string;\n    pushkey: string;\n    data: IPusherData;\n    append?: boolean;\n    profile_tag?: string;\n}\n\ninterface IPusherData {\n    format?: string;\n    url?: string;\n    endpoint?: PushSubscriptionJSON[\"endpoint\"];\n    keys?: PushSubscriptionJSON[\"keys\"];\n}\n\nexport class Pusher {\n    private readonly _description: IPusherDescription;\n\n    constructor(description: IPusherDescription) {\n        this._description = description;\n    }\n\n    static httpPusher(host: string, appId: string, pushkey: string, data: IPusherData): Pusher {\n        return new Pusher({\n            kind: \"http\",\n            append: true,   // as pushkeys are shared between multiple users on one origin\n            data: Object.assign({}, data, {url: host + \"/_matrix/push/v1/notify\"}),\n            pushkey,\n            app_id: appId,\n            app_display_name: \"Hydrogen\",\n            device_display_name: \"Hydrogen\",\n            lang: \"en\"\n        });\n    }\n\n    static createDefaultPayload(sessionId: string): {session_id: string} {\n        return {session_id: sessionId};\n    }\n\n    async enable(hsApi: HomeServerApi, log: ILogItem): Promise<void> {\n        try {\n            log.set(\"endpoint\", new URL(this._description.data.endpoint!).host);\n        } catch {\n            log.set(\"endpoint\", null);\n        }\n        await hsApi.setPusher(this._description, {log}).response();\n    }\n\n    async disable(hsApi: HomeServerApi, log: ILogItem): Promise<void> {\n        const deleteDescription = Object.assign({}, this._description, {kind: null});\n        await hsApi.setPusher(deleteDescription, {log}).response();\n    }\n\n    serialize(): IPusherDescription {\n        return this._description;\n    }\n\n    equals(pusher): boolean {\n        if (this._description.app_id !== pusher._description.app_id) {\n            return false;\n        }\n        if (this._description.pushkey !== pusher._description.pushkey) {\n            return false;\n        }\n        return JSON.stringify(this._description.data) === JSON.stringify(pusher._description.data);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function groupBy<K, V>(array: V[], groupFn: (V) => K): Map<K, V[]> {\n    return groupByWithCreator<K, V, V[]>(array, groupFn,\n        () => {return [];},\n        (array, value) => array.push(value)\n    );\n}\n\nexport function groupByWithCreator<K, V, C>(array: V[], groupFn: (V) => K, createCollectionFn: () => C, addCollectionFn: (C, V) => void): Map<K, C> {\n    return array.reduce((map, value) => {\n        const key = groupFn(value);\n        let collection = map.get(key);\n        if (!collection) {\n            collection = createCollectionFn();\n            map.set(key, collection);\n        }\n        addCollectionFn(collection, value);\n        return map;\n    }, new Map<K, C>());\n}\n\nexport function countBy<V>(events: V[], mapper: (V) => string | number): { [key: string]: number } {\n    return events.reduce((counts, event) => {\n        const mappedValue = mapper(event);\n        if (!counts[mappedValue]) {\n            counts[mappedValue] = 1;\n        } else {\n            counts[mappedValue] += 1;\n        }\n        return counts;\n    }, {});\n}\n\nexport function tests() {\n    return {\n        countBy: assert => {\n            const counts = countBy([{type: \"foo\"}, {type: \"bar\"}, {type: \"foo\"}], o => o.type);\n            assert.equal(Object.keys(counts).length, 2);\n            assert.equal(counts.foo, 2);\n            assert.equal(counts.bar, 1);\n        }\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {OLM_ALGORITHM} from \"./e2ee/common.js\";\nimport {countBy, groupBy} from \"../utils/groupBy\";\n\nexport class DeviceMessageHandler {\n    constructor({storage}) {\n        this._storage = storage;\n        this._olmDecryption = null;\n        this._megolmDecryption = null;\n    }\n\n    enableEncryption({olmDecryption, megolmDecryption}) {\n        this._olmDecryption = olmDecryption;\n        this._megolmDecryption = megolmDecryption;\n    }\n\n    obtainSyncLock(toDeviceEvents) {\n        return this._olmDecryption?.obtainDecryptionLock(toDeviceEvents);\n    }\n\n    async prepareSync(toDeviceEvents, lock, txn, log) {\n        log.set(\"messageTypes\", countBy(toDeviceEvents, e => e.type));\n        const encryptedEvents = toDeviceEvents.filter(e => e.type === \"m.room.encrypted\");\n        if (!this._olmDecryption) {\n            log.log(\"can't decrypt, encryption not enabled\", log.level.Warn);\n            return;\n        }\n        // only know olm for now\n        const olmEvents = encryptedEvents.filter(e => e.content?.algorithm === OLM_ALGORITHM);\n        if (olmEvents.length) {\n            const olmDecryptChanges = await this._olmDecryption.decryptAll(olmEvents, lock, txn);\n            log.set(\"decryptedTypes\", countBy(olmDecryptChanges.results, r => r.event?.type));\n            for (const err of olmDecryptChanges.errors) {\n                log.child(\"decrypt_error\").catch(err);\n            }\n            const newRoomKeys = this._megolmDecryption.roomKeysFromDeviceMessages(olmDecryptChanges.results, log);\n            return new SyncPreparation(olmDecryptChanges, newRoomKeys);\n        }\n    }\n\n    /** check that prep is not undefined before calling this */\n    async writeSync(prep, txn) {\n        // write olm changes\n        prep.olmDecryptChanges.write(txn);\n        const didWriteValues = await Promise.all(prep.newRoomKeys.map(key => this._megolmDecryption.writeRoomKey(key, txn)));\n        return didWriteValues.some(didWrite => !!didWrite);\n    }\n}\n\nclass SyncPreparation {\n    constructor(olmDecryptChanges, newRoomKeys) {\n        this.olmDecryptChanges = olmDecryptChanges;\n        this.newRoomKeys = newRoomKeys;\n        this.newKeysByRoom = groupBy(newRoomKeys, r => r.roomId);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport anotherjson from \"another-json\";\nimport {SESSION_E2EE_KEY_PREFIX, OLM_ALGORITHM, MEGOLM_ALGORITHM} from \"./common.js\";\n\n// use common prefix so it's easy to clear properties that are not e2ee related during session clear\nconst ACCOUNT_SESSION_KEY = SESSION_E2EE_KEY_PREFIX + \"olmAccount\";\nconst DEVICE_KEY_FLAG_SESSION_KEY = SESSION_E2EE_KEY_PREFIX + \"areDeviceKeysUploaded\";\nconst SERVER_OTK_COUNT_SESSION_KEY = SESSION_E2EE_KEY_PREFIX + \"serverOTKCount\";\n\nasync function initiallyStoreAccount(account, pickleKey, areDeviceKeysUploaded, serverOTKCount, storage) {\n    const pickledAccount = account.pickle(pickleKey);\n    const txn = await storage.readWriteTxn([\n        storage.storeNames.session\n    ]);\n    try {\n        // add will throw if the key already exists\n        // we would not want to overwrite olmAccount here\n        txn.session.add(ACCOUNT_SESSION_KEY, pickledAccount);\n        txn.session.add(DEVICE_KEY_FLAG_SESSION_KEY, areDeviceKeysUploaded);\n        txn.session.add(SERVER_OTK_COUNT_SESSION_KEY, serverOTKCount);\n    } catch (err) {\n        txn.abort();\n        throw err;\n    }\n    await txn.complete();\n}\n\nexport class Account {\n    static async load({olm, pickleKey, hsApi, userId, deviceId, olmWorker, txn}) {\n        const pickledAccount = await txn.session.get(ACCOUNT_SESSION_KEY);\n        if (pickledAccount) {\n            const account = new olm.Account();\n            const areDeviceKeysUploaded = await txn.session.get(DEVICE_KEY_FLAG_SESSION_KEY);\n            account.unpickle(pickleKey, pickledAccount);\n            const serverOTKCount = await txn.session.get(SERVER_OTK_COUNT_SESSION_KEY);\n            return new Account({pickleKey, hsApi, account, userId,\n                deviceId, areDeviceKeysUploaded, serverOTKCount, olm, olmWorker});\n        }\n    }\n\n    static async adoptDehydratedDevice({olm, dehydratedDevice, pickleKey, hsApi, userId, olmWorker, storage}) {\n        const account = dehydratedDevice.adoptUnpickledOlmAccount();\n        const oneTimeKeys = JSON.parse(account.one_time_keys());\n        // only one algorithm supported by olm atm, so hardcode its name\n        const oneTimeKeysEntries = Object.entries(oneTimeKeys.curve25519);\n        const serverOTKCount = oneTimeKeysEntries.length;\n        const areDeviceKeysUploaded = true;\n        await initiallyStoreAccount(account, pickleKey, areDeviceKeysUploaded, serverOTKCount, storage);\n        return new Account({\n            pickleKey, hsApi, account, userId,\n            deviceId: dehydratedDevice.deviceId,\n            areDeviceKeysUploaded, serverOTKCount, olm, olmWorker\n        });\n    }\n\n    static async create({olm, pickleKey, hsApi, userId, deviceId, olmWorker, storage}) {\n        const account = new olm.Account();\n        if (olmWorker) {\n            await olmWorker.createAccountAndOTKs(account, account.max_number_of_one_time_keys());\n        } else {\n            account.create();\n            account.generate_one_time_keys(account.max_number_of_one_time_keys());\n        }\n        const areDeviceKeysUploaded = false;\n        const serverOTKCount = 0;\n        if (storage) {\n            await initiallyStoreAccount(account, pickleKey, areDeviceKeysUploaded, serverOTKCount, storage);\n        }\n        return new Account({pickleKey, hsApi, account, userId,\n            deviceId, areDeviceKeysUploaded, serverOTKCount, olm, olmWorker});\n    }\n\n    constructor({pickleKey, hsApi, account, userId, deviceId, areDeviceKeysUploaded, serverOTKCount, olm, olmWorker}) {\n        this._olm = olm;\n        this._pickleKey = pickleKey;\n        this._hsApi = hsApi;\n        this._account = account;\n        this._userId = userId;\n        this._deviceId = deviceId;\n        this._areDeviceKeysUploaded = areDeviceKeysUploaded;\n        this._serverOTKCount = serverOTKCount;\n        this._olmWorker = olmWorker;\n        this._identityKeys = JSON.parse(this._account.identity_keys());\n    }\n\n    get identityKeys() {\n        return this._identityKeys;\n    }\n\n    setDeviceId(deviceId) {\n        this._deviceId = deviceId;\n    }\n\n    async uploadKeys(storage, isDehydratedDevice, log) {\n        const oneTimeKeys = JSON.parse(this._account.one_time_keys());\n        // only one algorithm supported by olm atm, so hardcode its name\n        const oneTimeKeysEntries = Object.entries(oneTimeKeys.curve25519);\n        if (oneTimeKeysEntries.length || !this._areDeviceKeysUploaded) {\n            const payload = {};\n            if (!this._areDeviceKeysUploaded) {\n                log.set(\"identity\", true);\n                const identityKeys = JSON.parse(this._account.identity_keys());\n                payload.device_keys = this._deviceKeysPayload(identityKeys);\n            }\n            if (oneTimeKeysEntries.length) {\n                log.set(\"otks\", true);\n                payload.one_time_keys = this._oneTimeKeysPayload(oneTimeKeysEntries);\n            }\n            const dehydratedDeviceId = isDehydratedDevice ? this._deviceId : undefined;\n            const response = await this._hsApi.uploadKeys(dehydratedDeviceId, payload, {log}).response();\n            this._serverOTKCount = response?.one_time_key_counts?.signed_curve25519;\n            log.set(\"serverOTKCount\", this._serverOTKCount);\n            // TODO: should we not modify this in the txn like we do elsewhere?\n            // we'd have to pickle and unpickle the account to clone it though ...\n            // and the upload has succeed at this point, so in-memory would be correct\n            // but in-storage not if the txn fails. \n            await this._updateSessionStorage(storage, sessionStore => {\n                if (oneTimeKeysEntries.length) {\n                    this._account.mark_keys_as_published();\n                    sessionStore?.set(ACCOUNT_SESSION_KEY, this._account.pickle(this._pickleKey));\n                    sessionStore?.set(SERVER_OTK_COUNT_SESSION_KEY, this._serverOTKCount);\n                }\n                if (!this._areDeviceKeysUploaded) {\n                    this._areDeviceKeysUploaded = true;\n                    sessionStore?.set(DEVICE_KEY_FLAG_SESSION_KEY, this._areDeviceKeysUploaded);\n                }\n            });\n        }\n    }\n\n    async generateOTKsIfNeeded(storage, log) {\n        // We need to keep a pool of one time public keys on the server so that\n        // other devices can start conversations with us. But we can only store\n        // a finite number of private keys in the olm Account object.\n        // To complicate things further there can be a delay between a device\n        // claiming a public one time key from the server and it sending us a\n        // message. We need to keep the corresponding private key locally until\n        // we receive the message.\n        // But that message might never arrive leaving us stuck with duff\n        // private keys clogging up our local storage.\n        // So we need some kind of engineering compromise to balance all of\n        // these factors.\n        \n        // Check how many keys we can store in the Account object.\n        const maxOTKs = this._account.max_number_of_one_time_keys();\n        // Try to keep at most half that number on the server. This leaves the\n        // rest of the slots free to hold keys that have been claimed from the\n        // server but we haven't recevied a message for.\n        // If we run out of slots when generating new keys then olm will\n        // discard the oldest private keys first. This will eventually clean\n        // out stale private keys that won't receive a message.\n        const keyLimit = Math.floor(maxOTKs / 2);\n        // does the server have insufficient OTKs?\n        if (this._serverOTKCount < keyLimit) {\n            const oneTimeKeys = JSON.parse(this._account.one_time_keys());\n            const oneTimeKeysEntries = Object.entries(oneTimeKeys.curve25519);\n            const unpublishedOTKCount = oneTimeKeysEntries.length;\n            // we want to end up with maxOTKs / 2 key on the server,\n            // so generate any on top of the remaining ones on the server and the unpublished ones\n            // (we have generated before but haven't uploaded yet for some reason)\n            // to get to that number.\n            const newKeyCount = keyLimit - unpublishedOTKCount - this._serverOTKCount;\n            if (newKeyCount > 0) {\n                await log.wrap(\"generate otks\", log => {\n                    log.set(\"max\", maxOTKs);\n                    log.set(\"server\", this._serverOTKCount);\n                    log.set(\"unpublished\", unpublishedOTKCount);\n                    log.set(\"new\", newKeyCount);\n                    log.set(\"limit\", keyLimit);\n                    this._account.generate_one_time_keys(newKeyCount);\n                    this._updateSessionStorage(storage, sessionStore => {\n                        sessionStore.set(ACCOUNT_SESSION_KEY, this._account.pickle(this._pickleKey));\n                    });\n                });\n            }\n            // even though we didn't generate any keys, we still have some unpublished ones that should be published\n            return true;\n        }\n        return false;\n    }\n\n    createInboundOlmSession(senderKey, body) {\n        const newSession = new this._olm.Session();\n        try {\n            newSession.create_inbound_from(this._account, senderKey, body);\n            return newSession;\n        } catch (err) {\n            newSession.free();\n            throw err;\n        }\n    }\n\n    async createOutboundOlmSession(theirIdentityKey, theirOneTimeKey) {\n        const newSession = new this._olm.Session();\n        try {\n            if (this._olmWorker) {\n                await this._olmWorker.createOutboundOlmSession(this._account, newSession, theirIdentityKey, theirOneTimeKey);\n            } else {\n                newSession.create_outbound(this._account, theirIdentityKey, theirOneTimeKey);\n            }\n            return newSession;\n        } catch (err) {\n            newSession.free();\n            throw err;\n        }\n    }\n\n    writeRemoveOneTimeKey(session, txn) {\n        // this is side-effecty and will have applied the change if the txn fails,\n        // but don't want to clone the account for now\n        // and it is not the worst thing to think we have used a OTK when\n        // decrypting the message that actually used it threw for some reason.\n        this._account.remove_one_time_keys(session);\n        txn.session.set(ACCOUNT_SESSION_KEY, this._account.pickle(this._pickleKey));\n    }\n\n    writeSync(deviceOneTimeKeysCount, txn, log) {\n        // we only upload signed_curve25519 otks\n        const otkCount = deviceOneTimeKeysCount.signed_curve25519;\n        if (Number.isSafeInteger(otkCount) && otkCount !== this._serverOTKCount) {\n            txn.session.set(SERVER_OTK_COUNT_SESSION_KEY, otkCount);\n            log.set(\"otkCount\", otkCount);\n            return otkCount;\n        }\n    }\n\n    afterSync(otkCount) {\n        // could also be undefined\n        if (Number.isSafeInteger(otkCount)) {\n            this._serverOTKCount = otkCount;\n        }\n    }\n\n    _deviceKeysPayload(identityKeys) {\n        const obj = {\n            user_id: this._userId,\n            device_id: this._deviceId,\n            algorithms: [OLM_ALGORITHM, MEGOLM_ALGORITHM],\n            keys: {}\n        };\n        for (const [algorithm, pubKey] of Object.entries(identityKeys)) {\n            obj.keys[`${algorithm}:${this._deviceId}`] = pubKey;\n        }\n        this.signObject(obj);\n        return obj;\n    }\n\n    _oneTimeKeysPayload(oneTimeKeysEntries) {\n        const obj = {};\n        for (const [keyId, pubKey] of oneTimeKeysEntries) {\n            const keyObj = {\n                key: pubKey  \n            };\n            this.signObject(keyObj);\n            obj[`signed_curve25519:${keyId}`] = keyObj;\n        }\n        return obj;\n    }\n\n    async _updateSessionStorage(storage, callback) {\n        if (storage) {\n            const txn = await storage.readWriteTxn([\n                storage.storeNames.session\n            ]);\n            try {\n                await callback(txn.session);\n            } catch (err) {\n                txn.abort();\n                throw err;\n            }\n            await txn.complete();\n        } else {\n            await callback(undefined);\n        }\n    }\n\n    signObject(obj) {\n        const sigs = obj.signatures || {};\n        const unsigned = obj.unsigned;\n\n        delete obj.signatures;\n        delete obj.unsigned;\n\n        sigs[this._userId] = sigs[this._userId] || {};\n        sigs[this._userId][\"ed25519:\" + this._deviceId] = \n            this._account.sign(anotherjson.stringify(obj));\n        obj.signatures = sigs;\n        if (unsigned !== undefined) {\n            obj.unsigned = unsigned;\n        }\n    }\n\n    pickleWithKey(key) {\n        return this._account.pickle(key);\n    }\n\n    dispose() {\n        this._account.free();\n        this._account = undefined;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type {Platform} from \"../../platform/web/Platform.js\";\n\nexport type KeyDescriptionData = {\n    algorithm: string;\n    passphrase: {\n        algorithm: string;\n        iterations: number;\n        salt: string;\n        bits?: number;\n    };\n    mac: string;\n    iv: string;\n}\n\nexport class KeyDescription {\n    private readonly _id: string;\n    private readonly _keyDescription: KeyDescriptionData;\n\n    constructor(id: string, keyDescription: KeyDescriptionData) {\n        this._id = id;\n        this._keyDescription = keyDescription;\n    }\n\n    get id(): string {\n        return this._id;\n    }\n\n    get passphraseParams(): KeyDescriptionData[\"passphrase\"] {\n        return this._keyDescription?.passphrase;\n    }\n\n    get algorithm(): string {\n        return this._keyDescription?.algorithm;\n    }\n\n    async isCompatible(key: Key, platform: Platform): Promise<boolean> {\n        if (this.algorithm === \"m.secret_storage.v1.aes-hmac-sha2\") {\n            const kd = this._keyDescription;\n            if (kd.mac) {\n                const otherMac = await calculateKeyMac(key.binaryKey, kd.iv, platform);\n                return kd.mac === otherMac;\n            } else if (kd.passphrase) {\n                const kdOther = key.description._keyDescription;\n                if (!kdOther.passphrase) {\n                    return false;\n                }\n                return kd.passphrase.algorithm === kdOther.passphrase.algorithm && \n                    kd.passphrase.iterations === kdOther.passphrase.iterations && \n                    kd.passphrase.salt === kdOther.passphrase.salt;\n            }\n        }\n        return false;\n    }\n}\n\nexport class Key {\n    private readonly _keyDescription: KeyDescription;\n    private readonly _binaryKey: Uint8Array;\n\n    constructor(keyDescription: KeyDescription, binaryKey: Uint8Array) {\n        this._keyDescription = keyDescription;\n        this._binaryKey = binaryKey;\n    }\n\n    withDescription(description: KeyDescription): Key {\n        return new Key(description, this._binaryKey);\n    }\n\n    get description(): KeyDescription {\n        return this._keyDescription;\n    }\n\n    get id(): string {\n        return this._keyDescription.id;\n    }\n\n    get binaryKey(): Uint8Array {\n        return this._binaryKey;\n    }\n\n    get algorithm(): string {\n        return this._keyDescription.algorithm;\n    }\n}\n\nasync function calculateKeyMac(key: BufferSource, ivStr: string, platform: Platform): Promise<string> {\n    const {crypto, encoding} = platform;\n    const {utf8, base64} = encoding;\n    const {derive, aes, hmac} = crypto;\n\n    const iv = base64.decode(ivStr);\n\n    // salt for HKDF, with 8 bytes of zeros\n    const zerosalt = new Uint8Array(8);\n    const ZERO_STR = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n    \n    const info = utf8.encode(\"\");\n    const keybits = await derive.hkdf(key, zerosalt, info, \"SHA-256\", 512);\n    const aesKey = keybits.slice(0, 32);\n    const hmacKey = keybits.slice(32);\n    const ciphertext = await aes.encryptCTR({key: aesKey, iv, data: utf8.encode(ZERO_STR)});\n    const mac = await hmac.compute(hmacKey, ciphertext, \"SHA-256\");\n\n    return base64.encode(mac);\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {Key} from \"./common\";\nimport type {KeyDescription} from \"./common\";\nimport type {Platform} from \"../../platform/web/Platform.js\";\n\nconst DEFAULT_ITERATIONS = 500000;\nconst DEFAULT_BITSIZE = 256;\n\n/**\n * @param  {KeyDescription} keyDescription\n * @param  {string} passphrase\n * @param  {Platform} platform\n * @return {Key}\n */\nexport async function keyFromPassphrase(keyDescription: KeyDescription, passphrase: string, platform: Platform): Promise<Key> {\n    const {passphraseParams} = keyDescription;\n    if (!passphraseParams) {\n        throw new Error(\"not a passphrase key\");\n    }\n    if (passphraseParams.algorithm !== \"m.pbkdf2\") {\n        throw new Error(`Unsupported passphrase algorithm: ${passphraseParams.algorithm}`);\n    }\n    const {utf8} = platform.encoding;\n    const keyBits = await platform.crypto.derive.pbkdf2(\n        utf8.encode(passphrase),\n        passphraseParams.iterations || DEFAULT_ITERATIONS,\n        // salt is just a random string, not encoded in any way\n        utf8.encode(passphraseParams.salt),\n        \"SHA-512\",\n        passphraseParams.bits || DEFAULT_BITSIZE);\n    return new Key(keyDescription, keyBits);\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {Key} from \"./common\";\nimport {KeyDescription} from \"./common\";\nimport type {Platform} from \"../../platform/web/Platform.js\";\nimport type * as OlmNamespace from \"@matrix-org/olm\";\ntype Olm = typeof OlmNamespace;\n\nconst OLM_RECOVERY_KEY_PREFIX = [0x8B, 0x01] as const;\n\n/**\n * @param  {Olm} olm\n * @param  {KeyDescription} keyDescription\n * @param  {string} recoveryKey\n * @return {Key}\n */\nexport function keyFromRecoveryKey(keyDescription: KeyDescription, recoveryKey: string, olm: Olm, platform: Platform): Key {\n    const result = platform.encoding.base58.decode(recoveryKey.replace(/ /g, ''));\n\n    let parity = 0;\n    for (const b of result) {\n        parity ^= b;\n    }\n    if (parity !== 0) {\n        throw new Error(\"Incorrect parity\");\n    }\n\n    for (let i = 0; i < OLM_RECOVERY_KEY_PREFIX.length; ++i) {\n        if (result[i] !== OLM_RECOVERY_KEY_PREFIX[i]) {\n            throw new Error(\"Incorrect prefix\");\n        }\n    }\n\n    if (\n        result.length !==\n        OLM_RECOVERY_KEY_PREFIX.length + olm.PRIVATE_KEY_LENGTH + 1\n    ) {\n        throw new Error(\"Incorrect length\");\n    }\n\n    const keyBits = Uint8Array.from(result.slice(\n        OLM_RECOVERY_KEY_PREFIX.length,\n        OLM_RECOVERY_KEY_PREFIX.length + olm.PRIVATE_KEY_LENGTH,\n    ));\n\n    return new Key(keyDescription, keyBits);\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {KeyDescription, Key} from \"./common\";\nimport {keyFromPassphrase} from \"./passphrase\";\nimport {keyFromRecoveryKey} from \"./recoveryKey\";\nimport {SESSION_E2EE_KEY_PREFIX} from \"../e2ee/common.js\";\nimport type {Storage} from \"../storage/idb/Storage\";\nimport type {Transaction} from \"../storage/idb/Transaction\";\nimport type {KeyDescriptionData} from \"./common\";\nimport type {Platform} from \"../../platform/web/Platform.js\";\nimport type * as OlmNamespace from \"@matrix-org/olm\"\n\ntype Olm = typeof OlmNamespace;\n\nconst SSSS_KEY = `${SESSION_E2EE_KEY_PREFIX}ssssKey`;\nconst BACKUPVERSION_KEY = `${SESSION_E2EE_KEY_PREFIX}keyBackupVersion`;\n\nexport enum KeyType {\n    \"RecoveryKey\",\n    \"Passphrase\"\n}\n\nasync function readDefaultKeyDescription(storage: Storage): Promise<KeyDescription | undefined> {\n    const txn = await storage.readTxn([\n        storage.storeNames.accountData\n    ]);\n    const defaultKeyEvent = await txn.accountData.get(\"m.secret_storage.default_key\");\n    const id = defaultKeyEvent?.content?.key;\n    if (!id) {\n        return;\n    }\n    const keyAccountData = await txn.accountData.get(`m.secret_storage.key.${id}`);\n    if (!keyAccountData) {\n        return;\n    }\n    return new KeyDescription(id, keyAccountData.content as KeyDescriptionData);\n}\n\nexport async function writeKey(key: Key, keyBackupVersion: number, txn: Transaction): Promise<number | undefined> {\n    const existingVersion: number | undefined = await txn.session.get(BACKUPVERSION_KEY);\n    txn.session.set(BACKUPVERSION_KEY, keyBackupVersion);\n    txn.session.set(SSSS_KEY, {id: key.id, binaryKey: key.binaryKey});\n    return existingVersion;\n}\n\nexport async function readKey(txn: Transaction): Promise<Key | undefined> {\n    const keyData = await txn.session.get(SSSS_KEY);\n    if (!keyData) {\n        return;\n    }\n    const keyAccountData = await txn.accountData.get(`m.secret_storage.key.${keyData.id}`);\n    if (keyAccountData) {\n        return new Key(new KeyDescription(keyData.id, keyAccountData.content as KeyDescriptionData), keyData.binaryKey);\n    }\n}\n\n\nexport async function removeKey(txn: Transaction): Promise<void> {\n    txn.session.remove(SSSS_KEY);\n}\n\nexport async function keyFromCredential(type: KeyType, credential: string, storage: Storage, platform: Platform, olm: Olm): Promise<Key> {\n    const keyDescription = await readDefaultKeyDescription(storage);\n    if (!keyDescription) {\n        throw new Error(\"Could not find a default secret storage key in account data\");\n    }\n    return await keyFromCredentialAndDescription(type, credential, keyDescription, platform, olm);\n}\n\nexport async function keyFromCredentialAndDescription(type: KeyType, credential: string, keyDescription: KeyDescription, platform: Platform, olm: Olm): Promise<Key> {\n    let key: Key;\n    if (type === KeyType.Passphrase) {\n        key = await keyFromPassphrase(keyDescription, credential, platform);\n    } else if (type === KeyType.RecoveryKey) {\n        key = keyFromRecoveryKey(keyDescription, credential, olm, platform);\n    } else {\n        throw new Error(`Invalid type: ${type}`);\n    }\n    return key;\n}\n\nexport async function keyFromDehydratedDeviceKey(key: Key, storage: Storage, platform: Platform): Promise<Key | undefined> {\n    const keyDescription = await readDefaultKeyDescription(storage);\n    if (await keyDescription?.isCompatible(key, platform)) {\n        return key.withDescription(keyDescription!);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nconst DEHYDRATION_LIBOLM_PICKLE_ALGORITHM = \"org.matrix.msc2697.v1.olm.libolm_pickle\"; \nimport {KeyDescription} from \"../ssss/common\";\nimport {keyFromCredentialAndDescription} from \"../ssss/index\";\n\nexport async function getDehydratedDevice(hsApi, olm, platform, log) {\n    try {\n        const response = await hsApi.getDehydratedDevice({log}).response();\n        if (response.device_data.algorithm === DEHYDRATION_LIBOLM_PICKLE_ALGORITHM) {\n            return new EncryptedDehydratedDevice(response, olm, platform);\n        }\n    } catch (err) {\n        if (err.name !== \"HomeServerError\") {\n            log.error = err;\n        }\n        return undefined;\n    }\n}\n\nexport async function uploadAccountAsDehydratedDevice(account, hsApi, key, deviceDisplayName, log) {\n    const response = await hsApi.createDehydratedDevice({\n        device_data: {\n            algorithm: DEHYDRATION_LIBOLM_PICKLE_ALGORITHM,\n            account: account.pickleWithKey(key.binaryKey.slice()),\n            passphrase: key.description?.passphraseParams || {},\n        },\n        initial_device_display_name: deviceDisplayName\n    }).response();\n    const deviceId = response.device_id;\n    account.setDeviceId(deviceId);\n    await account.uploadKeys(undefined, true, log);\n    return deviceId;\n}\n\nclass EncryptedDehydratedDevice {\n    constructor(dehydratedDevice, olm, platform) {\n        this._dehydratedDevice = dehydratedDevice;\n        this._olm = olm;\n        this._platform = platform;\n    }\n\n    async decrypt(keyType, credential) {\n        const keyDescription = new KeyDescription(\"dehydrated_device\", this._dehydratedDevice.device_data.passphrase);\n        const key = await keyFromCredentialAndDescription(keyType, credential, keyDescription, this._platform, this._olm);\n        const account = new this._olm.Account();\n        try {\n            const pickledAccount = this._dehydratedDevice.device_data.account;\n            account.unpickle(key.binaryKey.slice(), pickledAccount);\n            return new DehydratedDevice(this._dehydratedDevice, account, key);\n        } catch (err) {\n            account.free();\n            if (err.message === \"OLM.BAD_ACCOUNT_KEY\") {\n                return undefined;\n            } else {\n                throw err;\n            }\n        }\n    }\n\n    get deviceId() {\n        return this._dehydratedDevice.device_id;\n    }\n}\n\nclass DehydratedDevice {\n    constructor(dehydratedDevice, account, key) {\n        this._dehydratedDevice = dehydratedDevice;\n        this._account = account;\n        this._key = key;\n    }\n\n    async claim(hsApi, log) {\n        try {\n            const response = await hsApi.claimDehydratedDevice(this.deviceId, {log}).response();\n            return response.success;\n        } catch (err) {\n            return false;\n        }\n    }\n\n    // make it clear that ownership is transfered upon calling this\n    adoptUnpickledOlmAccount() {\n        const account = this._account;\n        this._account = undefined;\n        return account;\n    }\n\n    get deviceId() {\n        return this._dehydratedDevice.device_id;\n    }\n\n    get key() {\n        return this._key;\n    }\n\n    dispose() {\n        this._account?.free();\n        this._account = undefined;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class Lock {\n    private _promise?: Promise<void>;\n    private _resolve?: (() => void);\n\n    tryTake(): boolean {\n        if (!this._promise) {\n            this._promise = new Promise(resolve => {\n                this._resolve = resolve;\n            });\n            return true;\n        }\n        return false;\n    }\n\n    async take(): Promise<void> {\n        while(!this.tryTake()) {\n            await this.released();\n        }\n    }\n\n    get isTaken(): boolean {\n        return !!this._promise;\n    }\n\n    release(): void {\n        if (this._resolve) {\n            this._promise = undefined;\n            const resolve = this._resolve;\n            this._resolve = undefined;\n            resolve();\n        }\n    }\n\n    released(): Promise<void> | undefined {\n        return this._promise;\n    }\n}\n\nexport class MultiLock {\n\n    constructor(public readonly locks: Lock[]) {\n    }\n\n    release(): void {\n        for (const lock of this.locks) {\n            lock.release();\n        }\n    }\n}\n\nexport function tests() {\n    return {\n        \"taking a lock twice returns false\": assert => {\n            const lock = new Lock();\n            assert.equal(lock.tryTake(), true);\n            assert.equal(lock.isTaken, true);\n            assert.equal(lock.tryTake(), false);\n        },\n        \"can take a released lock again\": assert => {\n            const lock = new Lock();\n            lock.tryTake();\n            lock.release();\n            assert.equal(lock.isTaken, false);\n            assert.equal(lock.tryTake(), true);\n        },\n        \"2 waiting for lock, only first one gets it\": async assert => {\n            const lock = new Lock();\n            lock.tryTake();\n\n            let first;\n            lock.released()!.then(() => first = lock.tryTake());\n            let second;\n            lock.released()!.then(() => second = lock.tryTake());\n            const promise = lock.released();\n            lock.release();\n            await promise;\n            assert.strictEqual(first, true);\n            assert.strictEqual(second, false);\n        },\n        \"await non-taken lock\": async assert => {\n            const lock = new Lock();\n            await lock.released();\n            assert(true);\n        }\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function createSessionEntry(olmSession, senderKey, timestamp, pickleKey) {\n    return {\n        session: olmSession.pickle(pickleKey),\n        sessionId: olmSession.session_id(),\n        senderKey,\n        lastUsed: timestamp,\n    };\n}\n\nexport class Session {\n    constructor(data, pickleKey, olm, isNew = false) {\n        this.data = data;\n        this._olm = olm;\n        this._pickleKey = pickleKey;\n        this.isNew = isNew;\n        this.isModified = isNew;\n    }\n\n    static create(senderKey, olmSession, olm, pickleKey, timestamp) {\n        const data = createSessionEntry(olmSession, senderKey, timestamp, pickleKey);\n        return new Session(data, pickleKey, olm, true);\n    }\n\n    get id() {\n        return this.data.sessionId;\n    }\n\n    load() {\n        const session = new this._olm.Session();\n        session.unpickle(this._pickleKey, this.data.session);\n        return session;\n    }\n\n    unload(olmSession) {\n        olmSession.free();\n    }\n\n    save(olmSession) {\n        this.data.session = olmSession.pickle(this._pickleKey);\n        this.isModified = true;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n/**\n * @property {object} event the plaintext event (type and content property)\n * @property {string} senderCurve25519Key the curve25519 sender key of the olm event\n * @property {string} claimedEd25519Key The ed25519 fingerprint key retrieved from the decryption payload.\n *                                      The sender of the olm event claims this is the ed25519 fingerprint key\n *                                      that matches the curve25519 sender key.\n *                                      The caller needs to check if this key does indeed match the senderKey\n *                                      for a device with a valid signature returned from /keys/query,\n *                                      see DeviceTracker\n */\n\n\n\nexport class DecryptionResult {\n    constructor(event, senderCurve25519Key, claimedEd25519Key) {\n        this.event = event;\n        this.senderCurve25519Key = senderCurve25519Key;\n        this.claimedEd25519Key = claimedEd25519Key;\n        this._device = null;\n        this._roomTracked = true;\n    }\n\n    setDevice(device) {\n        this._device = device;\n    }\n\n    setRoomNotTrackedYet() {\n        this._roomTracked = false;\n    }\n\n    get isVerified() {\n        if (this._device) {\n            const comesFromDevice = this._device.ed25519Key === this.claimedEd25519Key;\n            return comesFromDevice;\n        }\n        return false;\n    }\n\n    get isUnverified() {\n        if (this._device) {\n            return !this.isVerified;\n        } else if (this.isVerificationUnknown) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    get isVerificationUnknown() {\n        // verification is unknown if we haven't yet fetched the devices for the room\n        return !this._device && !this._roomTracked;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {DecryptionError} from \"../common.js\";\nimport {groupBy} from \"../../../utils/groupBy\";\nimport {MultiLock} from \"../../../utils/Lock\";\nimport {Session} from \"./Session.js\";\nimport {DecryptionResult} from \"../DecryptionResult.js\";\n\nconst SESSION_LIMIT_PER_SENDER_KEY = 4;\n\nfunction isPreKeyMessage(message) {\n    return message.type === 0;\n}\n\nfunction sortSessions(sessions) {\n    sessions.sort((a, b) => {\n        return b.data.lastUsed - a.data.lastUsed;\n    });\n}\n\nexport class Decryption {\n    constructor({account, pickleKey, now, ownUserId, storage, olm, senderKeyLock}) {\n        this._account = account;\n        this._pickleKey = pickleKey;\n        this._now = now;\n        this._ownUserId = ownUserId;\n        this._storage = storage;\n        this._olm = olm;\n        this._senderKeyLock = senderKeyLock;\n    }\n    \n    // we need to lock because both encryption and decryption can't be done in one txn,\n    // so for them not to step on each other toes, we need to lock.\n    // \n    // the lock is release from 1 of 3 places, whichever comes first:\n    //  - decryptAll below fails (to release the lock as early as we can)\n    //  - DecryptionChanges.write succeeds\n    //  - Sync finishes the writeSync phase (or an error was thrown, in case we never get to DecryptionChanges.write) \n    async obtainDecryptionLock(events) {\n        const senderKeys = new Set();\n        for (const event of events) {\n            const senderKey = event.content?.[\"sender_key\"];\n            if (senderKey) {\n                senderKeys.add(senderKey);\n            }\n        }\n        // take a lock on all senderKeys so encryption or other calls to decryptAll (should not happen)\n        // don't modify the sessions at the same time\n        const locks = await Promise.all(Array.from(senderKeys).map(senderKey => {\n            return this._senderKeyLock.takeLock(senderKey);\n        }));\n        return new MultiLock(locks);\n    }\n\n    // we need decryptAll because there is some parallelization we can do for decrypting different sender keys at once\n    // but for the same sender key we need to do one by one\n    // \n    // also we want to store the room key, etc ... in the same txn as we remove the pending encrypted event\n    // \n    // so we need to decrypt events in a batch (so we can decide which ones can run in parallel and which one one by one)\n    // and also can avoid side-effects before all can be stored this way\n    // \n    // doing it one by one would be possible, but we would lose the opportunity for parallelization\n    // \n    \n    /**\n     * It is importants the lock obtained from obtainDecryptionLock is for the same set of events as passed in here.\n     * [decryptAll description]\n     * @param  {[type]} events\n     * @return {Promise<DecryptionChanges>}        [description]\n     */\n    async decryptAll(events, lock, txn) {\n        try {\n            const eventsPerSenderKey = groupBy(events, event => event.content?.[\"sender_key\"]);\n            const timestamp = this._now();\n            // decrypt events for different sender keys in parallel\n            const senderKeyOperations = await Promise.all(Array.from(eventsPerSenderKey.entries()).map(([senderKey, events]) => {\n                return this._decryptAllForSenderKey(senderKey, events, timestamp, txn);\n            }));\n            const results = senderKeyOperations.reduce((all, r) => all.concat(r.results), []);\n            const errors = senderKeyOperations.reduce((all, r) => all.concat(r.errors), []);\n            const senderKeyDecryptions = senderKeyOperations.map(r => r.senderKeyDecryption);\n            return new DecryptionChanges(senderKeyDecryptions, results, errors, this._account, lock);\n        } catch (err) {\n            // make sure the locks are release if something throws\n            // otherwise they will be released in DecryptionChanges after having written\n            // or after the writeSync phase in Sync\n            lock.release();\n            throw err;\n        }\n    }\n\n    async _decryptAllForSenderKey(senderKey, events, timestamp, readSessionsTxn) {\n        const sessions = await this._getSessions(senderKey, readSessionsTxn);\n        const senderKeyDecryption = new SenderKeyDecryption(senderKey, sessions, this._olm, timestamp);\n        const results = [];\n        const errors = [];\n        // events for a single senderKey need to be decrypted one by one\n        for (const event of events) {\n            try {\n                const result = this._decryptForSenderKey(senderKeyDecryption, event, timestamp);\n                results.push(result);\n            } catch (err) {\n                errors.push(err);\n            }\n        }\n        return {results, errors, senderKeyDecryption};\n    }\n\n    _decryptForSenderKey(senderKeyDecryption, event, timestamp) {\n        const senderKey = senderKeyDecryption.senderKey;\n        const message = this._getMessageAndValidateEvent(event);\n        let plaintext;\n        try {\n            plaintext = senderKeyDecryption.decrypt(message);\n        } catch (err) {\n            // TODO: is it ok that an error on one session prevents other sessions from being attempted?\n            throw new DecryptionError(\"OLM_BAD_ENCRYPTED_MESSAGE\", event, {senderKey, error: err.message});\n        }\n        // could not decrypt with any existing session\n        if (typeof plaintext !== \"string\" && isPreKeyMessage(message)) {\n            let createResult;\n            try {\n                createResult = this._createSessionAndDecrypt(senderKey, message, timestamp);\n            } catch (error) {\n                throw new DecryptionError(`Could not create inbound olm session: ${error.message}`, event, {senderKey, error});\n            }\n            senderKeyDecryption.addNewSession(createResult.session);\n            plaintext = createResult.plaintext;\n        }\n        if (typeof plaintext === \"string\") {\n            let payload;\n            try {\n                payload = JSON.parse(plaintext);\n            } catch (error) {\n                throw new DecryptionError(\"PLAINTEXT_NOT_JSON\", event, {plaintext, error});\n            }\n            this._validatePayload(payload, event);\n            return new DecryptionResult(payload, senderKey, payload.keys.ed25519);\n        } else {\n            throw new DecryptionError(\"OLM_NO_MATCHING_SESSION\", event,\n                {knownSessionIds: senderKeyDecryption.sessions.map(s => s.id)});\n        }\n    }\n\n    // only for pre-key messages after having attempted decryption with existing sessions\n    _createSessionAndDecrypt(senderKey, message, timestamp) {\n        let plaintext;\n        // if we have multiple messages encrypted with the same new session,\n        // this could create multiple sessions as the OTK isn't removed yet\n        // (this only happens in DecryptionChanges.write)\n        // This should be ok though as we'll first try to decrypt with the new session\n        const olmSession = this._account.createInboundOlmSession(senderKey, message.body);\n        try {\n            plaintext = olmSession.decrypt(message.type, message.body);\n            const session = Session.create(senderKey, olmSession, this._olm, this._pickleKey, timestamp);\n            session.unload(olmSession);\n            return {session, plaintext};\n        } catch (err) {\n            olmSession.free();\n            throw err;\n        }\n    }\n\n    _getMessageAndValidateEvent(event) {\n        const ciphertext = event.content?.ciphertext;\n        if (!ciphertext) {\n            throw new DecryptionError(\"OLM_MISSING_CIPHERTEXT\", event);\n        }\n        const message = ciphertext?.[this._account.identityKeys.curve25519];\n        if (!message) {\n            throw new DecryptionError(\"OLM_NOT_INCLUDED_IN_RECIPIENTS\", event);\n        }\n\n        return message;\n    }\n\n    async _getSessions(senderKey, txn) {\n        const sessionEntries = await txn.olmSessions.getAll(senderKey);\n        // sort most recent used sessions first\n        const sessions = sessionEntries.map(s => new Session(s, this._pickleKey, this._olm));\n        sortSessions(sessions);\n        return sessions;\n    }\n\n    _validatePayload(payload, event) {\n        if (payload.sender !== event.sender) {\n            throw new DecryptionError(\"OLM_FORWARDED_MESSAGE\", event, {sentBy: event.sender, encryptedBy: payload.sender});\n        }\n        if (payload.recipient !== this._ownUserId) {\n            throw new DecryptionError(\"OLM_BAD_RECIPIENT\", event, {recipient: payload.recipient});\n        }\n        if (payload.recipient_keys?.ed25519 !== this._account.identityKeys.ed25519) {\n            throw new DecryptionError(\"OLM_BAD_RECIPIENT_KEY\", event, {key: payload.recipient_keys?.ed25519});\n        }\n        // TODO: check room_id\n        if (!payload.type) {\n            throw new DecryptionError(\"missing type on payload\", event, {payload});\n        }\n        if (typeof payload.keys?.ed25519 !== \"string\") {\n            throw new DecryptionError(\"Missing or invalid claimed ed25519 key on payload\", event, {payload});\n        }\n    }\n}\n\n// decryption helper for a single senderKey\nclass SenderKeyDecryption {\n    constructor(senderKey, sessions, olm, timestamp) {\n        this.senderKey = senderKey;\n        this.sessions = sessions;\n        this._olm = olm;\n        this._timestamp = timestamp;\n    }\n\n    addNewSession(session) {\n        // add at top as it is most recent\n        this.sessions.unshift(session);\n    }\n\n    decrypt(message) {\n        for (const session of this.sessions) {\n            const plaintext = this._decryptWithSession(session, message);\n            if (typeof plaintext === \"string\") {\n                // keep them sorted so will try the same session first for other messages\n                // and so we can assume the excess ones are at the end\n                // if they grow too large\n                sortSessions(this.sessions);\n                return plaintext;\n            }\n        }\n    }\n\n    getModifiedSessions() {\n        return this.sessions.filter(session => session.isModified);\n    }\n\n    get hasNewSessions() {\n        return this.sessions.some(session => session.isNew);\n    }\n\n    // this could internally dispatch to a web-worker\n    // and is why we unpickle/pickle on each iteration\n    // if this turns out to be a real cost for IE11,\n    // we could look into adding a less expensive serialization mechanism\n    // for olm sessions to libolm\n    _decryptWithSession(session, message) {\n        const olmSession = session.load();\n        try {\n            if (isPreKeyMessage(message) && !olmSession.matches_inbound(message.body)) {\n                return;\n            }\n            try {\n                const plaintext = olmSession.decrypt(message.type, message.body);\n                session.save(olmSession);\n                session.lastUsed = this._timestamp;\n                return plaintext;\n            } catch (err) {\n                if (isPreKeyMessage(message)) {\n                    throw new Error(`Error decrypting prekey message with existing session id ${session.id}: ${err.message}`);\n                }\n                // decryption failed, bail out\n                return;\n            }\n        } finally {\n            session.unload(olmSession);\n        }\n    }\n}\n\n/**\n * @property {Array<DecryptionResult>} results\n * @property {Array<DecryptionError>} errors  see DecryptionError.event to retrieve the event that failed to decrypt.\n */\nclass DecryptionChanges {\n    constructor(senderKeyDecryptions, results, errors, account, lock) {\n        this._senderKeyDecryptions = senderKeyDecryptions;\n        this._account = account;    \n        this.results = results;\n        this.errors = errors;\n        this._lock = lock;\n    }\n\n    get hasNewSessions() {\n        return this._senderKeyDecryptions.some(skd => skd.hasNewSessions);\n    }\n\n    write(txn) {\n        try {\n            for (const senderKeyDecryption of this._senderKeyDecryptions) {\n                for (const session of senderKeyDecryption.getModifiedSessions()) {\n                    txn.olmSessions.set(session.data);\n                    if (session.isNew) {\n                        const olmSession = session.load();\n                        try {\n                            this._account.writeRemoveOneTimeKey(olmSession, txn);\n                        } finally {\n                            session.unload(olmSession);\n                        }\n                    }\n                }\n                if (senderKeyDecryption.sessions.length > SESSION_LIMIT_PER_SENDER_KEY) {\n                    const {senderKey, sessions} = senderKeyDecryption;\n                    // >= because index is zero-based\n                    for (let i = sessions.length - 1; i >= SESSION_LIMIT_PER_SENDER_KEY ; i -= 1) {\n                        const session = sessions[i];\n                        txn.olmSessions.remove(senderKey, session.id);\n                    }\n                }\n            }\n        } finally {\n            this._lock.release();\n        }\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {groupByWithCreator} from \"../../../utils/groupBy\";\nimport {verifyEd25519Signature, OLM_ALGORITHM} from \"../common.js\";\nimport {createSessionEntry} from \"./Session.js\";\n\nfunction findFirstSessionId(sessionIds) {\n    return sessionIds.reduce((first, sessionId) => {\n        if (!first || sessionId < first) {\n            return sessionId;\n        } else {\n            return first;\n        }\n    }, null);\n}\n\nconst OTK_ALGORITHM = \"signed_curve25519\";\n// only encrypt this amount of olm messages at once otherwise we run out of wasm memory\n// with all the sessions loaded at the same time\n// See https://github.com/vector-im/hydrogen-web/issues/150 as well, which indicates the limit is 44,\n// but let's take a conservative limit as the megolm session cache also takes space\nconst MAX_BATCH_SIZE = 20;\n\nexport class Encryption {\n    constructor({account, olm, olmUtil, ownUserId, storage, now, pickleKey, senderKeyLock}) {\n        this._account = account;\n        this._olm = olm;\n        this._olmUtil = olmUtil;\n        this._ownUserId = ownUserId;\n        this._storage = storage;\n        this._now = now;\n        this._pickleKey = pickleKey;\n        this._senderKeyLock = senderKeyLock;\n    }\n\n    async encrypt(type, content, devices, hsApi, log) {\n        let messages = [];\n        for (let i = 0; i < devices.length ; i += MAX_BATCH_SIZE) {\n            const batchDevices = devices.slice(i, i + MAX_BATCH_SIZE);\n            const batchMessages = await this._encryptForMaxDevices(type, content, batchDevices, hsApi, log);\n            messages = messages.concat(batchMessages);\n        }\n        return messages;\n    }\n\n    async _encryptForMaxDevices(type, content, devices, hsApi, log) {\n        // TODO: see if we can only hold some of the locks until after the /keys/claim call (if needed) \n        // take a lock on all senderKeys so decryption and other calls to encrypt (should not happen)\n        // don't modify the sessions at the same time\n        const locks = await Promise.all(devices.map(device => {\n            return this._senderKeyLock.takeLock(device.curve25519Key);\n        }));\n        try {\n            const {\n                devicesWithoutSession,\n                existingEncryptionTargets,\n            } = await this._findExistingSessions(devices);\n        \n            const timestamp = this._now(); \n\n            let encryptionTargets = [];\n            try {\n                if (devicesWithoutSession.length) {\n                    const newEncryptionTargets = await log.wrap(\"create sessions\", log => this._createNewSessions(\n                        devicesWithoutSession, hsApi, timestamp, log));\n                    encryptionTargets = encryptionTargets.concat(newEncryptionTargets);\n                }\n                await this._loadSessions(existingEncryptionTargets);\n                encryptionTargets = encryptionTargets.concat(existingEncryptionTargets);\n                const encryptLog = {l: \"encrypt\", targets: encryptionTargets.length};\n                const messages = log.wrap(encryptLog, () => encryptionTargets.map(target => {\n                    const encryptedContent = this._encryptForDevice(type, content, target);\n                    return new EncryptedMessage(encryptedContent, target.device);\n                }));\n                await this._storeSessions(encryptionTargets, timestamp);\n                return messages;\n            } finally {\n                for (const target of encryptionTargets) {\n                    target.dispose();\n                }\n            }\n        } finally {\n            for (const lock of locks) {\n                lock.release();\n            }\n        }\n    }\n\n    async _findExistingSessions(devices) {\n        const txn = await this._storage.readTxn([this._storage.storeNames.olmSessions]);\n        const sessionIdsForDevice = await Promise.all(devices.map(async device => {\n            return await txn.olmSessions.getSessionIds(device.curve25519Key);\n        }));\n        const devicesWithoutSession = devices.filter((_, i) => {\n            const sessionIds = sessionIdsForDevice[i];\n            return !(sessionIds?.length);\n        });\n\n        const existingEncryptionTargets = devices.map((device, i) => {\n            const sessionIds = sessionIdsForDevice[i];\n            if (sessionIds?.length > 0) {\n                const sessionId = findFirstSessionId(sessionIds);\n                return EncryptionTarget.fromSessionId(device, sessionId);\n            }\n        }).filter(target => !!target);\n\n        return {devicesWithoutSession, existingEncryptionTargets};\n    }\n\n    _encryptForDevice(type, content, target) {\n        const {session, device} = target;\n        const plaintext = JSON.stringify(this._buildPlainTextMessageForDevice(type, content, device));\n        const message = session.encrypt(plaintext);\n        const encryptedContent = {\n            algorithm: OLM_ALGORITHM,\n            sender_key: this._account.identityKeys.curve25519,\n            ciphertext: {\n                [device.curve25519Key]: message\n            }\n        };\n        return encryptedContent;\n    }\n\n    _buildPlainTextMessageForDevice(type, content, device) {\n        return {\n            keys: {\n                \"ed25519\": this._account.identityKeys.ed25519\n            },\n            recipient_keys: {\n                \"ed25519\": device.ed25519Key\n            },\n            recipient: device.userId,\n            sender: this._ownUserId,\n            content,\n            type\n        }\n    }\n\n    async _createNewSessions(devicesWithoutSession, hsApi, timestamp, log) {\n        const newEncryptionTargets = await log.wrap(\"claim\", log => this._claimOneTimeKeys(hsApi, devicesWithoutSession, log));\n        try {\n            for (const target of newEncryptionTargets) {\n                const {device, oneTimeKey} = target;\n                target.session = await this._account.createOutboundOlmSession(device.curve25519Key, oneTimeKey);\n            }\n            await this._storeSessions(newEncryptionTargets, timestamp);\n        } catch (err) {\n            for (const target of newEncryptionTargets) {\n                target.dispose();\n            }\n            throw err;\n        }\n        return newEncryptionTargets;\n    }\n\n    async _claimOneTimeKeys(hsApi, deviceIdentities, log) {\n        // create a Map<userId, Map<deviceId, deviceIdentity>>\n        const devicesByUser = groupByWithCreator(deviceIdentities,\n            device => device.userId,\n            () => new Map(),\n            (deviceMap, device) => deviceMap.set(device.deviceId, device)\n        );\n        const oneTimeKeys = Array.from(devicesByUser.entries()).reduce((usersObj, [userId, deviceMap]) => {\n            usersObj[userId] = Array.from(deviceMap.values()).reduce((devicesObj, device) => {\n                devicesObj[device.deviceId] = OTK_ALGORITHM;\n                return devicesObj;\n            }, {});\n            return usersObj;\n        }, {});\n        const claimResponse = await hsApi.claimKeys({\n            timeout: 10000,\n            one_time_keys: oneTimeKeys\n        }, {log}).response();\n        if (Object.keys(claimResponse.failures).length) {\n            log.log({l: \"failures\", servers: Object.keys(claimResponse.failures)}, log.level.Warn);\n        }\n        const userKeyMap = claimResponse?.[\"one_time_keys\"];\n        return this._verifyAndCreateOTKTargets(userKeyMap, devicesByUser, log);\n    }\n\n    _verifyAndCreateOTKTargets(userKeyMap, devicesByUser, log) {\n        const verifiedEncryptionTargets = [];\n        for (const [userId, userSection] of Object.entries(userKeyMap)) {\n            for (const [deviceId, deviceSection] of Object.entries(userSection)) {\n                const [firstPropName, keySection] = Object.entries(deviceSection)[0];\n                const [keyAlgorithm] = firstPropName.split(\":\");\n                if (keyAlgorithm === OTK_ALGORITHM) {\n                    const device = devicesByUser.get(userId)?.get(deviceId);\n                    if (device) {\n                        const isValidSignature = verifyEd25519Signature(\n                            this._olmUtil, userId, deviceId, device.ed25519Key, keySection, log);\n                        if (isValidSignature) {\n                            const target = EncryptionTarget.fromOTK(device, keySection.key);\n                            verifiedEncryptionTargets.push(target);\n                        }\n                    }\n                }\n            } \n        }\n        return verifiedEncryptionTargets;\n    }\n\n    async _loadSessions(encryptionTargets) {\n        const txn = await this._storage.readTxn([this._storage.storeNames.olmSessions]);\n        // given we run loading in parallel, there might still be some\n        // storage requests that will finish later once one has failed.\n        // those should not allocate a session anymore.\n        let failed = false;\n        try {\n            await Promise.all(encryptionTargets.map(async encryptionTarget => {\n                const sessionEntry = await txn.olmSessions.get(\n                    encryptionTarget.device.curve25519Key, encryptionTarget.sessionId);\n                if (sessionEntry && !failed) {\n                    const olmSession = new this._olm.Session();\n                    olmSession.unpickle(this._pickleKey, sessionEntry.session);\n                    encryptionTarget.session = olmSession;\n                }\n            }));\n        } catch (err) {\n            failed = true;\n            // clean up the sessions that did load\n            for (const target of encryptionTargets) {\n                target.dispose();\n            }\n            throw err;\n        }\n    }\n\n    async _storeSessions(encryptionTargets, timestamp) {\n        const txn = await this._storage.readWriteTxn([this._storage.storeNames.olmSessions]);\n        try {\n            for (const target of encryptionTargets) {\n                const sessionEntry = createSessionEntry(\n                    target.session, target.device.curve25519Key, timestamp, this._pickleKey);\n                txn.olmSessions.set(sessionEntry);\n            }\n        } catch (err) {\n            txn.abort();\n            throw err;\n        }\n        await txn.complete();\n    }\n}\n\n// just a container needed to encrypt a message for a recipient device\n// it is constructed with either a oneTimeKey\n// (and later converted to a session) in case of a new session\n// or an existing session\nclass EncryptionTarget {\n    constructor(device, oneTimeKey, sessionId) {\n        this.device = device;\n        this.oneTimeKey = oneTimeKey;\n        this.sessionId = sessionId;\n        // an olmSession, should probably be called olmSession\n        this.session = null;\n    }\n\n    static fromOTK(device, oneTimeKey) {\n        return new EncryptionTarget(device, oneTimeKey, null);\n    }\n\n    static fromSessionId(device, sessionId) {\n        return new EncryptionTarget(device, null, sessionId);\n    }\n\n    dispose() {\n        if (this.session) {\n            this.session.free();\n        }\n    }\n}\n\nclass EncryptedMessage {\n    constructor(content, device) {\n        this.content = content;\n        this.device = device;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {DecryptionError} from \"../../common.js\";\n\nexport class DecryptionChanges {\n    constructor(roomId, results, errors, replayEntries) {\n        this._roomId = roomId;\n        this._results = results;\n        this._errors = errors;\n        this._replayEntries = replayEntries;\n    }\n\n    /**\n     * @type MegolmBatchDecryptionResult\n     * @property {Map<string, DecryptionResult>} results a map of event id to decryption result\n     * @property {Map<string, Error>} errors event id -> errors\n     * \n     * Handle replay attack detection, and return result\n     * @param  {[type]} txn [description]\n     * @return {MegolmBatchDecryptionResult}\n     */\n    async write(txn) {\n        await Promise.all(this._replayEntries.map(async replayEntry => {\n            try {\n                this._handleReplayAttack(this._roomId, replayEntry, txn);\n            } catch (err) {\n                this._errors.set(replayEntry.eventId, err);\n            }\n        }));\n        return {\n            results: this._results,\n            errors: this._errors\n        };\n    }\n\n    // need to handle replay attack because\n    // if we redecrypted the same message twice and showed it again\n    // then it could be a malicious server admin replaying the word “yes”\n    // to make you respond to a msg you didn’t say “yes” to, or something\n    async _handleReplayAttack(roomId, replayEntry, txn) {\n        const {messageIndex, sessionId, eventId, timestamp} = replayEntry;\n        const decryption = await txn.groupSessionDecryptions.get(roomId, sessionId, messageIndex);\n\n        if (decryption && decryption.eventId !== eventId) {\n            // the one with the newest timestamp should be the attack\n            const decryptedEventIsBad = decryption.timestamp < timestamp;\n            const badEventId = decryptedEventIsBad ? eventId : decryption.eventId;\n            // discard result\n            this._results.delete(eventId);\n\n            throw new DecryptionError(\"MEGOLM_REPLAYED_INDEX\", event, {\n                messageIndex,\n                badEventId,\n                otherEventId: decryption.eventId\n            });\n        }\n\n        if (!decryption) {\n            txn.groupSessionDecryptions.set(roomId, sessionId, messageIndex, {\n                eventId,\n                timestamp\n            });\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function mergeMap<K, V>(src: Map<K, V> | undefined, dst: Map<K, V>): void {\n    if (src) {\n        for (const [key, value] of src.entries()) {\n            dst.set(key, value);\n        }\n    }\n}\n\nexport function tests() {\n    return {\n        \"mergeMap with src\": assert => {\n            const src = new Map();\n            src.set(1, \"a\");\n            const dst = new Map();\n            dst.set(2, \"b\");\n            mergeMap(src, dst);\n            assert.equal(dst.get(1), \"a\");\n            assert.equal(dst.get(2), \"b\");\n            assert.equal(src.get(2), null);\n        },\n        \"mergeMap without src doesn't fail\": () => {\n            mergeMap(undefined, new Map());\n        }\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {DecryptionChanges} from \"./DecryptionChanges.js\";\nimport {mergeMap} from \"../../../../utils/mergeMap\";\n\n/**\n * Class that contains all the state loaded from storage to decrypt the given events\n */\nexport class DecryptionPreparation {\n    constructor(roomId, sessionDecryptions, errors) {\n        this._roomId = roomId;\n        this._sessionDecryptions = sessionDecryptions;\n        this._initialErrors = errors;\n    }\n\n    async decrypt() {\n        try {\n            const errors = this._initialErrors;\n            const results = new Map();\n            const replayEntries = [];\n            await Promise.all(this._sessionDecryptions.map(async sessionDecryption => {\n                const sessionResult = await sessionDecryption.decryptAll();\n                mergeMap(sessionResult.errors, errors);\n                mergeMap(sessionResult.results, results);\n                replayEntries.push(...sessionResult.replayEntries);\n            }));\n            return new DecryptionChanges(this._roomId, results, errors, replayEntries);\n        } finally {\n            this.dispose();\n        }\n    }\n\n    dispose() {\n        for (const sd of this._sessionDecryptions) {\n            sd.dispose();\n        }\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type {TimelineEvent} from \"../../../storage/types\";\n\nexport class ReplayDetectionEntry {\n    public readonly sessionId: string;\n    public readonly messageIndex: number;\n    public readonly event: TimelineEvent;\n\n    constructor(sessionId: string, messageIndex: number, event: TimelineEvent) {\n        this.sessionId = sessionId;\n        this.messageIndex = messageIndex;\n        this.event = event;\n    }\n\n    get eventId(): string {\n        return this.event.event_id;\n    }\n\n    get timestamp(): number {\n        return this.event.origin_server_ts;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {DecryptionResult} from \"../../DecryptionResult.js\";\nimport {DecryptionError} from \"../../common.js\";\nimport {ReplayDetectionEntry} from \"./ReplayDetectionEntry\";\nimport type {RoomKey} from \"./RoomKey\";\nimport type {KeyLoader, OlmDecryptionResult} from \"./KeyLoader\";\nimport type {OlmWorker} from \"../../OlmWorker\";\nimport type {TimelineEvent} from \"../../../storage/types\";\n\ninterface DecryptAllResult {\n    readonly results: Map<string, DecryptionResult>;\n    readonly errors?: Map<string, Error>;\n    readonly replayEntries: ReplayDetectionEntry[];\n}\n/**\n * Does the actual decryption of all events for a given megolm session in a batch\n */\nexport class SessionDecryption {\n    private key: RoomKey;\n    private events: TimelineEvent[];\n    private keyLoader: KeyLoader;\n    private olmWorker?: OlmWorker;\n    private decryptionRequests?: any[];\n\n    constructor(key: RoomKey, events: TimelineEvent[], olmWorker: OlmWorker | undefined, keyLoader: KeyLoader) {\n        this.key = key;\n        this.events = events;\n        this.olmWorker = olmWorker;\n        this.keyLoader = keyLoader;\n        this.decryptionRequests = olmWorker ? [] : undefined;\n    }\n\n    async decryptAll(): Promise<DecryptAllResult> {\n        const replayEntries: ReplayDetectionEntry[] = [];\n        const results: Map<string, DecryptionResult> = new Map();\n        let errors: Map<string, Error> | undefined;\n\n        await this.keyLoader.useKey(this.key, async session => {\n            for (const event of this.events) {\n                try {\n                    const ciphertext = event.content.ciphertext as string;\n                    let decryptionResult: OlmDecryptionResult | undefined;\n                    // TODO: pass all cipthertexts in one go to the megolm worker and don't deserialize the key until in the worker?\n                    if (this.olmWorker) {\n                        const request = this.olmWorker.megolmDecrypt(session, ciphertext);\n                        this.decryptionRequests!.push(request);\n                        decryptionResult = await request.response();\n                    } else {\n                        decryptionResult = session.decrypt(ciphertext) as OlmDecryptionResult;\n                    }\n                    const {plaintext} = decryptionResult!;\n                    let payload;\n                    try {\n                        payload = JSON.parse(plaintext);\n                    } catch (err) {\n                        throw new DecryptionError(\"PLAINTEXT_NOT_JSON\", event, {plaintext, err});\n                    }\n                    if (payload.room_id !== this.key.roomId) {\n                        throw new DecryptionError(\"MEGOLM_WRONG_ROOM\", event,\n                            {encryptedRoomId: payload.room_id, eventRoomId: this.key.roomId});\n                    }\n                    replayEntries.push(new ReplayDetectionEntry(this.key.sessionId, decryptionResult!.message_index, event));\n                    const result = new DecryptionResult(payload, this.key.senderKey, this.key.claimedEd25519Key);\n                    results.set(event.event_id, result);\n                } catch (err) {\n                    // ignore AbortError from cancelling decryption requests in dispose method\n                    if (err.name === \"AbortError\") {\n                        return;\n                    }\n                    if (!errors) {\n                        errors = new Map();\n                    }\n                    errors.set(event.event_id, err);\n                }\n            }\n        });\n\n        return {results, errors, replayEntries};\n    }\n\n    dispose() {\n        if (this.decryptionRequests) {\n            for (const r of this.decryptionRequests) {\n                r.abort();\n            }\n        }\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {groupByWithCreator} from \"../../../../utils/groupBy\";\nimport type {TimelineEvent} from \"../../../storage/types\";\n\nfunction getSenderKey(event: TimelineEvent): string | undefined {\n    return event.content?.[\"sender_key\"];\n}\n\nfunction getSessionId(event: TimelineEvent): string | undefined {\n    return event.content?.[\"session_id\"];\n}\n\nfunction getCiphertext(event: TimelineEvent): string | undefined {\n    return event.content?.ciphertext;\n}\n\nexport function validateEvent(event: TimelineEvent) {\n    return typeof getSenderKey(event) === \"string\" &&\n           typeof getSessionId(event) === \"string\" &&\n           typeof getCiphertext(event) === \"string\";\n}\n\nexport class SessionKeyGroup {\n    public readonly events: TimelineEvent[];\n    constructor() {\n        this.events = [];\n    }\n\n    get senderKey(): string | undefined {\n        return getSenderKey(this.events[0]!);\n    }\n\n    get sessionId(): string | undefined {\n        return getSessionId(this.events[0]!);\n    }\n}\n\nexport function groupEventsBySession(events: TimelineEvent[]): Map<string, SessionKeyGroup> {\n    return groupByWithCreator<string, TimelineEvent, SessionKeyGroup>(events,\n        (event: TimelineEvent) => `${getSenderKey(event)}|${getSessionId(event)}`,\n        () => new SessionKeyGroup(),\n        (group: SessionKeyGroup, event: TimelineEvent) => group.events.push(event)\n    );\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BackupStatus, KeySource} from \"../../../storage/idb/stores/InboundGroupSessionStore\";\nimport type {InboundGroupSessionEntry} from \"../../../storage/idb/stores/InboundGroupSessionStore\";\nimport type {Transaction} from \"../../../storage/idb/Transaction\";\nimport type {DecryptionResult} from \"../../DecryptionResult\";\nimport type {KeyLoader} from \"./KeyLoader\";\nimport type * as OlmNamespace from \"@matrix-org/olm\";\ntype Olm = typeof OlmNamespace;\n\nexport abstract class RoomKey {\n    private _isBetter: boolean | undefined;\n\n    isForSession(roomId: string, senderKey: string, sessionId: string) {\n        return this.roomId === roomId && this.senderKey === senderKey && this.sessionId === sessionId;\n    }\n\n    abstract get roomId(): string;\n    abstract get senderKey(): string;\n    abstract get sessionId(): string;\n    abstract get claimedEd25519Key(): string;\n    abstract get serializationKey(): string;\n    abstract get serializationType(): string;\n    abstract get eventIds(): string[] | undefined;\n    abstract loadInto(session: Olm.InboundGroupSession, pickleKey: string): void;\n    /* Whether the key has been checked against storage (or is from storage)\n     * to be the better key for a given session. Given that all keys are checked to be better\n     * as part of writing, we can trust that when this returns true, it really is the best key\n     * available between storage and cached keys in memory. This is why keys with this field set to\n     * true are used by the key loader to return cached keys. Also see KeyOperation.isBest there. */\n    get isBetter(): boolean | undefined { return this._isBetter; }\n    // should only be set in key.checkBetterThanKeyInStorage\n    set isBetter(value: boolean | undefined) { this._isBetter = value; }\n}\n\nexport function isBetterThan(newSession: Olm.InboundGroupSession, existingSession: Olm.InboundGroupSession) {\n     return newSession.first_known_index() < existingSession.first_known_index();\n}\n\nexport abstract class IncomingRoomKey extends RoomKey {\n    private _eventIds?: string[];\n    \n    checkBetterThanKeyInStorage(loader: KeyLoader, txn: Transaction): Promise<boolean> {\n        return this._checkBetterThanKeyInStorage(loader, undefined, txn);\n    }\n\n    async write(loader: KeyLoader, txn: Transaction): Promise<boolean> {\n        // we checked already and we had a better session in storage, so don't write\n        let pickledSession: string | undefined;\n        if (this.isBetter === undefined) {\n            // if this key wasn't used to decrypt any messages in the same sync,\n            // we haven't checked if this is the best key yet,\n            // so do that now to not overwrite a better key.\n            // while we have the key deserialized, also pickle it to store it later on here.\n            await this._checkBetterThanKeyInStorage(loader, (session, pickleKey) => {\n                pickledSession = session.pickle(pickleKey);\n            }, txn);\n        }\n        if (this.isBetter === false) {\n            return false;\n        }\n        // before calling write in parallel, we need to check loader.running is false so we are sure our transaction will not be closed\n        if (!pickledSession) {\n            pickledSession = await loader.useKey(this, (session, pickleKey) => session.pickle(pickleKey));\n        }\n        const sessionEntry = {\n            roomId: this.roomId,\n            senderKey: this.senderKey,\n            sessionId: this.sessionId,\n            session: pickledSession,\n            backup: this.backupStatus,\n            source: this.keySource,\n            claimedKeys: {\"ed25519\": this.claimedEd25519Key},\n        };\n        txn.inboundGroupSessions.set(sessionEntry);\n        return true;\n    }\n\n    get eventIds() { return this._eventIds; }\n\n    private async _checkBetterThanKeyInStorage(loader: KeyLoader, callback: (((session: Olm.InboundGroupSession, pickleKey: string) => void) | undefined), txn: Transaction): Promise<boolean> {\n        if (this.isBetter !== undefined) {\n            return this.isBetter;\n        }\n        let existingKey = loader.getCachedKey(this.roomId, this.senderKey, this.sessionId);\n        if (!existingKey) {\n            const storageKey = await keyFromStorage(this.roomId, this.senderKey, this.sessionId, txn);\n            // store the event ids that can be decrypted with this key\n            // before we overwrite them if called from `write`.\n            if (storageKey) {\n                if (storageKey.hasSession) {\n                    existingKey = storageKey;\n                } else if (storageKey.eventIds) {\n                    this._eventIds = storageKey.eventIds;\n                }\n            }\n        }\n        if (existingKey) {\n            const key = existingKey;\n            await loader.useKey(this, async newSession => {\n                await loader.useKey(key, (existingSession, pickleKey) => {\n                    // set isBetter as soon as possible, on both keys compared, \n                    // as it is is used to determine whether a key can be used for the cache\n                    this.isBetter = isBetterThan(newSession, existingSession);\n                    key.isBetter = !this.isBetter;\n                    if (this.isBetter && callback) {\n                        callback(newSession, pickleKey);\n                    }\n                });\n            });\n        } else {\n            // no previous key, so we're the best \\o/\n            this.isBetter = true;\n        }\n        return this.isBetter!;\n    }\n\n    protected get backupStatus(): BackupStatus {\n        return BackupStatus.NotBackedUp;\n    }\n\n    protected abstract get keySource(): KeySource;\n}\n\nclass DeviceMessageRoomKey extends IncomingRoomKey {\n    private _decryptionResult: DecryptionResult;\n\n    constructor(decryptionResult: DecryptionResult) {\n        super();\n        this._decryptionResult = decryptionResult;\n    }\n\n    get roomId() { return this._decryptionResult.event.content?.[\"room_id\"]; }\n    get senderKey() { return this._decryptionResult.senderCurve25519Key; }\n    get sessionId() { return this._decryptionResult.event.content?.[\"session_id\"]; }\n    get claimedEd25519Key() { return this._decryptionResult.claimedEd25519Key; }\n    get serializationKey(): string { return this._decryptionResult.event.content?.[\"session_key\"]; }\n    get serializationType(): string { return \"create\"; }\n    protected get keySource(): KeySource { return KeySource.DeviceMessage; }\n\n    loadInto(session) {\n        session.create(this.serializationKey);\n    }\n}\n\n// a room key we send out ourselves,\n// here adapted to write it as an incoming key\n// as we don't send it to ourself with a to_device msg\nexport class OutboundRoomKey extends IncomingRoomKey {\n    private _sessionKey: string;\n\n    constructor(\n        private readonly _roomId: string,\n        private readonly outboundSession: Olm.OutboundGroupSession,\n        private readonly identityKeys: {[algo: string]: string}\n    ) {\n        super();\n        // this is a new key, so always better than what might be in storage, no need to check\n        this.isBetter = true;\n        // cache this, as it is used by key loader to find a matching key and\n        // this calls into WASM so is not just reading a prop\n        this._sessionKey = this.outboundSession.session_key();\n    }\n\n    get roomId(): string { return this._roomId; }\n    get senderKey(): string { return this.identityKeys.curve25519; }\n    get sessionId(): string { return this.outboundSession.session_id(); }\n    get claimedEd25519Key(): string { return this.identityKeys.ed25519; }\n    get serializationKey(): string { return this._sessionKey; }\n    get serializationType(): string { return \"create\"; }\n    protected get keySource(): KeySource { return KeySource.Outbound; }\n\n    loadInto(session: Olm.InboundGroupSession) {\n        session.create(this.serializationKey);\n    }\n}\n\nclass BackupRoomKey extends IncomingRoomKey {\n    constructor(private _roomId: string, private _sessionId: string, private _backupInfo: object) {\n        super();\n    }\n\n    get roomId() { return this._roomId; }\n    get senderKey() { return this._backupInfo[\"sender_key\"]; }\n    get sessionId() { return this._sessionId; }\n    get claimedEd25519Key() { return this._backupInfo[\"sender_claimed_keys\"]?.[\"ed25519\"]; }\n    get serializationKey(): string { return this._backupInfo[\"session_key\"]; }\n    get serializationType(): string { return \"import_session\"; }\n    protected get keySource(): KeySource { return KeySource.Backup; }\n\n    loadInto(session) {\n        session.import_session(this.serializationKey);\n    }\n\n    protected get backupStatus(): BackupStatus {\n        return BackupStatus.BackedUp;\n    }\n}\n\nexport class StoredRoomKey extends RoomKey {\n    private storageEntry: InboundGroupSessionEntry;\n\n    constructor(storageEntry: InboundGroupSessionEntry) {\n        super();\n        this.isBetter = true; // usually the key in storage is the best until checks prove otherwise\n        this.storageEntry = storageEntry;\n    }\n\n    get roomId() { return this.storageEntry.roomId; }\n    get senderKey() { return this.storageEntry.senderKey; }\n    get sessionId() { return this.storageEntry.sessionId; }\n    get claimedEd25519Key() { return this.storageEntry.claimedKeys![\"ed25519\"]; }\n    get eventIds() { return this.storageEntry.eventIds; }\n    get serializationKey(): string { return this.storageEntry.session || \"\"; }\n    get serializationType(): string { return \"unpickle\"; }\n    \n    loadInto(session, pickleKey) {\n        session.unpickle(pickleKey, this.serializationKey);\n    }\n\n    get hasSession() {\n        // sessions are stored before they are received\n        // to keep track of events that need it to be decrypted.\n        // This is used to retry decryption of those events once the session is received.\n        return !!this.serializationKey;\n    }\n}\n\nexport function keyFromDeviceMessage(dr: DecryptionResult): DeviceMessageRoomKey | undefined {\n    const sessionKey = dr.event.content?.[\"session_key\"];\n    const key = new DeviceMessageRoomKey(dr);\n    if (\n        typeof key.roomId === \"string\" && \n        typeof key.sessionId === \"string\" && \n        typeof key.senderKey === \"string\" &&\n        typeof sessionKey === \"string\"\n    ) {\n        return key;\n    }\n}\n\n/*\nsessionInfo is a response from key backup and has the following keys:\n    algorithm\n    forwarding_curve25519_key_chain\n    sender_claimed_keys\n    sender_key\n    session_key\n */\nexport function keyFromBackup(roomId, sessionId, backupInfo): BackupRoomKey | undefined {\n    const sessionKey = backupInfo[\"session_key\"];\n    const senderKey = backupInfo[\"sender_key\"];\n    // TODO: can we just trust this?\n    const claimedEd25519Key = backupInfo[\"sender_claimed_keys\"]?.[\"ed25519\"];\n\n    if (\n        typeof roomId === \"string\" && \n        typeof sessionId === \"string\" && \n        typeof senderKey === \"string\" &&\n        typeof sessionKey === \"string\" &&\n        typeof claimedEd25519Key === \"string\"\n    ) {\n        return new BackupRoomKey(roomId, sessionId, backupInfo);\n    }\n}\n\nexport async function keyFromStorage(roomId: string, senderKey: string, sessionId: string, txn: Transaction): Promise<StoredRoomKey | undefined> {\n    const existingSessionEntry = await txn.inboundGroupSessions.get(roomId, senderKey, sessionId);\n    if (existingSessionEntry) {\n        return new StoredRoomKey(existingSessionEntry);\n    }\n    return;\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {DecryptionError} from \"../common.js\";\nimport {DecryptionPreparation} from \"./decryption/DecryptionPreparation.js\";\nimport {SessionDecryption} from \"./decryption/SessionDecryption\";\nimport {MEGOLM_ALGORITHM} from \"../common.js\";\nimport {validateEvent, groupEventsBySession} from \"./decryption/utils\";\nimport {keyFromStorage, keyFromDeviceMessage, keyFromBackup} from \"./decryption/RoomKey\";\nimport type {RoomKey, IncomingRoomKey} from \"./decryption/RoomKey\";\nimport type {KeyLoader} from \"./decryption/KeyLoader\";\nimport type {OlmWorker} from \"../OlmWorker\";\nimport type {Transaction} from \"../../storage/idb/Transaction\";\nimport type {TimelineEvent} from \"../../storage/types\";\nimport type {DecryptionResult} from \"../DecryptionResult\";\nimport type {ILogItem} from \"../../../logging/types\";\n\nexport class Decryption {\n    private keyLoader: KeyLoader;\n    private olmWorker?: OlmWorker;\n\n    constructor(keyLoader: KeyLoader, olmWorker: OlmWorker | undefined) {\n        this.keyLoader = keyLoader;\n        this.olmWorker = olmWorker;\n    }\n\n    async addMissingKeyEventIds(roomId, senderKey, sessionId, eventIds, txn) {\n        let sessionEntry = await txn.inboundGroupSessions.get(roomId, senderKey, sessionId);\n        // we never want to overwrite an existing key\n        if (sessionEntry?.session) {\n            return;\n        }\n        if (sessionEntry) {\n            const uniqueEventIds = new Set(sessionEntry.eventIds);\n            for (const id of eventIds) {\n                uniqueEventIds.add(id);\n            }\n            sessionEntry.eventIds = Array.from(uniqueEventIds);\n        } else {\n            sessionEntry = {roomId, senderKey, sessionId, eventIds};\n        }\n        txn.inboundGroupSessions.set(sessionEntry);\n    }\n\n    async getEventIdsForMissingKey(roomId, senderKey, sessionId, txn) {\n        const sessionEntry = await txn.inboundGroupSessions.get(roomId, senderKey, sessionId);\n        if (sessionEntry && !sessionEntry.session) {\n            return sessionEntry.eventIds;\n        }\n    }\n\n    async hasSession(roomId, senderKey, sessionId, txn) {\n        const sessionEntry = await txn.inboundGroupSessions.get(roomId, senderKey, sessionId);\n        const isValidSession = typeof sessionEntry?.session === \"string\";\n        return isValidSession;\n    }\n\n    /**\n     * Reads all the state from storage to be able to decrypt the given events.\n     * Decryption can then happen outside of a storage transaction.\n     * @param  {[type]} roomId       [description]\n     * @param  {[type]} events       [description]\n     * @param  {RoomKey[]?} newKeys  keys as returned from extractRoomKeys, but not yet committed to storage. May be undefined.\n     * @param  {[type]} sessionCache [description]\n     * @param  {[type]} txn          [description]\n     * @return {DecryptionPreparation}\n     */\n    async prepareDecryptAll(roomId: string, events: TimelineEvent[], newKeys: IncomingRoomKey[] | undefined, txn: Transaction) {\n        const errors = new Map();\n        const validEvents: TimelineEvent[] = [];\n\n        for (const event of events) {\n            if (validateEvent(event)) {\n                validEvents.push(event);\n            } else {\n                errors.set(event.event_id, new DecryptionError(\"MEGOLM_INVALID_EVENT\", event))\n            }\n        }\n\n        const eventsBySession = groupEventsBySession(validEvents);\n\n        const sessionDecryptions: SessionDecryption[] = [];\n        await Promise.all(Array.from(eventsBySession.values()).map(async group => {\n            const key = await this.getRoomKey(roomId, group.senderKey!, group.sessionId!, newKeys, txn);\n            if (key) {\n                sessionDecryptions.push(new SessionDecryption(key, group.events, this.olmWorker, this.keyLoader));\n            } else {\n                for (const event of group.events) {\n                    errors.set(event.event_id, new DecryptionError(\"MEGOLM_NO_SESSION\", event));\n                }\n            }\n        }));\n\n        return new DecryptionPreparation(roomId, sessionDecryptions, errors);\n    }\n\n    private async getRoomKey(roomId: string, senderKey: string, sessionId: string, newKeys: IncomingRoomKey[] | undefined, txn: Transaction): Promise<RoomKey | undefined> {\n        if (newKeys) {\n            const key = newKeys.find(k => k.isForSession(roomId, senderKey, sessionId));\n            if (key && await key.checkBetterThanKeyInStorage(this.keyLoader, txn)) {\n                return key;\n            }\n        }\n        // look only in the cache after looking into newKeys as it may contains that are better\n        const cachedKey = this.keyLoader.getCachedKey(roomId, senderKey, sessionId);\n        if (cachedKey) {\n            return cachedKey;\n        }\n        const storageKey = await keyFromStorage(roomId, senderKey, sessionId, txn);\n        if (storageKey && storageKey.serializationKey) {\n            return storageKey;\n        }\n    }\n\n    /**\n     * Writes the key as an inbound group session if there is not already a better key in the store\n     */\n    writeRoomKey(key: IncomingRoomKey, txn: Transaction): Promise<boolean> {\n        return key.write(this.keyLoader, txn);\n    }\n\n    /**\n     * Extracts room keys from decrypted device messages.\n     * The key won't be persisted yet, you need to call RoomKey.write for that.\n     */\n    roomKeysFromDeviceMessages(decryptionResults: DecryptionResult[], log: ILogItem): IncomingRoomKey[] {\n        const keys: IncomingRoomKey[] = [];\n        for (const dr of decryptionResults) {\n            if (dr.event?.type !== \"m.room_key\" || dr.event.content?.algorithm !== MEGOLM_ALGORITHM) {\n                continue;\n            }\n            log.wrap(\"room_key\", log => {\n                const key = keyFromDeviceMessage(dr);\n                if (key) {\n                    log.set(\"roomId\", key.roomId);\n                    log.set(\"id\", key.sessionId);\n                    keys.push(key);\n                } else {\n                    log.logLevel = log.level.Warn;\n                    log.set(\"invalid\", true);\n                }\n            }, log.level.Detail);\n        }\n        return keys;\n    }\n\n    roomKeyFromBackup(roomId: string, sessionId: string, sessionInfo: string): IncomingRoomKey | undefined {\n        return keyFromBackup(roomId, sessionId, sessionInfo);\n    }\n\n    dispose() {\n        this.keyLoader.dispose();\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {isBetterThan, IncomingRoomKey} from \"./RoomKey\";\nimport {BaseLRUCache} from \"../../../../utils/LRUCache\";\nimport type {RoomKey} from \"./RoomKey\";\nimport type * as OlmNamespace from \"@matrix-org/olm\";\ntype Olm = typeof OlmNamespace;\n\nexport declare class OlmDecryptionResult {\n    readonly plaintext: string;\n    readonly message_index: number;\n}\n\n/*\nBecause Olm only has very limited memory available when compiled to wasm,\nwe limit the amount of sessions held in memory.\n*/\nexport class KeyLoader extends BaseLRUCache<KeyOperation> {\n\n    private pickleKey: string;\n    private olm: Olm;\n    private resolveUnusedOperation?: () => void;\n    private operationBecomesUnusedPromise?: Promise<void>;\n\n    constructor(olm: Olm, pickleKey: string, limit: number) {\n        super(limit);\n        this.pickleKey = pickleKey;\n        this.olm = olm;\n    }\n\n    getCachedKey(roomId: string, senderKey: string, sessionId: string): RoomKey | undefined {\n        const idx = this.findCachedKeyIndex(roomId, senderKey, sessionId);\n        if (idx !== -1) {\n            return this._getByIndexAndMoveUp(idx)!.key;\n        }\n    }\n\n    async useKey<T>(key: RoomKey, callback: (session: Olm.InboundGroupSession, pickleKey: string) => Promise<T> | T): Promise<T> {\n        const keyOp = await this.allocateOperation(key);\n        try {\n            return await callback(keyOp.session, this.pickleKey);\n        } finally {\n            this.releaseOperation(keyOp);\n        }\n    }\n\n    get running() {\n        return this._entries.some(op => op.refCount !== 0);\n    }\n\n    dispose() {\n        for (let i = 0; i < this._entries.length; i += 1) {\n            this._entries[i].dispose();\n        }\n        // remove all entries\n        this._entries.splice(0, this._entries.length);\n    }\n\n    private async allocateOperation(key: RoomKey): Promise<KeyOperation> {\n        let idx;\n        while((idx = this.findIndexForAllocation(key)) === -1) {\n            await this.operationBecomesUnused();\n        }\n        if (idx < this.size) {\n            const op = this._getByIndexAndMoveUp(idx)!;\n            // cache hit\n            if (op.isForKey(key)) {\n                op.refCount += 1;\n                return op;\n            } else {\n                // refCount should be 0 here\n                op.refCount = 1;\n                op.key = key;\n                key.loadInto(op.session, this.pickleKey);\n            }\n            return op;\n        } else {\n            // create new operation\n            const session = new this.olm.InboundGroupSession();\n            key.loadInto(session, this.pickleKey);\n            const op = new KeyOperation(key, session);\n            this._set(op);\n            return op;\n        }\n    }\n\n    private releaseOperation(op: KeyOperation) {\n        op.refCount -= 1;\n        if (op.refCount <= 0 && this.resolveUnusedOperation) {\n            this.resolveUnusedOperation();\n            // promise is resolved now, we'll need a new one for next await so clear\n            this.operationBecomesUnusedPromise = this.resolveUnusedOperation = undefined;\n        }\n    }\n\n    private operationBecomesUnused(): Promise<void> {\n        if (!this.operationBecomesUnusedPromise) {\n            this.operationBecomesUnusedPromise = new Promise(resolve => {\n                this.resolveUnusedOperation = resolve;\n            });\n        }\n        return this.operationBecomesUnusedPromise;\n    }\n\n    private findIndexForAllocation(key: RoomKey) {\n        let idx = this.findIndexSameKey(key); // cache hit\n        if (idx === -1) {\n            if (this.size < this.limit) {\n                idx = this.size;\n            } else {\n                idx = this.findIndexSameSessionUnused(key);\n                if (idx === -1) {\n                    idx = this.findIndexOldestUnused();\n                }\n            }\n        }\n        return idx;\n    }\n\n    private findCachedKeyIndex(roomId: string, senderKey: string, sessionId: string): number {\n        return this._entries.reduce((bestIdx, op, i, arr) => {\n            const bestOp = bestIdx === -1 ? undefined : arr[bestIdx];\n            // only operations that are the \"best\" for their session can be used, see comment on isBest\n            if (op.isBest === true && op.isForSameSession(roomId, senderKey, sessionId)) {\n                if (!bestOp || op.isBetter(bestOp)) {\n                    return i;\n                }\n            }\n            return bestIdx;\n        }, -1);\n    }\n\n    private findIndexSameKey(key: RoomKey): number {\n        return this._entries.findIndex(op => {\n            return op.isForSameSession(key.roomId, key.senderKey, key.sessionId) && op.isForKey(key);\n        });\n    }\n\n    private findIndexSameSessionUnused(key: RoomKey): number {\n        return this._entries.reduce((worstIdx, op, i, arr) => {\n            const worst = worstIdx === -1 ? undefined : arr[worstIdx];\n            // we try to pick the worst operation to overwrite, so the best one stays in the cache\n            if (op.refCount === 0 && op.isForSameSession(key.roomId, key.senderKey, key.sessionId)) {\n                if (!worst || !op.isBetter(worst)) {\n                    return i;\n                }\n            }\n            return worstIdx;\n        }, -1);\n    }\n\n    private findIndexOldestUnused(): number {\n        for (let i = this._entries.length - 1; i >= 0; i -= 1) {\n            const op = this._entries[i];\n            if (op.refCount === 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\nclass KeyOperation {\n    session: Olm.InboundGroupSession;\n    key: RoomKey;\n    refCount: number;\n\n    constructor(key: RoomKey, session: Olm.InboundGroupSession) {\n        this.key = key;\n        this.session = session;\n        this.refCount = 1;\n    }\n\n    isForSameSession(roomId: string, senderKey: string, sessionId: string): boolean {\n        return this.key.roomId === roomId && this.key.senderKey === senderKey && this.key.sessionId === sessionId;\n    }\n\n    // assumes isForSameSession is true\n    isBetter(other: KeyOperation) {\n        return isBetterThan(this.session, other.session);\n    }\n\n    isForKey(key: RoomKey) {\n        return this.key.serializationKey === key.serializationKey &&\n            this.key.serializationType === key.serializationType;\n    }\n\n    dispose() {\n        this.session.free();\n        this.session = undefined as any;\n    }\n\n    /** returns whether the key for this operation has been checked at some point against storage\n     * and was determined to be the better key, undefined if it hasn't been checked yet.\n     * Only keys that are the best keys can be returned by getCachedKey as returning a cache hit\n     * will usually not check for a better session in storage. Also see RoomKey.isBetter. */\n    get isBest(): boolean | undefined {\n        return this.key.isBetter;\n    }\n}\n\nimport {KeySource} from \"../../../storage/idb/stores/InboundGroupSessionStore\";\n\n\nexport function tests() {\n    let instances = 0;\n\n    class MockRoomKey extends IncomingRoomKey {\n        private _roomId: string;\n        private _senderKey: string;\n        private _sessionId: string;\n        private _firstKnownIndex: number;\n\n        constructor(roomId: string, senderKey: string, sessionId: string, firstKnownIndex: number) {\n            super();\n            this._roomId = roomId;\n            this._senderKey = senderKey;\n            this._sessionId = sessionId;\n            this._firstKnownIndex = firstKnownIndex;\n        }\n\n        get roomId(): string { return this._roomId; }\n        get senderKey(): string { return this._senderKey; }\n        get sessionId(): string { return this._sessionId; }\n        get claimedEd25519Key(): string { return \"claimedEd25519Key\"; }\n        get serializationKey(): string { return `key-${this.sessionId}-${this._firstKnownIndex}`; }\n        get serializationType(): string { return \"type\"; }\n        get eventIds(): string[] | undefined { return undefined; }\n        get keySource(): KeySource { return KeySource.DeviceMessage; }\n\n        loadInto(session: Olm.InboundGroupSession) {\n            const mockSession = session as MockInboundSession;\n            mockSession.sessionId = this.sessionId;\n            mockSession.firstKnownIndex = this._firstKnownIndex;\n        }\n    }\n\n    class MockInboundSession {\n        public sessionId: string = \"\";\n        public firstKnownIndex: number = 0;\n\n        constructor() {\n            instances += 1;\n        }\n\n        free(): void { instances -= 1; }\n        pickle(key: string | Uint8Array): string { return `${this.sessionId}-pickled-session`; }\n        unpickle(key: string | Uint8Array, pickle: string) {}\n        create(session_key: string): string { return `${this.sessionId}-created-session`; }\n        import_session(session_key: string): string { return \"\"; }\n        decrypt(message: string): OlmDecryptionResult { return {} as OlmDecryptionResult; }\n        session_id(): string { return this.sessionId; }\n        first_known_index(): number { return this.firstKnownIndex; }\n        export_session(message_index: number): string { return `${this.sessionId}-exported-session`; }\n    }\n\n    const PICKLE_KEY = \"🥒🔑\";\n    const olm = {InboundGroupSession: MockInboundSession};\n    const roomId = \"!abc:hs.tld\";\n    const aliceSenderKey = \"abc\";\n    const bobSenderKey = \"def\";\n    const sessionId1 = \"s123\";\n    const sessionId2 = \"s456\";\n    \n    return {\n        \"load key gives correct session\": async assert => {\n            const loader = new KeyLoader(olm as any as Olm, PICKLE_KEY, 2);\n            let callback1Called = false;\n            let callback2Called = false;\n            const p1 = loader.useKey(new MockRoomKey(roomId, aliceSenderKey, sessionId1, 1), async session => {\n                callback1Called = true;\n                assert.equal(session.session_id(), sessionId1);\n                assert.equal(session.first_known_index(), 1);\n                await Promise.resolve(); // make sure they are busy in parallel\n            });\n            const p2 = loader.useKey(new MockRoomKey(roomId, aliceSenderKey, sessionId2, 2), async session => {\n                callback2Called = true;\n                assert.equal(session.session_id(), sessionId2);\n                assert.equal(session.first_known_index(), 2);\n                await Promise.resolve(); // make sure they are busy in parallel\n            });\n            assert.equal(loader.size, 2);\n            await Promise.all([p1, p2]);\n            assert(callback1Called);\n            assert(callback2Called);\n        },\n        \"keys with different first index are kept separate\": async assert => {\n            const loader = new KeyLoader(olm as any as Olm, PICKLE_KEY, 2);\n            let callback1Called = false;\n            let callback2Called = false;\n            const p1 = loader.useKey(new MockRoomKey(roomId, aliceSenderKey, sessionId1, 1), async session => {\n                callback1Called = true;\n                assert.equal(session.session_id(), sessionId1);\n                assert.equal(session.first_known_index(), 1);\n                await Promise.resolve(); // make sure they are busy in parallel\n            });\n            const p2 = loader.useKey(new MockRoomKey(roomId, aliceSenderKey, sessionId1, 2), async session => {\n                callback2Called = true;\n                assert.equal(session.session_id(), sessionId1);\n                assert.equal(session.first_known_index(), 2);\n                await Promise.resolve(); // make sure they are busy in parallel\n            });\n            assert.equal(loader.size, 2);\n            await Promise.all([p1, p2]);\n            assert(callback1Called);\n            assert(callback2Called);\n        },\n        \"useKey blocks as long as no free sessions are available\": async assert => {\n            const loader = new KeyLoader(olm as any as Olm, PICKLE_KEY, 1);\n            let resolve;\n            let callbackCalled = false;\n            loader.useKey(new MockRoomKey(roomId, aliceSenderKey, sessionId1, 1), async session => {\n                await new Promise(r => resolve = r);\n            });\n            await Promise.resolve();\n            assert.equal(loader.size, 1);\n            const promise = loader.useKey(new MockRoomKey(roomId, aliceSenderKey, sessionId2, 1), session => {\n                callbackCalled = true;\n            });\n            assert.equal(callbackCalled, false);\n            resolve();\n            await promise;\n            assert.equal(callbackCalled, true);\n        },\n        \"cache hit while key in use, then replace (check refCount works properly)\": async assert => {\n            const loader = new KeyLoader(olm as any as Olm, PICKLE_KEY, 1);\n            let resolve1, resolve2;\n            const key1 = new MockRoomKey(roomId, aliceSenderKey, sessionId1, 1);\n            const p1 = loader.useKey(key1, async session => {\n                await new Promise(r => resolve1 = r);\n            });\n            const p2 = loader.useKey(key1, async session => {\n                await new Promise(r => resolve2 = r);\n            });\n            await Promise.resolve();\n            assert.equal(loader.size, 1);\n            assert.equal(loader.running, true);\n            resolve1();\n            await p1;\n            assert.equal(loader.running, true);\n            resolve2();\n            await p2;\n            assert.equal(loader.running, false);\n            let callbackCalled = false;\n            await loader.useKey(new MockRoomKey(roomId, aliceSenderKey, sessionId2, 1), async session => {\n                callbackCalled = true;\n                assert.equal(session.session_id(), sessionId2);\n                assert.equal(session.first_known_index(), 1);\n            });\n            assert.equal(loader.size, 1);\n            assert.equal(callbackCalled, true);\n        },\n        \"cache hit while key not in use\": async assert => {\n            const loader = new KeyLoader(olm as any as Olm, PICKLE_KEY, 2);\n            let resolve1, resolve2, invocations = 0;\n            const key1 = new MockRoomKey(roomId, aliceSenderKey, sessionId1, 1);\n            await loader.useKey(key1, async session => { invocations += 1; });\n            key1.isBetter = true;\n            assert.equal(loader.size, 1);\n            const cachedKey = loader.getCachedKey(roomId, aliceSenderKey, sessionId1)!;\n            assert.equal(cachedKey, key1);\n            await loader.useKey(cachedKey, async session => { invocations += 1; });\n            assert.equal(loader.size, 1);\n            assert.equal(invocations, 2);\n        },\n        \"dispose calls free on all sessions\": async assert => {\n            instances = 0;\n            const loader = new KeyLoader(olm as any as Olm, PICKLE_KEY, 2);\n            await loader.useKey(new MockRoomKey(roomId, aliceSenderKey, sessionId1, 1), async session => {});\n            await loader.useKey(new MockRoomKey(roomId, aliceSenderKey, sessionId2, 1), async session => {});\n            assert.equal(instances, 2);\n            assert.equal(loader.size, 2);\n            loader.dispose();\n            assert.strictEqual(instances, 0, \"instances\");\n            assert.strictEqual(loader.size, 0, \"loader.size\");\n        },\n        \"checkBetterThanKeyInStorage false with cache\": async assert => {\n            const loader = new KeyLoader(olm as any as Olm, PICKLE_KEY, 2);\n            const key1 = new MockRoomKey(roomId, aliceSenderKey, sessionId1, 2);\n            await loader.useKey(key1, async session => {});\n            // fake we've checked with storage that this is the best key,\n            // and as long is it remains the best key with newly added keys,\n            // it will be returned from getCachedKey (as called from checkBetterThanKeyInStorage)\n            key1.isBetter = true;\n            const key2 = new MockRoomKey(roomId, aliceSenderKey, sessionId1, 3);\n            // this will hit cache of key 1 so we pass in null as txn\n            const isBetter = await key2.checkBetterThanKeyInStorage(loader, null as any);\n            assert.strictEqual(isBetter, false);\n            assert.strictEqual(key2.isBetter, false);\n        },\n        \"checkBetterThanKeyInStorage true with cache\": async assert => {\n            const loader = new KeyLoader(olm as any as Olm, PICKLE_KEY, 2);\n            const key1 = new MockRoomKey(roomId, aliceSenderKey, sessionId1, 2);\n            key1.isBetter = true; // fake we've check with storage so far (not including key2) this is the best key\n            await loader.useKey(key1, async session => {});\n            const key2 = new MockRoomKey(roomId, aliceSenderKey, sessionId1, 1);\n            // this will hit cache of key 1 so we pass in null as txn\n            const isBetter = await key2.checkBetterThanKeyInStorage(loader, null as any);\n            assert.strictEqual(isBetter, true);\n            assert.strictEqual(key2.isBetter, true);\n        },\n        \"prefer to remove worst key for a session from cache\": async assert => {\n            const loader = new KeyLoader(olm as any as Olm, PICKLE_KEY, 2);\n            const key1 = new MockRoomKey(roomId, aliceSenderKey, sessionId1, 2);\n            await loader.useKey(key1, async session => {});\n            key1.isBetter = true; // set to true just so it gets returned from getCachedKey\n            const key2 = new MockRoomKey(roomId, aliceSenderKey, sessionId1, 4);\n            await loader.useKey(key2, async session => {});\n            const key3 = new MockRoomKey(roomId, aliceSenderKey, sessionId1, 3);\n            await loader.useKey(key3, async session => {});\n            assert.strictEqual(loader.getCachedKey(roomId, aliceSenderKey, sessionId1), key1);\n        },\n    }\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {MEGOLM_ALGORITHM} from \"../../common\";\nimport type {RoomKey} from \"../decryption/RoomKey\";\n\nimport type {BaseBackupInfo, SignatureMap, SessionKeyInfo} from \"./types\";\nimport type * as OlmNamespace from \"@matrix-org/olm\";\ntype Olm = typeof OlmNamespace;\n\nexport const Algorithm = \"m.megolm_backup.v1.curve25519-aes-sha2\";\n\nexport type BackupInfo = BaseBackupInfo & {\n    algorithm: typeof Algorithm,\n    auth_data: AuthData,\n}\n\ntype AuthData = {\n    public_key: string,\n    signatures: SignatureMap\n}\n\nexport type SessionData = {\n    ciphertext: string,\n    mac: string,\n    ephemeral: string,\n}\n\nexport class BackupEncryption {\n    constructor(\n        private encryption?: Olm.PkEncryption,\n        private decryption?: Olm.PkDecryption\n    ) {}\n\n    static fromAuthData(authData: AuthData, privateKey: Uint8Array, olm: Olm): BackupEncryption {\n        const expectedPubKey = authData.public_key;\n        const decryption = new olm.PkDecryption();\n        const encryption = new olm.PkEncryption();\n        try {\n            const pubKey = decryption.init_with_private_key(privateKey);\n            if (pubKey !== expectedPubKey) {\n                throw new Error(`Bad backup key, public key does not match. Calculated ${pubKey} but expected ${expectedPubKey}`);\n            }\n            encryption.set_recipient_key(pubKey);\n        } catch(err) {\n            decryption.free();\n            throw err;\n        }\n        return new BackupEncryption(encryption, decryption);\n    }\n\n    decryptRoomKey(sessionData: SessionData): SessionKeyInfo {\n        const sessionInfo = this.decryption!.decrypt(\n            sessionData.ephemeral,\n            sessionData.mac,\n            sessionData.ciphertext,\n        );\n        return JSON.parse(sessionInfo) as SessionKeyInfo;\n    }\n\n    encryptRoomKey(key: RoomKey, sessionKey: string): SessionData {\n        const sessionInfo: SessionKeyInfo = {\n            algorithm: MEGOLM_ALGORITHM,\n            sender_key: key.senderKey,\n            sender_claimed_keys: {ed25519: key.claimedEd25519Key},\n            forwarding_curve25519_key_chain: [],\n            session_key: sessionKey\n        };\n        return this.encryption!.encrypt(JSON.stringify(sessionInfo)) as SessionData;\n    }\n\n    dispose() {\n        this.decryption?.free();\n        this.decryption = undefined;\n        this.encryption?.free();\n        this.encryption = undefined;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {StoreNames} from \"../../../storage/common\";\nimport {StoredRoomKey, keyFromBackup} from \"../decryption/RoomKey\";\nimport {MEGOLM_ALGORITHM} from \"../../common\";\nimport * as Curve25519 from \"./Curve25519\";\nimport {AbortableOperation} from \"../../../../utils/AbortableOperation\";\nimport {ObservableValue} from \"../../../../observable/ObservableValue\";\n\nimport {SetAbortableFn} from \"../../../../utils/AbortableOperation\";\nimport type {BackupInfo, SessionData, SessionKeyInfo, SessionInfo, KeyBackupPayload} from \"./types\";\nimport type {HomeServerApi} from \"../../../net/HomeServerApi\";\nimport type {IncomingRoomKey, RoomKey} from \"../decryption/RoomKey\";\nimport type {KeyLoader} from \"../decryption/KeyLoader\";\nimport type {SecretStorage} from \"../../../ssss/SecretStorage\";\nimport type {Storage} from \"../../../storage/idb/Storage\";\nimport type {ILogItem} from \"../../../../logging/types\";\nimport type {Platform} from \"../../../../platform/web/Platform\";\nimport type {Transaction} from \"../../../storage/idb/Transaction\";\nimport type * as OlmNamespace from \"@matrix-org/olm\";\ntype Olm = typeof OlmNamespace;\n\nconst KEYS_PER_REQUEST = 200;\n\nexport class KeyBackup {\n    public readonly operationInProgress = new ObservableValue<AbortableOperation<Promise<void>, Progress> | undefined>(undefined);\n\n    private _stopped = false;\n    private _needsNewKey = false;\n    private _hasBackedUpAllKeys = false;\n    private _error?: Error;\n\n    constructor(\n        private readonly backupInfo: BackupInfo,\n        private readonly crypto: Curve25519.BackupEncryption,\n        private readonly hsApi: HomeServerApi,\n        private readonly keyLoader: KeyLoader,\n        private readonly storage: Storage,\n        private readonly platform: Platform,\n        private readonly maxDelay: number = 10000\n    ) {}\n\n    get hasStopped(): boolean { return this._stopped; }\n    get error(): Error | undefined { return this._error; }\n    get version(): string { return this.backupInfo.version; }\n    get needsNewKey(): boolean { return this._needsNewKey; }\n    get hasBackedUpAllKeys(): boolean { return this._hasBackedUpAllKeys; }\n\n    async getRoomKey(roomId: string, sessionId: string, log: ILogItem): Promise<IncomingRoomKey | undefined> {\n        const sessionResponse = await this.hsApi.roomKeyForRoomAndSession(this.backupInfo.version, roomId, sessionId, {log}).response();\n        if (!sessionResponse.session_data) {\n            return;\n        }\n        const sessionKeyInfo = this.crypto.decryptRoomKey(sessionResponse.session_data as SessionData);\n        if (sessionKeyInfo?.algorithm === MEGOLM_ALGORITHM) {\n            return keyFromBackup(roomId, sessionId, sessionKeyInfo);\n        } else if (sessionKeyInfo?.algorithm) {\n            log.set(\"unknown algorithm\", sessionKeyInfo.algorithm);\n        }\n    }\n\n    markAllForBackup(txn: Transaction): Promise<number> {\n        return txn.inboundGroupSessions.markAllAsNotBackedUp();\n    }\n\n    flush(log: ILogItem): void {\n        if (!this.operationInProgress.get()) {\n            log.wrapDetached(\"flush key backup\", async log => {\n                if (this._needsNewKey) {\n                    log.set(\"needsNewKey\", this._needsNewKey);\n                    return;\n                }\n                this._stopped = false;\n                this._error = undefined;\n                this._hasBackedUpAllKeys = false;\n                const operation = this._runFlushOperation(log);\n                this.operationInProgress.set(operation);\n                try {\n                    await operation.result;\n                    this._hasBackedUpAllKeys = true;\n                } catch (err) {\n                    this._stopped = true;\n                    if (err.name === \"HomeServerError\" && (err.errcode === \"M_WRONG_ROOM_KEYS_VERSION\" || err.errcode === \"M_NOT_FOUND\")) {\n                        log.set(\"wrong_version\", true);\n                        this._needsNewKey = true;\n                    } else {\n                        // TODO should really also use AbortError in storage\n                        if (err.name !== \"AbortError\" || (err.name === \"StorageError\" && err.errcode === \"AbortError\")) {\n                            this._error = err;\n                        }\n                    }\n                    log.catch(err);\n                }\n                this.operationInProgress.set(undefined);\n            });\n        }\n    }\n\n    private _runFlushOperation(log: ILogItem): AbortableOperation<Promise<void>, Progress> {\n        return new AbortableOperation(async (setAbortable, setProgress) => {\n            let total = 0;\n            let amountFinished = 0;\n            while (true) {\n                const waitMs = this.platform.random() * this.maxDelay;\n                const timeout = this.platform.clock.createTimeout(waitMs);\n                setAbortable(timeout);\n                await timeout.elapsed();\n                const txn = await this.storage.readTxn([StoreNames.inboundGroupSessions]);\n                setAbortable(txn);\n                // fetch total again on each iteration as while we are flushing, sync might be adding keys\n                total = amountFinished + await txn.inboundGroupSessions.countNonBackedUpSessions();\n                setProgress(new Progress(total, amountFinished));\n                const keysNeedingBackup = (await txn.inboundGroupSessions.getFirstNonBackedUpSessions(KEYS_PER_REQUEST))\n                    .map(entry => new StoredRoomKey(entry));\n                if (keysNeedingBackup.length === 0) {\n                    log.set(\"total\", total);\n                    return;\n                }\n                const payload = await this.encodeKeysForBackup(keysNeedingBackup);\n                const uploadRequest = this.hsApi.uploadRoomKeysToBackup(this.backupInfo.version, payload, {log});\n                setAbortable(uploadRequest);\n                await uploadRequest.response();\n                await this.markKeysAsBackedUp(keysNeedingBackup, setAbortable);\n                amountFinished += keysNeedingBackup.length;\n                setProgress(new Progress(total, amountFinished));\n            }\n        });\n    }\n\n    private async encodeKeysForBackup(roomKeys: RoomKey[]): Promise<KeyBackupPayload> {\n        const payload: KeyBackupPayload = { rooms: {} };\n        const payloadRooms = payload.rooms;\n        for (const key of roomKeys) {\n            let roomPayload = payloadRooms[key.roomId];\n            if (!roomPayload) {\n               roomPayload = payloadRooms[key.roomId] = { sessions: {} };\n            }\n            roomPayload.sessions[key.sessionId] = await this.encodeRoomKey(key);\n        }\n        return payload;\n    }\n\n    private async markKeysAsBackedUp(roomKeys: RoomKey[], setAbortable: SetAbortableFn) {\n        const txn = await this.storage.readWriteTxn([\n            StoreNames.inboundGroupSessions,\n        ]);\n        setAbortable(txn);\n        try {\n            await Promise.all(roomKeys.map(key => {\n                return txn.inboundGroupSessions.markAsBackedUp(key.roomId, key.senderKey, key.sessionId);\n            }));\n        } catch (err) {\n            txn.abort();\n            throw err;\n        }\n        await txn.complete();\n    }\n\n    private async encodeRoomKey(roomKey: RoomKey): Promise<SessionInfo> {\n        return await this.keyLoader.useKey(roomKey, session => {\n            const firstMessageIndex = session.first_known_index();\n            const sessionKey = session.export_session(firstMessageIndex);\n            return {\n                first_message_index: firstMessageIndex,\n                forwarded_count: 0,\n                is_verified: false,\n                session_data: this.crypto.encryptRoomKey(roomKey, sessionKey)\n            };\n        });\n    }\n\n    dispose() {\n        this.crypto.dispose();\n    }\n\n    static async fromSecretStorage(platform: Platform, olm: Olm, secretStorage: SecretStorage, hsApi: HomeServerApi, keyLoader: KeyLoader, storage: Storage, txn: Transaction): Promise<KeyBackup | undefined> {\n        const base64PrivateKey = await secretStorage.readSecret(\"m.megolm_backup.v1\", txn);\n        if (base64PrivateKey) {\n            const privateKey = new Uint8Array(platform.encoding.base64.decode(base64PrivateKey));\n            const backupInfo = await hsApi.roomKeysVersion().response() as BackupInfo;\n            if (backupInfo.algorithm === Curve25519.Algorithm) {\n                const crypto = Curve25519.BackupEncryption.fromAuthData(backupInfo.auth_data, privateKey, olm);\n                return new KeyBackup(backupInfo, crypto, hsApi, keyLoader, storage, platform);\n            } else {\n                throw new Error(`Unknown backup algorithm: ${backupInfo.algorithm}`);\n            }\n        }\n    }\n}\n\nexport class Progress {\n    constructor(\n        public readonly total: number,\n        public readonly finished: number\n    ) {}\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {MEGOLM_ALGORITHM} from \"../common.js\";\nimport {OutboundRoomKey} from \"./decryption/RoomKey\";\n\nexport class Encryption {\n    constructor({pickleKey, olm, account, keyLoader, storage, now, ownDeviceId}) {\n        this._pickleKey = pickleKey;\n        this._olm = olm;\n        this._account = account;\n        this._keyLoader = keyLoader;\n        this._storage = storage;\n        this._now = now;\n        this._ownDeviceId = ownDeviceId;\n    }\n\n    discardOutboundSession(roomId, txn) {\n        txn.outboundGroupSessions.remove(roomId);\n    }\n\n    async createRoomKeyMessage(roomId, txn) {\n        let sessionEntry = await txn.outboundGroupSessions.get(roomId);\n        if (sessionEntry) {\n            const session = new this._olm.OutboundGroupSession();\n            try {\n                session.unpickle(this._pickleKey, sessionEntry.session);\n                return this._createRoomKeyMessage(session, roomId);\n            } finally {\n                session.free();\n            }\n        }\n    }\n\n    createWithheldMessage(roomMessage, code, reason) {\n        return {\n            algorithm: roomMessage.algorithm,\n            code,\n            reason,\n            room_id: roomMessage.room_id,\n            sender_key: this._account.identityKeys.curve25519,\n            session_id: roomMessage.session_id\n        };\n    }\n\n    async ensureOutboundSession(roomId, encryptionParams) {\n        let session = new this._olm.OutboundGroupSession();\n        try {\n            const txn = await this._storage.readWriteTxn([\n                this._storage.storeNames.inboundGroupSessions,\n                this._storage.storeNames.outboundGroupSessions,\n            ]);\n            let roomKeyMessage;\n            try {\n                let sessionEntry = await txn.outboundGroupSessions.get(roomId);\n                roomKeyMessage = await this._readOrCreateSession(session, sessionEntry, roomId, encryptionParams, txn);\n                if (roomKeyMessage) {\n                    this._writeSession(this._now(), session, roomId, txn);\n                }\n            } catch (err) {\n                txn.abort();\n                throw err;\n            }\n            await txn.complete();\n            return roomKeyMessage;\n        } finally {\n            session.free();\n        }\n    }\n\n    async _readOrCreateSession(session, sessionEntry, roomId, encryptionParams, txn) {\n        if (sessionEntry) {\n            session.unpickle(this._pickleKey, sessionEntry.session);\n        }\n        if (!sessionEntry || this._needsToRotate(session, sessionEntry.createdAt, encryptionParams)) {\n            // in the case of rotating, recreate a session as we already unpickled into it\n            if (sessionEntry) {\n                session.free();\n                session = new this._olm.OutboundGroupSession();\n            }\n            session.create();\n            const roomKeyMessage = this._createRoomKeyMessage(session, roomId);\n            const roomKey = new OutboundRoomKey(roomId, session, this._account.identityKeys);\n            await roomKey.write(this._keyLoader, txn);\n            return roomKeyMessage;\n        }\n    }\n\n    _writeSession(createdAt, session, roomId, txn) {\n        txn.outboundGroupSessions.set({\n            roomId,\n            session: session.pickle(this._pickleKey),\n            createdAt,\n        });\n    }\n\n    /**\n     * Encrypts a message with megolm\n     * @param  {string} roomId           \n     * @param  {string} type             event type to encrypt\n     * @param  {string} content          content to encrypt\n     * @param  {object} encryptionParams the content of the m.room.encryption event\n     * @return {Promise<EncryptionResult>}\n     */\n    async encrypt(roomId, type, content, encryptionParams) {\n        let session = new this._olm.OutboundGroupSession();\n        try {\n            const txn = await this._storage.readWriteTxn([\n                this._storage.storeNames.inboundGroupSessions,\n                this._storage.storeNames.outboundGroupSessions,\n            ]);\n            let roomKeyMessage;\n            let encryptedContent;\n            try {\n                let sessionEntry = await txn.outboundGroupSessions.get(roomId);\n                roomKeyMessage = await this._readOrCreateSession(session, sessionEntry, roomId, encryptionParams, txn);\n                encryptedContent = this._encryptContent(roomId, session, type, content);\n                // update timestamp when a new session is created\n                const createdAt = roomKeyMessage ? this._now() : sessionEntry.createdAt;\n                this._writeSession(createdAt, session, roomId, txn);\n\n            } catch (err) {\n                txn.abort();\n                throw err;\n            }\n            await txn.complete();\n            return new EncryptionResult(encryptedContent, roomKeyMessage);\n        } finally {\n            if (session) {\n                session.free();\n            }\n        }\n    }\n\n    _needsToRotate(session, createdAt, encryptionParams) {\n        let rotationPeriodMs = 604800000; // default\n        if (Number.isSafeInteger(encryptionParams?.rotation_period_ms)) {\n            rotationPeriodMs = encryptionParams?.rotation_period_ms;\n        }\n        let rotationPeriodMsgs = 100; // default\n        if (Number.isSafeInteger(encryptionParams?.rotation_period_msgs)) {\n            rotationPeriodMsgs = encryptionParams?.rotation_period_msgs;\n        }\n\n        if (this._now() > (createdAt + rotationPeriodMs)) {\n            return true;\n        }\n        if (session.message_index() >= rotationPeriodMsgs) {\n            return true;\n        }  \n    }\n\n    _encryptContent(roomId, session, type, content) {\n        const plaintext = JSON.stringify({\n            room_id: roomId,\n            type,\n            content\n        });\n        const ciphertext = session.encrypt(plaintext);\n\n        const encryptedContent = {\n            algorithm: MEGOLM_ALGORITHM,\n            sender_key: this._account.identityKeys.curve25519,\n            ciphertext,\n            session_id: session.session_id(),\n            device_id: this._ownDeviceId\n        };\n\n        return encryptedContent;\n    }\n\n    _createRoomKeyMessage(session, roomId) {\n        return {\n            room_id: roomId,\n            session_id: session.session_id(),\n            session_key: session.session_key(),\n            algorithm: MEGOLM_ALGORITHM,\n            // chain_index is ignored by element-web if not all clients\n            // but let's send it anyway, as element-web does so\n            chain_index: session.message_index()\n        }\n    }\n}\n\n/**\n * @property {object?} roomKeyMessage  if encrypting this message\n *                                     created a new outbound session,\n *                                     this contains the content of the m.room_key message\n *                                     that should be sent out over olm.\n * @property {object} content  the encrypted message as the content of\n *                             the m.room.encrypted event that should be sent out   \n */\nclass EncryptionResult {\n    constructor(content, roomKeyMessage) {\n        this.content = content;\n        this.roomKeyMessage = roomKeyMessage;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {MEGOLM_ALGORITHM, DecryptionSource} from \"./common.js\";\nimport {groupEventsBySession} from \"./megolm/decryption/utils\";\nimport {mergeMap} from \"../../utils/mergeMap\";\nimport {groupBy} from \"../../utils/groupBy\";\nimport {makeTxnId} from \"../common.js\";\n\nconst ENCRYPTED_TYPE = \"m.room.encrypted\";\n// how often ensureMessageKeyIsShared can check if it needs to\n// create a new outbound session\n// note that encrypt could still create a new session\nconst MIN_PRESHARE_INTERVAL = 60 * 1000; // 1min\n\n// TODO: this class is a good candidate for splitting up into encryption and decryption, there doesn't seem to be much overlap\nexport class RoomEncryption {\n    constructor({room, deviceTracker, olmEncryption, megolmEncryption, megolmDecryption, encryptionParams, storage, keyBackup, notifyMissingMegolmSession, clock}) {\n        this._room = room;\n        this._deviceTracker = deviceTracker;\n        this._olmEncryption = olmEncryption;\n        this._megolmEncryption = megolmEncryption;\n        this._megolmDecryption = megolmDecryption;\n        // content of the m.room.encryption event\n        this._encryptionParams = encryptionParams;\n        // caches devices to verify events\n        this._senderDeviceCache = new Map();\n        this._storage = storage;\n        this._keyBackup = keyBackup;\n        this._notifyMissingMegolmSession = notifyMissingMegolmSession;\n        this._clock = clock;\n        this._isFlushingRoomKeyShares = false;\n        this._lastKeyPreShareTime = null;\n        this._keySharePromise = null;\n        this._disposed = false;\n    }\n\n    enableKeyBackup(keyBackup) {\n        if (this._keyBackup && !!keyBackup) {\n            return;\n        }\n        this._keyBackup = keyBackup;\n    }\n\n    async restoreMissingSessionsFromBackup(entries, log) {\n        const events = entries.filter(e => e.isEncrypted && !e.isDecrypted && e.event).map(e => e.event);\n        const eventsBySession = groupEventsBySession(events);\n        const groups = Array.from(eventsBySession.values());\n        const txn = await this._storage.readTxn([this._storage.storeNames.inboundGroupSessions]);\n        const hasSessions = await Promise.all(groups.map(async group => {\n            return this._megolmDecryption.hasSession(this._room.id, group.senderKey, group.sessionId, txn);\n        }));\n        const missingSessions = groups.filter((_, i) => !hasSessions[i]);\n        if (missingSessions.length) {\n            // start with last sessions which should be for the last items in the timeline\n            for (var i = missingSessions.length - 1; i >= 0; i--) {\n                const session = missingSessions[i];\n                await log.wrap(\"session\", log => this._requestMissingSessionFromBackup(session.senderKey, session.sessionId, log));\n            }\n        }\n    }\n\n    notifyTimelineClosed() {\n        this._senderDeviceCache = new Map();    // purge the sender device cache\n    }\n\n    async writeMemberChanges(memberChanges, txn, log) {\n        let shouldFlush = false;\n        const memberChangesArray = Array.from(memberChanges.values());\n        // this also clears our session if we leave the room ourselves\n        if (memberChangesArray.some(m => m.hasLeft)) {\n            log.log({\n                l: \"discardOutboundSession\",\n                leftUsers: memberChangesArray.filter(m => m.hasLeft).map(m => m.userId),\n            });\n            this._megolmEncryption.discardOutboundSession(this._room.id, txn);\n        }\n        if (memberChangesArray.some(m => m.hasJoined)) {\n            shouldFlush = await this._addShareRoomKeyOperationForNewMembers(memberChangesArray, txn, log);\n        }\n        await this._deviceTracker.writeMemberChanges(this._room, memberChanges, txn);\n        return shouldFlush;\n    }\n\n    async prepareDecryptAll(events, newKeys, source, txn) {\n        const errors = new Map();\n        const validEvents = [];\n        for (const event of events) {\n            if (event.redacted_because || event.unsigned?.redacted_because) {\n                continue;\n            }\n            if (event.content?.algorithm !== MEGOLM_ALGORITHM) {\n                errors.set(event.event_id, new Error(\"Unsupported algorithm: \" + event.content?.algorithm));\n            }\n            validEvents.push(event);\n        }\n        const preparation = await this._megolmDecryption.prepareDecryptAll(\n            this._room.id, validEvents, newKeys, txn);\n        return new DecryptionPreparation(preparation, errors, source, this, events);\n    }\n\n    async _processDecryptionResults(events, results, errors, source, txn, log) {\n        const missingSessionEvents = events.filter(event => {\n            const error = errors.get(event.event_id);\n            return error?.code === \"MEGOLM_NO_SESSION\";\n        });\n        if (!missingSessionEvents.length) {\n            return;\n        }\n        // store missing event ids if received from sync\n        const missingEventsBySession = groupEventsBySession(missingSessionEvents);\n        if (source === DecryptionSource.Sync) {\n            await Promise.all(Array.from(missingEventsBySession.values()).map(async group => {\n                const eventIds = group.events.map(e => e.event_id);\n                return this._megolmDecryption.addMissingKeyEventIds(\n                    this._room.id, group.senderKey, group.sessionId, eventIds, txn);\n            }));\n        }\n        \n        if (!this._keyBackup) {\n            return;\n        }\n\n        log.wrapDetached(\"check key backup\", async log => {\n            // if the message came from sync, wait 10s to see if the room key arrives late,\n            // and only after that proceed to request from backup\n            log.set(\"source\", source);\n            log.set(\"events\", missingSessionEvents.length);\n            log.set(\"sessions\", missingEventsBySession.size);\n            if (source === DecryptionSource.Sync) {\n                await this._clock.createTimeout(10000).elapsed();\n                if (this._disposed) {\n                    return;\n                }\n                // now check which sessions have been received already\n                const txn = await this._storage.readTxn([this._storage.storeNames.inboundGroupSessions]);\n                await Promise.all(Array.from(missingEventsBySession).map(async ([key, group]) => {\n                    if (await this._megolmDecryption.hasSession(this._room.id, group.senderKey, group.sessionId, txn)) {\n                        missingEventsBySession.delete(key);\n                    }\n                }));\n            }\n            await Promise.all(Array.from(missingEventsBySession.values()).map(group => {\n                return log.wrap(\"session\", log => this._requestMissingSessionFromBackup(group.senderKey, group.sessionId, log));\n            }));\n        });\n    }\n\n    async _verifyDecryptionResult(result, txn) {\n        let device = this._senderDeviceCache.get(result.senderCurve25519Key);\n        if (!device) {\n            device = await this._deviceTracker.getDeviceByCurve25519Key(result.senderCurve25519Key, txn);\n            this._senderDeviceCache.set(result.senderCurve25519Key, device);\n        }\n        if (device) {\n            result.setDevice(device);\n        } else if (!this._room.isTrackingMembers) {\n            result.setRoomNotTrackedYet();\n        }\n    }\n\n    async _requestMissingSessionFromBackup(senderKey, sessionId, log) {\n        // show prompt to enable secret storage\n        if (!this._keyBackup) {\n            log.set(\"enabled\", false);\n            this._notifyMissingMegolmSession();\n            return;\n        }\n        log.set(\"id\", sessionId);\n        log.set(\"senderKey\", senderKey);\n        try {\n            const roomKey = await this._keyBackup.getRoomKey(this._room.id, sessionId, log);\n            if (roomKey) {\n                if (roomKey.senderKey !== senderKey) {\n                    log.set(\"wrong_sender_key\", roomKey.senderKey);\n                    log.logLevel = log.level.Warn;\n                    return;\n                }\n                let keyIsBestOne = false;\n                let retryEventIds;\n                const txn = await this._storage.readWriteTxn([this._storage.storeNames.inboundGroupSessions]);\n                try {\n                    keyIsBestOne = await this._megolmDecryption.writeRoomKey(roomKey, txn);\n                    log.set(\"isBetter\", keyIsBestOne);\n                    if (keyIsBestOne) {\n                        retryEventIds = roomKey.eventIds;\n                    }\n                } catch (err) {\n                    txn.abort();\n                    throw err;\n                }\n                await txn.complete();\n                if (keyIsBestOne) {\n                    await log.wrap(\"retryDecryption\", log => this._room.notifyRoomKey(roomKey, retryEventIds || [], log));\n                }\n            }\n        } catch (err) {\n            if (!(err.name === \"HomeServerError\" && err.errcode === \"M_NOT_FOUND\")) {\n                log.set(\"not_found\", true);\n            } else {\n                log.error = err;\n                log.logLevel = log.level.Error;\n            }\n        }\n    }\n\n    /**\n     * @param  {RoomKey} roomKeys\n     * @param {Transaction} txn\n     * @return {Promise<Array<string>>} the event ids that should be retried to decrypt\n     */\n    getEventIdsForMissingKey(roomKey, txn) {\n        return this._megolmDecryption.getEventIdsForMissingKey(this._room.id, roomKey.senderKey, roomKey.sessionId, txn);\n    }\n\n    /** shares the encryption key for the next message if needed */\n    async ensureMessageKeyIsShared(hsApi, log) {\n        if (this._lastKeyPreShareTime?.measure() < MIN_PRESHARE_INTERVAL) {\n            return;\n        }\n        this._lastKeyPreShareTime = this._clock.createMeasure();\n        try {\n            this._keySharePromise = (async () => {\n                const roomKeyMessage = await this._megolmEncryption.ensureOutboundSession(this._room.id, this._encryptionParams);\n                if (roomKeyMessage) {\n                    this._keyBackup?.flush(log);\n                    await log.wrap(\"share key\", log => this._shareNewRoomKey(roomKeyMessage, hsApi, log));\n                }\n            })();\n            await this._keySharePromise;\n        } finally {\n            this._keySharePromise = null;\n        }\n    }\n\n    async encrypt(type, content, hsApi, log) {\n        // ensureMessageKeyIsShared is still running,\n        // wait for it to create and share a key if needed\n        if (this._keySharePromise) {\n            log.set(\"waitForRunningKeyShare\", true);\n            await this._keySharePromise;\n        }\n        const megolmResult = await log.wrap(\"megolm encrypt\", () => this._megolmEncryption.encrypt(this._room.id, type, content, this._encryptionParams));\n        if (megolmResult.roomKeyMessage) {\n            this._keyBackup?.flush(log);\n            await log.wrap(\"share key\", log => this._shareNewRoomKey(megolmResult.roomKeyMessage, hsApi, log));\n        }\n        return {\n            type: ENCRYPTED_TYPE,\n            content: megolmResult.content\n        };\n    }\n\n    needsToShareKeys(memberChanges) {\n        for (const m of memberChanges.values()) {\n            if (m.hasJoined) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    async _shareNewRoomKey(roomKeyMessage, hsApi, log) {\n        let writeOpTxn = await this._storage.readWriteTxn([this._storage.storeNames.operations]);\n        let operation;\n        try {\n            operation = this._writeRoomKeyShareOperation(roomKeyMessage, null, writeOpTxn);\n        } catch (err) {\n            writeOpTxn.abort();\n            throw err;\n        }\n        // TODO: at this point we have the room key stored, and the rest is sort of optional\n        // it would be nice if we could signal SendQueue that any error from here on is non-fatal and\n        // return the encrypted payload.\n        await this._processShareRoomKeyOperation(operation, hsApi, log);\n    }\n\n    async _addShareRoomKeyOperationForNewMembers(memberChangesArray, txn, log) {\n        const userIds = memberChangesArray.filter(m => m.hasJoined).map(m => m.userId);\n        const roomKeyMessage = await this._megolmEncryption.createRoomKeyMessage(\n            this._room.id, txn);\n        if (roomKeyMessage) {\n            log.log({\n                l: \"share key for new members\", userIds,\n                id: roomKeyMessage.session_id,\n                chain_index: roomKeyMessage.chain_index\n            });\n            this._writeRoomKeyShareOperation(roomKeyMessage, userIds, txn);\n            return true;\n        }\n        return false;\n    }\n\n    async flushPendingRoomKeyShares(hsApi, operations, log) {\n        // this has to be reentrant as it can be called from Room.start while still running\n        if (this._isFlushingRoomKeyShares) {\n            return;\n        }\n        this._isFlushingRoomKeyShares = true;\n        try {\n            if (!operations) {\n                const txn = await this._storage.readTxn([this._storage.storeNames.operations]);\n                operations = await txn.operations.getAllByTypeAndScope(\"share_room_key\", this._room.id);\n            }\n            for (const operation of operations) {\n                // just to be sure\n                if (operation.type !== \"share_room_key\") {\n                    continue;\n                }\n                await log.wrap(\"operation\", log => this._processShareRoomKeyOperation(operation, hsApi, log));\n            }\n        } finally {\n            this._isFlushingRoomKeyShares = false;\n        }\n    }\n\n    _writeRoomKeyShareOperation(roomKeyMessage, userIds, txn) {\n        const id = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString();\n        const operation = {\n            id,\n            type: \"share_room_key\",\n            scope: this._room.id,\n            userIds,\n            roomKeyMessage,\n        };\n        txn.operations.add(operation);\n        return operation;\n    }\n\n    async _processShareRoomKeyOperation(operation, hsApi, log) {\n        log.set(\"id\", operation.id);\n\n        await this._deviceTracker.trackRoom(this._room, log);\n        let devices;\n        if (operation.userIds === null) {\n            devices = await this._deviceTracker.devicesForTrackedRoom(this._room.id, hsApi, log);\n            const userIds = Array.from(devices.reduce((set, device) => set.add(device.userId), new Set()));\n            operation.userIds = userIds;\n            await this._updateOperationsStore(operations => operations.update(operation));\n        } else {\n            devices = await this._deviceTracker.devicesForRoomMembers(this._room.id, operation.userIds, hsApi, log);\n        }\n        \n        const messages = await log.wrap(\"olm encrypt\", log => this._olmEncryption.encrypt(\n            \"m.room_key\", operation.roomKeyMessage, devices, hsApi, log));\n        const missingDevices = devices.filter(d => !messages.some(m => m.device === d));\n        await log.wrap(\"send\", log => this._sendMessagesToDevices(ENCRYPTED_TYPE, messages, hsApi, log));\n        if (missingDevices.length) {\n            await log.wrap(\"missingDevices\", async log => {\n                log.set(\"devices\", missingDevices.map(d => d.deviceId));\n                const unsentUserIds = operation.userIds.filter(userId => missingDevices.some(d => d.userId === userId));\n                log.set(\"unsentUserIds\", unsentUserIds);\n                operation.userIds = unsentUserIds;\n                // first remove the users that we've sent the keys already from the operation,\n                // so if anything fails, we don't send them again\n                await this._updateOperationsStore(operations => operations.update(operation));\n                // now, let the devices we could not claim their key\n                const withheldMessage = this._megolmEncryption.createWithheldMessage(operation.roomKeyMessage, \"m.no_olm\", \"OTKs exhausted\");\n                await this._sendSharedMessageToDevices(\"org.matrix.room_key.withheld\", withheldMessage, missingDevices, hsApi, log);\n            });\n        }\n        await this._updateOperationsStore(operations => operations.remove(operation.id));\n    }\n\n    async _updateOperationsStore(callback) {\n        const writeTxn = await this._storage.readWriteTxn([this._storage.storeNames.operations]);\n        try {\n            callback(writeTxn.operations);\n        } catch (err) {\n            writeTxn.abort();\n            throw err;\n        }\n        await writeTxn.complete();\n    }\n\n    async _sendSharedMessageToDevices(type, message, devices, hsApi, log) {\n        const devicesByUser = groupBy(devices, device => device.userId);\n        const payload = {\n            messages: Array.from(devicesByUser.entries()).reduce((userMap, [userId, devices]) => {\n                userMap[userId] = devices.reduce((deviceMap, device) => {\n                    deviceMap[device.deviceId] = message;\n                    return deviceMap;\n                }, {});\n                return userMap;\n            }, {})\n        };\n        const txnId = makeTxnId();\n        await hsApi.sendToDevice(type, payload, txnId, {log}).response();\n    }\n\n    async _sendMessagesToDevices(type, messages, hsApi, log) {\n        log.set(\"messages\", messages.length);\n        const messagesByUser = groupBy(messages, message => message.device.userId);\n        const payload = {\n            messages: Array.from(messagesByUser.entries()).reduce((userMap, [userId, messages]) => {\n                userMap[userId] = messages.reduce((deviceMap, message) => {\n                    deviceMap[message.device.deviceId] = message.content;\n                    return deviceMap;\n                }, {});\n                return userMap;\n            }, {})\n        };\n        const txnId = makeTxnId();\n        await hsApi.sendToDevice(type, payload, txnId, {log}).response();\n    }\n\n    filterUndecryptedEventEntriesForKeys(entries, keys) {\n        return entries.filter(entry => {\n            if (entry.isEncrypted && !entry.isDecrypted) {\n                const {event} = entry;\n                if (event) {\n                    const senderKey = event.content?.[\"sender_key\"];\n                    const sessionId = event.content?.[\"session_id\"];\n                    return keys.some(key => senderKey === key.senderKey && sessionId === key.sessionId);\n                }\n            }\n            return false;\n        });\n    }\n\n    dispose() {\n        this._disposed = true;\n    }\n}\n\n/**\n * wrappers around megolm decryption classes to be able to post-process\n * the decryption results before turning them\n */\nclass DecryptionPreparation {\n    constructor(megolmDecryptionPreparation, extraErrors, source, roomEncryption, events) {\n        this._megolmDecryptionPreparation = megolmDecryptionPreparation;\n        this._extraErrors = extraErrors;\n        this._source = source;\n        this._roomEncryption = roomEncryption;\n        this._events = events;\n    }\n\n    async decrypt() {\n        return new DecryptionChanges(\n            await this._megolmDecryptionPreparation.decrypt(),\n            this._extraErrors,\n            this._source,\n            this._roomEncryption,\n            this._events);\n    }\n\n    dispose() {\n        this._megolmDecryptionPreparation.dispose();\n    }\n}\n\nclass DecryptionChanges {\n    constructor(megolmDecryptionChanges, extraErrors, source, roomEncryption, events) {\n        this._megolmDecryptionChanges = megolmDecryptionChanges;\n        this._extraErrors = extraErrors;\n        this._source = source;\n        this._roomEncryption = roomEncryption;\n        this._events = events;\n    }\n\n    async write(txn, log) {\n        const {results, errors} = await this._megolmDecryptionChanges.write(txn);\n        mergeMap(this._extraErrors, errors);\n        await this._roomEncryption._processDecryptionResults(this._events, results, errors, this._source, txn, log);\n        return new BatchDecryptionResult(results, errors, this._roomEncryption);\n    }\n}\n\nclass BatchDecryptionResult {\n    constructor(results, errors, roomEncryption) {\n        this.results = results;\n        this.errors = errors;\n        this._roomEncryption = roomEncryption;\n    }\n\n    applyToEntries(entries) {\n        for (const entry of entries) {\n            const result = this.results.get(entry.id);\n            if (result) {\n                entry.setDecryptionResult(result);\n            } else {\n                const error = this.errors.get(entry.id);\n                if (error) {\n                    entry.setDecryptionError(error);\n                }\n            }\n        }\n    }\n\n    verifySenders(txn) {\n        return Promise.all(Array.from(this.results.values()).map(result => {\n            return this._roomEncryption._verifyDecryptionResult(result, txn);\n        }));\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {Lock} from \"./Lock\";\n\nexport class LockMap<T> {\n    private readonly _map: Map<T, Lock> = new Map();\n\n    async takeLock(key: T): Promise<Lock> {\n        let lock = this._map.get(key);\n        if (lock) {\n            await lock.take();\n        } else {\n            lock = new Lock();\n            lock.tryTake();\n            this._map.set(key, lock);\n        }\n        // don't leave old locks lying around\n        lock.released()!.then(() => {\n            // give others a chance to take the lock first\n            Promise.resolve().then(() => {\n                if (!lock!.isTaken) {\n                    this._map.delete(key);\n                }\n            });\n        });\n        return lock;\n    }\n}\n\nexport function tests() {\n    return {\n        \"taking a lock on the same key blocks\": async assert => {\n            const lockMap = new LockMap();\n            const lock = await lockMap.takeLock(\"foo\");\n            let second = false;\n            const prom = lockMap.takeLock(\"foo\").then(() => {\n                second = true;\n            });\n            assert.equal(second, false);\n            // do a delay to make sure prom does not resolve on its own\n            await Promise.resolve();\n            lock.release();\n            await prom;\n            assert.equal(second, true);\n        },\n        \"lock is not cleaned up with second request\": async assert => {\n            const lockMap = new LockMap();\n            const lock = await lockMap.takeLock(\"foo\");\n            let ranSecond = false;\n            const prom = lockMap.takeLock(\"foo\").then(returnedLock => {\n                ranSecond = true;\n                assert.equal(returnedLock.isTaken, true);\n                // peek into internals, naughty\n                // @ts-ignore\n                assert.equal(lockMap._map.get(\"foo\"), returnedLock);\n            });\n            lock.release();\n            await prom;\n            // double delay to make sure cleanup logic ran\n            await Promise.resolve();\n            await Promise.resolve();\n            assert.equal(ranSecond, true);\n        },\n        \"lock is cleaned up without other request\": async assert => {\n            const lockMap = new LockMap();\n            const lock = await lockMap.takeLock(\"foo\");\n            await Promise.resolve();\n            lock.release();\n            // double delay to make sure cleanup logic ran\n            await Promise.resolve();\n            await Promise.resolve();\n            // @ts-ignore\n            assert.equal(lockMap._map.has(\"foo\"), false);\n        },\n        \n    };\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport type {Key} from \"./common\";\nimport type {Platform} from \"../../platform/web/Platform.js\";\nimport type {Transaction} from \"../storage/idb/Transaction\";\n\ntype EncryptedData = {\n    iv: string;\n    ciphertext: string;\n    mac: string;\n}\n\nexport class SecretStorage {\n    private readonly _key: Key;\n    private readonly _platform: Platform;\n\n    constructor({key, platform}: {key: Key, platform: Platform}) {\n        this._key = key;\n        this._platform = platform;\n    }\n\n    async readSecret(name: string, txn: Transaction): Promise<string | undefined> {\n        const accountData = await txn.accountData.get(name);\n        if (!accountData) {\n            return;\n        }\n        const encryptedData = accountData?.content?.encrypted?.[this._key.id] as EncryptedData;\n        if (!encryptedData) {\n            throw new Error(`Secret ${accountData.type} is not encrypted for key ${this._key.id}`);\n        }\n\n        if (this._key.algorithm === \"m.secret_storage.v1.aes-hmac-sha2\") {\n            return await this._decryptAESSecret(accountData.type, encryptedData);\n        } else {\n            throw new Error(`Unsupported algorithm for key ${this._key.id}: ${this._key.algorithm}`);\n        }\n    }\n\n    async _decryptAESSecret(type: string, encryptedData: EncryptedData): Promise<string> {\n        const {base64, utf8} = this._platform.encoding;\n        // now derive the aes and mac key from the 4s key\n        const hkdfKey = await this._platform.crypto.derive.hkdf(\n            this._key.binaryKey,\n            new Uint8Array(8).buffer,   //zero salt\n            utf8.encode(type), // info\n            \"SHA-256\",\n            512 // 512 bits or 64 bytes\n        );\n        const aesKey = hkdfKey.slice(0, 32);\n        const hmacKey = hkdfKey.slice(32);\n        const ciphertextBytes = base64.decode(encryptedData.ciphertext);\n\n        const isVerified = await this._platform.crypto.hmac.verify(\n            hmacKey, base64.decode(encryptedData.mac),\n            ciphertextBytes, \"SHA-256\");\n\n        if (!isVerified) {\n            throw new Error(\"Bad MAC\");\n        }\n\n        const plaintextBytes = await this._platform.crypto.aes.decryptCTR({\n            key: aesKey,\n            iv: base64.decode(encryptedData.iv),\n            data: ciphertextBytes\n        });\n\n        return utf8.decode(plaintextBytes);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {Room} from \"./room/Room.js\";\nimport {ArchivedRoom} from \"./room/ArchivedRoom.js\";\nimport {RoomStatus} from \"./room/common\";\nimport {RoomBeingCreated} from \"./room/RoomBeingCreated\";\nimport {Invite} from \"./room/Invite.js\";\nimport {Pusher} from \"./push/Pusher\";\nimport { ObservableMap } from \"../observable/index.js\";\nimport {User} from \"./User.js\";\nimport {DeviceMessageHandler} from \"./DeviceMessageHandler.js\";\nimport {Account as E2EEAccount} from \"./e2ee/Account.js\";\nimport {uploadAccountAsDehydratedDevice} from \"./e2ee/Dehydration.js\";\nimport {Decryption as OlmDecryption} from \"./e2ee/olm/Decryption.js\";\nimport {Encryption as OlmEncryption} from \"./e2ee/olm/Encryption.js\";\nimport {Decryption as MegOlmDecryption} from \"./e2ee/megolm/Decryption\";\nimport {KeyLoader as MegOlmKeyLoader} from \"./e2ee/megolm/decryption/KeyLoader\";\nimport {KeyBackup} from \"./e2ee/megolm/keybackup/KeyBackup\";\nimport {Encryption as MegOlmEncryption} from \"./e2ee/megolm/Encryption.js\";\nimport {MEGOLM_ALGORITHM} from \"./e2ee/common.js\";\nimport {RoomEncryption} from \"./e2ee/RoomEncryption.js\";\nimport {DeviceTracker} from \"./e2ee/DeviceTracker.js\";\nimport {LockMap} from \"../utils/LockMap\";\nimport {groupBy} from \"../utils/groupBy\";\nimport {\n    keyFromCredential as ssssKeyFromCredential,\n    readKey as ssssReadKey,\n    writeKey as ssssWriteKey,\n    removeKey as ssssRemoveKey,\n    keyFromDehydratedDeviceKey as createSSSSKeyFromDehydratedDeviceKey\n} from \"./ssss/index\";\nimport {SecretStorage} from \"./ssss/SecretStorage\";\nimport {ObservableValue, RetainedObservableValue} from \"../observable/ObservableValue\";\n\nconst PICKLE_KEY = \"DEFAULT_KEY\";\nconst PUSHER_KEY = \"pusher\";\n\nexport class Session {\n    // sessionInfo contains deviceId, userId and homeserver\n    constructor({storage, hsApi, sessionInfo, olm, olmWorker, platform, mediaRepository}) {\n        this._platform = platform;\n        this._storage = storage;\n        this._hsApi = hsApi;\n        this._mediaRepository = mediaRepository;\n        this._syncInfo = null;\n        this._sessionInfo = sessionInfo;\n        this._rooms = new ObservableMap();\n        this._roomUpdateCallback = (room, params) => this._rooms.update(room.id, params);\n        this._activeArchivedRooms = new Map();\n        this._invites = new ObservableMap();\n        this._inviteUpdateCallback = (invite, params) => this._invites.update(invite.id, params);\n        this._roomsBeingCreatedUpdateCallback = (rbc, params) => {\n            if (rbc.isCancelled) {\n                this._roomsBeingCreated.remove(rbc.id);\n            } else {\n                this._roomsBeingCreated.update(rbc.id, params)\n            }\n        };\n        this._roomsBeingCreated = new ObservableMap();\n        this._user = new User(sessionInfo.userId);\n        this._deviceMessageHandler = new DeviceMessageHandler({storage});\n        this._olm = olm;\n        this._olmUtil = null;\n        this._e2eeAccount = null;\n        this._deviceTracker = null;\n        this._olmEncryption = null;\n        this._keyLoader = null;\n        this._megolmEncryption = null;\n        this._megolmDecryption = null;\n        this._getSyncToken = () => this.syncToken;\n        this._olmWorker = olmWorker;\n        this._keyBackup = new ObservableValue(undefined);\n        this._observedRoomStatus = new Map();\n\n        if (olm) {\n            this._olmUtil = new olm.Utility();\n            this._deviceTracker = new DeviceTracker({\n                storage,\n                getSyncToken: this._getSyncToken,\n                olmUtil: this._olmUtil,\n                ownUserId: sessionInfo.userId,\n                ownDeviceId: sessionInfo.deviceId,\n            });\n        }\n        this._createRoomEncryption = this._createRoomEncryption.bind(this);\n        this._forgetArchivedRoom = this._forgetArchivedRoom.bind(this);\n        this.needsKeyBackup = new ObservableValue(false);\n    }\n\n    get fingerprintKey() {\n        return this._e2eeAccount?.identityKeys.ed25519;\n    }\n\n    get hasSecretStorageKey() {\n        return this._hasSecretStorageKey;\n    }\n\n    get deviceId() {\n        return this._sessionInfo.deviceId;\n    }\n\n    get userId() {\n        return this._sessionInfo.userId;\n    }\n\n    // called once this._e2eeAccount is assigned\n    _setupEncryption() {\n        // TODO: this should all go in a wrapper in e2ee/ that is bootstrapped by passing in the account\n        // and can create RoomEncryption objects and handle encrypted to_device messages and device list changes.\n        const senderKeyLock = new LockMap();\n        const olmDecryption = new OlmDecryption({\n            account: this._e2eeAccount,\n            pickleKey: PICKLE_KEY,\n            olm: this._olm,\n            storage: this._storage,\n            now: this._platform.clock.now,\n            ownUserId: this._user.id,\n            senderKeyLock\n        });\n        this._olmEncryption = new OlmEncryption({\n            account: this._e2eeAccount,\n            pickleKey: PICKLE_KEY,\n            olm: this._olm,\n            storage: this._storage,\n            now: this._platform.clock.now,\n            ownUserId: this._user.id,\n            olmUtil: this._olmUtil,\n            senderKeyLock\n        });\n        this._keyLoader = new MegOlmKeyLoader(this._olm, PICKLE_KEY, 20);\n        this._megolmEncryption = new MegOlmEncryption({\n            account: this._e2eeAccount,\n            pickleKey: PICKLE_KEY,\n            olm: this._olm,\n            storage: this._storage,\n            keyLoader: this._keyLoader,\n            now: this._platform.clock.now,\n            ownDeviceId: this._sessionInfo.deviceId,\n        });\n        this._megolmDecryption = new MegOlmDecryption(this._keyLoader, this._olmWorker);\n        this._deviceMessageHandler.enableEncryption({olmDecryption, megolmDecryption: this._megolmDecryption});\n    }\n\n    _createRoomEncryption(room, encryptionParams) {\n        // TODO: this will actually happen when users start using the e2ee version for the first time\n\n        // this should never happen because either a session was already synced once\n        // and thus an e2ee account was created as well and _setupEncryption is called from load\n        // OR\n        // this is a new session and loading it will load zero rooms, thus not calling this method.\n        // in this case _setupEncryption is called from beforeFirstSync, right after load,\n        // so any incoming synced rooms won't be there yet\n        if (!this._olmEncryption) {\n            throw new Error(\"creating room encryption before encryption got globally enabled\");\n        }\n        // only support megolm\n        if (encryptionParams.algorithm !== MEGOLM_ALGORITHM) {\n            return null;\n        }\n        return new RoomEncryption({\n            room,\n            deviceTracker: this._deviceTracker,\n            olmEncryption: this._olmEncryption,\n            megolmEncryption: this._megolmEncryption,\n            megolmDecryption: this._megolmDecryption,\n            storage: this._storage,\n            keyBackup: this._keyBackup?.get(),\n            encryptionParams,\n            notifyMissingMegolmSession: () => {\n                if (!this._keyBackup.get()) {\n                    this.needsKeyBackup.set(true)\n                }\n            },\n            clock: this._platform.clock\n        });\n    }\n\n    /**\n     * Enable secret storage by providing the secret storage credential.\n     * This will also see if there is a megolm key backup and try to enable that if so.\n     * \n     * @param  {string} type       either \"passphrase\" or \"recoverykey\"\n     * @param  {string} credential either the passphrase or the recovery key, depending on the type\n     * @return {Promise} resolves or rejects after having tried to enable secret storage\n     */\n    enableSecretStorage(type, credential, log = undefined) {\n        return this._platform.logger.wrapOrRun(log, \"enable secret storage\", async log => {\n            if (!this._olm) {\n                throw new Error(\"olm required\");\n            }\n            if (this._keyBackup.get()) {\n                this._keyBackup.get().dispose();\n                this._keyBackup.set(null);\n            }\n            const key = await ssssKeyFromCredential(type, credential, this._storage, this._platform, this._olm);\n            // and create key backup, which needs to read from accountData\n            const readTxn = await this._storage.readTxn([\n                this._storage.storeNames.accountData,\n            ]);\n            if (await this._createKeyBackup(key, readTxn, log)) {\n                // only after having read a secret, write the key\n                // as we only find out if it was good if the MAC verification succeeds\n                await this._writeSSSSKey(key, log);\n                this._keyBackup.get().flush(log);\n                return key;\n            } else {\n                throw new Error(\"Could not read key backup with the given key\");\n            }\n        });\n    }\n\n    async _writeSSSSKey(key, log) {\n        // we're going to write the 4S key, and also the backup version.\n        // this way, we can detect when we enter a key for a new backup version\n        // and mark all inbound sessions to be backed up again\n        const keyBackup = this._keyBackup.get();\n        if (!keyBackup) {\n            return;\n        }\n        const backupVersion = keyBackup.version;\n        const writeTxn = await this._storage.readWriteTxn([\n            this._storage.storeNames.session,\n            this._storage.storeNames.inboundGroupSessions,\n        ]);\n        try {\n            const previousBackupVersion = await ssssWriteKey(key, backupVersion, writeTxn);\n            log.set(\"previousBackupVersion\", previousBackupVersion);\n            log.set(\"backupVersion\", backupVersion);\n            if (!!previousBackupVersion && previousBackupVersion !== backupVersion) {\n                const amountMarked = await keyBackup.markAllForBackup(writeTxn);\n                log.set(\"amountMarkedForBackup\", amountMarked);\n            }\n        } catch (err) {\n            writeTxn.abort();\n            throw err;\n        }\n        await writeTxn.complete();\n    }\n\n    async disableSecretStorage() {\n        const writeTxn = await this._storage.readWriteTxn([\n            this._storage.storeNames.session,\n        ]);\n        try {\n            ssssRemoveKey(writeTxn);\n        } catch (err) {\n            writeTxn.abort();\n            throw err;\n        }\n        await writeTxn.complete();\n        if (this._keyBackup.get()) {\n            for (const room of this._rooms.values()) {\n                if (room.isEncrypted) {\n                    room.enableKeyBackup(undefined);\n                }\n            }\n            this._keyBackup.get().dispose();\n            this._keyBackup.set(null);\n        }\n    }\n\n    _createKeyBackup(ssssKey, txn, log) {\n        return log.wrap(\"enable key backup\", async log => {\n            try {\n                const secretStorage = new SecretStorage({key: ssssKey, platform: this._platform});\n                const keyBackup = await KeyBackup.fromSecretStorage(\n                    this._platform,\n                    this._olm,\n                    secretStorage,\n                    this._hsApi,\n                    this._keyLoader,\n                    this._storage,\n                    txn\n                );\n                if (keyBackup) {\n                    for (const room of this._rooms.values()) {\n                        if (room.isEncrypted) {\n                            room.enableKeyBackup(keyBackup);\n                        }\n                    }\n                    this._keyBackup.set(keyBackup);\n                    return true;\n                }\n            } catch (err) {\n                log.catch(err);\n            }\n            return false;\n        });\n    }\n\n    /**\n     * @type {ObservableValue<KeyBackup | undefined | null}\n     *  - `undefined` means, we're not done with catchup sync yet and haven't checked yet if key backup is configured\n     *  - `null` means we've checked and key backup hasn't been configured correctly or at all.\n     */\n    get keyBackup() {\n        return this._keyBackup;\n    }\n\n    get hasIdentity() {\n        return !!this._e2eeAccount;\n    }\n\n    /** @internal */\n    async createIdentity(log) {\n        if (this._olm) {\n            if (!this._e2eeAccount) {\n                this._e2eeAccount = await this._createNewAccount(this._sessionInfo.deviceId, this._storage);\n                log.set(\"keys\", this._e2eeAccount.identityKeys);\n                this._setupEncryption();\n            }\n            await this._e2eeAccount.generateOTKsIfNeeded(this._storage, log);\n            await log.wrap(\"uploadKeys\", log => this._e2eeAccount.uploadKeys(this._storage, false, log));\n        }\n    }\n\n    /** @internal */\n    async dehydrateIdentity(dehydratedDevice, log) {\n        log.set(\"deviceId\", dehydratedDevice.deviceId);\n        if (!this._olm) {\n            log.set(\"no_olm\", true);\n            return false;\n        }\n        if (dehydratedDevice.deviceId !== this.deviceId) {\n            log.set(\"wrong_device\", true);\n            return false;\n        }\n        if (this._e2eeAccount) {\n            log.set(\"account_already_setup\", true);\n            return false;\n        }\n        if (!await dehydratedDevice.claim(this._hsApi, log)) {\n            log.set(\"already_claimed\", true);\n            return false;\n        }\n        this._e2eeAccount = await E2EEAccount.adoptDehydratedDevice({\n            dehydratedDevice,\n            hsApi: this._hsApi,\n            olm: this._olm,\n            pickleKey: PICKLE_KEY,\n            userId: this._sessionInfo.userId,\n            olmWorker: this._olmWorker,\n            deviceId: this.deviceId,\n            storage: this._storage,\n        });\n        log.set(\"keys\", this._e2eeAccount.identityKeys);\n        this._setupEncryption();\n        return true;\n    }\n\n    _createNewAccount(deviceId, storage = undefined) {\n        // storage is optional and if omitted the account won't be persisted (useful for dehydrating devices)\n        return E2EEAccount.create({\n            hsApi: this._hsApi,\n            olm: this._olm,\n            pickleKey: PICKLE_KEY,\n            userId: this._sessionInfo.userId,\n            olmWorker: this._olmWorker,\n            deviceId,\n            storage,\n        });\n    }\n\n    setupDehydratedDevice(key, log = null) {\n        return this._platform.logger.wrapOrRun(log, \"setupDehydratedDevice\", async log => {\n            const dehydrationAccount = await this._createNewAccount(\"temp-device-id\");\n            try {\n                const deviceId = await uploadAccountAsDehydratedDevice(\n                    dehydrationAccount, this._hsApi, key, \"Dehydrated device\", log);\n                log.set(\"deviceId\", deviceId);\n                return deviceId;\n            } finally {\n                dehydrationAccount.dispose();\n            }\n        });\n    }\n\n    /** @internal */\n    async load(log) {\n        const txn = await this._storage.readTxn([\n            this._storage.storeNames.session,\n            this._storage.storeNames.roomSummary,\n            this._storage.storeNames.invites,\n            this._storage.storeNames.roomMembers,\n            this._storage.storeNames.timelineEvents,\n            this._storage.storeNames.timelineFragments,\n            this._storage.storeNames.pendingEvents,\n        ]);\n        // restore session object\n        this._syncInfo = await txn.session.get(\"sync\");\n        // restore e2ee account, if any\n        if (this._olm) {\n            this._e2eeAccount = await E2EEAccount.load({\n                hsApi: this._hsApi,\n                olm: this._olm,\n                pickleKey: PICKLE_KEY,\n                userId: this._sessionInfo.userId,\n                deviceId: this._sessionInfo.deviceId,\n                olmWorker: this._olmWorker,\n                txn\n            });\n            if (this._e2eeAccount) {\n                log.set(\"keys\", this._e2eeAccount.identityKeys);\n                this._setupEncryption();\n            }\n        }\n        const pendingEventsByRoomId = await this._getPendingEventsByRoom(txn);\n        // load invites\n        const invites = await txn.invites.getAll();\n        const inviteLoadPromise = Promise.all(invites.map(async inviteData => {\n            const invite = this.createInvite(inviteData.roomId);\n            log.wrap(\"invite\", log => invite.load(inviteData, log));\n            this._invites.add(invite.id, invite);\n        }));\n        // load rooms\n        const rooms = await txn.roomSummary.getAll();\n        const roomLoadPromise = Promise.all(rooms.map(async summary => {\n            const room = this.createJoinedRoom(summary.roomId, pendingEventsByRoomId.get(summary.roomId));\n            await log.wrap(\"room\", log => room.load(summary, txn, log));\n            this._rooms.add(room.id, room);\n        }));\n        // load invites and rooms in parallel\n        await Promise.all([inviteLoadPromise, roomLoadPromise]);\n        for (const [roomId, invite] of this.invites) {\n            const room = this.rooms.get(roomId);\n            if (room) {\n                room.setInvite(invite);\n            }\n        }\n    }\n\n    dispose() {\n        this._olmWorker?.dispose();\n        this._olmWorker = undefined;\n        this._keyBackup.get()?.dispose();\n        this._keyBackup.set(undefined);\n        this._megolmDecryption?.dispose();\n        this._megolmDecryption = undefined;\n        this._e2eeAccount?.dispose();\n        this._e2eeAccount = undefined;\n        for (const room of this._rooms.values()) {\n            room.dispose();\n        }\n        this._rooms = undefined;\n    }\n\n    /**\n     * @internal called from session container when coming back online and catchup syncs have finished.\n     * @param  {Object} lastVersionResponse a response from /versions, which is polled while offline,\n     *                                      and useful to store so we can later tell what capabilities\n     *                                      our homeserver has.\n     */\n    async start(lastVersionResponse, dehydratedDevice, log) {\n        if (lastVersionResponse) {\n            // store /versions response\n            const txn = await this._storage.readWriteTxn([\n                this._storage.storeNames.session\n            ]);\n            txn.session.set(\"serverVersions\", lastVersionResponse);\n            // TODO: what can we do if this throws?\n            await txn.complete();\n        }\n        // enable session backup, this requests the latest backup version\n        if (!this._keyBackup.get()) {\n            if (dehydratedDevice) {\n                await log.wrap(\"SSSSKeyFromDehydratedDeviceKey\", async log => {\n                    const ssssKey = await createSSSSKeyFromDehydratedDeviceKey(dehydratedDevice.key, this._storage, this._platform);\n                    if (ssssKey) {\n                        log.set(\"success\", true);\n                        await this._writeSSSSKey(ssssKey);\n                    }\n                });\n            }\n            const txn = await this._storage.readTxn([\n                this._storage.storeNames.session,\n                this._storage.storeNames.accountData,\n            ]);\n            // try set up session backup if we stored the ssss key\n            const ssssKey = await ssssReadKey(txn);\n            if (ssssKey) {\n                // txn will end here as this does a network request\n                if (await this._createKeyBackup(ssssKey, txn, log)) {\n                    this._keyBackup.get()?.flush(log);\n                }\n            }\n            if (!this._keyBackup.get()) {\n                // null means key backup isn't configured yet\n                // as opposed to undefined, which means we're still checking\n                this._keyBackup.set(null);\n            }\n        }\n        // restore unfinished operations, like sending out room keys\n        const opsTxn = await this._storage.readWriteTxn([\n            this._storage.storeNames.operations\n        ]);\n        const operations = await opsTxn.operations.getAll();\n        const operationsByScope = groupBy(operations, o => o.scope);\n\n        for (const room of this._rooms.values()) {\n            let roomOperationsByType;\n            const roomOperations = operationsByScope.get(room.id);\n            if (roomOperations) {\n                roomOperationsByType = groupBy(roomOperations, r => r.type);\n            }\n            room.start(roomOperationsByType, log);\n        }\n    }\n\n    async _getPendingEventsByRoom(txn) {\n        const pendingEvents = await txn.pendingEvents.getAll();\n        return pendingEvents.reduce((groups, pe) => {\n            const group = groups.get(pe.roomId);\n            if (group) {\n                group.push(pe);\n            } else {\n                groups.set(pe.roomId, [pe]);\n            }\n            return groups;\n        }, new Map());\n    }\n\n    get rooms() {\n        return this._rooms;\n    }\n\n    findDirectMessageForUserId(userId) {\n        for (const [,room] of this._rooms) {\n            if (room.isDirectMessageForUserId(userId)) {\n                return room;\n            }\n        }\n        for (const [,invite] of this._invites) {\n            if (invite.isDirectMessageForUserId(userId)) {\n                return invite;\n            }\n        }\n    }\n\n    /** @internal */\n    createJoinedRoom(roomId, pendingEvents) {\n        return new Room({\n            roomId,\n            getSyncToken: this._getSyncToken,\n            storage: this._storage,\n            emitCollectionChange: this._roomUpdateCallback,\n            hsApi: this._hsApi,\n            mediaRepository: this._mediaRepository,\n            pendingEvents,\n            user: this._user,\n            createRoomEncryption: this._createRoomEncryption,\n            platform: this._platform\n        });\n    }\n\n    /** @internal */\n    _createArchivedRoom(roomId) {\n        const room = new ArchivedRoom({\n            roomId,\n            getSyncToken: this._getSyncToken,\n            storage: this._storage,\n            emitCollectionChange: () => {},\n            releaseCallback: () => this._activeArchivedRooms.delete(roomId),\n            forgetCallback: this._forgetArchivedRoom,\n            hsApi: this._hsApi,\n            mediaRepository: this._mediaRepository,\n            user: this._user,\n            createRoomEncryption: this._createRoomEncryption,\n            platform: this._platform\n        });\n        this._activeArchivedRooms.set(roomId, room);\n        return room;\n    }\n\n    get invites() {\n        return this._invites;\n    }\n\n    /** @internal */\n    createInvite(roomId) {\n        return new Invite({\n            roomId,\n            hsApi: this._hsApi,\n            emitCollectionUpdate: this._inviteUpdateCallback,\n            mediaRepository: this._mediaRepository,\n            user: this._user,\n            platform: this._platform,\n        });\n    }\n\n    get roomsBeingCreated() {\n        return this._roomsBeingCreated;\n    }\n\n    createRoom(options) {\n        let roomBeingCreated;\n        this._platform.logger.runDetached(\"create room\", async log => {\n            const id = `local-${Math.floor(this._platform.random() * Number.MAX_SAFE_INTEGER)}`;\n            roomBeingCreated = new RoomBeingCreated(\n                id, options, this._roomsBeingCreatedUpdateCallback,\n                this._mediaRepository, this._platform, log);\n            this._roomsBeingCreated.set(id, roomBeingCreated);\n            const promises = [roomBeingCreated.create(this._hsApi, log)];\n            const loadProfiles = options.loadProfiles !== false; // default to true\n            if (loadProfiles) {\n                promises.push(roomBeingCreated.loadProfiles(this._hsApi, log));\n            }\n            await Promise.all(promises);\n            // we should now know the roomId, check if the room was synced before we received\n            // the room id. Replace the room being created with the synced room.\n            if (roomBeingCreated.roomId) {\n                if (this.rooms.get(roomBeingCreated.roomId)) {\n                    this._tryReplaceRoomBeingCreated(roomBeingCreated.roomId, log);\n                }\n                await roomBeingCreated.adjustDirectMessageMapIfNeeded(this._user, this._storage, this._hsApi, log);\n            }\n        });\n        return roomBeingCreated;\n    }\n\n    async obtainSyncLock(syncResponse) {\n        const toDeviceEvents = syncResponse.to_device?.events;\n        if (Array.isArray(toDeviceEvents) && toDeviceEvents.length) {\n            return await this._deviceMessageHandler.obtainSyncLock(toDeviceEvents);\n        }\n    }\n\n    async prepareSync(syncResponse, lock, txn, log) {\n        const toDeviceEvents = syncResponse.to_device?.events;\n        if (Array.isArray(toDeviceEvents) && toDeviceEvents.length) {\n            return await log.wrap(\"deviceMsgs\", log => this._deviceMessageHandler.prepareSync(toDeviceEvents, lock, txn, log));\n        }\n    }\n\n    /** @internal */\n    async writeSync(syncResponse, syncFilterId, preparation, txn, log) {\n        const changes = {\n            syncInfo: null,\n            e2eeAccountChanges: null\n        };\n        const syncToken = syncResponse.next_batch;\n        if (syncToken !== this.syncToken) {\n            const syncInfo = {token: syncToken, filterId: syncFilterId};\n            // don't modify `this` because transaction might still fail\n            txn.session.set(\"sync\", syncInfo);\n            changes.syncInfo = syncInfo;\n        }\n\n        const deviceOneTimeKeysCount = syncResponse.device_one_time_keys_count;\n        if (this._e2eeAccount && deviceOneTimeKeysCount) {\n            changes.e2eeAccountChanges = this._e2eeAccount.writeSync(deviceOneTimeKeysCount, txn, log);\n        }\n    \n        const deviceLists = syncResponse.device_lists;\n        if (this._deviceTracker && Array.isArray(deviceLists?.changed) && deviceLists.changed.length) {\n            await log.wrap(\"deviceLists\", log => this._deviceTracker.writeDeviceChanges(deviceLists.changed, txn, log));\n        }\n\n        if (preparation) {\n            changes.hasNewRoomKeys = await log.wrap(\"deviceMsgs\", log => this._deviceMessageHandler.writeSync(preparation, txn, log));\n        }\n\n        // store account data\n        const accountData = syncResponse[\"account_data\"];\n        if (Array.isArray(accountData?.events)) {\n            for (const event of accountData.events) {\n                if (typeof event.type === \"string\") {\n                    txn.accountData.set(event);\n                }\n            }\n        }\n        return changes;\n    }\n\n    /** @internal */\n    afterSync({syncInfo, e2eeAccountChanges}) {\n        if (syncInfo) {\n            // sync transaction succeeded, modify object state now\n            this._syncInfo = syncInfo;\n        }\n        if (this._e2eeAccount) {\n            this._e2eeAccount.afterSync(e2eeAccountChanges);\n        }\n    }\n\n    /** @internal */\n    async afterSyncCompleted(changes, isCatchupSync, log) {\n        // we don't start uploading one-time keys until we've caught up with\n        // to-device messages, to help us avoid throwing away one-time-keys that we\n        // are about to receive messages for\n        // (https://github.com/vector-im/riot-web/issues/2782).\n        if (!isCatchupSync) {\n            const needsToUploadOTKs = await this._e2eeAccount.generateOTKsIfNeeded(this._storage, log);\n            if (needsToUploadOTKs) {\n                await log.wrap(\"uploadKeys\", log => this._e2eeAccount.uploadKeys(this._storage, false, log));\n            }\n        }\n        if (changes.hasNewRoomKeys) {\n            this._keyBackup.get()?.flush(log);\n        }\n    }\n\n    _tryReplaceRoomBeingCreated(roomId, log) {\n        for (const [,roomBeingCreated] of this._roomsBeingCreated) {\n            if (roomBeingCreated.roomId === roomId) {\n                const observableStatus = this._observedRoomStatus.get(roomBeingCreated.id);\n                if (observableStatus) {\n                    log.log(`replacing room being created`)\n                       .set(\"localId\", roomBeingCreated.id)\n                       .set(\"roomId\", roomBeingCreated.roomId);\n                    observableStatus.set(observableStatus.get() | RoomStatus.Replaced);\n                }\n                roomBeingCreated.dispose();\n                this._roomsBeingCreated.remove(roomBeingCreated.id);\n                return;\n            }\n        }\n    }\n\n    applyRoomCollectionChangesAfterSync(inviteStates, roomStates, archivedRoomStates, log) {\n        // update the collections after sync\n        for (const rs of roomStates) {\n            if (rs.shouldAdd) {\n                this._rooms.add(rs.id, rs.room);\n                this._tryReplaceRoomBeingCreated(rs.id, log);\n            } else if (rs.shouldRemove) {\n                this._rooms.remove(rs.id);\n            }\n        }\n        for (const is of inviteStates) {\n            if (is.shouldAdd) {\n                this._invites.add(is.id, is.invite);\n            } else if (is.shouldRemove) {\n                this._invites.remove(is.id);\n            }\n        }\n        // now all the collections are updated, update the room status\n        // so any listeners to the status will find the collections\n        // completely up to date\n        if (this._observedRoomStatus.size !== 0) {\n            for (const ars of archivedRoomStates) {\n                if (ars.shouldAdd) {\n                    this._observedRoomStatus.get(ars.id)?.set(RoomStatus.Archived);\n                }\n            }\n            for (const rs of roomStates) {\n                if (rs.shouldAdd) {\n                    this._observedRoomStatus.get(rs.id)?.set(RoomStatus.Joined);\n                }\n            }\n            for (const is of inviteStates) {\n                const statusObservable = this._observedRoomStatus.get(is.id);\n                if (statusObservable) {\n                    const withInvited = statusObservable.get() | RoomStatus.Invited;\n                    if (is.shouldAdd) {\n                        statusObservable.set(withInvited);\n                    } else if (is.shouldRemove) {\n                        const withoutInvited = withInvited ^ RoomStatus.Invited;\n                        statusObservable.set(withoutInvited);\n                    }\n                }\n            }\n        }\n    }\n\n    _forgetArchivedRoom(roomId) {\n        const statusObservable = this._observedRoomStatus.get(roomId);\n        if (statusObservable) {\n            statusObservable.set((statusObservable.get() | RoomStatus.Archived) ^ RoomStatus.Archived);\n        }\n    }\n\n    /** @internal */\n    get syncToken() {\n        return this._syncInfo?.token;\n    }\n\n    /** @internal */\n    get syncFilterId() {\n        return this._syncInfo?.filterId;\n    }\n\n    get user() {\n        return this._user;\n    }\n\n    get mediaRepository() {\n        return this._mediaRepository;\n    }\n\n    enablePushNotifications(enable) {\n        if (enable) {\n            return this._enablePush();\n        } else {\n            return this._disablePush();\n        }\n    }\n\n    async _enablePush() {\n        return this._platform.logger.run(\"enablePush\", async log => {\n            const defaultPayload = Pusher.createDefaultPayload(this._sessionInfo.id);\n            const pusher = await this._platform.notificationService.enablePush(Pusher, defaultPayload);\n            if (!pusher) {\n                log.set(\"no_pusher\", true);\n                return false;\n            }\n            await pusher.enable(this._hsApi, log);\n            // store pusher data, so we know we enabled it across reloads,\n            // and we can disable it without too much hassle\n            const txn = await this._storage.readWriteTxn([this._storage.storeNames.session]);\n            txn.session.set(PUSHER_KEY, pusher.serialize());\n            await txn.complete();\n            return true;\n        });\n    }\n\n\n    async _disablePush() {\n        return this._platform.logger.run(\"disablePush\", async log => {\n            await this._platform.notificationService.disablePush();\n            const readTxn = await this._storage.readTxn([this._storage.storeNames.session]);\n            const pusherData = await readTxn.session.get(PUSHER_KEY);\n            if (!pusherData) {\n                // we've disabled push in the notif service at least\n                return true;\n            }\n            const pusher = new Pusher(pusherData);\n            await pusher.disable(this._hsApi, log);\n            const txn = await this._storage.readWriteTxn([this._storage.storeNames.session]);\n            txn.session.remove(PUSHER_KEY);\n            await txn.complete();\n            return true;\n        });\n    }\n\n    async arePushNotificationsEnabled() {\n        if (!await this._platform.notificationService.isPushEnabled()) {\n            return false;\n        }\n        const readTxn = await this._storage.readTxn([this._storage.storeNames.session]);\n        const pusherData = await readTxn.session.get(PUSHER_KEY);\n        return !!pusherData;\n    }\n\n    async checkPusherEnabledOnHomeserver() {\n        const readTxn = await this._storage.readTxn([this._storage.storeNames.session]);\n        const pusherData = await readTxn.session.get(PUSHER_KEY);\n        if (!pusherData) {\n            return false;\n        }\n        const myPusher = new Pusher(pusherData);\n        const serverPushersData = await this._hsApi.getPushers().response();\n        const serverPushers = (serverPushersData?.pushers || []).map(data => new Pusher(data));\n        return serverPushers.some(p => p.equals(myPusher));\n    }\n\n    async getRoomStatus(roomId) {\n        const isBeingCreated = !!this._roomsBeingCreated.get(roomId);\n        if (isBeingCreated) {\n            return RoomStatus.BeingCreated;\n        }\n        const isJoined = !!this._rooms.get(roomId);\n        if (isJoined) {\n            return RoomStatus.Joined;\n        } else {\n            const isInvited = !!this._invites.get(roomId);\n            const txn = await this._storage.readTxn([this._storage.storeNames.archivedRoomSummary]);\n            const isArchived = await txn.archivedRoomSummary.has(roomId);\n            if (isInvited && isArchived) {\n                return RoomStatus.Invited | RoomStatus.Archived;\n            } else if (isInvited) {\n                return RoomStatus.Invited;\n            } else if (isArchived) {\n                return RoomStatus.Archived;\n            } else {\n                return RoomStatus.None;\n            }\n        }\n    }\n\n    async observeRoomStatus(roomId) {\n        let observable = this._observedRoomStatus.get(roomId);\n        if (!observable) {\n            const status = await this.getRoomStatus(roomId);\n            observable = new RetainedObservableValue(status, () => {\n                this._observedRoomStatus.delete(roomId);\n            });\n\n            this._observedRoomStatus.set(roomId, observable);\n        }\n        return observable;\n    }\n\n    /**\n    Creates an empty (summary isn't loaded) the archived room if it isn't\n    loaded already, assuming sync will either remove it (when rejoining) or\n    write a full summary adopting it from the joined room when leaving\n    \n    @internal\n    */\n    createOrGetArchivedRoomForSync(roomId) {\n        let archivedRoom = this._activeArchivedRooms.get(roomId);\n        if (archivedRoom) {\n            archivedRoom.retain();\n        } else {\n            archivedRoom = this._createArchivedRoom(roomId);\n        }\n        return archivedRoom;\n    }\n\n    loadArchivedRoom(roomId, log = null) {\n        return this._platform.logger.wrapOrRun(log, \"loadArchivedRoom\", async log => {\n            log.set(\"id\", roomId);\n            const activeArchivedRoom = this._activeArchivedRooms.get(roomId);\n            if (activeArchivedRoom) {\n                activeArchivedRoom.retain();\n                return activeArchivedRoom;\n            }\n            const txn = await this._storage.readTxn([\n                this._storage.storeNames.archivedRoomSummary,\n                this._storage.storeNames.roomMembers,\n            ]);\n            const summary = await txn.archivedRoomSummary.get(roomId);\n            if (summary) {\n                const room = this._createArchivedRoom(roomId);\n                await room.load(summary, txn, log);\n                return room;\n            }\n        });\n    }\n\n    joinRoom(roomIdOrAlias, log = null) {\n        return this._platform.logger.wrapOrRun(log, \"joinRoom\", async log => {\n            const body = await this._hsApi.joinIdOrAlias(roomIdOrAlias, {log}).response();\n            return body.room_id;\n        });\n    }\n}\n\nexport function tests() {\n    function createStorageMock(session, pendingEvents = []) {\n        return {\n            readTxn() {\n                return {\n                    session: {\n                        get(key) {\n                            return Promise.resolve(session[key]);\n                        }\n                    },\n                    pendingEvents: {\n                        getAll() {\n                            return Promise.resolve(pendingEvents);\n                        }\n                    },\n                    roomSummary: {\n                        getAll() {\n                            return Promise.resolve([]);\n                        }\n                    },\n                    invites: {\n                        getAll() {\n                            return Promise.resolve([]);\n                        }\n                    }\n                };\n            },\n            storeNames: {}\n        };\n    }\n\n    return {\n        \"session data is not modified until after sync\": async (assert) => {\n            const session = new Session({storage: createStorageMock({\n                sync: {token: \"a\", filterId: 5}\n            }), sessionInfo: {userId: \"\"}});\n            await session.load();\n            let syncSet = false;\n            const syncTxn = {\n                session: {\n                    set(key, value) {\n                        if (key === \"sync\") {\n                            assert.equal(value.token, \"b\");\n                            assert.equal(value.filterId, 6);\n                            syncSet = true;\n                        }\n                    }\n                }\n            };\n            const newSessionData = await session.writeSync({next_batch: \"b\"}, 6, null, syncTxn, {});\n            assert(syncSet);\n            assert.equal(session.syncToken, \"a\");\n            assert.equal(session.syncFilterId, 5);\n            session.afterSync(newSessionData);\n            assert.equal(session.syncToken, \"b\");\n            assert.equal(session.syncFilterId, 6);\n        }\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ILogItem} from \"../../logging/types\";\nimport {ILoginMethod} from \"./LoginMethod\";\nimport {HomeServerApi} from \"../net/HomeServerApi.js\";\n\nexport class PasswordLoginMethod implements ILoginMethod {\n    private readonly _username: string;\n    private readonly _password: string;\n    public readonly homeserver: string;\n\n    constructor({username, password, homeserver}: {username: string, password: string, homeserver: string}) {\n        this._username = username;\n        this._password = password;\n        this.homeserver = homeserver;\n    }\n\n    async login(hsApi: HomeServerApi, deviceName: string, log: ILogItem): Promise<Record<string, any>> {\n        return await hsApi.passwordLogin(this._username, this._password, deviceName, {log}).response();\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {makeTxnId} from \"../common.js\";\nimport {ILogItem} from \"../../logging/types\";\nimport {ILoginMethod} from \"./LoginMethod\";\nimport {HomeServerApi} from \"../net/HomeServerApi.js\";\n\nexport class TokenLoginMethod implements ILoginMethod {\n    private readonly _loginToken: string;\n    public readonly homeserver: string;\n\n    constructor({ homeserver, loginToken }: { homeserver: string, loginToken: string}) {\n        this.homeserver = homeserver;\n        this._loginToken = loginToken;\n    }\n\n    async login(hsApi: HomeServerApi, deviceName: string, log: ILogItem): Promise<Record<string, any>> {\n        return await hsApi.tokenLogin(this._loginToken, makeTxnId(), deviceName, {log}).response();\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class SSOLoginHelper{\n    private _homeserver: string;\n\n    constructor(homeserver: string) {\n        this._homeserver = homeserver;\n    }\n\n    get homeserver(): string { return this._homeserver; }\n\n    createSSORedirectURL(returnURL: string): string {\n        return `${this._homeserver}/_matrix/client/r0/login/sso/redirect?redirectUrl=${returnURL}`;\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type {AuthenticationData, RegistrationParams} from \"../types\";\n\nexport abstract class BaseRegistrationStage {\n    protected _session: string;\n    protected _nextStage: BaseRegistrationStage;\n    protected readonly _params?: Record<string, any>\n\n    constructor(session: string, params?: RegistrationParams) {\n        this._session = session;\n        this._params = params;\n    }\n\n    /**\n     * eg: m.login.recaptcha or m.login.dummy\n     */\n    abstract get type(): string;\n\n    /**\n     * This method should return auth part that must be provided to\n     * /register endpoint to successfully complete this stage\n     */\n    /** @internal */\n    abstract generateAuthenticationData(): AuthenticationData;\n\n    setNextStage(stage: BaseRegistrationStage) {\n        this._nextStage = stage;\n    }\n\n    get nextStage(): BaseRegistrationStage {\n        return this._nextStage;\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {AuthenticationData} from \"../types\";\nimport {BaseRegistrationStage} from \"./BaseRegistrationStage\";\n\nexport class DummyAuth extends BaseRegistrationStage {\n    generateAuthenticationData(): AuthenticationData {\n        return {\n            session: this._session,\n            type: this.type,\n        };    \n    }\n\n    get type(): string {\n        return \"m.login.dummy\";\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {AuthenticationData} from \"../types\";\nimport {BaseRegistrationStage} from \"./BaseRegistrationStage\";\n\nexport class TermsAuth extends BaseRegistrationStage {\n    generateAuthenticationData(): AuthenticationData {\n        return {\n            session: this._session,\n            type: this.type,\n            // No other auth data needed for m.login.terms\n        };    \n    }\n\n    get type(): string {\n        return \"m.login.terms\";\n    }\n\n    get privacyPolicy() {\n        return this._params?.policies[\"privacy_policy\"];\n    }\n\n    get termsOfService() {\n        return this._params?.policies[\"terms_of_service\"];\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type {HomeServerApi} from \"../net/HomeServerApi\";\nimport type {BaseRegistrationStage} from \"./stages/BaseRegistrationStage\";\nimport {DummyAuth} from \"./stages/DummyAuth\";\nimport {TermsAuth} from \"./stages/TermsAuth\";\nimport type {\n    AccountDetails,\n    RegistrationFlow,\n    RegistrationResponseMoreDataNeeded,\n    RegistrationResponse,\n    RegistrationResponseSuccess,\n    RegistrationParams,\n} from \"./types\";\n\ntype FlowSelector = (flows: RegistrationFlow[]) => RegistrationFlow | void;\n\nexport class Registration {\n    private readonly _hsApi: HomeServerApi;\n    private readonly _accountDetails: AccountDetails;\n    private readonly _flowSelector: FlowSelector;\n    private _sessionInfo?: RegistrationResponseSuccess\n\n    constructor(hsApi: HomeServerApi, accountDetails: AccountDetails, flowSelector?: FlowSelector) {\n        this._hsApi = hsApi;\n        this._accountDetails = accountDetails;\n        this._flowSelector = flowSelector ?? (flows => flows[0]);\n    }\n\n    async start(): Promise<BaseRegistrationStage> {\n        const response = await this._hsApi.register(\n            this._accountDetails.username,\n            this._accountDetails.password,\n            this._accountDetails.initialDeviceDisplayName,\n            undefined,\n            this._accountDetails.inhibitLogin).response();\n        return this.parseStagesFromResponse(response);\n    }\n\n    /**\n     * Finish a registration stage, return value is:\n     * - the next stage if this stage was completed successfully\n     * - undefined if registration is completed\n     */\n    async submitStage(stage: BaseRegistrationStage): Promise<BaseRegistrationStage | undefined> {\n        const auth = stage.generateAuthenticationData();\n        const { username, password, initialDeviceDisplayName, inhibitLogin } = this._accountDetails;\n        const request = this._hsApi.register(username, password, initialDeviceDisplayName, auth, inhibitLogin);\n        const response = await request.response();\n        const status = await request.responseCode();\n        const registrationResponse: RegistrationResponse = { ...response, status };\n        return this.parseRegistrationResponse(registrationResponse, stage);\n    }\n\n    private parseStagesFromResponse(response: RegistrationResponseMoreDataNeeded): BaseRegistrationStage {\n        const { session, params } = response;\n        const flow = this._flowSelector(response.flows);\n        if (!flow) {\n            throw new Error(\"flowSelector did not return any flow!\");\n        }\n        let firstStage: BaseRegistrationStage | undefined;\n        let lastStage: BaseRegistrationStage | undefined;\n        for (const stage of flow.stages) {\n            const registrationStage = this._createRegistrationStage(stage, session, params);\n            if (!firstStage) {\n                firstStage = registrationStage;\n                lastStage = registrationStage;\n            } else {\n                lastStage!.setNextStage(registrationStage);\n                lastStage = registrationStage;\n            }\n        }\n        return firstStage!;\n    }\n\n    private async parseRegistrationResponse(response: RegistrationResponse, currentStage: BaseRegistrationStage) {\n        switch (response.status) {\n            case 200:\n                this._sessionInfo = response;\n                return undefined;\n            case 401:\n                if (response.completed?.includes(currentStage.type)) {\n                    return currentStage.nextStage;\n                }\n                else {\n                    throw new Error(\"This stage could not be completed!\");\n                }\n        }\n    }\n\n    private _createRegistrationStage(type: string, session: string, params?: RegistrationParams) {\n        switch (type) {\n            case \"m.login.dummy\":\n                return new DummyAuth(session, params?.[type]);\n            case \"m.login.terms\":\n                return new TermsAuth(session, params?.[type]);\n            default:\n                throw new Error(`Unknown stage: ${type}`);\n        }\n    }\n\n    get sessionInfo(): RegistrationResponseSuccess | undefined {\n        return this._sessionInfo;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {createEnum} from \"../utils/enum\";\nimport {lookupHomeserver} from \"./well-known.js\";\nimport {AbortableOperation} from \"../utils/AbortableOperation\";\nimport {ObservableValue} from \"../observable/ObservableValue\";\nimport {HomeServerApi} from \"./net/HomeServerApi\";\nimport {Reconnector, ConnectionStatus} from \"./net/Reconnector\";\nimport {ExponentialRetryDelay} from \"./net/ExponentialRetryDelay\";\nimport {MediaRepository} from \"./net/MediaRepository\";\nimport {RequestScheduler} from \"./net/RequestScheduler\";\nimport {Sync, SyncStatus} from \"./Sync.js\";\nimport {Session} from \"./Session.js\";\nimport {PasswordLoginMethod} from \"./login/PasswordLoginMethod\";\nimport {TokenLoginMethod} from \"./login/TokenLoginMethod\";\nimport {SSOLoginHelper} from \"./login/SSOLoginHelper\";\nimport {getDehydratedDevice} from \"./e2ee/Dehydration.js\";\nimport {Registration} from \"./registration/Registration\";\n\nexport const LoadStatus = createEnum(\n    \"NotLoading\",\n    \"Login\",\n    \"LoginFailed\",\n    \"QueryAccount\", // check for dehydrated device after login\n    \"AccountSetup\", // asked to restore from dehydrated device if present, call sc.accountSetup.finish() to progress to the next stage\n    \"Loading\",\n    \"SessionSetup\", // upload e2ee keys, ...\n    \"Migrating\",    // not used atm, but would fit here\n    \"FirstSync\",\n    \"Error\",\n    \"Ready\",\n);\n\nexport const LoginFailure = createEnum(\n    \"Connection\",\n    \"Credentials\",\n    \"Unknown\",\n);\n\nexport class Client {\n    constructor(platform) {\n        this._platform = platform;\n        this._sessionStartedByReconnector = false;\n        this._status = new ObservableValue(LoadStatus.NotLoading);\n        this._error = null;\n        this._loginFailure = null;\n        this._reconnector = null;\n        this._session = null;\n        this._sync = null;\n        this._sessionId = null;\n        this._storage = null;\n        this._requestScheduler = null;\n        this._olmPromise = platform.loadOlm();\n        this._workerPromise = platform.loadOlmWorker();\n        this._accountSetup = undefined;\n    }\n\n    createNewSessionId() {\n        return (Math.floor(this._platform.random() * Number.MAX_SAFE_INTEGER)).toString();\n    }\n\n    get sessionId() {\n        return this._sessionId;\n    }\n\n    async startWithExistingSession(sessionId) {\n        if (this._status.get() !== LoadStatus.NotLoading) {\n            return;\n        }\n        this._status.set(LoadStatus.Loading);\n        await this._platform.logger.run(\"load session\", async log => {\n            log.set(\"id\", sessionId);\n            try {\n                const sessionInfo = await this._platform.sessionInfoStorage.get(sessionId);\n                if (!sessionInfo) {\n                    throw new Error(\"Invalid session id: \" + sessionId);\n                }\n                await this._loadSessionInfo(sessionInfo, null, log);\n                log.set(\"status\", this._status.get());\n            } catch (err) {\n                log.catch(err);\n                this._error = err;\n                this._status.set(LoadStatus.Error);\n            }\n        });\n    }\n\n    _parseLoginOptions(options, homeserver) {\n        /*\n        Take server response and return new object which has two props password and sso which\n        implements LoginMethod\n        */\n        const flows = options.flows;\n        const result = {homeserver};\n        for (const flow of flows) {\n            if (flow.type === \"m.login.password\") {\n                result.password = (username, password) => new PasswordLoginMethod({homeserver, username, password});\n            }\n            else if (flow.type === \"m.login.sso\" && flows.find(flow => flow.type === \"m.login.token\")) {\n                result.sso = new SSOLoginHelper(homeserver);\n            }\n            else if (flow.type === \"m.login.token\") {\n                result.token = loginToken => new TokenLoginMethod({homeserver, loginToken});\n            }\n        }\n        return result;\n    }\n\n    queryLogin(homeserver) {\n        return new AbortableOperation(async setAbortable => {\n            homeserver = await lookupHomeserver(homeserver, (url, options) => {\n                return setAbortable(this._platform.request(url, options));\n            });\n            const hsApi = new HomeServerApi({homeserver, request: this._platform.request});\n            const response = await setAbortable(hsApi.getLoginFlows()).response();\n            return this._parseLoginOptions(response, homeserver);\n        });\n    }\n\n    async startRegistration(homeserver, username, password, initialDeviceDisplayName) {\n        const request = this._platform.request;\n        const hsApi = new HomeServerApi({homeserver, request});\n        const registration = new Registration(hsApi, {\n            username, \n            password,\n            initialDeviceDisplayName,\n        });\n        return registration;\n    }\n\n    async startWithLogin(loginMethod, {inspectAccountSetup} = {}) {\n        const currentStatus = this._status.get();\n        if (currentStatus !== LoadStatus.LoginFailed &&\n            currentStatus !== LoadStatus.NotLoading &&\n            currentStatus !== LoadStatus.Error) {\n            return;\n        }\n        this._resetStatus();\n        await this._platform.logger.run(\"login\", async log => {\n            this._status.set(LoadStatus.Login);\n            const clock = this._platform.clock;\n            let sessionInfo;\n            try {\n                const request = this._platform.request;\n                const hsApi = new HomeServerApi({homeserver: loginMethod.homeserver, request});\n                const loginData = await loginMethod.login(hsApi, \"Hydrogen\", log);\n                const sessionId = this.createNewSessionId();\n                sessionInfo = {\n                    id: sessionId,\n                    deviceId: loginData.device_id,\n                    userId: loginData.user_id,\n                    homeServer: loginMethod.homeserver, // deprecate this over time\n                    homeserver: loginMethod.homeserver,\n                    accessToken: loginData.access_token,\n                    lastUsed: clock.now()\n                };\n                log.set(\"id\", sessionId);\n            } catch (err) {\n                this._error = err;\n                if (err.name === \"HomeServerError\") {\n                    if (err.errcode === \"M_FORBIDDEN\") {\n                        this._loginFailure = LoginFailure.Credentials;\n                    } else {\n                        this._loginFailure = LoginFailure.Unknown;\n                    }\n                    log.set(\"loginFailure\", this._loginFailure);\n                    this._status.set(LoadStatus.LoginFailed);\n                } else if (err.name === \"ConnectionError\") {\n                    this._loginFailure = LoginFailure.Connection;\n                    this._status.set(LoadStatus.LoginFailed);\n                } else {\n                    this._status.set(LoadStatus.Error);\n                }\n                return;\n            }\n            let dehydratedDevice;\n            if (inspectAccountSetup) {\n                dehydratedDevice = await this._inspectAccountAfterLogin(sessionInfo, log);\n                if (dehydratedDevice) {\n                    sessionInfo.deviceId = dehydratedDevice.deviceId;\n                }\n            }\n            await this._platform.sessionInfoStorage.add(sessionInfo);            \n            // loading the session can only lead to\n            // LoadStatus.Error in case of an error,\n            // so separate try/catch\n            try {\n                await this._loadSessionInfo(sessionInfo, dehydratedDevice, log);\n                log.set(\"status\", this._status.get());\n            } catch (err) {\n                log.catch(err);\n                // free olm Account that might be contained\n                dehydratedDevice?.dispose();\n                this._error = err;\n                this._status.set(LoadStatus.Error);\n            }\n        });\n    }\n\n    async _loadSessionInfo(sessionInfo, dehydratedDevice, log) {\n        log.set(\"appVersion\", this._platform.version);\n        const clock = this._platform.clock;\n        this._sessionStartedByReconnector = false;\n        this._status.set(LoadStatus.Loading);\n        this._reconnector = new Reconnector({\n            onlineStatus: this._platform.onlineStatus,\n            retryDelay: new ExponentialRetryDelay(clock.createTimeout),\n            createMeasure: clock.createMeasure\n        });\n        const hsApi = new HomeServerApi({\n            homeserver: sessionInfo.homeServer,\n            accessToken: sessionInfo.accessToken,\n            request: this._platform.request,\n            reconnector: this._reconnector,\n        });\n        this._sessionId = sessionInfo.id;\n        this._storage = await this._platform.storageFactory.create(sessionInfo.id, log);\n        // no need to pass access token to session\n        const filteredSessionInfo = {\n            id: sessionInfo.id,\n            deviceId: sessionInfo.deviceId,\n            userId: sessionInfo.userId,\n            homeserver: sessionInfo.homeServer,\n        };\n        const olm = await this._olmPromise;\n        let olmWorker = null;\n        if (this._workerPromise) {\n            olmWorker = await this._workerPromise;\n        }\n        this._requestScheduler = new RequestScheduler({hsApi, clock});\n        this._requestScheduler.start();\n        const mediaRepository = new MediaRepository({\n            homeserver: sessionInfo.homeServer,\n            platform: this._platform,\n        });\n        this._session = new Session({\n            storage: this._storage,\n            sessionInfo: filteredSessionInfo,\n            hsApi: this._requestScheduler.hsApi,\n            olm,\n            olmWorker,\n            mediaRepository,\n            platform: this._platform,\n        });\n        await this._session.load(log);\n        if (dehydratedDevice) {\n            await log.wrap(\"dehydrateIdentity\", log => this._session.dehydrateIdentity(dehydratedDevice, log));\n            await this._session.setupDehydratedDevice(dehydratedDevice.key, log);\n        } else if (!this._session.hasIdentity) {\n            this._status.set(LoadStatus.SessionSetup);\n            await log.wrap(\"createIdentity\", log => this._session.createIdentity(log));\n        }\n        \n        this._sync = new Sync({hsApi: this._requestScheduler.hsApi, storage: this._storage, session: this._session, logger: this._platform.logger});\n        // notify sync and session when back online\n        this._reconnectSubscription = this._reconnector.connectionStatus.subscribe(state => {\n            if (state === ConnectionStatus.Online) {\n                this._platform.logger.runDetached(\"reconnect\", async log => {\n                    // needs to happen before sync and session or it would abort all requests\n                    this._requestScheduler.start();\n                    this._sync.start();\n                    this._sessionStartedByReconnector = true;\n                    const d = dehydratedDevice;\n                    dehydratedDevice = undefined;\n                    await log.wrap(\"session start\", log => this._session.start(this._reconnector.lastVersionsResponse, d, log));\n                });\n            }\n        });\n        await log.wrap(\"wait first sync\", () => this._waitForFirstSync());\n        if (this._isDisposed) {\n            return;\n        }\n        this._status.set(LoadStatus.Ready);\n\n        // if the sync failed, and then the reconnector\n        // restored the connection, it would have already\n        // started to session, so check first\n        // to prevent an extra /versions request\n        if (!this._sessionStartedByReconnector) {\n            const lastVersionsResponse = await hsApi.versions({timeout: 10000, log}).response();\n            if (this._isDisposed) {\n                return;\n            }\n            const d = dehydratedDevice;\n            dehydratedDevice = undefined;\n            // log as ref as we don't want to await it\n            await log.wrap(\"session start\", log => this._session.start(lastVersionsResponse, d, log));\n        }\n    }\n\n    async _waitForFirstSync() {\n        this._sync.start();\n        this._status.set(LoadStatus.FirstSync);\n        // only transition into Ready once the first sync has succeeded\n        this._waitForFirstSyncHandle = this._sync.status.waitFor(s => {\n            if (s === SyncStatus.Stopped) {\n                // keep waiting if there is a ConnectionError\n                // as the reconnector above will call \n                // sync.start again to retry in this case\n                return this._sync.error?.name !== \"ConnectionError\";\n            }\n            return s === SyncStatus.Syncing;\n        });\n        try {\n            await this._waitForFirstSyncHandle.promise;\n            if (this._sync.status.get() === SyncStatus.Stopped && this._sync.error) {\n                throw this._sync.error;\n            }\n        } catch (err) {\n            // if dispose is called from stop, bail out\n            if (err.name === \"AbortError\") {\n                return;\n            }\n            throw err;\n        } finally {\n            this._waitForFirstSyncHandle = null;\n        }\n    }\n\n    _inspectAccountAfterLogin(sessionInfo, log) {\n        return log.wrap(\"inspectAccount\", async log => {\n            this._status.set(LoadStatus.QueryAccount);\n            const hsApi = new HomeServerApi({\n                homeserver: sessionInfo.homeServer,\n                accessToken: sessionInfo.accessToken,\n                request: this._platform.request,\n            });\n            const olm = await this._olmPromise;\n            let encryptedDehydratedDevice;\n            try {\n                encryptedDehydratedDevice = await getDehydratedDevice(hsApi, olm, this._platform, log);\n            } catch (err) {\n                if (err.name === \"HomeServerError\") {\n                    log.set(\"not_supported\", true);\n                } else {\n                    throw err;\n                }\n            }\n            if (encryptedDehydratedDevice) {\n                let resolveStageFinish;\n                const promiseStageFinish = new Promise(r => resolveStageFinish = r);\n                this._accountSetup = new AccountSetup(encryptedDehydratedDevice, resolveStageFinish);\n                this._status.set(LoadStatus.AccountSetup);\n                await promiseStageFinish;\n                const dehydratedDevice = this._accountSetup?._dehydratedDevice;\n                this._accountSetup = null;\n                return dehydratedDevice;\n            }\n        });\n    }\n\n    get accountSetup() {\n        return this._accountSetup;\n    }\n\n    get loadStatus() {\n        return this._status;\n    }\n\n    get loadError() {\n        return this._error;\n    }\n\n    get loginFailure() {\n        return this._loginFailure;\n    }\n\n    /** only set at loadStatus InitialSync, CatchupSync or Ready */\n    get sync() {\n        return this._sync;\n    }\n\n    /** only set at loadStatus InitialSync, CatchupSync or Ready */\n    get session() {\n        return this._session;\n    }\n\n    get reconnector() {\n        return this._reconnector;\n    }\n\n    get _isDisposed() {\n        return !this._reconnector;\n    }\n\n    startLogout(sessionId) {\n        return this._platform.logger.run(\"logout\", async log => {\n            this._sessionId = sessionId;\n            log.set(\"id\", this._sessionId);\n            const sessionInfo = await this._platform.sessionInfoStorage.get(this._sessionId);\n            if (!sessionInfo) {\n                throw new Error(`Could not find session for id ${this._sessionId}`);\n            }\n            try {\n                const hsApi = new HomeServerApi({\n                    homeserver: sessionInfo.homeServer,\n                    accessToken: sessionInfo.accessToken,\n                    request: this._platform.request\n                });\n                await hsApi.logout({log}).response();\n            } catch (err) {}\n            await this.deleteSession(log);\n        });\n    }\n\n    dispose() {\n        if (this._reconnectSubscription) {\n            this._reconnectSubscription();\n            this._reconnectSubscription = null;\n        }\n        this._reconnector = null;\n        if (this._requestScheduler) {\n            this._requestScheduler.stop();\n            this._requestScheduler = null;\n        }\n        if (this._sync) {\n            this._sync.stop();\n            this._sync = null;\n        }\n        if (this._session) {\n            this._session.dispose();\n            this._session = null;\n        }\n        if (this._waitForFirstSyncHandle) {\n            this._waitForFirstSyncHandle.dispose();\n            this._waitForFirstSyncHandle = null;\n        }\n        if (this._storage) {\n            this._storage.close();\n            this._storage = null;\n        }\n    }\n\n    async deleteSession(log) {\n        if (this._sessionId) {\n            // need to dispose first, so the storage is closed,\n            // and also first sync finishing won't call Session.start anymore,\n            // which assumes that the storage works.\n            this.dispose();\n            // if one fails, don't block the other from trying\n            // also, run in parallel\n            await Promise.all([\n                log.wrap(\"storageFactory\", () => this._platform.storageFactory.delete(this._sessionId)),\n                log.wrap(\"sessionInfoStorage\", () => this._platform.sessionInfoStorage.delete(this._sessionId)),\n            ]);\n            this._sessionId = null;\n        }\n    }\n\n    _resetStatus() {\n        this._status.set(LoadStatus.NotLoading);\n        this._error = null;\n        this._loginFailure = null;\n    }\n}\n\nclass AccountSetup {\n    constructor(encryptedDehydratedDevice, finishStage) {\n        this._encryptedDehydratedDevice = encryptedDehydratedDevice;\n        this._dehydratedDevice = undefined;\n        this._finishStage = finishStage;\n    }\n\n    get encryptedDehydratedDevice() {\n        return this._encryptedDehydratedDevice;\n    }\n\n    finish(dehydratedDevice) {\n        this._dehydratedDevice = dehydratedDevice;\n        this._finishStage();\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// ViewModel should just be an eventemitter, not an ObservableValue\n// as in some cases it would really be more convenient to have multiple events (like telling the timeline to scroll down)\n// we do need to return a disposable from EventEmitter.on, or at least have a method here to easily track a subscription to an EventEmitter\n\nimport {EventEmitter} from \"../utils/EventEmitter\";\nimport {Disposables} from \"../utils/Disposables\";\n\nexport class ViewModel extends EventEmitter {\n    constructor(options = {}) {\n        super();\n        this.disposables = null;\n        this._isDisposed = false;\n        this._options = options;\n    }\n\n    childOptions(explicitOptions) {\n        const {navigation, urlCreator, platform} = this._options;\n        return Object.assign({navigation, urlCreator, platform}, explicitOptions);\n    }\n\n    // makes it easier to pass through dependencies of a sub-view model\n    getOption(name) {\n        return this._options[name];\n    }\n\n    track(disposable) {\n        if (!this.disposables) {\n            this.disposables = new Disposables();\n        }\n        return this.disposables.track(disposable);\n    }\n\n    untrack(disposable) {\n        if (this.disposables) {\n            return this.disposables.untrack(disposable);\n        }\n        return null;\n    }\n\n    dispose() {\n        if (this.disposables) {\n            this.disposables.dispose();\n        }\n        this._isDisposed = true;\n    }\n\n    get isDisposed() {\n        return this._isDisposed;\n    }\n\n    disposeTracked(disposable) {\n        if (this.disposables) {\n            return this.disposables.disposeTracked(disposable);\n        }\n        return null;\n    }\n\n    // TODO: this will need to support binding\n    // if any of the expr is a function, assume the function is a binding, and return a binding function ourselves\n    // \n    // translated string should probably always be bindings, unless we're fine with a refresh when changing the language?\n    // we probably are, if we're using routing with a url, we could just refresh.\n    i18n(parts, ...expr) {\n        // just concat for now\n        let result = \"\";\n        for (let i = 0; i < parts.length; ++i) {\n            result = result + parts[i];\n            if (i < expr.length) {\n                result = result + expr[i];\n            }\n        }\n        return result;\n    }\n\n    updateOptions(options) {\n        this._options = Object.assign(this._options, options);\n    }\n\n    emitChange(changedProps) {\n        if (this._options.emitChange) {\n            this._options.emitChange(changedProps);\n        } else {\n            this.emit(\"change\", changedProps);\n        }\n    }\n\n    get platform() {\n        return this._options.platform;\n    }\n\n    get clock() {\n        return this._options.platform.clock;\n    }\n\n    get logger() {\n        return this.platform.logger;\n    }\n\n    /**\n     * The url router, only meant to be used to create urls with from view models.\n     * @return {URLRouter}\n     */\n    get urlCreator() {\n        return this._options.urlCreator;\n    }\n\n    get navigation() {\n        return this._options.navigation;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function avatarInitials(name) {\n    let firstChar = name.charAt(0);\n    if (firstChar === \"!\" || firstChar === \"@\" || firstChar === \"#\") {\n        firstChar = name.charAt(1);\n    }\n    return firstChar.toUpperCase();\n}\n\n/**\n * calculates a numeric hash for a given string\n *\n * @param {string} str string to hash\n *\n * @return {number}\n */\nfunction hashCode(str) {\n    let hash = 0;\n    let i;\n    let chr;\n    if (str.length === 0) {\n        return hash;\n    }\n    for (i = 0; i < str.length; i++) {\n        chr = str.charCodeAt(i);\n        hash = ((hash << 5) - hash) + chr;\n        hash |= 0;\n    }\n    return Math.abs(hash);\n}\n\nexport function getIdentifierColorNumber(id) {\n    return (hashCode(id) % 8) + 1;\n}\n\nexport function getAvatarHttpUrl(avatarUrl, cssSize, platform, mediaRepository) {\n    if (avatarUrl) {\n        const imageSize = cssSize * platform.devicePixelRatio;\n        return mediaRepository.mxcUrlThumbnail(avatarUrl, imageSize, imageSize, \"crop\");\n    }\n    return null;\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {avatarInitials, getIdentifierColorNumber, getAvatarHttpUrl} from \"../../avatar.js\";\nimport {ViewModel} from \"../../ViewModel.js\";\n\nconst KIND_ORDER = [\"roomBeingCreated\", \"invite\", \"room\"];\n\nexport class BaseTileViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._isOpen = false;\n        this._hidden = false;\n    }\n\n    get hidden() {\n        return this._hidden;\n    }\n\n    set hidden(value) {\n        if (value !== this._hidden) {\n            this._hidden = value;\n            this.emitChange(\"hidden\");\n        }\n    }\n\n    close() {\n        if (this._isOpen) {\n            this._isOpen = false;\n            this.emitChange(\"isOpen\");\n        }\n    }\n\n    open() {\n        if (!this._isOpen) {\n            this._isOpen = true;\n            this.emitChange(\"isOpen\");\n        }\n    }\n\n    get isOpen() {\n        return this._isOpen;\n    }\n\n    compare(other) {\n        if (other.kind !== this.kind) {\n            return KIND_ORDER.indexOf(this.kind) - KIND_ORDER.indexOf(other.kind);\n        }\n        return 0;\n    }\n\n    // Avatar view model contract\n    get avatarLetter() {\n        return avatarInitials(this.name);\n    }\n\n    get avatarColorNumber() {\n        return getIdentifierColorNumber(this._avatarSource.avatarColorId);\n    }\n\n    avatarUrl(size) {\n        return getAvatarHttpUrl(this._avatarSource.avatarUrl, size, this.platform, this._avatarSource.mediaRepository);\n    }\n\n    get avatarTitle() {\n        return this.name;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseTileViewModel} from \"./BaseTileViewModel.js\";\n\nexport class RoomTileViewModel extends BaseTileViewModel {\n    constructor(options) {\n        super(options);\n        const {room} = options;\n        this._room = room;\n        this._url = this.urlCreator.openRoomActionUrl(this._room.id);\n    }\n\n    get kind() {\n        return \"room\";\n    }\n\n    get url() {\n        return this._url;\n    }\n\n    /** very important that sorting order is stable and that comparing\n     * to itself always returns 0, otherwise SortedMapList will\n     * remove the wrong children, etc ... */\n    compare(other) {\n        const parentComparison = super.compare(other);\n        if (parentComparison !== 0) {\n            return parentComparison;\n        }\n        /*\n        put unread rooms first\n        then put rooms with a timestamp first, and sort by name\n        then sort by name for rooms without a timestamp\n         */\n        const myRoom = this._room;\n        const theirRoom = other._room;\n\n        if (myRoom.isLowPriority !== theirRoom.isLowPriority) {\n            if (myRoom.isLowPriority) {\n                return 1;\n            }\n            return -1;\n        }\n        const myTimestamp = myRoom.lastMessageTimestamp;\n        const theirTimestamp = theirRoom.lastMessageTimestamp;\n        const myTimestampValid = Number.isSafeInteger(myTimestamp);\n        const theirTimestampValid = Number.isSafeInteger(theirTimestamp);\n        // if either does not have a timestamp, put the one with a timestamp first\n        if (myTimestampValid !== theirTimestampValid) {\n            if (!theirTimestampValid) {\n                return -1;\n            }\n            return 1;\n        }\n        const timeDiff = theirTimestamp - myTimestamp;\n        if (timeDiff === 0 || !theirTimestampValid || !myTimestampValid) {\n            // sort alphabetically\n            const nameCmp = this.name.localeCompare(other.name);\n            if (nameCmp === 0) {\n                return this._room.id.localeCompare(other._room.id);\n            }\n            return nameCmp;\n        }\n        return timeDiff;\n    }\n\n    get isUnread() {\n        return this._room.isUnread;\n    }\n\n    get name() {\n        return this._room.name || this.i18n`Empty Room`;\n    }\n\n    get badgeCount() {\n        return this._room.notificationCount;\n    }\n\n    get isHighlighted() {\n        return this._room.highlightCount !== 0;\n    }\n\n    get _avatarSource() {\n        return this._room;\n    }\n}\n","/*\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function comparePrimitive(a, b) {\n    if (a === b) {\n        return 0;\n    } else {\n        return a < b ? -1 : 1;\n    }\n}\n","/*\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseTileViewModel} from \"./BaseTileViewModel.js\";\nimport {comparePrimitive} from \"./common\";\n\nexport class InviteTileViewModel extends BaseTileViewModel {\n    constructor(options) {\n        super(options);\n        const {invite} = options;\n        this._invite = invite;\n        this._url = this.urlCreator.openRoomActionUrl(this._invite.id);\n    }\n\n    get busy() { return this._invite.accepting || this._invite.rejecting; }\n    get kind() { return \"invite\"; }\n    get url() { return this._url; }\n    get name() { return this._invite.name; }\n    get isHighlighted() { return true; }\n    get isUnread() { return true; }\n    get badgeCount() { return this.i18n`!`; }\n    get _avatarSource() { return this._invite; }\n\n    /** very important that sorting order is stable and that comparing\n     * to itself always returns 0, otherwise SortedMapList will\n     * remove the wrong children, etc ... */\n    compare(other) {\n        const parentComparison = super.compare(other);\n        if (parentComparison !== 0) {\n            return parentComparison;\n        }\n        const timeDiff = other._invite.timestamp - this._invite.timestamp;\n        if (timeDiff !== 0) {\n            return timeDiff;\n        }\n        return comparePrimitive(this._invite.id, other._invite.id);\n    }\n}\n\nexport function tests() {\n    return {\n        \"test compare with timestamp\": assert => {\n            const urlCreator = {openRoomActionUrl() { return \"\";}}\n            const vm1 = new InviteTileViewModel({invite: {timestamp: 500, id: \"1\"}, urlCreator});\n            const vm2 = new InviteTileViewModel({invite: {timestamp: 250, id: \"2\"}, urlCreator});\n            assert(vm1.compare(vm2) < 0);\n            assert(vm2.compare(vm1) > 0);\n            assert.equal(vm1.compare(vm1), 0);\n        },\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseTileViewModel} from \"./BaseTileViewModel.js\";\nimport {comparePrimitive} from \"./common\";\n\nexport class RoomBeingCreatedTileViewModel extends BaseTileViewModel {\n    constructor(options) {\n        super(options);\n        const {roomBeingCreated} = options;\n        this._roomBeingCreated = roomBeingCreated;\n        this._url = this.urlCreator.openRoomActionUrl(this._roomBeingCreated.id);\n    }\n\n    get busy() { return !this._roomBeingCreated.error; }\n    get kind() { return \"roomBeingCreated\"; }\n    get isHighlighted() { return !this.busy; }\n    get badgeCount() { return !this.busy && this.i18n`Failed`; }\n    get url() { return this._url; }\n    get name() { return this._roomBeingCreated.name; }\n    get _avatarSource() { return this._roomBeingCreated; }\n\n    /** very important that sorting order is stable and that comparing\n     * to itself always returns 0, otherwise SortedMapList will\n     * remove the wrong children, etc ... */\n    compare(other) {\n        const parentCmp = super.compare(other);\n        if (parentCmp !== 0) {\n            return parentCmp;\n        }\n        const nameCmp = comparePrimitive(this.name, other.name);\n        if (nameCmp === 0) {\n            return comparePrimitive(this._roomBeingCreated.id, other._roomBeingCreated.id);\n        } else {\n            return nameCmp;\n        }\n    }\n\n    avatarUrl(size) {\n        // allow blob url which doesn't need mxc => http resolution\n        return this._roomBeingCreated.avatarBlobUrl ?? super.avatarUrl(size);\n    }\n}\n\nexport function tests() {\n    return {\n        \"test compare with names\": assert => {\n            const urlCreator = {openRoomActionUrl() { return \"\";}}\n            const vm1 = new RoomBeingCreatedTileViewModel({roomBeingCreated: {name: \"A\", id: \"1\"}, urlCreator});\n            const vm2 = new RoomBeingCreatedTileViewModel({roomBeingCreated: {name: \"B\", id: \"2\"}, urlCreator});\n            assert(vm1.compare(vm2) < 0);\n            assert(vm2.compare(vm1) > 0);\n            assert.equal(vm1.compare(vm1), 0);\n        },\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class RoomFilter {\n    constructor(query) {\n        this._parts = query.split(\" \").map(s => s.toLowerCase().trim());\n    }\n\n    matches(roomTileVM) {\n        const name = roomTileVM.name.toLowerCase();\n        return this._parts.every(p => name.includes(p));\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableMap} from \"./BaseObservableMap.js\";\n\nexport class ApplyMap extends BaseObservableMap {\n    constructor(source, apply) {\n        super();\n        this._source = source;\n        this._apply = apply;\n        this._subscription = null;\n    }\n\n    hasApply() {\n        return !!this._apply;\n    }\n\n    setApply(apply) {\n        this._apply = apply;\n        if (apply) {\n            this.applyOnce(this._apply);\n        }\n    }\n\n    applyOnce(apply) {\n        for (const [key, value] of this._source) {\n            apply(key, value);\n        }\n    }\n\n    onAdd(key, value) {\n        if (this._apply) {\n            this._apply(key, value);\n        }\n        this.emitAdd(key, value);\n    }\n\n    onRemove(key, value) {\n        this.emitRemove(key, value);\n    }\n\n    onUpdate(key, value, params) {\n        if (this._apply) {\n            this._apply(key, value, params);\n        }\n        this.emitUpdate(key, value, params);\n    }\n\n    onSubscribeFirst() {\n        this._subscription = this._source.subscribe(this);\n        if (this._apply) {\n            this.applyOnce(this._apply);\n        }\n        super.onSubscribeFirst();\n    }\n\n    onUnsubscribeLast() {\n        super.onUnsubscribeLast();\n        this._subscription = this._subscription();\n    }\n\n    onReset() {\n        if (this._apply) {\n            this.applyOnce(this._apply);\n        }\n        this.emitReset();\n    }\n\n    [Symbol.iterator]() {\n        return this._source[Symbol.iterator]();\n    }\n\n    get size() {\n        return this._source.size;\n    }\n\n    get(key) {\n        return this._source.get(key);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableValue, ObservableValue} from \"../../observable/ObservableValue\";\n\nexport class Navigation {\n    constructor(allowsChild) {\n        this._allowsChild = allowsChild;\n        this._path = new Path([], allowsChild);\n        this._observables = new Map();\n        this._pathObservable = new ObservableValue(this._path);\n    }\n\n    get pathObservable() {\n        return this._pathObservable;\n    }\n\n    get path() {\n        return this._path;\n    }\n\n    push(type, value = undefined) {\n        return this.applyPath(this.path.with(new Segment(type, value)));\n    }\n\n    applyPath(path) {\n        // Path is not exported, so you can only create a Path through Navigation,\n        // so we assume it respects the allowsChild rules\n        const oldPath = this._path;\n        this._path = path;\n        // clear values not in the new path in reverse order of path\n        for (let i = oldPath.segments.length - 1; i >= 0; i -= 1) {\n            const segment = oldPath.segments[i];\n            if (!this._path.get(segment.type)) {\n                const observable = this._observables.get(segment.type);\n                observable?.emitIfChanged();\n            }\n        }\n        // change values in order of path\n        for (const segment of this._path.segments) {\n            const observable = this._observables.get(segment.type);\n            observable?.emitIfChanged();\n        }\n        // to observe the whole path having changed\n        // Since paths are immutable,\n        // we can just use set here which will compare the references\n        this._pathObservable.set(this._path);\n    }\n\n    observe(type) {\n        let observable = this._observables.get(type);\n        if (!observable) {\n            observable = new SegmentObservable(this, type);\n            this._observables.set(type, observable);\n        }\n        return observable;\n    }\n\n    pathFrom(segments) {\n        let parent;\n        let i;\n        for (i = 0; i < segments.length; i += 1) {\n            if (!this._allowsChild(parent, segments[i])) {\n                return new Path(segments.slice(0, i), this._allowsChild);\n            }\n            parent = segments[i];\n        }\n        return new Path(segments, this._allowsChild);\n    }\n\n    segment(type, value) {\n        return new Segment(type, value);\n    }\n}\n\nfunction segmentValueEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    // allow (sparse) arrays\n    if (Array.isArray(a) && Array.isArray(b)) {\n        const len = Math.max(a.length, b.length);\n        for (let i = 0; i < len; i += 1) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\nexport class Segment {\n    constructor(type, value) {\n        this.type = type;\n        this.value = value === undefined ? true : value;\n    }\n}\n\nclass Path {\n    constructor(segments = [], allowsChild) {\n        this._segments = segments;\n        this._allowsChild = allowsChild;\n    }\n\n    clone() {\n        return new Path(this._segments.slice(), this._allowsChild);\n    }\n\n    with(segment) {\n        let index = this._segments.length - 1;\n        do {\n            if (this._allowsChild(this._segments[index], segment)) {\n                // pop the elements that didn't allow the new segment as a child\n                const newSegments = this._segments.slice(0, index + 1);\n                newSegments.push(segment);\n                return new Path(newSegments, this._allowsChild);\n            }\n            index -= 1;\n        } while(index >= -1);\n        // allow -1 as well so we check if the segment is allowed as root\n        return null;\n    }\n\n    until(type) {\n        const index = this._segments.findIndex(s => s.type === type);\n        if (index !== -1) {\n            return new Path(this._segments.slice(0, index + 1), this._allowsChild)\n        }\n        return new Path([], this._allowsChild);\n    }\n\n    get(type) {\n        return this._segments.find(s => s.type === type);\n    }\n\n    replace(segment) {\n        const index = this._segments.findIndex(s => s.type === segment.type);\n        if (index !== -1) {\n            const parent = this._segments[index - 1];\n            if (this._allowsChild(parent, segment)) {\n                const child = this._segments[index + 1];\n                if (!child || this._allowsChild(segment, child)) {\n                    const newSegments = this._segments.slice();\n                    newSegments[index] = segment;\n                    return new Path(newSegments, this._allowsChild);\n                }\n            }\n        }\n        return null;\n    }\n\n    get segments() {\n        return this._segments;\n    }\n}\n\n/**\n * custom observable so it always returns what is in navigation.path, even if we haven't emitted the change yet.\n * This ensures that observers of a segment can also read the most recent value of other segments.\n */\nclass SegmentObservable extends BaseObservableValue {\n    constructor(navigation, type) {\n        super();\n        this._navigation = navigation;\n        this._type = type;\n        this._lastSetValue = navigation.path.get(type)?.value;\n    }\n\n    get() {\n        const path = this._navigation.path;\n        const segment = path.get(this._type);\n        const value = segment?.value;\n        return value;\n    }\n\n    emitIfChanged() {\n        const newValue = this.get();\n        if (!segmentValueEqual(newValue, this._lastSetValue)) {\n            this._lastSetValue = newValue;\n            this.emit(newValue);\n        }\n    }\n}\n\nexport function tests() {\n\n    function createMockNavigation() {\n        return new Navigation((parent, {type}) => {\n            switch (parent?.type) {\n                case undefined:\n                    return type === \"1\" || \"2\";\n                case \"1\":\n                    return type === \"1.1\";\n                case \"1.1\":\n                    return type === \"1.1.1\";\n                case \"2\":\n                    return type === \"2.1\" || \"2.2\";\n                default:\n                    return false;\n            }\n        });\n    }\n\n    function observeTypes(nav, types) {\n        const changes = [];\n        for (const type of types) {\n            nav.observe(type).subscribe(value => {\n                changes.push({type, value});\n            });\n        }\n        return changes;\n    }\n\n    return {\n        \"applying a path emits an event on the observable\": assert => {\n            const nav = createMockNavigation();\n            const path = nav.pathFrom([\n                new Segment(\"2\", 7),\n                new Segment(\"2.2\", 8),\n            ]);\n            assert.equal(path.segments.length, 2);\n            let changes = observeTypes(nav, [\"2\", \"2.2\"]);\n            nav.applyPath(path);\n            assert.equal(changes.length, 2);\n            assert.equal(changes[0].type, \"2\");\n            assert.equal(changes[0].value, 7);\n            assert.equal(changes[1].type, \"2.2\");\n            assert.equal(changes[1].value, 8);\n        },\n        \"path.get\": assert => {\n            const path = new Path([new Segment(\"foo\", 5), new Segment(\"bar\", 6)], () => true);\n            assert.equal(path.get(\"foo\").value, 5);\n            assert.equal(path.get(\"bar\").value, 6);\n        },\n        \"path.replace success\": assert => {\n            const path = new Path([new Segment(\"foo\", 5), new Segment(\"bar\", 6)], () => true);\n            const newPath = path.replace(new Segment(\"foo\", 1));\n            assert.equal(newPath.get(\"foo\").value, 1);\n            assert.equal(newPath.get(\"bar\").value, 6);\n        },\n        \"path.replace not found\": assert => {\n            const path = new Path([new Segment(\"foo\", 5), new Segment(\"bar\", 6)], () => true);\n            const newPath = path.replace(new Segment(\"baz\", 1));\n            assert.equal(newPath, null);\n        }\n    };\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class URLRouter {\n    constructor({history, navigation, parseUrlPath, stringifyPath}) {\n        this._history = history;\n        this._navigation = navigation;\n        this._parseUrlPath = parseUrlPath;\n        this._stringifyPath = stringifyPath;\n        this._subscription = null;\n        this._pathSubscription = null;\n        this._isApplyingUrl = false;\n        this._defaultSessionId = this._getLastSessionId();\n    }\n\n    _getLastSessionId() {\n        const navPath = this._urlAsNavPath(this._history.getLastUrl() || \"\");\n        const sessionId = navPath.get(\"session\")?.value;\n        if (typeof sessionId === \"string\") {\n            return sessionId;\n        }\n        return null;\n    }\n\n    attach() {\n        this._subscription = this._history.subscribe(url => this._applyUrl(url));\n        // subscribe to path before applying initial url\n        // so redirects in _applyNavPathToHistory are reflected in url bar\n        this._pathSubscription = this._navigation.pathObservable.subscribe(path => this._applyNavPathToHistory(path));\n        this._applyUrl(this._history.get());\n    }\n\n    dispose() {\n        this._subscription = this._subscription();\n        this._pathSubscription = this._pathSubscription();\n    }\n\n    _applyNavPathToHistory(path) {\n        const url = this.urlForPath(path);\n        if (url !== this._history.get()) {\n            if (this._isApplyingUrl) {\n                // redirect\n                this._history.replaceUrlSilently(url);\n            } else {\n                this._history.pushUrlSilently(url);\n            }\n        }\n    }\n\n    _applyNavPathToNavigation(navPath) {\n        // this will cause _applyNavPathToHistory to be called,\n        // so set a flag whether this request came from ourselves\n        // (in which case it is a redirect if the url does not match the current one)\n        this._isApplyingUrl = true;\n        this._navigation.applyPath(navPath);\n        this._isApplyingUrl = false;\n    }\n\n    _urlAsNavPath(url) {\n        const urlPath = this._history.urlAsPath(url);\n        return this._navigation.pathFrom(this._parseUrlPath(urlPath, this._navigation.path, this._defaultSessionId));\n    }\n\n    _applyUrl(url) {\n        const navPath = this._urlAsNavPath(url);\n        this._applyNavPathToNavigation(navPath);\n    }\n\n    pushUrl(url) {\n        this._history.pushUrl(url);\n    }\n\n    tryRestoreLastUrl() {\n        const lastNavPath = this._urlAsNavPath(this._history.getLastUrl() || \"\");\n        if (lastNavPath.segments.length !== 0) {\n            this._applyNavPathToNavigation(lastNavPath);\n            return true;\n        }\n        return false;\n    }\n\n    urlForSegments(segments) {\n        let path = this._navigation.path;\n        for (const segment of segments) {\n            path = path.with(segment);\n            if (!path) {\n                return;\n            }\n        }\n        return this.urlForPath(path);\n    }\n\n    urlForSegment(type, value) {\n        return this.urlForSegments([this._navigation.segment(type, value)]);\n    }\n\n    urlUntilSegment(type) {\n        return this.urlForPath(this._navigation.path.until(type));\n    }\n\n    urlForPath(path) {\n        return this._history.pathAsUrl(this._stringifyPath(path));\n    }\n\n    openRoomActionUrl(roomId) {\n        // not a segment to navigation knowns about, so append it manually\n        const urlPath = `${this._stringifyPath(this._navigation.path.until(\"session\"))}/open-room/${roomId}`;\n        return this._history.pathAsUrl(urlPath);\n    }\n\n    createSSOCallbackURL() {\n        return window.location.origin;\n    }\n\n    normalizeUrl() {\n        // Remove any queryParameters from the URL\n        // Gets rid of the loginToken after SSO\n        this._history.replaceUrlSilently(`${window.location.origin}/${window.location.hash}`);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {Navigation, Segment} from \"./Navigation.js\";\nimport {URLRouter} from \"./URLRouter.js\";\n\nexport function createNavigation() {\n    return new Navigation(allowsChild);\n}\n\nexport function createRouter({history, navigation}) {\n    return new URLRouter({history, navigation, stringifyPath, parseUrlPath});\n}\n\nfunction allowsChild(parent, child) {\n    const {type} = child;\n    switch (parent?.type) {\n        case undefined:\n            // allowed root segments\n            return type === \"login\"  || type === \"session\" || type === \"sso\" || type === \"logout\";\n        case \"session\":\n            return type === \"room\" || type === \"rooms\" || type === \"settings\" || type === \"create-room\";\n        case \"rooms\":\n            // downside of the approach: both of these will control which tile is selected\n            return type === \"room\" || type === \"empty-grid-tile\";\n        case \"room\":\n            return type === \"lightbox\" || type === \"right-panel\";\n        case \"right-panel\":\n            return type === \"details\"|| type === \"members\" || type === \"member\";\n        default:\n            return false;\n    }\n}\n\nexport function removeRoomFromPath(path, roomId) {\n    const rooms = path.get(\"rooms\");\n    let roomIdGridIndex = -1;\n    // first delete from rooms segment\n    if (rooms) {\n        roomIdGridIndex = rooms.value.indexOf(roomId);\n        if (roomIdGridIndex !== -1) {\n            const idsWithoutRoom = rooms.value.slice();\n            idsWithoutRoom[roomIdGridIndex] = \"\";\n            path = path.replace(new Segment(\"rooms\", idsWithoutRoom));\n        }\n    }\n    const room = path.get(\"room\");\n    // then from room (which occurs with or without rooms)\n    if (room && room.value === roomId) {\n        if (roomIdGridIndex !== -1) {\n            path = path.with(new Segment(\"empty-grid-tile\", roomIdGridIndex));\n        } else {\n            path = path.until(\"session\");\n        }\n    }\n    return path;\n}\n\nfunction roomsSegmentWithRoom(rooms, roomId, path) {\n    if(!rooms.value.includes(roomId)) {\n        const emptyGridTile = path.get(\"empty-grid-tile\");\n        const oldRoom = path.get(\"room\");\n        let index = 0;\n        if (emptyGridTile) {\n            index = emptyGridTile.value;\n        } else if (oldRoom) {\n            index = rooms.value.indexOf(oldRoom.value);\n        }\n        const roomIds = rooms.value.slice();\n        roomIds[index] = roomId;\n        return new Segment(\"rooms\", roomIds);\n    } else {\n        return rooms;\n    }\n}\n\nfunction pushRightPanelSegment(array, segment, value = true) {\n    array.push(new Segment(\"right-panel\"));\n    array.push(new Segment(segment, value));\n}\n\nexport function addPanelIfNeeded(navigation, path) {\n    const segments = navigation.path.segments;\n    const i = segments.findIndex(segment => segment.type === \"right-panel\");\n    let _path = path;\n    if (i !== -1) {\n        _path = path.until(\"room\");\n        _path = _path.with(segments[i]);\n        _path = _path.with(segments[i + 1]);\n    }\n    return _path;\n}\n\nexport function parseUrlPath(urlPath, currentNavPath, defaultSessionId) {\n    // substr(1) to take of initial /\n    const parts = urlPath.substr(1).split(\"/\");\n    const iterator = parts[Symbol.iterator]();\n    const segments = [];\n    let next; \n    while (!(next = iterator.next()).done) {\n        const type = next.value;\n        if (type === \"rooms\") {\n            const roomsValue = iterator.next().value;\n            if (roomsValue === undefined) { break; }\n            const roomIds = roomsValue.split(\",\");\n            segments.push(new Segment(type, roomIds));\n            const selectedIndex = parseInt(iterator.next().value || \"0\", 10);\n            const roomId = roomIds[selectedIndex];\n            if (roomId) {\n                segments.push(new Segment(\"room\", roomId));\n            } else {\n                segments.push(new Segment(\"empty-grid-tile\", selectedIndex));\n            }\n        } else if (type === \"open-room\") {\n            const roomId = iterator.next().value;\n            if (!roomId) { break; }\n            const rooms = currentNavPath.get(\"rooms\");\n            if (rooms) {\n                segments.push(roomsSegmentWithRoom(rooms, roomId, currentNavPath));\n            }\n            segments.push(new Segment(\"room\", roomId));\n            const openRoomPartIndex = parts.findIndex(part => part === \"open-room\");\n            const hasOnlyRoomIdAfterPart = openRoomPartIndex >= parts.length - 2;\n            if (hasOnlyRoomIdAfterPart) {\n                // Copy right-panel segments from previous path only if there are no other parts after open-room\n                // fixes memberlist -> member details closing/opening grid view\n                const previousSegments = currentNavPath.segments;\n                const i = previousSegments.findIndex(s => s.type === \"right-panel\");\n                if (i !== -1) {\n                    segments.push(...previousSegments.slice(i));\n                }\n            }\n        } else if (type === \"last-session\") {\n            let sessionSegment = currentNavPath.get(\"session\");\n            if (typeof sessionSegment?.value !== \"string\" && defaultSessionId) {\n                sessionSegment = new Segment(\"session\", defaultSessionId);\n            }\n            if (sessionSegment) {\n                segments.push(sessionSegment);\n            }\n        } else if (type === \"details\" || type === \"members\") {\n            pushRightPanelSegment(segments, type);\n        } else if (type === \"member\") {\n            const userId = iterator.next().value;\n            if (!userId) { break; }\n            pushRightPanelSegment(segments, type, userId);\n        } else if (type.includes(\"loginToken\")) {\n            // Special case for SSO-login with query parameter loginToken=<token>\n            const loginToken = type.split(\"=\").pop();\n            segments.push(new Segment(\"sso\", loginToken));\n        } else {\n            // might be undefined, which will be turned into true by Segment \n            const value = iterator.next().value;\n            segments.push(new Segment(type, value));\n        }\n    }\n    return segments;\n}\n\nexport function stringifyPath(path) {\n    let urlPath = \"\";\n    let prevSegment;\n    for (const segment of path.segments) {\n        switch (segment.type) {\n            case \"rooms\":\n                urlPath += `/rooms/${segment.value.join(\",\")}`;\n                break;\n            case \"empty-grid-tile\":\n                urlPath += `/${segment.value}`;\n                break;\n            case \"room\":\n                if (prevSegment?.type === \"rooms\") {\n                    const index = prevSegment.value.indexOf(segment.value);\n                    urlPath += `/${index}`;\n                } else {\n                    urlPath += `/${segment.type}/${segment.value}`;\n                }\n                break;\n            case \"right-panel\":\n            case \"sso\":\n                // Do not put these segments in URL\n                continue;\n            default:\n                urlPath += `/${segment.type}`;\n                if (segment.value && segment.value !== true) {\n                    urlPath += `/${segment.value}`;\n                }\n        }\n        prevSegment = segment;\n    }\n    return urlPath;\n}\n\nexport function tests() {\n    return {\n        \"stringify grid url with focused empty tile\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"rooms\", [\"a\", \"b\", \"c\"]),\n                new Segment(\"empty-grid-tile\", 3)\n            ]);\n            const urlPath = stringifyPath(path);\n            assert.equal(urlPath, \"/session/1/rooms/a,b,c/3\");\n        },\n        \"stringify grid url with focused room\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"rooms\", [\"a\", \"b\", \"c\"]),\n                new Segment(\"room\", \"b\")\n            ]);\n            const urlPath = stringifyPath(path);\n            assert.equal(urlPath, \"/session/1/rooms/a,b,c/1\");\n        },\n        \"stringify url with right-panel and details segment\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"rooms\", [\"a\", \"b\", \"c\"]),\n                new Segment(\"room\", \"b\"),\n                new Segment(\"right-panel\"),\n                new Segment(\"details\")\n            ]);\n            const urlPath = stringifyPath(path);\n            assert.equal(urlPath, \"/session/1/rooms/a,b,c/1/details\");\n        },\n        \"Parse loginToken query parameter into SSO segment\": assert => {\n            const segments = parseUrlPath(\"?loginToken=a1232aSD123\");\n            assert.equal(segments.length, 1);\n            assert.equal(segments[0].type, \"sso\");\n            assert.equal(segments[0].value, \"a1232aSD123\");\n        },\n        \"parse grid url path with focused empty tile\": assert => {\n            const segments = parseUrlPath(\"/session/1/rooms/a,b,c/3\");\n            assert.equal(segments.length, 3);\n            assert.equal(segments[0].type, \"session\");\n            assert.equal(segments[0].value, \"1\");\n            assert.equal(segments[1].type, \"rooms\");\n            assert.deepEqual(segments[1].value, [\"a\", \"b\", \"c\"]);\n            assert.equal(segments[2].type, \"empty-grid-tile\");\n            assert.equal(segments[2].value, 3);\n        },\n        \"parse grid url path with focused room\": assert => {\n            const segments = parseUrlPath(\"/session/1/rooms/a,b,c/1\");\n            assert.equal(segments.length, 3);\n            assert.equal(segments[0].type, \"session\");\n            assert.equal(segments[0].value, \"1\");\n            assert.equal(segments[1].type, \"rooms\");\n            assert.deepEqual(segments[1].value, [\"a\", \"b\", \"c\"]);\n            assert.equal(segments[2].type, \"room\");\n            assert.equal(segments[2].value, \"b\");\n        },\n        \"parse empty grid url\": assert => {\n            const segments = parseUrlPath(\"/session/1/rooms/\");\n            assert.equal(segments.length, 3);\n            assert.equal(segments[0].type, \"session\");\n            assert.equal(segments[0].value, \"1\");\n            assert.equal(segments[1].type, \"rooms\");\n            assert.deepEqual(segments[1].value, [\"\"]);\n            assert.equal(segments[2].type, \"empty-grid-tile\");\n            assert.equal(segments[2].value, 0);\n        },\n        \"parse empty grid url with focus\": assert => {\n            const segments = parseUrlPath(\"/session/1/rooms//1\");\n            assert.equal(segments.length, 3);\n            assert.equal(segments[0].type, \"session\");\n            assert.equal(segments[0].value, \"1\");\n            assert.equal(segments[1].type, \"rooms\");\n            assert.deepEqual(segments[1].value, [\"\"]);\n            assert.equal(segments[2].type, \"empty-grid-tile\");\n            assert.equal(segments[2].value, 1);\n        },\n        \"parse open-room action replacing the current focused room\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"rooms\", [\"a\", \"b\", \"c\"]),\n                new Segment(\"room\", \"b\")\n            ]);\n            const segments = parseUrlPath(\"/session/1/open-room/d\", path);\n            assert.equal(segments.length, 3);\n            assert.equal(segments[0].type, \"session\");\n            assert.equal(segments[0].value, \"1\");\n            assert.equal(segments[1].type, \"rooms\");\n            assert.deepEqual(segments[1].value, [\"a\", \"d\", \"c\"]);\n            assert.equal(segments[2].type, \"room\");\n            assert.equal(segments[2].value, \"d\");\n        },\n        \"parse open-room action changing focus to an existing room\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"rooms\", [\"a\", \"b\", \"c\"]),\n                new Segment(\"room\", \"b\")\n            ]);\n            const segments = parseUrlPath(\"/session/1/open-room/a\", path);\n            assert.equal(segments.length, 3);\n            assert.equal(segments[0].type, \"session\");\n            assert.equal(segments[0].value, \"1\");\n            assert.equal(segments[1].type, \"rooms\");\n            assert.deepEqual(segments[1].value, [\"a\", \"b\", \"c\"]);\n            assert.equal(segments[2].type, \"room\");\n            assert.equal(segments[2].value, \"a\");\n        },\n        \"parse open-room action changing focus to an existing room with details open\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"rooms\", [\"a\", \"b\", \"c\"]),\n                new Segment(\"room\", \"b\"),\n                new Segment(\"right-panel\", true),\n                new Segment(\"details\", true)\n            ]);\n            const segments = parseUrlPath(\"/session/1/open-room/a\", path);\n            assert.equal(segments.length, 5);\n            assert.equal(segments[0].type, \"session\");\n            assert.equal(segments[0].value, \"1\");\n            assert.equal(segments[1].type, \"rooms\");\n            assert.deepEqual(segments[1].value, [\"a\", \"b\", \"c\"]);\n            assert.equal(segments[2].type, \"room\");\n            assert.equal(segments[2].value, \"a\");\n            assert.equal(segments[3].type, \"right-panel\");\n            assert.equal(segments[3].value, true);\n            assert.equal(segments[4].type, \"details\");\n            assert.equal(segments[4].value, true);\n        },\n        \"open-room action should only copy over previous segments if there are no parts after open-room\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"rooms\", [\"a\", \"b\", \"c\"]),\n                new Segment(\"room\", \"b\"),\n                new Segment(\"right-panel\", true),\n                new Segment(\"members\", true)\n            ]);\n            const segments = parseUrlPath(\"/session/1/open-room/a/member/foo\", path);\n            assert.equal(segments.length, 5);\n            assert.equal(segments[0].type, \"session\");\n            assert.equal(segments[0].value, \"1\");\n            assert.equal(segments[1].type, \"rooms\");\n            assert.deepEqual(segments[1].value, [\"a\", \"b\", \"c\"]);\n            assert.equal(segments[2].type, \"room\");\n            assert.equal(segments[2].value, \"a\");\n            assert.equal(segments[3].type, \"right-panel\");\n            assert.equal(segments[3].value, true);\n            assert.equal(segments[4].type, \"member\");\n            assert.equal(segments[4].value, \"foo\");\n        },\n        \"parse open-room action setting a room in an empty tile\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"rooms\", [\"a\", \"b\", \"c\"]),\n                new Segment(\"empty-grid-tile\", 4)\n            ]);\n            const segments = parseUrlPath(\"/session/1/open-room/d\", path);\n            assert.equal(segments.length, 3);\n            assert.equal(segments[0].type, \"session\");\n            assert.equal(segments[0].value, \"1\");\n            assert.equal(segments[1].type, \"rooms\");\n            assert.deepEqual(segments[1].value, [\"a\", \"b\", \"c\", , \"d\"]); //eslint-disable-line no-sparse-arrays\n            assert.equal(segments[2].type, \"room\");\n            assert.equal(segments[2].value, \"d\");\n        },\n        \"parse session url path without id\": assert => {\n            const segments = parseUrlPath(\"/session\");\n            assert.equal(segments.length, 1);\n            assert.equal(segments[0].type, \"session\");\n            assert.strictEqual(segments[0].value, true);\n        },\n        \"remove active room from grid path turns it into empty tile\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"rooms\", [\"a\", \"b\", \"c\"]),\n                new Segment(\"room\", \"b\")\n            ]);\n            const newPath = removeRoomFromPath(path, \"b\");\n            assert.equal(newPath.segments.length, 3);\n            assert.equal(newPath.segments[0].type, \"session\");\n            assert.equal(newPath.segments[0].value, 1);\n            assert.equal(newPath.segments[1].type, \"rooms\");\n            assert.deepEqual(newPath.segments[1].value, [\"a\", \"\", \"c\"]);\n            assert.equal(newPath.segments[2].type, \"empty-grid-tile\");\n            assert.equal(newPath.segments[2].value, 1);\n        },\n        \"remove inactive room from grid path\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"rooms\", [\"a\", \"b\", \"c\"]),\n                new Segment(\"room\", \"b\")\n            ]);\n            const newPath = removeRoomFromPath(path, \"a\");\n            assert.equal(newPath.segments.length, 3);\n            assert.equal(newPath.segments[0].type, \"session\");\n            assert.equal(newPath.segments[0].value, 1);\n            assert.equal(newPath.segments[1].type, \"rooms\");\n            assert.deepEqual(newPath.segments[1].value, [\"\", \"b\", \"c\"]);\n            assert.equal(newPath.segments[2].type, \"room\");\n            assert.equal(newPath.segments[2].value, \"b\");\n        },\n        \"remove inactive room from grid path with empty tile\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"rooms\", [\"a\", \"b\", \"\"]),\n                new Segment(\"empty-grid-tile\", 3)\n            ]);\n            const newPath = removeRoomFromPath(path, \"b\");\n            assert.equal(newPath.segments.length, 3);\n            assert.equal(newPath.segments[0].type, \"session\");\n            assert.equal(newPath.segments[0].value, 1);\n            assert.equal(newPath.segments[1].type, \"rooms\");\n            assert.deepEqual(newPath.segments[1].value, [\"a\", \"\", \"\"]);\n            assert.equal(newPath.segments[2].type, \"empty-grid-tile\");\n            assert.equal(newPath.segments[2].value, 3);\n        },\n        \"remove active room\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"room\", \"b\")\n            ]);\n            const newPath = removeRoomFromPath(path, \"b\");\n            assert.equal(newPath.segments.length, 1);\n            assert.equal(newPath.segments[0].type, \"session\");\n            assert.equal(newPath.segments[0].value, 1);\n        },\n        \"remove inactive room doesn't do anything\": assert => {\n            const nav = new Navigation(allowsChild);\n            const path = nav.pathFrom([\n                new Segment(\"session\", 1),\n                new Segment(\"room\", \"b\")\n            ]);\n            const newPath = removeRoomFromPath(path, \"a\");\n            assert.equal(newPath.segments.length, 2);\n            assert.equal(newPath.segments[0].type, \"session\");\n            assert.equal(newPath.segments[0].value, 1);\n            assert.equal(newPath.segments[1].type, \"room\");\n            assert.equal(newPath.segments[1].value, \"b\");\n        },\n        \n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../../ViewModel.js\";\nimport {RoomTileViewModel} from \"./RoomTileViewModel.js\";\nimport {InviteTileViewModel} from \"./InviteTileViewModel.js\";\nimport {RoomBeingCreatedTileViewModel} from \"./RoomBeingCreatedTileViewModel.js\";\nimport {RoomFilter} from \"./RoomFilter.js\";\nimport {ApplyMap} from \"../../../observable/map/ApplyMap.js\";\nimport {addPanelIfNeeded} from \"../../navigation/index.js\";\n\nexport class LeftPanelViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {session} = options;\n        this._tileViewModelsMap = this._mapTileViewModels(session.roomsBeingCreated, session.invites, session.rooms);\n        this._tileViewModelsFilterMap = new ApplyMap(this._tileViewModelsMap);\n        this._tileViewModels = this._tileViewModelsFilterMap.sortValues((a, b) => a.compare(b));\n        this._currentTileVM = null;\n        this._setupNavigation();\n        this._closeUrl = this.urlCreator.urlForSegment(\"session\");\n        this._settingsUrl = this.urlCreator.urlForSegment(\"settings\");\n        this._createRoomUrl = this.urlCreator.urlForSegment(\"create-room\");\n    }\n\n    _mapTileViewModels(roomsBeingCreated, invites, rooms) {\n        // join is not commutative, invites will take precedence over rooms\n        const allTiles = invites.join(roomsBeingCreated, rooms).mapValues((item, emitChange) => {\n            let vm;\n            if (item.isBeingCreated) {\n                vm = new RoomBeingCreatedTileViewModel(this.childOptions({roomBeingCreated: item, emitChange}));\n            } else if (item.isInvite) {\n                vm = new InviteTileViewModel(this.childOptions({invite: item, emitChange}));\n            } else {\n                vm = new RoomTileViewModel(this.childOptions({room: item, emitChange}));\n            }\n            const isOpen = this.navigation.path.get(\"room\")?.value === item.id;\n            if (isOpen) {\n                vm.open();\n                this._updateCurrentVM(vm);\n            }\n            return vm;\n        });\n        return allTiles;\n    }\n\n    _updateCurrentVM(vm) {\n        // need to also update the current vm here as\n        // we can't call `_open` from the ctor as the map\n        // is only populated when the view subscribes.\n        this._currentTileVM?.close();\n        this._currentTileVM = vm;\n    }\n\n    get closeUrl() {\n        return this._closeUrl;\n    }\n\n    get settingsUrl() {\n        return this._settingsUrl;\n    }\n\n    get createRoomUrl() { return this._createRoomUrl; }\n\n    _setupNavigation() {\n        const roomObservable = this.navigation.observe(\"room\");\n        this.track(roomObservable.subscribe(roomId => this._open(roomId)));\n\n        const gridObservable = this.navigation.observe(\"rooms\");\n        this.gridEnabled = !!gridObservable.get();\n        this.track(gridObservable.subscribe(roomIds => {\n            const changed = this.gridEnabled ^ !!roomIds;\n            this.gridEnabled = !!roomIds;\n            if (changed) {\n                this.emitChange(\"gridEnabled\");\n            }\n        }));\n    }\n\n    _open(roomId) {\n        this._currentTileVM?.close();\n        this._currentTileVM = null;\n        if (roomId) {\n            this._currentTileVM = this._tileViewModelsMap.get(roomId);\n            this._currentTileVM?.open();\n        }\n    }\n\n    toggleGrid() {\n        const room = this.navigation.path.get(\"room\");\n        let path = this.navigation.path.until(\"session\");\n        if (this.gridEnabled) {\n            if (room) {\n                path = path.with(room);\n                path = addPanelIfNeeded(this.navigation, path);\n            }\n        } else {\n            if (room) {\n                path = path.with(this.navigation.segment(\"rooms\", [room.value]));\n                path = path.with(room);\n                path = addPanelIfNeeded(this.navigation, path);\n            } else {\n                path = path.with(this.navigation.segment(\"rooms\", []));\n                path = path.with(this.navigation.segment(\"empty-grid-tile\", 0));\n            }\n        }\n        this.navigation.applyPath(path);\n    }\n\n    get tileViewModels() {\n        return this._tileViewModels;\n    }\n\n    clearFilter() {\n        this._tileViewModelsFilterMap.setApply(null);\n        this._tileViewModelsFilterMap.applyOnce((roomId, vm) => vm.hidden = false);\n    }\n\n    setFilter(query) {\n        query = query.trim();\n        if (query.length === 0) {\n            this.clearFilter();\n            return false;\n        } else {\n            const startFiltering = !this._tileViewModelsFilterMap.hasApply();\n            const filter = new RoomFilter(query);\n            this._tileViewModelsFilterMap.setApply((roomId, vm) => {\n                vm.hidden = !filter.matches(vm);\n            });\n            return startFiltering;\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class UpdateAction {\n    constructor(remove, update, replace, updateParams) {\n        this._remove = remove;\n        this._update = update;\n        this._replace = replace;\n        this._updateParams = updateParams;\n    }\n\n    get shouldReplace() {\n        return this._replace;\n    }\n\n    get shouldRemove() {\n        return this._remove;\n    }\n\n    get shouldUpdate() {\n        return this._update;\n    }\n\n    get updateParams() {\n        return this._updateParams;\n    }\n\n    static Remove() {\n        return new UpdateAction(true, false, false, null);\n    }\n\n    static Update(newParams) {\n        return new UpdateAction(false, true, false, newParams);\n    }\n\n    static Nothing() {\n        return new UpdateAction(false, false, false, null);\n    }\n\n    static Replace(params) {\n        return new UpdateAction(false, false, true, params);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableList} from \"../../../../observable/list/BaseObservableList\";\nimport {sortedIndex} from \"../../../../utils/sortedIndex\";\n\n// maps 1..n entries to 0..1 tile. Entries are what is stored in the timeline, either an event or fragmentboundary\n// for now, tileCreator should be stable in whether it returns a tile or not.\n// e.g. the decision to create a tile or not should be based on properties\n// not updated later on (e.g. event type)\n// also see big comment in onUpdate\nexport class TilesCollection extends BaseObservableList {\n    constructor(entries, tileCreator) {\n        super();\n        this._entries = entries;\n        this._tiles = null;\n        this._entrySubscription = null;\n        this._tileCreator = tileCreator;\n        this._emitSpontanousUpdate = this._emitSpontanousUpdate.bind(this);\n    }\n\n    _emitSpontanousUpdate(tile, params) {\n        const entry = tile.lowerEntry;\n        const tileIdx = this._findTileIdx(entry);\n        this.emitUpdate(tileIdx, tile, params);\n    }\n\n    onSubscribeFirst() {\n        this._entrySubscription = this._entries.subscribe(this);\n        this._populateTiles();\n    }\n\n    _populateTiles() {\n        this._tiles = [];\n        let currentTile = null;\n        for (let entry of this._entries) {\n            if (!currentTile || !currentTile.tryIncludeEntry(entry)) {\n                currentTile = this._tileCreator(entry);\n                if (currentTile) {\n                    this._tiles.push(currentTile);\n                }\n            }\n        }\n        let prevTile = null;\n        for (let tile of this._tiles) {\n            if (prevTile) {\n                prevTile.updateNextSibling(tile);\n            }\n            tile.updatePreviousSibling(prevTile);\n            prevTile = tile;\n        }\n        if (prevTile) {\n            prevTile.updateNextSibling(null);\n        }\n        // now everything is wired up,\n        // allow tiles to emit updates\n        for (const tile of this._tiles) {\n            tile.setUpdateEmit(this._emitSpontanousUpdate);\n        }\n    }\n\n    _findTileIdx(entry) {\n        return sortedIndex(this._tiles, entry, (entry, tile) => {\n            // negate result because we're switching the order of the params\n            return -tile.compareEntry(entry);\n        });\n    }\n\n    _findTileAtIdx(entry, idx) {\n        const tile = this._getTileAtIdx(idx);\n        if (tile && tile.compareEntry(entry) === 0) {\n            return tile;\n        }\n    }\n\n    _getTileAtIdx(tileIdx) {\n        if (tileIdx >= 0 && tileIdx < this._tiles.length) {\n            return this._tiles[tileIdx];\n        }\n        return null;\n    }\n\n    onUnsubscribeLast() {\n        this._entrySubscription = this._entrySubscription();\n        for(let i = 0; i < this._tiles.length; i+= 1) {\n            this._tiles[i].dispose();\n        }\n        this._tiles = null;\n    }\n\n    onReset() {\n        // if TileViewModel were disposable, dispose here, or is that for views to do? views I suppose ...\n        this._buildInitialTiles();\n        this.emitReset();\n    }\n\n    onAdd(index, entry) {\n        const tileIdx = this._findTileIdx(entry);\n        const prevTile = this._getTileAtIdx(tileIdx - 1);\n        if (prevTile && prevTile.tryIncludeEntry(entry)) {\n            this.emitUpdate(tileIdx - 1, prevTile);\n            return;\n        }\n        // not + 1 because this entry hasn't been added yet\n        const nextTile = this._getTileAtIdx(tileIdx);\n        if (nextTile && nextTile.tryIncludeEntry(entry)) {\n            this.emitUpdate(tileIdx, nextTile);\n            return;\n        }\n\n        const newTile = this._tileCreator(entry);\n        if (newTile) {\n            if (prevTile) {\n                prevTile.updateNextSibling(newTile);\n                // this emits an update while the add hasn't been emitted yet\n                newTile.updatePreviousSibling(prevTile);\n            }\n            if (nextTile) {\n                newTile.updateNextSibling(nextTile);\n                nextTile.updatePreviousSibling(newTile);\n            }\n            this._tiles.splice(tileIdx, 0, newTile);\n            this.emitAdd(tileIdx, newTile);\n            // add event is emitted, now the tile\n            // can emit updates\n            newTile.setUpdateEmit(this._emitSpontanousUpdate);\n        }\n        // find position by sort key\n        // ask siblings to be included? both? yes, twice: a (insert c here) b, ask a(c), if yes ask b(a), else ask b(c)? if yes then b(a)?\n    }\n\n    onUpdate(index, entry, params) {\n        // if an update is emitted while calling source.subscribe() from onSubscribeFirst, ignore it\n        if (!this._tiles) {\n            return;\n        }\n        const tileIdx = this._findTileIdx(entry);\n        const tile = this._findTileAtIdx(entry, tileIdx);\n        if (tile) {\n            const action = tile.updateEntry(entry, params, this._tileCreator);\n            if (action.shouldReplace) {\n                const newTile = this._tileCreator(entry);\n                if (newTile) {\n                    this._replaceTile(tileIdx, tile, newTile, action.updateParams);\n                    newTile.setUpdateEmit(this._emitSpontanousUpdate);\n                } else {\n                    this._removeTile(tileIdx, tile);\n                }\n            }\n            if (action.shouldRemove) {\n                this._removeTile(tileIdx, tile);\n            }\n            if (action.shouldUpdate) {\n                this.emitUpdate(tileIdx, tile, action.updateParams);\n            }\n        }\n        // technically we should handle adding a tile here as well\n        // in case before we didn't have a tile for it but now we do\n        // but in reality we don't have this use case as the type and msgtype\n        // doesn't change. Decryption maybe is the exception?\n\n\n        // outcomes here can be\n        //   tiles should be removed (got redacted and we don't want it in the timeline)\n        //   tile should be added where there was none before ... ?\n        //   entry should get it's own tile now\n        //   merge with neighbours? ... hard to imagine use case for this  ...\n    }\n\n    _replaceTile(tileIdx, existingTile, newTile, updateParams) {\n        existingTile.dispose();\n        const prevTile = this._getTileAtIdx(tileIdx - 1);\n        const nextTile = this._getTileAtIdx(tileIdx + 1);\n        this._tiles[tileIdx] = newTile;\n        prevTile?.updateNextSibling(newTile);\n        newTile.updatePreviousSibling(prevTile);\n        newTile.updateNextSibling(nextTile);\n        nextTile?.updatePreviousSibling(newTile);\n        this.emitUpdate(tileIdx, newTile, updateParams);\n    }\n\n    _removeTile(tileIdx, tile) {\n        const prevTile = this._getTileAtIdx(tileIdx - 1);\n        const nextTile = this._getTileAtIdx(tileIdx + 1);\n        // applying and emitting the remove should happen\n        // atomically, as updateNext/PreviousSibling might\n        // emit an update with the wrong index otherwise \n        this._tiles.splice(tileIdx, 1);\n        tile.dispose();\n        this.emitRemove(tileIdx, tile);\n        prevTile?.updateNextSibling(nextTile);\n        nextTile?.updatePreviousSibling(prevTile);\n    }\n\n    // would also be called when unloading a part of the timeline\n    onRemove(index, entry) {\n        const tileIdx = this._findTileIdx(entry);\n        const tile = this._findTileAtIdx(entry, tileIdx);\n        if (tile) {\n            const removeTile = tile.removeEntry(entry);\n            if (removeTile) {\n                this._removeTile(tileIdx, tile);\n            } else {\n                this.emitUpdate(tileIdx, tile);\n            }\n        }\n    }\n\n    onMove(/*fromIdx, toIdx, value*/) {\n        // this ... cannot happen in the timeline?\n        // perhaps we can use this event to support a local echo (in a different fragment)\n        // to be moved to the key of the remote echo, so we don't loose state ... ?\n    }\n\n    [Symbol.iterator]() {\n        return this._tiles.values();\n    }\n\n    get length() {\n        return this._tiles.length;\n    }\n\n    getFirst() {\n        return this._tiles[0];\n    }\n\n    getTileIndex(searchTile) {\n        const idx = sortedIndex(this._tiles, searchTile, (searchTile, tile) => {\n            return searchTile.compare(tile);\n        });\n        const foundTile = this._tiles[idx];\n        if (foundTile?.compare(searchTile) === 0) {\n            return idx;\n        }\n        return -1;\n    }\n\n    sliceIterator(start, end) {\n        return this._tiles.slice(start, end)[Symbol.iterator]();\n    }\n}\n\nimport {ObservableArray} from \"../../../../observable/list/ObservableArray\";\nimport {UpdateAction} from \"./UpdateAction.js\";\n\nexport function tests() {\n    class TestTile {\n        constructor(entry) {\n            this.entry = entry;\n            this.update = null;\n        }\n        setUpdateEmit(update) {\n            this.update = update;\n        }\n        tryIncludeEntry() {\n            return false;\n        }\n        compareEntry(b) {\n            return this.entry.n - b.n;\n        }\n        removeEntry() {\n            return true;\n        }\n        get upperEntry() {\n            return this.entry;\n        }\n\n        get lowerEntry() {\n            return this.entry;\n        }\n        updateNextSibling() {}\n        updatePreviousSibling() {}\n        updateEntry() {\n            return UpdateAction.Nothing;\n        }\n\n        dispose() {}\n    }\n\n    return {\n        \"don't emit update before add\": assert => {\n            class UpdateOnSiblingTile extends TestTile {\n                updateNextSibling() {\n                    // this happens with isContinuation\n                    this.update && this.update(this, \"next\");\n                }\n                updatePreviousSibling() {\n                    // this happens with isContinuation\n                    this.update && this.update(this, \"previous\");\n                }\n            }\n            const entries = new ObservableArray([{n: 5}, {n: 10}]);\n            const tiles = new TilesCollection(entries, entry => new UpdateOnSiblingTile(entry));\n            let receivedAdd = false;\n            tiles.subscribe({\n                onAdd(idx, tile) {\n                    assert(tile.entry.n, 7);\n                    receivedAdd = true;\n                },\n                onUpdate(idx, tile) {\n                    if (tile.entry.n === 7) {\n                        assert(!receivedAdd, \"receiving update before add\");\n                    }\n                }\n            });\n            entries.insert(1, {n: 7});\n            assert(receivedAdd);\n        },\n        \"emit update with correct index in updatePreviousSibling during remove\": assert => {\n            class UpdateOnSiblingTile extends TestTile {\n                updatePreviousSibling() {\n                    this.update?.(this, \"previous\");\n                }\n            }\n            const entries = new ObservableArray([{n: 5}, {n: 10}, {n: 15}]);\n            const tiles = new TilesCollection(entries, entry => new UpdateOnSiblingTile(entry));\n            const events = [];\n            tiles.subscribe({\n                onUpdate(idx, tile) {\n                    assert.equal(idx, 1);\n                    assert.equal(tile.entry.n, 15);\n                    events.push(\"update\");\n                },\n                onRemove(idx, tile) {\n                    assert.equal(idx, 1);\n                    assert.equal(tile.entry.n, 10);\n                    events.push(\"remove\");\n                }\n            });\n            entries.remove(1);\n            assert.deepEqual(events, [\"remove\", \"update\"]);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\nneed better naming, but\nentry = event or gap from matrix layer\ntile = item on visual timeline like event, date separator?, group of joined events\n\n\nshall we put date separators as marker in EventViewItem or separate item? binary search will be complicated ...\n\n\npagination ...\n\non the timeline viewmodel (containing the TilesCollection?) we'll have a method to (un)load a tail or head of\nthe timeline (counted in tiles), which results to a range in sortKeys we want on the screen. We pass that range\nto the room timeline, which unload entries from memory.\nwhen loading, it just reads events from a sortkey backwards or forwards...\n*/\nimport {TilesCollection} from \"./TilesCollection.js\";\nimport {ViewModel} from \"../../../ViewModel.js\";\n\nexport class TimelineViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {timeline, tilesCreator} = options;\n        this._timeline = this.track(timeline);\n        this._tiles = new TilesCollection(timeline.entries, tilesCreator);\n        this._startTile = null;\n        this._endTile = null;\n        this._topLoadingPromise = null;\n        this._requestedStartTile = null;\n        this._requestedEndTile = null;\n        this._requestScheduled = false;\n        this._showJumpDown = false;\n    }\n\n    /** if this.tiles is empty, call this with undefined for both startTile and endTile */\n    setVisibleTileRange(startTile, endTile) {\n        // don't clear these once done as they are used to check\n        // for more tiles once loadAtTop finishes\n        this._requestedStartTile = startTile;\n        this._requestedEndTile = endTile;\n        if (!this._requestScheduled) {\n            Promise.resolve().then(() => {\n                this._setVisibleTileRange(this._requestedStartTile, this._requestedEndTile);\n                this._requestScheduled = false;\n            });\n            this._requestScheduled = true;\n        }\n    }\n\n    _setVisibleTileRange(startTile, endTile) {\n        let loadTop;\n        if (startTile && endTile) {\n            // old tiles could have been removed from tilescollection once we support unloading\n            this._startTile = startTile;\n            this._endTile = endTile;\n            const startIndex = this._tiles.getTileIndex(this._startTile);\n            const endIndex = this._tiles.getTileIndex(this._endTile);\n            for (const tile of this._tiles.sliceIterator(startIndex, endIndex + 1)) {\n                tile.notifyVisible();\n            }\n            loadTop = startIndex < 10;\n            this._setShowJumpDown(endIndex < (this._tiles.length - 1));\n        } else {\n            // tiles collection is empty, load more at top\n            loadTop = true;\n            this._setShowJumpDown(false);\n        }\n\n        if (loadTop && !this._topLoadingPromise) {\n            this._topLoadingPromise = this._timeline.loadAtTop(10).then(hasReachedEnd => {\n                this._topLoadingPromise = null;\n                if (!hasReachedEnd) {\n                    // check if more items need to be loaded by recursing\n                    // use the requested start / end tile,\n                    // so we don't end up overwriting a newly requested visible range here\n                    this.setVisibleTileRange(this._requestedStartTile, this._requestedEndTile);\n                }\n            });\n        }\n    }\n\n    get tiles() {\n        return this._tiles;\n    }\n\n    _setShowJumpDown(show) {\n        if (this._showJumpDown !== show) {\n            this._showJumpDown = show;\n            this.emitChange(\"showJumpDown\");\n        }\n    }\n\n    get showJumpDown() {\n        return this._showJumpDown;\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../../ViewModel.js\";\n\nexport class ComposerViewModel extends ViewModel {\n    constructor(roomVM) {\n        super();\n        this._roomVM = roomVM;\n        this._isEmpty = true;\n        this._replyVM = null;\n    }\n\n    setReplyingTo(entry) {\n        const changed = new Boolean(entry) !== new Boolean(this._replyVM) || !this._replyVM?.id.equals(entry.asEventKey());\n        if (changed) {\n            this._replyVM = this.disposeTracked(this._replyVM);\n            if (entry) {\n                this._replyVM = this.track(this._roomVM._createTile(entry));\n                this._replyVM.notifyVisible();\n            }\n            this.emitChange(\"replyViewModel\");\n            this.emit(\"focus\");\n        }\n    }\n\n    clearReplyingTo() {\n        this.setReplyingTo(null);\n    }\n\n    get replyViewModel() {\n        return this._replyVM;\n    }\n\n    get isEncrypted() {\n        return this._roomVM.isEncrypted;\n    }\n\n    async sendMessage(message) {\n        const success = await this._roomVM._sendMessage(message, this._replyVM);\n        if (success) {\n            this._isEmpty = true;\n            this.emitChange(\"canSend\");\n            this.clearReplyingTo();\n        }\n        return success;\n    }\n\n    sendPicture() {\n        this._roomVM._pickAndSendPicture();\n    }\n\n    sendFile() {\n        this._roomVM._pickAndSendFile();\n    }\n\n    sendVideo() {\n        this._roomVM._pickAndSendVideo();\n    }\n\n    get canSend() {\n        return !this._isEmpty;\n    }\n\n    async setInput(text) {\n        const wasEmpty = this._isEmpty;\n        this._isEmpty = text.length === 0;\n        if (wasEmpty && !this._isEmpty) {\n            this._roomVM._room.ensureMessageKeyIsShared();\n        }\n        if (wasEmpty !== this._isEmpty) {\n            this.emitChange(\"canSend\");\n        }\n    }\n\n    get kind() {\n        return \"composer\";\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {UpdateAction} from \"../UpdateAction.js\";\nimport {ViewModel} from \"../../../../ViewModel.js\";\nimport {SendStatus} from \"../../../../../matrix/room/sending/PendingEvent.js\";\n\nexport class SimpleTile extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._entry = options.entry;\n    }\n    // view model props for all subclasses\n    // hmmm, could also do instanceof ... ?\n    get shape() {\n        return null;\n        // \"gap\" | \"message\" | \"image\" | ... ?\n    }\n\n    // don't show display name / avatar\n    // probably only for BaseMessageTiles of some sort?\n    get isContinuation() {\n        return false;\n    }\n\n    get hasDateSeparator() {\n        return false;\n    }\n\n    get id() {\n        return this._entry.asEventKey();\n    }\n\n    get isPending() {\n        return this._entry.isPending;\n    }\n\n    get isUnsent() {\n        return this._entry.isPending && this._entry.pendingEvent.status !== SendStatus.Sent;\n    }\n\n    get canAbortSending() {\n        return this._entry.isPending &&\n            !this._entry.pendingEvent.hasStartedSending;\n    }\n\n    abortSending() {\n        this._entry.pendingEvent?.abort();\n    }\n\n    // TilesCollection contract below\n    setUpdateEmit(emitUpdate) {\n        this.updateOptions({emitChange: paramName => {\n            // it can happen that after some network call\n            // we switched away from the room and the response\n            // comes in, triggering an emitChange in a tile that\n            // has been disposed already (and hence the change\n            // callback has been cleared by dispose) We should just ignore this.\n            if (emitUpdate) {\n                emitUpdate(this, paramName);\n            }\n        }});\n    }\n\n    get upperEntry() {\n        return this._entry;\n    }\n\n    get lowerEntry() {\n        return this._entry;\n    }\n\n    compare(tile) {\n        return this.upperEntry.compare(tile.upperEntry);\n    }\n\n    compareEntry(entry) {\n        return this._entry.compare(entry);\n    }\n\n    // update received for already included (falls within sort keys) entry\n    updateEntry(entry, param) {\n        const renderedAsRedacted = this.shape === \"redacted\";\n        if (!entry.isGap && entry.isRedacted !== renderedAsRedacted) {\n            // recreate the tile if the entry becomes redacted\n            return UpdateAction.Replace(\"shape\");\n        } else {\n            this._entry = entry;\n            return UpdateAction.Update(param);\n        }\n    }\n\n    // return whether the tile should be removed\n    // as SimpleTile only has one entry, the tile should be removed\n    removeEntry(/*entry*/) {\n        return true;\n    }\n\n    // SimpleTile can only contain 1 entry\n    tryIncludeEntry() {\n        return false;\n    }\n    // let item know it has a new sibling\n    updatePreviousSibling(/*prev*/) {\n\n    }\n\n    // let item know it has a new sibling\n    updateNextSibling(/*next*/) {\n    \n    }\n\n    notifyVisible() {}\n\n    dispose() {\n        this.setUpdateEmit(null);\n        super.dispose();\n    }\n    // TilesCollection contract above\n\n    get _room() {\n        return this._roomVM.room;\n    }\n\n    get _roomVM() {\n        return this._options.roomVM;\n    }\n\n    get _timeline() {\n        return this._options.timeline;\n    }\n\n    get _powerLevels() {\n        return this._timeline.powerLevels;\n    }\n\n    get _ownMember() {\n        return this._options.timeline.me;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {SimpleTile} from \"./SimpleTile.js\";\nimport {UpdateAction} from \"../UpdateAction.js\";\n\nexport class GapTile extends SimpleTile {\n    constructor(options) {\n        super(options);\n        this._loading = false;\n        this._error = null;\n        this._isAtTop = true;\n        this._siblingChanged = false;\n    }\n\n    async fill() {\n        if (!this._loading && !this._entry.edgeReached) {\n            this._loading = true;\n            this.emitChange(\"isLoading\");\n            try {\n                await this._room.fillGap(this._entry, 10);\n            } catch (err) {\n                console.error(`room.fillGap(): ${err.message}:\\n${err.stack}`);\n                this._error = err;\n                this.emitChange(\"error\");\n                // rethrow so caller of this method\n                // knows not to keep calling this for now\n                throw err;\n            } finally {\n                this._loading = false;\n                this.emitChange(\"isLoading\");\n            }\n                return true;\n        }\n        return false;\n    }\n\n    async notifyVisible() {\n        // we do (up to 10) backfills while no new tiles have been added to the timeline\n        // because notifyVisible won't be called again until something gets added to the timeline\n        let depth = 0;\n        let canFillMore;\n        this._siblingChanged = false;\n        do {\n            canFillMore = await this.fill();\n            depth = depth + 1;\n        } while (depth < 10 && !this._siblingChanged && canFillMore && !this.isDisposed);\n    }\n\n    get isAtTop() {\n        return this._isAtTop;\n    }\n\n    updatePreviousSibling(prev) {\n        super.updatePreviousSibling(prev);\n        const isAtTop = !prev;\n        if (this._isAtTop !== isAtTop) {\n            this._isAtTop = isAtTop;\n            this.emitChange(\"isAtTop\");\n        }\n        this._siblingChanged = true;\n    }\n\n    updateNextSibling() {\n        // if the sibling of the gap changed while calling room.fill(),\n        // we intepret this as at least one new tile has been added to\n        // the timeline. See notifyVisible why this is important.\n        this._siblingChanged = true;\n    }\n\n    updateEntry(entry, params, tilesCreator) {\n        super.updateEntry(entry, params, tilesCreator);\n        if (!entry.isGap) {\n            return UpdateAction.Remove();\n        } else {\n            return UpdateAction.Nothing();\n        }\n    }\n\n    get shape() {\n        return \"gap\";\n    }\n\n    get isLoading() {\n        return this._loading;\n    }\n\n    get error() {\n        if (this._error) {\n            const dir = this._entry.prev_batch ? \"previous\" : \"next\";\n            return `Could not load ${dir} messages: ${this._error.message}`;\n        }\n        return null;\n    }\n}\n\nimport {FragmentBoundaryEntry} from \"../../../../../matrix/room/timeline/entries/FragmentBoundaryEntry.js\";\nexport function tests() {\n    return {\n        \"uses updated token to fill\": async assert => {\n            let currentToken = 5;\n            const fragment = {\n                id: 0,\n                previousToken: currentToken,\n                roomId: \"!abc\"\n            };\n            const room = {\n                async fillGap(entry) {\n                    assert.equal(entry.token, currentToken);\n                    currentToken += 1;\n                    const newEntry = entry.withUpdatedFragment(Object.assign({}, fragment, {previousToken: currentToken}));\n                    tile.updateEntry(newEntry);\n                }\n            };\n            const tile = new GapTile({entry: new FragmentBoundaryEntry(fragment, true), roomVM: {room}});\n            await tile.fill();\n            await tile.fill();\n            await tile.fill();\n            assert.equal(currentToken, 8);\n        }\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {ObservableMap} from \"../../../../observable/map/ObservableMap.js\";\n\nexport class ReactionsViewModel {\n    constructor(parentTile) {\n        this._parentTile = parentTile;\n        this._map = new ObservableMap();\n        this._reactions = this._map.sortValues((a, b) => a._compare(b));\n    }\n\n    /** @package */\n    update(annotations, pendingAnnotations) {\n        if (annotations) {\n            for (const key in annotations) {\n                if (annotations.hasOwnProperty(key)) {\n                    const annotation = annotations[key];\n                    const reaction = this._map.get(key);\n                    if (reaction) {\n                        if (reaction._tryUpdate(annotation)) {\n                            this._map.update(key);\n                        }\n                    } else {\n                        this._map.add(key, new ReactionViewModel(key, annotation, null, this._parentTile));\n                    }\n                }\n            }\n        }\n        if (pendingAnnotations) {\n            for (const [key, annotation] of pendingAnnotations.entries()) {\n                const reaction = this._map.get(key);\n                if (reaction) {\n                    reaction._tryUpdatePending(annotation);\n                    this._map.update(key);\n                } else {\n                    this._map.add(key, new ReactionViewModel(key, null, annotation, this._parentTile));\n                }\n            }\n        }\n        for (const existingKey of this._map.keys()) {\n            const hasPending = pendingAnnotations?.has(existingKey);\n            const hasRemote = annotations?.hasOwnProperty(existingKey);\n            if (!hasRemote && !hasPending) {\n                this._map.remove(existingKey);\n            } else if (!hasRemote) {\n                if (this._map.get(existingKey)._tryUpdate(null)) {\n                    this._map.update(existingKey);\n                }\n            } else if (!hasPending) {\n                if (this._map.get(existingKey)._tryUpdatePending(null)) {\n                    this._map.update(existingKey);\n                }\n            }\n        }\n    }\n\n    get reactions() {\n        return this._reactions;\n    }\n\n    getReaction(key) {\n        return this._map.get(key);\n    }\n}\n\nclass ReactionViewModel {\n    constructor(key, annotation, pending, parentTile) {\n        this._key = key;\n        this._annotation = annotation;\n        this._pending = pending;\n        this._parentTile = parentTile;\n        this._isToggling = false;\n    }\n\n    _tryUpdate(annotation) {\n        const oneSetAndOtherNot = !!this._annotation !== !!annotation;\n        const bothSet = this._annotation && annotation;\n        const areDifferent = bothSet &&  (\n            annotation.me !== this._annotation.me ||\n            annotation.count !== this._annotation.count ||\n            annotation.firstTimestamp !== this._annotation.firstTimestamp\n        );\n        if (oneSetAndOtherNot || areDifferent) {\n            this._annotation = annotation;\n            return true;\n        }\n        return false;\n    }\n\n    _tryUpdatePending(pending) {\n        if (!pending && !this._pending) {\n            return false;\n        }\n        this._pending = pending;\n        return true;\n    }\n\n    get key() {\n        return this._key;\n    }\n\n    get count() {\n        return (this._pending?.count || 0) + (this._annotation?.count || 0);\n    }\n\n    get isPending() {\n        return this._pending !== null;\n    }\n\n    /** @returns {boolean} true if the user has a (pending) reaction\n     *    already for this key, or they have a pending redaction for\n     *    the reaction, false if there is nothing pending and\n     *    the user has not reacted yet. */\n    get isActive() {\n        return this._annotation?.me || this.isPending;\n    }\n\n    get firstTimestamp() {\n        let ts = Number.MAX_SAFE_INTEGER;\n        if (this._annotation) {\n            ts = Math.min(ts, this._annotation.firstTimestamp);\n        }\n        if (this._pending) {\n            ts = Math.min(ts, this._pending.firstTimestamp);\n        }\n        return ts;\n    }\n\n    _compare(other) {\n        // the comparator is also used to test for equality by sortValues, if the comparison returns 0\n        // given that the firstTimestamp isn't set anymore when the last reaction is removed,\n        // the remove event wouldn't be able to find the correct index anymore. So special case equality.\n        if (other === this) {\n            return 0;\n        }\n        if (this.count !== other.count) {\n            return other.count - this.count;\n        } else {\n            const cmp = this.firstTimestamp - other.firstTimestamp;\n            if (cmp === 0) {\n                return this.key < other.key ? -1 : 1;\n            }\n            return cmp;\n        }\n    }\n\n    async toggle(log = null) {\n        if (this._isToggling) {\n            console.log(\"busy toggling reaction already\");\n            return;\n        }\n        this._isToggling = true;\n        try {\n            await this._parentTile.toggleReaction(this.key, log);\n        } finally {\n            this._isToggling = false;\n        }\n    }\n}\n\n// matrix classes uses in the integration test below\nimport {User} from \"../../../../matrix/User.js\";\nimport {SendQueue} from \"../../../../matrix/room/sending/SendQueue.js\";\nimport {Timeline} from \"../../../../matrix/room/timeline/Timeline.js\";\nimport {EventEntry} from \"../../../../matrix/room/timeline/entries/EventEntry.js\";\nimport {RelationWriter} from \"../../../../matrix/room/timeline/persistence/RelationWriter.js\";\nimport {FragmentIdComparer} from \"../../../../matrix/room/timeline/FragmentIdComparer.js\";\nimport {createAnnotation} from \"../../../../matrix/room/timeline/relations.js\";\n// mocks\nimport {Clock as MockClock} from \"../../../../mocks/Clock.js\";\nimport {createMockStorage} from \"../../../../mocks/Storage\";\nimport {ListObserver} from \"../../../../mocks/ListObserver.js\";\nimport {createEvent, withTextBody, withContent} from \"../../../../mocks/event.js\";\nimport {NullLogItem, NullLogger} from \"../../../../logging/NullLogger\";\nimport {HomeServer as MockHomeServer} from \"../../../../mocks/HomeServer.js\";\n// other imports\nimport {BaseMessageTile} from \"./tiles/BaseMessageTile.js\";\nimport {MappedList} from \"../../../../observable/list/MappedList\";\nimport {ObservableValue} from \"../../../../observable/ObservableValue\";\nimport {PowerLevels} from \"../../../../matrix/room/PowerLevels.js\";\n\nexport function tests() {\n    const fragmentIdComparer = new FragmentIdComparer([]);\n    const roomId = \"$abc\";\n    const alice = \"@alice:hs.tld\";\n    const bob = \"@bob:hs.tld\";\n    const logger = new NullLogger();\n\n    function findInIterarable(it, predicate) {\n        let i = 0;\n        for (const item of it) {\n            if (predicate(item, i)) {\n                return item;\n            }\n            i += 1;\n        }\n        throw new Error(\"not found\");\n    }\n\n    function mapMessageEntriesToBaseMessageTile(timeline, queue) {\n        const room = {\n            id: roomId,\n            sendEvent(eventType, content, attachments, log) {\n                return queue.enqueueEvent(eventType, content, attachments, log);\n            },\n            sendRedaction(eventIdOrTxnId, reason, log) {\n                return queue.enqueueRedaction(eventIdOrTxnId, reason, log);\n            }\n        };\n        const tiles = new MappedList(timeline.entries, entry => {\n            if (entry.eventType === \"m.room.message\") {\n                return new BaseMessageTile({entry, roomVM: {room}, timeline, platform: {logger}});\n            }\n            return null;\n        }, (tile, params, entry) => tile?.updateEntry(entry, params, function () {}));\n        return tiles;\n    }\n\n    return {\n        // these are more an integration test than unit tests,\n        // but fully test the local echo when toggling and\n        // the correct send queue modifications happen\n        \"toggling reaction with own remote reaction\": async assert => {\n            // 1. put message and reaction in storage\n            const messageEvent = withTextBody(\"Dogs > Cats\", createEvent(\"m.room.message\", \"!abc\", bob));\n            const myReactionEvent = withContent(createAnnotation(messageEvent.event_id, \"🐶\"), createEvent(\"m.reaction\", \"!def\", alice));\n            myReactionEvent.origin_server_ts = 5;\n            const myReactionEntry = new EventEntry({event: myReactionEvent, roomId}, fragmentIdComparer);\n            const relationWriter = new RelationWriter({roomId, ownUserId: alice, fragmentIdComparer});\n            const storage = await createMockStorage();\n            const txn = await storage.readWriteTxn([\n                storage.storeNames.timelineEvents,\n                storage.storeNames.timelineRelations,\n                storage.storeNames.timelineFragments\n            ]);\n            txn.timelineFragments.add({id: 1, roomId});\n            txn.timelineEvents.tryInsert({fragmentId: 1, eventIndex: 2, event: messageEvent, roomId}, new NullLogItem());\n            txn.timelineEvents.tryInsert({fragmentId: 1, eventIndex: 3, event: myReactionEvent, roomId}, new NullLogItem());\n            await relationWriter.writeRelation(myReactionEntry, txn, new NullLogItem());\n            await txn.complete();\n            // 2. setup queue & timeline\n            const queue = new SendQueue({roomId, storage, hsApi: new MockHomeServer().api});\n            const powerLevelsObservable = new ObservableValue(new PowerLevels({ ownUserId: alice, membership: \"join\" }));\n            const timeline = new Timeline({\n                roomId,\n                storage,\n                fragmentIdComparer,\n                clock: new MockClock(),\n                pendingEvents: queue.pendingEvents,\n                powerLevelsObservable\n            });\n            // 3. load the timeline, which will load the message with the reaction\n            await timeline.load(new User(alice), \"join\", new NullLogItem());\n            const tiles = mapMessageEntriesToBaseMessageTile(timeline, queue);\n            // 4. subscribe to the queue to observe, and the tiles (so we can safely iterate)\n            const queueObserver = new ListObserver();\n            queue.pendingEvents.subscribe(queueObserver);\n            tiles.subscribe(new ListObserver());\n            const messageTile = findInIterarable(tiles, e => !!e); // the other entries are mapped to null\n            const reactionVM = messageTile.reactions.getReaction(\"🐶\");\n            // 5. test toggling\n            // make sure the preexisting reaction is counted\n            assert.equal(reactionVM.count, 1);\n            // 5.1. unset reaction, should redact the pre-existing reaction\n            await reactionVM.toggle();\n            {\n                assert.equal(reactionVM.count, 0);\n                const {value: redaction, type} = await queueObserver.next();\n                assert.equal(\"add\", type);\n                assert.equal(redaction.eventType, \"m.room.redaction\");\n                assert.equal(redaction.relatedEventId, myReactionEntry.id);\n                // SendQueue puts redaction in sending status, as it is first in the queue\n                assert.equal(\"update\", (await queueObserver.next()).type);\n            }\n            // 5.2. set reaction, should send a new reaction as the redaction is already sending\n            await reactionVM.toggle();\n            let reactionIndex;\n            {\n                assert.equal(reactionVM.count, 1);\n                const {value: reaction, type, index} = await queueObserver.next();\n                assert.equal(\"add\", type);\n                assert.equal(reaction.eventType, \"m.reaction\");\n                assert.equal(reaction.relatedEventId, messageEvent.event_id);\n                reactionIndex = index;\n            }\n            // 5.3. unset reaction, should abort the previous pending reaction as it hasn't started sending yet\n            await reactionVM.toggle();\n            {\n                assert.equal(reactionVM.count, 0);\n                const {index, type} = await queueObserver.next();\n                assert.equal(\"remove\", type);\n                assert.equal(reactionIndex, index);\n            }\n        },\n        \"toggling reaction without own remote reaction\": async assert => {\n            // 1. put message in storage\n            const messageEvent = withTextBody(\"Dogs > Cats\", createEvent(\"m.room.message\", \"!abc\", bob));\n            const storage = await createMockStorage();\n\n            const txn = await storage.readWriteTxn([\n                storage.storeNames.timelineEvents,\n                storage.storeNames.timelineFragments\n            ]);\n            txn.timelineFragments.add({id: 1, roomId});\n            txn.timelineEvents.tryInsert({fragmentId: 1, eventIndex: 2, event: messageEvent, roomId}, new NullLogItem());\n            await txn.complete();\n            // 2. setup queue & timeline\n            const queue = new SendQueue({roomId, storage, hsApi: new MockHomeServer().api});\n            const powerLevelsObservable = new ObservableValue(new PowerLevels({ ownUserId: alice, membership: \"join\" }));\n            const timeline = new Timeline({roomId, storage, fragmentIdComparer,\n                clock: new MockClock(), pendingEvents: queue.pendingEvents, powerLevelsObservable});\n\n            // 3. load the timeline, which will load the message with the reaction\n            await timeline.load(new User(alice), \"join\", new NullLogItem());\n            const tiles = mapMessageEntriesToBaseMessageTile(timeline, queue);\n            // 4. subscribe to the queue to observe, and the tiles (so we can safely iterate)\n            const queueObserver = new ListObserver();\n            queue.pendingEvents.subscribe(queueObserver);\n            tiles.subscribe(new ListObserver());\n            const messageTile = findInIterarable(tiles, e => !!e); // the other entries are mapped to null\n            // 5. test toggling\n            assert.equal(messageTile.reactions, null);\n            // 5.1. set reaction, should send a new reaction as there is none yet\n            await messageTile.react(\"🐶\");\n            // now there should be a reactions view model\n            const reactionVM = messageTile.reactions.getReaction(\"🐶\");\n            let reactionTxnId;\n            {\n                assert.equal(reactionVM.count, 1);\n                const {value: reaction, type} = await queueObserver.next();\n                assert.equal(\"add\", type);\n                assert.equal(reaction.eventType, \"m.reaction\");\n                assert.equal(reaction.relatedEventId, messageEvent.event_id);\n                // SendQueue puts reaction in sending status, as it is first in the queue\n                assert.equal(\"update\", (await queueObserver.next()).type);\n                reactionTxnId = reaction.txnId;\n            }\n            // 5.2. unset reaction, should redact the previous pending reaction as it has started sending already\n            let redactionIndex;\n            await reactionVM.toggle();\n            {\n                assert.equal(reactionVM.count, 0);\n                const {value: redaction, type, index} = await queueObserver.next();\n                assert.equal(\"add\", type);\n                assert.equal(redaction.eventType, \"m.room.redaction\");\n                assert.equal(redaction.relatedTxnId, reactionTxnId);\n                redactionIndex = index;\n            }\n            // 5.3. set reaction, should abort the previous pending redaction as it hasn't started sending yet\n            await reactionVM.toggle();\n            {\n                assert.equal(reactionVM.count, 1);\n                const {index, type} = await queueObserver.next();\n                assert.equal(\"remove\", type);\n                assert.equal(redactionIndex, index);\n                redactionIndex = index;\n            }\n        },\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {SimpleTile} from \"./SimpleTile.js\";\nimport {ReactionsViewModel} from \"../ReactionsViewModel.js\";\nimport {getIdentifierColorNumber, avatarInitials, getAvatarHttpUrl} from \"../../../../avatar.js\";\n\nexport class BaseMessageTile extends SimpleTile {\n    constructor(options) {\n        super(options);\n        this._date = this._entry.timestamp ? new Date(this._entry.timestamp) : null;\n        this._isContinuation = false;\n        this._reactions = null;\n        this._replyTile = null;\n        if (this._entry.annotations || this._entry.pendingAnnotations) {\n            this._updateReactions();\n        }\n        this._updateReplyTileIfNeeded(options.tilesCreator, undefined);\n    }\n\n    notifyVisible() {\n        super.notifyVisible();\n        this._replyTile?.notifyVisible();\n    }\n\n\n    get _mediaRepository() {\n        return this._room.mediaRepository;\n    }\n\n    get permaLink() {\n        return `https://matrix.to/#/${encodeURIComponent(this._room.id)}/${encodeURIComponent(this._entry.id)}`;\n    }\n\n    get senderProfileLink() {\n        return `https://matrix.to/#/${encodeURIComponent(this.sender)}`;\n    }\n\n    get displayName() {\n        return this._entry.displayName || this.sender;\n    }\n\n    get sender() {\n        return this._entry.sender;\n    }\n\n    get memberPanelLink() {\n        return `${this.urlCreator.urlUntilSegment(\"room\")}/member/${this.sender}`;\n    }\n\n    // Avatar view model contract\n    get avatarColorNumber() {\n        return getIdentifierColorNumber(this._entry.sender);\n    }\n\n    avatarUrl(size) {\n        return getAvatarHttpUrl(this._entry.avatarUrl, size, this.platform, this._mediaRepository);\n    }\n\n    get avatarLetter() {\n        return avatarInitials(this.sender);\n    }\n\n    get avatarTitle() {\n        return this.displayName;\n    }\n\n    get date() {\n        return this._date && this._date.toLocaleDateString({}, {month: \"numeric\", day: \"numeric\"});\n    }\n\n    get time() {\n        return this._date && this._date.toLocaleTimeString({}, {hour: \"numeric\", minute: \"2-digit\"});\n    }\n\n    get isOwn() {\n        return this._entry.sender === this._ownMember.userId;\n    }\n\n    get isContinuation() {\n        return this._isContinuation;\n    }\n\n    get isUnverified() {\n        return this._entry.isUnverified;\n    }\n\n    get isReply() {\n        return this._entry.isReply;\n    }\n\n    _getContent() {\n        return this._entry.content;\n    }\n\n    updatePreviousSibling(prev) {\n        super.updatePreviousSibling(prev);\n        let isContinuation = false;\n        if (prev && prev instanceof BaseMessageTile && prev.sender === this.sender) {\n            // timestamp is null for pending events\n            const myTimestamp = this._entry.timestamp;\n            const otherTimestamp = prev._entry.timestamp;\n            // other message was sent less than 5min ago\n            isContinuation = (myTimestamp - otherTimestamp) < (5 * 60 * 1000);\n        }\n        if (isContinuation !== this._isContinuation) {\n            this._isContinuation = isContinuation;\n            this.emitChange(\"isContinuation\");\n        }\n    }\n\n    updateEntry(entry, param, tilesCreator) {\n        const action = super.updateEntry(entry, param, tilesCreator);\n        if (action.shouldUpdate) {\n            this._updateReactions();\n        }\n        this._updateReplyTileIfNeeded(tilesCreator, param);\n        return action;\n    }\n\n    _updateReplyTileIfNeeded(tilesCreator, param) {\n        const replyEntry = this._entry.contextEntry;\n        if (replyEntry) {\n            // this is an update to contextEntry used for replyPreview\n            const action = this._replyTile?.updateEntry(replyEntry, param, tilesCreator);\n            if (action?.shouldReplace || !this._replyTile) {\n                this.disposeTracked(this._replyTile);\n                this._replyTile = tilesCreator(replyEntry);\n            }\n            if(action?.shouldUpdate) {\n                this._replyTile?.emitChange();\n            }\n        }\n    }\n\n    startReply() {\n        this._roomVM.startReply(this._entry);\n    }\n\n    reply(msgtype, body, log = null) {\n        return this._room.sendEvent(\"m.room.message\", this._entry.reply(msgtype, body), null, log);\n    }\n\n    redact(reason, log) {\n        return this._room.sendRedaction(this._entry.id, reason, log);\n    }\n\n    get canRedact() {\n        return this._powerLevels.canRedactFromSender(this._entry.sender);\n    }\n\n    get reactions() {\n        if (this.shape !== \"redacted\") {\n            return this._reactions;\n        }\n        return null;\n    }\n\n    get canReact() {\n        return this._powerLevels.canSendType(\"m.reaction\");\n    }\n\n    react(key, log = null) {\n        return this.logger.wrapOrRun(log, \"react\", async log => {\n            if (!this.canReact) {\n                log.set(\"powerlevel_lacking\", true);\n                return;\n            }\n            if (this._entry.haveAnnotation(key)) {\n                log.set(\"already_reacted\", true);\n                return;\n            }\n            const redaction = this._entry.pendingAnnotations?.get(key)?.redactionEntry;\n            if (redaction && !redaction.pendingEvent.hasStartedSending) {\n                log.set(\"abort_redaction\", true);\n                await redaction.pendingEvent.abort();\n            } else {\n                await this._room.sendEvent(\"m.reaction\", this._entry.annotate(key), null, log);\n            }\n        });\n    }\n\n    redactReaction(key, log = null) {\n        return this.logger.wrapOrRun(log, \"redactReaction\", async log => {\n            if (!this._powerLevels.canRedactFromSender(this._ownMember.userId)) {\n                log.set(\"powerlevel_lacking\", true);\n                return;\n            }\n            if (!this._entry.haveAnnotation(key)) {\n                log.set(\"not_yet_reacted\", true);\n                return;\n            }\n            let entry = this._entry.pendingAnnotations?.get(key)?.annotationEntry;\n            if (!entry) {\n                entry = await this._timeline.getOwnAnnotationEntry(this._entry.id, key);\n            }\n            if (entry) {\n                await this._room.sendRedaction(entry.id, null, log);\n            } else {\n                log.set(\"no_reaction\", true);\n            }\n        });\n    }\n\n    toggleReaction(key, log = null) {\n        return this.logger.wrapOrRun(log, \"toggleReaction\", async log => {\n            if (this._entry.haveAnnotation(key)) {\n                await this.redactReaction(key, log);\n            } else {\n                await this.react(key, log);\n            }\n        });\n    }\n\n    _updateReactions() {\n        const {annotations, pendingAnnotations} = this._entry;\n        if (!annotations && !pendingAnnotations) {\n            if (this._reactions) {\n                this._reactions = null;\n            }\n        } else {\n            if (!this._reactions) {\n                this._reactions = new ReactionsViewModel(this);\n            }\n            this._reactions.update(annotations, pendingAnnotations);\n        }\n    }\n\n    get replyTile() {\n        if (!this._entry.contextEventId) {\n            return null;\n        }\n        return this._replyTile;\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\nThe regex is split into component strings;\nmeaning that any escapes (\\) must also\nbe escaped.\n*/\nconst scheme = \"(?:https|http|ftp):\\\\/\\\\/\";\nconst noSpaceNorPunctuation = \"[^\\\\s.,?!)]\";\nconst hostCharacter = \"[a-zA-Z0-9:.\\\\[\\\\]-]\";\n\n/*\nUsing non-consuming group here to combine two criteria for the last character.\nSee point 1 below.\n*/\nconst host = `${hostCharacter}*(?=${hostCharacter})${noSpaceNorPunctuation}`;\n\n/*\nUse sub groups so we accept just / or #; but if anything comes after it,\nit should not end with punctuation or space.\n*/\nconst pathOrFragment = `(?:[\\\\/#](?:[^\\\\s]*${noSpaceNorPunctuation})?)`;\n\n/*\nThings to keep in mind:\n1.  URL must not contain non-ascii characters in host but may contain\n    them in path or fragment components.\n    https://matrix.org/<smiley> - valid\n    https://matrix.org<smiley> - invalid\n2. Do not treat punctuation at the end as a part of the URL (.,?!)\n3. Path/fragment is optional.\n*/\nconst urlRegex = `${scheme}${host}${pathOrFragment}?`;\n\nexport const regex = new RegExp(urlRegex, \"gi\");\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { regex } from \"./regex.js\";\n\n/**\n * Splits text into links and non-links.\n * For each such separated token, callback is called\n * with the token and a boolean passed as argument.\n * The boolean indicates whether the token is a link or not.\n * @param {string} text Text to split\n * @param {function(string, boolean)} callback A function to call with split tokens\n */\nexport function linkify(text, callback) {\n    const matches = text.matchAll(regex);\n    let curr = 0;\n    for (let match of matches) {\n        const precedingText = text.slice(curr, match.index);\n        callback(precedingText, false);\n        callback(match[0], true);\n        const len = match[0].length;\n        curr = match.index + len;\n    }\n    const remainingText = text.slice(curr);\n    callback(remainingText, false);\n}\n\nexport function tests() {\n\n    class MockCallback {\n        mockCallback(text, isLink) {\n            if (!text.length) {\n                return;\n            }\n            if (!this.result) {\n                this.result = [];\n            }\n            const type = isLink ? \"link\" : \"text\";\n            this.result.push({ type: type, text: text });\n        }\n    }\n\n    function test(assert, input, output) {\n        const m = new MockCallback;\n        linkify(input, m.mockCallback.bind(m));\n        assert.deepEqual(output, m.result);\n    }\n\n    function testLink(assert, link, expectFail = false) {\n        const input = link;\n        const output = expectFail ? [{ type: \"text\", text: input }] :\n            [{ type: \"link\", text: input }];\n        test(assert, input, output);\n    }\n\n    return {\n        \"Link with host\": assert => {\n            testLink(assert, \"https://matrix.org\");\n        },\n\n        \"Link with host & path\": assert => {\n            testLink(assert, \"https://matrix.org/docs/develop\");\n        },\n\n        \"Link with host & fragment\": assert => {\n            testLink(assert, \"https://matrix.org#test\");\n        },\n\n        \"Link with host & query\": assert => {\n            testLink(assert, \"https://matrix.org/?foo=bar\");\n        },\n\n        \"Complex link\": assert => {\n            const link = \"https://www.foobar.com/url?sa=t&rct=j&q=&esrc=s&source\" +\n                \"=web&cd=&cad=rja&uact=8&ved=2ahUKEwjyu7DJ-LHwAhUQyzgGHc\" +\n                \"OKA70QFjAAegQIBBAD&url=https%3A%2F%2Fmatrix.org%2Fdocs%\" +\n                \"2Fprojects%2Fclient%2Felement%2F&usg=AOvVaw0xpENrPHv_R-\" +\n                \"ERkyacR2Bd\";\n            testLink(assert, link);\n        },\n\n        \"Localhost link\": assert => {\n            testLink(assert, \"http://localhost\");\n            testLink(assert, \"http://localhost:3000\");\n        },\n\n        \"IPV4 link\": assert => {\n            testLink(assert, \"https://192.0.0.1\");\n            testLink(assert, \"https://250.123.67.23:5924\");\n        },\n\n        \"IPV6 link\": assert => {\n            testLink(assert, \"http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]\");\n            testLink(assert, \"http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:7000\");\n        },\n\n        \"Missing scheme must not linkify\": assert => {\n            testLink(assert, \"matrix.org/foo/bar\", true);\n        },\n\n        \"Punctuation at end of link must not linkify\": assert => {\n            const link = \"https://foo.bar/?nenjil=lal810\";\n            const end = \".,? \";\n            for (const char of end) {\n                const out = [{ type: \"link\", text: link }, { type: \"text\", text: char }];\n                test(assert, link + char, out);\n            }\n        },\n\n        \"Link doesn't adopt closing parenthesis\": assert => {\n            const link = \"(https://matrix.org)\";\n            const out = [{ type: \"text\", text: \"(\" }, { type: \"link\", text: \"https://matrix.org\" }, { type: \"text\", text: \")\" }];\n            test(assert, link, out);\n        },\n\n        \"Unicode in hostname must not linkify\": assert => {\n            const link = \"https://foo.bar\\uD83D\\uDE03.com\";\n            const out = [{ type: \"link\", text: \"https://foo.bar\" },\n            { type: \"text\", text: \"\\uD83D\\uDE03.com\" }];\n            test(assert, link, out);\n        },\n\n        \"Link with unicode only after / must linkify\": assert => {\n            testLink(assert, \"https://foo.bar.com/\\uD83D\\uDE03\");\n        },\n\n        \"Link with unicode after fragment without path must linkify\": assert => {\n            testLink(assert, \"https://foo.bar.com#\\uD83D\\uDE03\");\n        },\n\n        \"Link ends with <\": assert => {\n            const link = \"https://matrix.org<\";\n            const out = [{ type: \"link\", text: \"https://matrix.org\" }, { type: \"text\", text: \"<\" }];\n            test(assert, link, out);\n        }\n    };\n}\n","import { linkify } from \"./linkify/linkify.js\";\nimport { getIdentifierColorNumber, avatarInitials } from \"../../../avatar.js\";\n\n/**\n * Parse text into parts such as newline, links and text.\n * @param {string} body A string to parse into parts\n * @returns {MessageBody} Parsed result\n */\nexport function parsePlainBody(body) {\n    const parts = [];\n    const lines = body.split(\"\\n\");\n\n    // create callback outside of loop\n    const linkifyCallback = (text, isLink) => {\n        if (isLink) {\n            parts.push(new LinkPart(text, [new TextPart(text)]));\n        } else {\n            parts.push(new TextPart(text));\n        }\n    };\n\n    for (let i = 0; i < lines.length; i += 1) {\n        const line = lines[i];\n        if (line.length) {\n            linkify(line, linkifyCallback);\n        }\n        const isLastLine = i >= (lines.length - 1);\n        if (!isLastLine) {\n            parts.push(new NewLinePart());\n        }\n    }\n\n    return new MessageBody(body, parts);\n}\n\nexport function stringAsBody(body) {\n    return new MessageBody(body, [new TextPart(body)]);\n}\n\nexport class HeaderBlock {\n    constructor(level, inlines) {\n        this.level = level;\n        this.inlines = inlines;\n    }\n\n    get type() { return \"header\"; }\n}\n\nexport class CodeBlock {\n    constructor(language, text) {\n        this.language = language;\n        this.text = text;\n    }\n\n    get type() { return \"codeblock\"; }\n}\n\nexport class ListBlock {\n    constructor(startOffset, items) {\n        this.items = items;\n        this.startOffset = startOffset;\n    }\n\n    get type() { return \"list\"; }\n}\n\nexport class TableBlock {\n    constructor(head, body) {\n        this.head = head;\n        this.body = body;\n    }\n\n    get type() { return \"table\"; }\n}\n\nexport class RulePart {\n    get type() { return \"rule\"; }\n}\n\nexport class NewLinePart {\n    get type() { return \"newline\"; }\n}\n\nexport class FormatPart {\n    constructor(format, children) {\n        this.format = format.toLowerCase();\n        this.children = children;\n    }\n\n    get type() { return \"format\"; }\n}\n\nexport class ImagePart {\n    constructor(src, width, height, alt, title) {\n        this.src = src;\n        this.width = width;\n        this.height = height;\n        this.alt = alt;\n        this.title = title;\n    }\n\n    get type() { return \"image\"; }\n}\n\nexport class PillPart {\n    constructor(id, href, children) {\n        this.id = id;\n        this.href = href;\n        this.children = children;\n    }\n\n    get type() { return \"pill\"; }\n\n    get avatarColorNumber() {\n        return getIdentifierColorNumber(this.id);\n    }\n\n    get avatarInitials() {\n        return avatarInitials(this.id);\n    }\n}\n\nexport class LinkPart {\n    constructor(url, inlines) {\n        this.url = url;\n        this.inlines = inlines;\n    }\n\n    get type() { return \"link\"; }\n}\n\nexport class TextPart {\n    constructor(text) {\n        this.text = text;\n    }\n\n    get type() { return \"text\"; }\n}\n\nfunction isBlockquote(part){\n    return part.type === \"format\" && part.format === \"blockquote\";\n}\n\nexport class MessageBody {\n    constructor(sourceString, parts) {\n        this.sourceString = sourceString;\n        this.parts = parts;\n    }\n\n    insertEmote(string) {\n        // We want to skip quotes introduced by replies when emoting.\n        // We assume that such quotes are not TextParts, because replies\n        // must have a formatted body.\n        let i = 0;\n        for (; i < this.parts.length && isBlockquote(this.parts[i]); i++);\n        this.parts.splice(i, 0, new TextPart(string));\n    }\n}\n\nexport function tests() {\n\n    function test(assert, input, output) {\n        assert.deepEqual(parsePlainBody(input), new MessageBody(input, output));\n    }\n\n    return {\n        // Tests for text\n        \"Text only\": assert => {\n            const input = \"This is a sentence\";\n            const output = [new TextPart(input)];\n            test(assert, input, output);\n        },\n\n        \"Text with newline\": assert => {\n            const input = \"This is a sentence.\\nThis is another sentence.\";\n            const output = [\n                new TextPart(\"This is a sentence.\"),\n                new NewLinePart(),\n                new TextPart(\"This is another sentence.\")\n            ];\n            test(assert, input, output);\n        },\n\n        \"Text with newline & trailing newline\": assert => {\n            const input = \"This is a sentence.\\nThis is another sentence.\\n\";\n            const output = [\n                new TextPart(\"This is a sentence.\"),\n                new NewLinePart(),\n                new TextPart(\"This is another sentence.\"),\n                new NewLinePart()\n            ];\n            test(assert, input, output);\n        }\n    };\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMessageTile} from \"./BaseMessageTile.js\";\nimport {stringAsBody} from \"../MessageBody.js\";\nimport {createEnum} from \"../../../../../utils/enum\";\n\nexport const BodyFormat = createEnum(\"Plain\", \"Html\");\n\nexport class BaseTextTile extends BaseMessageTile {\n    constructor(options) {\n        super(options);\n        this._messageBody = null;\n        this._format = null\n    }\n\n    get shape() {\n        return \"message\";\n    }\n\n    _parseBody(body) {\n        return stringAsBody(body);\n    }\n\n    _getBodyFormat() {\n        return BodyFormat.Plain;\n    }\n\n    get body() {\n        const body = this._getBody();\n        const format = this._getBodyFormat();\n        // body is a string, so we can check for difference by just\n        // doing an equality check\n        // Even if the body hasn't changed, but the format has, we need\n        // to re-fill our cache.\n        if (!this._messageBody || this._messageBody.sourceString !== body || this._format !== format) {\n            // body with markup is an array of parts,\n            // so we should not recreate it for the same body string,\n            // or else the equality check in the binding will always fail.\n            // So cache it here.\n            this._messageBody = this._parseBody(body, format);\n            this._format = format;\n        }\n        return this._messageBody;\n    }\n\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MessageBody, HeaderBlock, TableBlock, ListBlock, CodeBlock, PillPart, FormatPart, NewLinePart, RulePart, TextPart, LinkPart, ImagePart } from \"./MessageBody.js\"\nimport { linkify } from \"./linkify/linkify.js\";\n\n/* At the time of writing (Jul 1 2021), Matrix Spec recommends\n * allowing the following HTML tags:\n *     font, del, h1, h2, h3, h4, h5, h6, blockquote, p, a, ul, ol, sup, sub, li, b, i, u,\n *     strong, em, strike, code, hr, br, div, table, thead, tbody, tr, th, td, caption, pre, span, img\n */\n\n/**\n * Nodes that don't have any properties to them other than their tag.\n * While <a> has `href`, and <img> has `src`, these have... themselves.\n */\nconst basicInline = [\"EM\", \"STRONG\", \"CODE\", \"DEL\", \"SPAN\" ];\nconst basicBlock = [\"DIV\", \"BLOCKQUOTE\"];\nconst safeSchemas = [\"https\", \"http\", \"ftp\", \"mailto\", \"magnet\"].map(name => `${name}://`);\nconst baseUrl = 'https://matrix.to';\nconst linkPrefix = `${baseUrl}/#/`;\n\nclass Deserializer {\n    constructor(result, mediaRepository) {\n        this.result = result;\n        this.mediaRepository = mediaRepository;\n    }\n\n    parsePillLink(link) {\n        if (!link.startsWith(linkPrefix)) {\n            return null;\n        }\n        const contents = link.substring(linkPrefix.length);\n        if (contents[0] === '@') {\n            return contents;\n        }\n        return null;\n    }\n\n    parseLink(node, children) {\n        const href = this.result.getAttributeValue(node, \"href\");\n        const lcUrl = href?.toLowerCase();\n        // urls should be absolute and with a safe schema, as listed in the spec\n        if (!lcUrl || !safeSchemas.some(schema => lcUrl.startsWith(schema))) {\n            return new FormatPart(\"span\", children);\n        }\n        const pillId = this.parsePillLink(href);\n        if (pillId) {\n            return new PillPart(pillId, href, children);\n        }\n        return new LinkPart(href, children);\n    }\n\n    parseList(node) {\n        const result = this.result;\n        let start = null;\n        if (result.getNodeElementName(node) === \"OL\") {\n            // Will return 1 for, say, '1A', which may not be intended?\n            start = parseInt(result.getAttributeValue(node, \"start\")) || 1;\n        }\n        const items = [];\n        for (const child of result.getChildNodes(node)) {\n            if (result.getNodeElementName(child) !== \"LI\") {\n                continue;\n            }\n            const item = this.parseAnyNodes(result.getChildNodes(child));\n            items.push(item);\n        }\n        return new ListBlock(start, items);\n    }\n\n    _ensureElement(node, tag) {\n        return node &&\n            this.result.isElementNode(node) &&\n            this.result.getNodeElementName(node) === tag;\n    }\n\n    parseCodeBlock(node) {\n        const result = this.result;\n        let codeNode;\n        for (const child of result.getChildNodes(node)) {\n            codeNode = child;\n            break;\n        }\n        let language = null;\n        if (!this._ensureElement(codeNode, \"CODE\")) {\n            return new CodeBlock(language, this.result.getNodeText(node));\n        }\n        const cl = result.getAttributeValue(codeNode, \"class\") || \"\"\n        for (const clname of cl.split(\" \")) {\n            if (clname.startsWith(\"language-\") && !clname.startsWith(\"language-_\")) {\n                language = clname.substring(9) // \"language-\".length\n                break;\n            }\n        }\n        return new CodeBlock(language, this.result.getNodeText(codeNode));\n    }\n\n    parseImage(node) {\n        const result = this.result;\n        const src = result.getAttributeValue(node, \"src\") || \"\";\n        const url = this.mediaRepository.mxcUrl(src);\n        // We just ignore non-mxc `src` attributes.\n        if (!url) {\n            return null;\n        }\n        const width = parseInt(result.getAttributeValue(node, \"width\")) || null;\n        const height = parseInt(result.getAttributeValue(node, \"height\")) || null;\n        const alt = result.getAttributeValue(node, \"alt\");\n        const title = result.getAttributeValue(node, \"title\");\n        return new ImagePart(url, width, height, alt, title);\n    }\n\n    parseTableRow(row, tag) {\n        const cells = [];\n        for (const node of this.result.getChildNodes(row)) {\n            if(!this._ensureElement(node, tag)) {\n                continue;\n            }\n            const children = this.result.getChildNodes(node);\n            const inlines = this.parseInlineNodes(children);\n            cells.push(inlines);\n        }\n        return cells;\n    }\n\n    parseTableHead(head) {\n        let headRow = null;\n        for (const node of this.result.getChildNodes(head)) {\n            headRow = node;\n            break;\n        }\n        if (this._ensureElement(headRow, \"TR\")) {\n            return this.parseTableRow(headRow, \"TH\");\n        }\n        return null;\n    }\n\n    parseTableBody(body) {\n        const rows = [];\n        for (const node of this.result.getChildNodes(body)) {\n            if(!this._ensureElement(node, \"TR\")) {\n                continue;\n            }\n            rows.push(this.parseTableRow(node, \"TD\"));\n        }\n        return rows;\n    }\n\n    parseTable(node) {\n        // We are only assuming iterable, so convert to arrary for indexing.\n        const children = Array.from(this.result.getChildNodes(node));\n        let head, body;\n        if (this._ensureElement(children[0], \"THEAD\") && this._ensureElement(children[1], \"TBODY\")) {\n            head = this.parseTableHead(children[0]);\n            body = this.parseTableBody(children[1]);\n        } else if (this._ensureElement(children[0], \"TBODY\")) {\n            head = null;\n            body = this.parseTableBody(children[0]);\n        }\n        return new TableBlock(head, body);\n    }\n\n    /** Once a node is known to be an element,\n     * attempt to interpret it as an inline element.\n     *\n     * @returns the inline message part, or null if the element\n     *   is not inline or not allowed.\n     */\n    parseInlineElement(node) {\n        const result = this.result;\n        const tag = result.getNodeElementName(node);\n        const children = result.getChildNodes(node);\n        switch (tag) {\n            case \"A\": {\n                const inlines = this.parseInlineNodes(children);\n                return this.parseLink(node, inlines);\n            }\n            case \"BR\":\n                return new NewLinePart();\n            default: {\n                if (!basicInline.includes(tag)) {\n                    return null;\n                }\n                const inlines = this.parseInlineNodes(children);\n                return new FormatPart(tag, inlines);\n            }\n        }\n    }\n\n    /** Attempt to interpret a node as inline.\n     *\n     * @returns the inline message part, or null if the\n     *   element is not inline or not allowed.\n     */\n    parseInlineNode(node) {\n        if (this.result.isElementNode(node)) {\n            return this.parseInlineElement(node);\n        }\n        return null;\n    }\n\n    /** Once a node is known to be an element, attempt\n     * to interpret it as a block element.\n     *\n     * @returns the block message part, or null of the\n     *   element is not a block or not allowed.\n     */\n    parseBlockElement(node) {\n        const result = this.result;\n        const tag = result.getNodeElementName(node);\n        const children = result.getChildNodes(node);\n        switch (tag) {\n            case \"H1\":\n            case \"H2\":\n            case \"H3\":\n            case \"H4\":\n            case \"H5\":\n            case \"H6\": {\n                const inlines = this.parseInlineNodes(children);\n                return new HeaderBlock(parseInt(tag[1]), inlines)\n            }\n            case \"UL\":\n            case \"OL\":\n                return this.parseList(node);\n            case \"PRE\":\n                return this.parseCodeBlock(node);\n            case \"HR\":\n                return new RulePart();\n            case \"IMG\":\n                return this.parseImage(node);\n            case \"P\": {\n                const inlines = this.parseInlineNodes(children);\n                return new FormatPart(tag, inlines);\n            }\n            case \"TABLE\":\n                return this.parseTable(node);\n            default: {\n                if (!basicBlock.includes(tag)) {\n                    return null;\n                }\n                const blocks = this.parseAnyNodes(children);\n                return new FormatPart(tag, blocks);\n            }\n        }\n    }\n\n    /** Attempt to parse a node as a block.\n     *\n     * @return the block message part, or null if the node\n     *   is not a block element.\n     */\n    parseBlockNode(node) {\n        if (this.result.isElementNode(node)) {\n            return this.parseBlockElement(node);\n        }\n        return null;\n    }\n\n    _parseTextParts(node, into) {\n        if(!this.result.isTextNode(node)) {\n            return false;\n        }\n\n        // XXX pretty much identical to `MessageBody`'s.\n        const linkifyCallback = (text, isLink) => {\n            if (isLink) {\n                into.push(new LinkPart(text, [new TextPart(text)]));\n            } else {\n                into.push(new TextPart(text));\n            }\n        };\n        linkify(this.result.getNodeText(node), linkifyCallback);\n        return true;\n    }\n\n    _isAllowedNode(node) {\n        return !this._ensureElement(node, \"MX-REPLY\");\n    }\n\n    _parseInlineNodes(nodes, into) {\n        for (const htmlNode of nodes) {\n            if (this._parseTextParts(htmlNode, into)) {\n                // This was a text node, and we already\n                // dumped its parts into our list.\n                continue;\n            }\n            const node = this.parseInlineNode(htmlNode);\n            if (node) {\n                into.push(node);\n                continue;\n            }\n            // Node is either block or unrecognized. In\n            // both cases, just move on to its children.\n            if (this._isAllowedNode(htmlNode)) {\n                this._parseInlineNodes(this.result.getChildNodes(htmlNode), into);\n            }\n        }\n    }\n\n    parseInlineNodes(nodes) {\n        const into = [];\n        this._parseInlineNodes(nodes, into);\n        return into;\n    }\n\n    // XXX very similar to `_parseInlineNodes`.\n    _parseAnyNodes(nodes, into) {\n        for (const htmlNode of nodes) {\n            if (this._parseTextParts(htmlNode, into)) {\n                // This was a text node, and we already\n                // dumped its parts into our list.\n                continue;\n            }\n            const node = this.parseInlineNode(htmlNode) || this.parseBlockNode(htmlNode);\n            if (node) {\n                into.push(node);\n                continue;\n            }\n            // Node is unrecognized. Just move on to its children.\n            if (this._isAllowedNode(htmlNode)) {\n                this._parseAnyNodes(this.result.getChildNodes(htmlNode), into);\n            }\n        }\n    }\n\n    parseAnyNodes(nodes) {\n        const into = [];\n        this._parseAnyNodes(nodes, into);\n        return into;\n    }\n}\n\nexport function parseHTMLBody(platform, mediaRepository, html) {\n    const parseResult = platform.parseHTML(html);\n    const deserializer = new Deserializer(parseResult, mediaRepository);\n    const parts = deserializer.parseAnyNodes(parseResult.rootNodes);\n    return new MessageBody(html, parts);\n}\n\n\nexport async function tests() {\n    // don't import node-html-parser until it's safe to assume we're actually in a unit test,\n    // as this is a devDependency\n    const nodeHtmlParser = await import(\"node-html-parser\");\n    const {parse} = nodeHtmlParser.default;\n\n    class HTMLParseResult {\n        constructor(bodyNode) {\n            this._bodyNode = bodyNode;\n        }\n\n        get rootNodes() {\n            return this._bodyNode.childNodes;\n        }\n\n        getChildNodes(node) {\n            return node.childNodes;\n        }\n\n        getAttributeNames(node) {\n            return node.getAttributeNames();\n        }\n\n        getAttributeValue(node, attr) {\n            return node.getAttribute(attr);\n        }\n\n        isTextNode(node) {\n            return !node.tagName;\n        }\n\n        getNodeText(node) {\n            return node.text;\n        }\n\n        isElementNode(node) {\n            return !!node.tagName;\n        }\n\n        getNodeElementName(node) {\n            return node.tagName;\n        }\n    }\n\n    const platform = {\n        parseHTML: (html) => new HTMLParseResult(parse(html))\n    };\n\n    function test(assert, input, output) {\n        assert.deepEqual(parseHTMLBody(platform, null, input), new MessageBody(input, output));\n    }\n\n    return {\n        \"Text only\": assert => {\n            const input = \"This is a sentence\";\n            const output = [new TextPart(input)];\n            test(assert, input, output);\n        },\n        \"Text with inline code format\": assert => {\n            const input = \"Here's <em>some</em> <code>code</code>!\";\n            const output = [\n                new TextPart(\"Here's \"),\n                new FormatPart(\"em\", [new TextPart(\"some\")]),\n                new TextPart(\" \"),\n                new FormatPart(\"code\", [new TextPart(\"code\")]),\n                new TextPart(\"!\")\n            ];\n            test(assert, input, output);\n        },\n        \"Text with ordered list with no attributes\": assert => {\n            const input = \"<ol><li>Lorem</li><li>Ipsum</li></ol>\";\n            const output = [\n                new ListBlock(1, [\n                    [ new TextPart(\"Lorem\") ],\n                    [ new TextPart(\"Ipsum\") ]\n                ])\n            ];\n            test(assert, input, output);\n        },\n        \"Text with ordered list starting at 3\": assert => {\n            const input = '<ol start=\"3\"><li>Lorem</li><li>Ipsum</li></ol>';\n            const output = [\n                new ListBlock(3, [\n                    [ new TextPart(\"Lorem\") ],\n                    [ new TextPart(\"Ipsum\") ]\n                ])\n            ];\n            test(assert, input, output);\n        },\n        \"Text with unordered list\": assert => {\n            const input = '<ul start=\"3\"><li>Lorem</li><li>Ipsum</li></ul>';\n            const output = [\n                new ListBlock(null, [\n                    [ new TextPart(\"Lorem\") ],\n                    [ new TextPart(\"Ipsum\") ]\n                ])\n            ];\n            test(assert, input, output);\n        },\n        \"Auto-closed tags\": assert => {\n            const input = '<p>hello<p>world</p></p>';\n            const output = [\n                new FormatPart(\"p\", [new TextPart(\"hello\")]),\n                new FormatPart(\"p\", [new TextPart(\"world\")])\n            ];\n            test(assert, input, output);\n        },\n        \"Block elements ignored inside inline elements\": assert => {\n            const input = '<span><p><code>Hello</code></p></span>';\n            const output = [\n                new FormatPart(\"span\", [new FormatPart(\"code\", [new TextPart(\"Hello\")])])\n            ];\n            test(assert, input, output);\n        },\n        \"Unknown tags are ignored, but their children are kept\": assert => {\n            const input = '<span><dfn><code>Hello</code></dfn><footer><em>World</em></footer></span>';\n            const output = [\n                new FormatPart(\"span\", [\n                    new FormatPart(\"code\", [new TextPart(\"Hello\")]),\n                    new FormatPart(\"em\", [new TextPart(\"World\")])\n                ])\n            ];\n            test(assert, input, output);\n        },\n        \"Unknown and invalid attributes are stripped\": assert => {\n            const input = '<em onmouseover=alert(\"Bad code!\")>Hello</em>';\n            const output = [\n                new FormatPart(\"em\", [new TextPart(\"Hello\")])\n            ];\n            test(assert, input, output);\n        },\n        \"Text with code block but no <code> tag\": assert => {\n            const code = 'main :: IO ()\\nmain = putStrLn \"Hello\"'\n            const input = `<pre>${code}</pre>`;\n            const output = [\n                new CodeBlock(null, code)\n            ];\n            test(assert, input, output);\n        },\n        \"Text with code block and 'unsupported' tag\": assert => {\n            const code = '<em>Hello, world</em>'\n            const input = `<pre>${code}</pre>`;\n            const output = [\n                new CodeBlock(null, code)\n            ];\n            test(assert, input, output);\n        },\n        \"Reply fallback is always stripped\": assert => {\n            const input = 'Hello, <em><mx-reply>World</mx-reply></em>!';\n            const output = [\n                new TextPart('Hello, '),\n                new FormatPart(\"em\", []),\n                new TextPart('!'),\n            ];\n            assert.deepEqual(parseHTMLBody(platform, null, input), new MessageBody(input, output));\n        }\n        /* Doesnt work: HTML library doesn't handle <pre><code> properly.\n        \"Text with code block\": assert => {\n            const code = 'main :: IO ()\\nmain = putStrLn \"Hello\"'\n            const input = `<pre><code>${code}</code></pre>`;\n            const output = [\n                new CodeBlock(null, code)\n            ];\n            test(assert, input, output);\n        }\n        */\n    };\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseTextTile, BodyFormat} from \"./BaseTextTile.js\";\nimport {parsePlainBody} from \"../MessageBody.js\";\nimport {parseHTMLBody} from \"../deserialize.js\";\n\nexport class TextTile extends BaseTextTile {\n    _getContentString(key) {\n        return this._getContent()?.[key] || \"\";\n    }\n\n    _getPlainBody() {\n        return this._getContentString(\"body\");\n    }\n\n    _getFormattedBody() {\n        return this._getContentString(\"formatted_body\");\n    }\n\n    _getBody() {\n        if (this._getBodyFormat() === BodyFormat.Html) {\n            return this._getFormattedBody();\n        } else {\n            return this._getPlainBody();\n        }\n    }\n\n    _getBodyFormat() {\n        if (this._getContent()?.format === \"org.matrix.custom.html\") {\n            return BodyFormat.Html;\n        } else {\n            return BodyFormat.Plain;\n        }\n    }\n\n    _parseBody(body, format) {\n        let messageBody;\n        if (format === BodyFormat.Html) {\n            messageBody = parseHTMLBody(this.platform, this._mediaRepository, body);\n        } else {\n            messageBody = parsePlainBody(body);\n        }\n        if (this._getContent()?.msgtype === \"m.emote\") {\n            messageBody.insertEmote(`* ${this.displayName} `);\n        }\n        return messageBody;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMessageTile} from \"./BaseMessageTile.js\";\n\nexport class RedactedTile extends BaseMessageTile {\n    get shape() {\n        return \"redacted\";\n    }\n\n    get description() {\n        const {redactionReason} = this._entry;\n        if (this.isRedacting) {\n            if (redactionReason) {\n                return this.i18n`This message is being deleted (${redactionReason})…`;\n            } else {\n                return this.i18n`This message is being deleted…`;\n            }\n        } else {\n            if (redactionReason) {\n                return this.i18n`This message has been deleted (${redactionReason}).`;\n            } else {\n                return this.i18n`This message has been deleted.`;\n            }\n        }\n    }\n\n    get isRedacting() {\n        return this._entry.isRedacting;\n    }\n    \n    /** override parent property to disable redacting, even if still pending */\n    get canRedact() {\n        return false;\n    }\n\n    abortPendingRedaction() {\n        return this._entry.abortPendingRedaction();\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMessageTile} from \"./BaseMessageTile.js\";\nimport {SendStatus} from \"../../../../../matrix/room/sending/PendingEvent.js\";\nconst MAX_HEIGHT = 300;\nconst MAX_WIDTH = 400;\n\nexport class BaseMediaTile extends BaseMessageTile {\n    constructor(options) {\n        super(options);\n        this._decryptedThumbnail = null;\n        this._decryptedFile = null;\n        this._isVisible = false;\n        this._error = null;\n    }\n\n    get isUploading() {\n        return this.isPending && this._entry.pendingEvent.status === SendStatus.UploadingAttachments;\n    }\n\n    get uploadPercentage() {\n        const {pendingEvent} = this._entry;\n        return pendingEvent && Math.round((pendingEvent.attachmentsSentBytes / pendingEvent.attachmentsTotalBytes) * 100);\n    }\n\n    get sendStatus() {\n        const {pendingEvent} = this._entry;\n        switch (pendingEvent?.status) {\n            case SendStatus.Waiting:\n                return this.i18n`Waiting…`;\n            case SendStatus.EncryptingAttachments:\n            case SendStatus.Encrypting:\n                return this.i18n`Encrypting…`;\n            case SendStatus.UploadingAttachments:\n                return this.i18n`Uploading…`;\n            case SendStatus.Sending:\n                return this.i18n`Sending…`;\n            case SendStatus.Error:\n                return this.i18n`Error: ${pendingEvent.error.message}`;\n            default:\n                return \"\";\n        }\n    }\n\n    get thumbnailUrl() {\n        if (!this._isVisible) {\n            return \"\";\n        }\n        if (this._decryptedThumbnail) {\n            return this._decryptedThumbnail.url;\n        } else {\n            const thumbnailMxc = this._getContent().info?.thumbnail_url;\n            if (thumbnailMxc) {\n                return this._mediaRepository.mxcUrlThumbnail(thumbnailMxc, this.width, this.height, \"scale\");\n            }\n        }\n        if (this._entry.isPending) {\n            const attachment = this._entry.pendingEvent.getAttachment(\"info.thumbnail_url\");\n            return attachment && attachment.localPreview.url;\n        }\n        if (this._isMainResourceImage()) {\n            if (this._decryptedFile) {\n                return this._decryptedFile.url;\n            } else {\n                const mxcUrl = this._getContent()?.url;\n                if (typeof mxcUrl === \"string\") {\n                    return this._mediaRepository.mxcUrlThumbnail(mxcUrl, this.width, this.height, \"scale\");\n                }\n            }\n        }\n        return \"\";\n    }\n\n    notifyVisible() {\n        super.notifyVisible();\n        this._isVisible = true;\n        this.emitChange(\"thumbnailUrl\");\n        if (!this.isPending) {\n            this._tryLoadEncryptedThumbnail();\n        }\n    }\n\n    get width() {\n        const info = this._getContent()?.info;\n        return Math.round(info?.w * this._scaleFactor());\n    }\n\n    get height() {\n        const info = this._getContent()?.info;\n        return Math.round(info?.h * this._scaleFactor());\n    }\n\n    get mimeType() {\n        const info = this._getContent()?.info;\n        return info?.mimetype;\n    }\n\n    get label() {\n        return this._getContent().body;\n    }\n\n    get error() {\n        if (this._error) {\n            return `Could not load media: ${this._error.message}`;\n        }\n        return null;\n    }\n\n    setViewError(err) {\n        this._error = err;\n        this.emitChange(\"error\");\n    }\n\n    async _loadEncryptedFile(file) {\n        const blob = await this._mediaRepository.downloadEncryptedFile(file, true);\n        if (this.isDisposed) {\n            blob.dispose();\n            return;\n        }\n        return this.track(blob);\n    }\n\n    async _tryLoadEncryptedThumbnail() {\n        try {\n            const thumbnailFile = this._getContent().info?.thumbnail_file;\n            const file = this._getContent().file;\n            if (thumbnailFile) {\n                this._decryptedThumbnail = await this._loadEncryptedFile(thumbnailFile);\n                this.emitChange(\"thumbnailUrl\");\n            } else if (file && this._isMainResourceImage()) { // is the main resource an image? then try that for a thumbnail\n                this._decryptedFile = await this._loadEncryptedFile(file);\n                this.emitChange(\"thumbnailUrl\");\n            }\n        } catch (err) {\n            this._error = err;\n            this.emitChange(\"error\");\n        }\n    }\n\n    _scaleFactor() {\n        const info = this._getContent()?.info;\n        const scaleHeightFactor = MAX_HEIGHT / info?.h;\n        const scaleWidthFactor = MAX_WIDTH / info?.w;\n        // take the smallest scale factor, to respect all constraints\n        // we should not upscale images, so limit scale factor to 1 upwards\n        return Math.min(scaleWidthFactor, scaleHeightFactor, 1);\n    }\n\n    _isMainResourceImage() {\n        return true; // overwritten in VideoTile\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMediaTile} from \"./BaseMediaTile.js\";\n\nexport class ImageTile extends BaseMediaTile {\n    constructor(options) {\n        super(options);\n        this._lightboxUrl = this.urlCreator.urlForSegments([\n            // ensure the right room is active if in grid view\n            this.navigation.segment(\"room\", this._room.id),\n            this.navigation.segment(\"lightbox\", this._entry.id)\n        ]);\n    }\n\n    get lightboxUrl() {\n        if (!this.isPending) {\n            return this._lightboxUrl;\n        }\n        return \"\";\n    }\n\n    get shape() {\n        return \"image\";\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMediaTile} from \"./BaseMediaTile.js\";\n\nexport class VideoTile extends BaseMediaTile {\n    async loadVideo() {\n        const file = this._getContent().file;\n        if (file && !this._decryptedFile) {\n            this._decryptedFile = await this._loadEncryptedFile(file);\n            this.emitChange(\"videoUrl\");\n        }\n    }\n\n    get videoUrl() {\n        if (this._decryptedFile) {\n            return this._decryptedFile.url;\n        }\n        const mxcUrl = this._getContent()?.url;\n        if (typeof mxcUrl === \"string\") {\n            return this._mediaRepository.mxcUrl(mxcUrl);\n        }\n        return \"\";\n    }\n\n    get shape() {\n        return \"video\";\n    }\n\n    _isMainResourceImage() {\n        return false;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\nexport function formatSize(size: number, decimals: number = 2): string {\n    if (Number.isSafeInteger(size)) {\n        const base = Math.min(3, Math.floor(Math.log(size) / Math.log(1024)));\n        const formattedSize = Math.round(size / Math.pow(1024, base)).toFixed(decimals);\n        switch (base) {\n            case 0: return `${formattedSize} bytes`;\n            case 1: return `${formattedSize} KB`;\n            case 2: return `${formattedSize} MB`;\n            case 3: return `${formattedSize} GB`;\n        }\n    }\n    return \"\";\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMessageTile} from \"./BaseMessageTile.js\";\nimport {formatSize} from \"../../../../../utils/formatSize\";\nimport {SendStatus} from \"../../../../../matrix/room/sending/PendingEvent.js\";\n\nexport class FileTile extends BaseMessageTile {\n    constructor(options) {\n        super(options);\n        this._downloadError = null;\n        this._downloading = false;\n    }\n\n    async download() {\n        if (this._downloading || this.isPending) {\n            return;\n        }\n        const content = this._getContent();\n        const filename = content.body;\n        this._downloading = true;\n        this.emitChange(\"label\");\n        let blob;\n        try {\n            blob = await this._mediaRepository.downloadAttachment(content);\n            this.platform.saveFileAs(blob, filename);\n        } catch (err) {\n            this._downloadError = err;\n        } finally {\n            blob?.dispose();\n            this._downloading = false;\n        }\n        this.emitChange(\"label\");\n    }\n\n    get label() {\n        if (this._downloadError) {\n            return `Could not download file: ${this._downloadError.message}`;\n        }\n        const content = this._getContent();\n        const filename = content.body;\n\n        if (this._entry.isPending) {\n            const {pendingEvent} = this._entry;\n            switch (pendingEvent?.status) {\n                case SendStatus.Waiting:\n                    return this.i18n`Waiting to send ${filename}…`;\n                case SendStatus.EncryptingAttachments:\n                case SendStatus.Encrypting:\n                    return this.i18n`Encrypting ${filename}…`;\n                case SendStatus.UploadingAttachments:{\n                    const percent = Math.round((pendingEvent.attachmentsSentBytes / pendingEvent.attachmentsTotalBytes) * 100);\n                    return this.i18n`Uploading ${filename}: ${percent}%`;\n                }\n                case SendStatus.Sending:\n                case SendStatus.Sent:\n                    return this.i18n`Sending ${filename}…`;\n                case SendStatus.Error:\n                    return this.i18n`Error: could not send ${filename}: ${pendingEvent.error.message}`;\n                default:\n                    return `Unknown send status for ${filename}`;\n            }\n        } else {\n            const size = formatSize(this._getContent().info?.size);\n            if (this._downloading) {\n                return this.i18n`Downloading ${filename} (${size})…`;\n            } else {\n                return this.i18n`Download ${filename} (${size})`;\n            }   \n        }\n    }\n\n    get shape() {\n        return \"file\";\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMessageTile} from \"./BaseMessageTile.js\";\n\nexport class LocationTile extends BaseMessageTile {\n    get shape() {\n        return \"location\";\n    }\n\n    get mapsLink() {\n        try {\n            const url = new URL(this._getContent().geo_uri);\n            if (url.protocol !== \"geo:\") {\n                return \"\";\n            }\n            const [locationStr, ...namedParams] = url.pathname.split(\";\");\n            const [latStr, longStr] = locationStr.split(\",\");\n            const lat = parseFloat(latStr);\n            const long = parseFloat(longStr);\n            let uncertainty;\n            for (const namedParam of namedParams) {\n                const [name, value] = namedParam.split(\"=\");\n                if (name === \"u\") {\n                    uncertainty = parseFloat(value);\n                }\n            }\n            if (this.platform.isIOS) {\n                return `http://maps.apple.com/?ll=${lat},${long}`;\n            } else {\n                let uri = `geo:${lat},${long}`;\n                if (uncertainty) {\n                    uri = uri + `;u=${uncertainty}`;\n                }\n                return uri;\n            }\n        } catch {\n            return \"\";\n        }\n    }\n\n    get label() {\n        return this.i18n`${this.displayName} sent their location`;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {SimpleTile} from \"./SimpleTile.js\";\n\nexport class RoomNameTile extends SimpleTile {\n    \n    get shape() {\n        return \"announcement\";\n    }\n\n    get announcement() {\n        const content = this._entry.content;\n        return `${this._entry.displayName || this._entry.sender} named the room \"${content?.name}\"`\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {SimpleTile} from \"./SimpleTile.js\";\n\nexport class RoomMemberTile extends SimpleTile {\n\n    get shape() {\n        return \"announcement\";\n    }\n\n    get announcement() {\n        const {sender, content, prevContent, stateKey} = this._entry;\n        const senderName =  this._entry.displayName || sender;\n        const targetName = sender === stateKey ? senderName : (this._entry.content?.displayname || stateKey);\n        const membership = content && content.membership;\n        const prevMembership = prevContent && prevContent.membership;\n\n        if (prevMembership === \"join\" && membership === \"join\") {\n            if (content.avatar_url !== prevContent.avatar_url) {\n                return `${senderName} changed their avatar`; \n            } else if (content.displayname !== prevContent.displayname) {\n                if (!content.displayname) {\n                    return `${stateKey} removed their name (${prevContent.displayname})`;\n                }\n                return `${prevContent.displayname ?? stateKey} changed their name to ${content.displayname}`; \n            }\n        } else if (membership === \"join\") {\n            return `${targetName} joined the room`;\n        } else if (membership === \"invite\") {\n            return `${targetName} was invited to the room by ${senderName}`;\n        } else if (prevMembership === \"invite\") {\n            if (membership === \"join\") {\n                return `${targetName} accepted the invitation to join the room`;\n            } else if (membership === \"leave\") {\n                return `${targetName} declined the invitation to join the room`;\n            }\n        } else if (membership === \"leave\") {\n            if (stateKey === sender) {\n                return `${targetName} left the room`;\n            } else {\n                const reason = content.reason;\n                return `${targetName} was kicked from the room by ${senderName}${reason ? `: ${reason}` : \"\"}`;\n            }\n        } else if (membership === \"ban\") {\n            return `${targetName} was banned from the room by ${senderName}`;\n        }\n        \n        return `${sender} membership changed to ${content.membership}`;\n    }\n}\n\nexport function tests() {\n    return {\n        \"user removes display name\": (assert) => {\n            const tile = new RoomMemberTile({\n                entry: {\n                    prevContent: {displayname: \"foo\", membership: \"join\"},\n                    content: {membership: \"join\"},\n                    stateKey: \"foo@bar.com\",\n                },\n            });\n            assert.strictEqual(tile.announcement, \"foo@bar.com removed their name (foo)\");\n        },\n        \"user without display name sets a new display name\": (assert) => {\n            const tile = new RoomMemberTile({\n                entry: {\n                    prevContent: {membership: \"join\"},\n                    content: {displayname: \"foo\", membership: \"join\" },\n                    stateKey: \"foo@bar.com\",\n                },\n            });\n            assert.strictEqual(tile.announcement, \"foo@bar.com changed their name to foo\");\n        },\n    };\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseTextTile} from \"./BaseTextTile.js\";\nimport {UpdateAction} from \"../UpdateAction.js\";\n\nexport class EncryptedEventTile extends BaseTextTile {\n    updateEntry(entry, params, tilesCreator) {\n        const parentResult = super.updateEntry(entry, params, tilesCreator);\n        // event got decrypted, recreate the tile and replace this one with it\n        if (entry.eventType !== \"m.room.encrypted\") {\n            // the \"shape\" parameter trigger tile recreation in TimelineView\n            return UpdateAction.Replace(\"shape\");\n        } else {\n            return parentResult;\n        }\n    }\n\n    get shape() {\n        return \"message-status\"\n    }\n\n    _getBody() {\n        const decryptionError = this._entry.decryptionError;\n        const code = decryptionError?.code;\n        let string;\n        if (code === \"MEGOLM_NO_SESSION\") {\n            string = this.i18n`The sender hasn't sent us the key for this message yet.`;\n        } else {\n            string = decryptionError?.message || this.i18n`Could not decrypt message because of unknown reason.`;\n        }\n        return string;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {SimpleTile} from \"./SimpleTile.js\";\n\nexport class EncryptionEnabledTile extends SimpleTile {\n    get shape() {\n        return \"announcement\";\n    }\n\n    get announcement() {\n        const senderName =  this._entry.displayName || this._entry.sender;\n        return this.i18n`${senderName} has enabled end-to-end encryption`;\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMessageTile} from \"./BaseMessageTile.js\";\n\nexport class MissingAttachmentTile extends BaseMessageTile {\n    get shape() {\n        return \"missing-attachment\"\n    }\n\n    get label() {\n        const name = this._getContent().body;\n        const msgtype = this._getContent().msgtype;\n        if (msgtype === \"m.image\") {\n            return this.i18n`The image ${name} wasn't fully sent previously and could not be recovered.`;\n        } else {\n            return this.i18n`The file ${name} wasn't fully sent previously and could not be recovered.`;\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {GapTile} from \"./tiles/GapTile.js\";\nimport {TextTile} from \"./tiles/TextTile.js\";\nimport {RedactedTile} from \"./tiles/RedactedTile.js\";\nimport {ImageTile} from \"./tiles/ImageTile.js\";\nimport {VideoTile} from \"./tiles/VideoTile.js\";\nimport {FileTile} from \"./tiles/FileTile.js\";\nimport {LocationTile} from \"./tiles/LocationTile.js\";\nimport {RoomNameTile} from \"./tiles/RoomNameTile.js\";\nimport {RoomMemberTile} from \"./tiles/RoomMemberTile.js\";\nimport {EncryptedEventTile} from \"./tiles/EncryptedEventTile.js\";\nimport {EncryptionEnabledTile} from \"./tiles/EncryptionEnabledTile.js\";\nimport {MissingAttachmentTile} from \"./tiles/MissingAttachmentTile.js\";\n\nexport function tilesCreator(baseOptions) {\n    const tilesCreator = function tilesCreator(entry, emitUpdate) {\n        const options = Object.assign({entry, emitUpdate, tilesCreator}, baseOptions);\n        if (entry.isGap) {\n            return new GapTile(options);\n        } else if (entry.isPending && entry.pendingEvent.isMissingAttachments) {\n            return new MissingAttachmentTile(options);\n        } else if (entry.eventType) {\n            switch (entry.eventType) {\n                case \"m.room.message\": {\n                    if (entry.isRedacted) {\n                        return new RedactedTile(options);\n                    }\n                    const content = entry.content;\n                    const msgtype = content && content.msgtype;\n                    switch (msgtype) {\n                        case \"m.text\":\n                        case \"m.notice\":\n                        case \"m.emote\":\n                            return new TextTile(options);\n                        case \"m.image\":\n                            return new ImageTile(options);\n                        case \"m.video\":\n                            return new VideoTile(options);\n                        case \"m.file\":\n                            return new FileTile(options);\n                        case \"m.location\":\n                            return new LocationTile(options);\n                        default:\n                            // unknown msgtype not rendered\n                            return null;\n                    }\n                }\n                case \"m.room.name\":\n                    return new RoomNameTile(options);\n                case \"m.room.member\":\n                    return new RoomMemberTile(options);\n                case \"m.room.encrypted\":\n                    if (entry.isRedacted) {\n                        return new RedactedTile(options);\n                    }\n                    return new EncryptedEventTile(options);\n                case \"m.room.encryption\":\n                    return new EncryptionEnabledTile(options);\n                default:\n                    // unknown type not rendered\n                    return null;\n            }\n        }\n    };\n    return tilesCreator;\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function imageToInfo(image) {\n    return {\n        w: image.width,\n        h: image.height,\n        mimetype: image.blob.mimeType,\n        size: image.blob.size\n    };\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TimelineViewModel} from \"./timeline/TimelineViewModel.js\";\nimport {ComposerViewModel} from \"./ComposerViewModel.js\"\nimport {avatarInitials, getIdentifierColorNumber, getAvatarHttpUrl} from \"../../avatar.js\";\nimport {tilesCreator} from \"./timeline/tilesCreator.js\";\nimport {ViewModel} from \"../../ViewModel.js\";\nimport {imageToInfo} from \"../common.js\";\n\nexport class RoomViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {room} = options;\n        this._room = room;\n        this._timelineVM = null;\n        this._tilesCreator = null;\n        this._onRoomChange = this._onRoomChange.bind(this);\n        this._timelineError = null;\n        this._sendError = null;\n        this._composerVM = null;\n        if (room.isArchived) {\n            this._composerVM = new ArchivedViewModel(this.childOptions({archivedRoom: room}));\n        } else {\n            this._composerVM = new ComposerViewModel(this);\n        }\n        this._clearUnreadTimout = null;\n        this._closeUrl = this.urlCreator.urlUntilSegment(\"session\");\n    }\n\n    async load() {\n        this._room.on(\"change\", this._onRoomChange);\n        try {\n            const timeline = await this._room.openTimeline();\n            this._tilesCreator = tilesCreator(this.childOptions({\n                roomVM: this,\n                timeline,\n            }));\n            this._timelineVM = this.track(new TimelineViewModel(this.childOptions({\n                tilesCreator: this._tilesCreator,\n                timeline,\n            })));\n            this.emitChange(\"timelineViewModel\");\n        } catch (err) {\n            console.error(`room.openTimeline(): ${err.message}:\\n${err.stack}`);\n            this._timelineError = err;\n            this.emitChange(\"error\");\n        }\n        this._clearUnreadAfterDelay();\n    }\n\n    async _clearUnreadAfterDelay() {\n        if (this._room.isArchived || this._clearUnreadTimout) {\n            return;\n        }\n        this._clearUnreadTimout = this.clock.createTimeout(2000);\n        try {\n            await this._clearUnreadTimout.elapsed();\n            await this._room.clearUnread();\n            this._clearUnreadTimout = null;\n        } catch (err) {\n            if (err.name !== \"AbortError\") {\n                throw err;\n            }\n        }\n    }\n\n    focus() {\n        this._clearUnreadAfterDelay();\n    }\n\n    dispose() {\n        super.dispose();\n        this._room.off(\"change\", this._onRoomChange);\n        if (this._room.isArchived) {\n            this._room.release();\n        }\n        if (this._clearUnreadTimout) {\n            this._clearUnreadTimout.abort();\n            this._clearUnreadTimout = null;\n        }\n    }\n\n    // room doesn't tell us yet which fields changed,\n    // so emit all fields originating from summary\n    _onRoomChange() {\n        // propagate the update to the child view models so it's bindings can update based on room changes\n        this._composerVM.emitChange();\n        this.emitChange();\n    }\n\n    get kind() { return \"room\"; }\n    get closeUrl() { return this._closeUrl; }\n    get name() { return this._room.name || this.i18n`Empty Room`; }\n    get id() { return this._room.id; }\n    get timelineViewModel() { return this._timelineVM; }\n    get isEncrypted() { return this._room.isEncrypted; }\n\n    get error() {\n        if (this._timelineError) {\n            return `Something went wrong loading the timeline: ${this._timelineError.message}`;\n        }\n        if (this._sendError) {\n            return `Something went wrong sending your message: ${this._sendError.message}`;\n        }\n        return \"\";\n    }\n\n    get avatarLetter() {\n        return avatarInitials(this.name);\n    }\n\n    get avatarColorNumber() {\n        return getIdentifierColorNumber(this._room.avatarColorId)\n    }\n\n    avatarUrl(size) {\n        return getAvatarHttpUrl(this._room.avatarUrl, size, this.platform, this._room.mediaRepository);\n    }\n\n    get avatarTitle() {\n        return this.name;\n    }\n\n    get canLeave() {\n        return this._room.isJoined;\n    }\n\n    leaveRoom() {\n        this._room.leave();\n    }\n\n    get canForget() {\n        return this._room.isArchived;\n    }\n\n    forgetRoom() {\n        this._room.forget();\n    }\n\n    get canRejoin() {\n        return this._room.isArchived;\n    }\n\n    rejoinRoom() {\n        this._room.join();\n    }\n\n    _createTile(entry) {\n        return this._tilesCreator(entry);\n    }\n    \n    async _sendMessage(message, replyingTo) {\n        if (!this._room.isArchived && message) {\n            try {\n                let msgtype = \"m.text\";\n                if (message.startsWith(\"/me \")) {\n                    message = message.substr(4).trim();\n                    msgtype = \"m.emote\";\n                }\n                if (replyingTo) {\n                    await replyingTo.reply(msgtype, message);\n                } else {\n                    await this._room.sendEvent(\"m.room.message\", {msgtype, body: message});\n                }\n            } catch (err) {\n                console.error(`room.sendMessage(): ${err.message}:\\n${err.stack}`);\n                this._sendError = err;\n                this._timelineError = null;\n                this.emitChange(\"error\");\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    async _pickAndSendFile() {\n        try {\n            const file = await this.platform.openFile();\n            if (!file) {\n                return;\n            }\n            return this._sendFile(file);\n        } catch (err) {\n            console.error(err);\n        }\n    }\n\n    async _sendFile(file) {\n        const content = {\n            body: file.name,\n            msgtype: \"m.file\"\n        };\n        await this._room.sendEvent(\"m.room.message\", content, {\n            \"url\": this._room.createAttachment(file.blob, file.name)\n        });\n    }\n\n    async _pickAndSendVideo() {\n        try {\n            if (!this.platform.hasReadPixelPermission()) {\n                alert(\"Please allow canvas image data access, so we can scale your images down.\");\n                return;\n            }\n            const file = await this.platform.openFile(\"video/*\");\n            if (!file) {\n                return;\n            }\n            if (!file.blob.mimeType.startsWith(\"video/\")) {\n                return this._sendFile(file);\n            }\n            let video;\n            try {\n                video = await this.platform.loadVideo(file.blob);\n            } catch (err) {\n                // TODO: extract platform dependent code from view model\n                if (err instanceof window.MediaError && err.code === 4) {\n                    throw new Error(`this browser does not support videos of type ${file?.blob.mimeType}.`);\n                } else {\n                    throw err;\n                }\n            }\n            const content = {\n                body: file.name,\n                msgtype: \"m.video\",\n                info: videoToInfo(video)\n            };\n            const attachments = {\n                \"url\": this._room.createAttachment(video.blob, file.name),\n            };\n\n            const limit = await this.platform.settingsStorage.getInt(\"sentImageSizeLimit\");\n            const maxDimension = limit || Math.min(video.maxDimension, 800);\n            const thumbnail = await video.scale(maxDimension);\n            content.info.thumbnail_info = imageToInfo(thumbnail);\n            attachments[\"info.thumbnail_url\"] = \n                this._room.createAttachment(thumbnail.blob, file.name);\n            await this._room.sendEvent(\"m.room.message\", content, attachments);\n        } catch (err) {\n            this._sendError = err;\n            this.emitChange(\"error\");\n            console.error(err.stack);\n        }\n    }\n\n    async _pickAndSendPicture() {\n        try {\n            if (!this.platform.hasReadPixelPermission()) {\n                alert(\"Please allow canvas image data access, so we can scale your images down.\");\n                return;\n            }\n            const file = await this.platform.openFile(\"image/*\");\n            if (!file) {\n                return;\n            }\n            if (!file.blob.mimeType.startsWith(\"image/\")) {\n                return this._sendFile(file);\n            }\n            let image = await this.platform.loadImage(file.blob);\n            const limit = await this.platform.settingsStorage.getInt(\"sentImageSizeLimit\");\n            if (limit && image.maxDimension > limit) {\n                const scaledImage = await image.scale(limit);\n                image.dispose();\n                image = scaledImage;\n            }\n            const content = {\n                body: file.name,\n                msgtype: \"m.image\",\n                info: imageToInfo(image)\n            };\n            const attachments = {\n                \"url\": this._room.createAttachment(image.blob, file.name),\n            };\n            if (image.maxDimension > 600) {\n                const thumbnail = await image.scale(400);\n                content.info.thumbnail_info = imageToInfo(thumbnail);\n                attachments[\"info.thumbnail_url\"] = \n                    this._room.createAttachment(thumbnail.blob, file.name);\n            }\n            await this._room.sendEvent(\"m.room.message\", content, attachments);\n        } catch (err) {\n            this._sendError = err;\n            this.emitChange(\"error\");\n            console.error(err.stack);\n        }\n    }\n\n    get room() {\n        return this._room;\n    }\n\n    get composerViewModel() {\n        return this._composerVM;\n    }\n\n    openDetailsPanel() {\n        let path = this.navigation.path.until(\"room\");\n        path = path.with(this.navigation.segment(\"right-panel\", true));\n        path = path.with(this.navigation.segment(\"details\", true));\n        this.navigation.applyPath(path);\n    }\n\n    startReply(entry) {\n        if (!this._room.isArchived) {\n            this._composerVM.setReplyingTo(entry);\n        }\n    }\n}\n\nfunction videoToInfo(video) {\n    const info = imageToInfo(video);\n    info.duration = video.duration;\n    return info;\n}\n\nclass ArchivedViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._archivedRoom = options.archivedRoom;\n    }\n\n    get description() {\n        if (this._archivedRoom.isKicked) {\n            if (this._archivedRoom.kickReason) {\n                return this.i18n`You were kicked from the room by ${this._archivedRoom.kickedBy.name} because: ${this._archivedRoom.kickReason}`;\n            } else {\n                return this.i18n`You were kicked from the room by ${this._archivedRoom.kickedBy.name}.`;\n            }\n        } else if (this._archivedRoom.isBanned) {\n            if (this._archivedRoom.kickReason) {\n                return this.i18n`You were banned from the room by ${this._archivedRoom.kickedBy.name} because: ${this._archivedRoom.kickReason}`;\n            } else {\n                return this.i18n`You were banned from the room by ${this._archivedRoom.kickedBy.name}.`;\n            }\n        } else {\n            return this.i18n`You left this room`;\n        }\n    }\n\n    get kind() {\n        return \"archived\";\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../../ViewModel.js\";\n\nexport class UnknownRoomViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {roomIdOrAlias, session} = options;\n        this._session = session;\n        this.roomIdOrAlias = roomIdOrAlias;\n        this._error = null;\n        this._busy = false;\n    }\n\n    get error() {\n        return this._error?.message;\n    }\n\n    async join() {\n        this._busy = true;\n        this.emitChange(\"busy\");\n        try {\n            const roomId = await this._session.joinRoom(this.roomIdOrAlias);\n            // navigate to roomId if we were at the alias\n            // so we're subscribed to the right room status\n            // and we'll switch to the room view model once\n            // the join is synced\n            this.navigation.push(\"room\", roomId);\n            // keep busy on true while waiting for the join to sync\n        } catch (err) {\n            this._error = err;\n            this._busy = false;\n            this.emitChange(\"error\");\n        }\n    }\n\n    get busy() {\n        return this._busy;\n    }\n\n    get kind() {\n        return \"unknown\";\n    }\n}","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {avatarInitials, getIdentifierColorNumber, getAvatarHttpUrl} from \"../../avatar.js\";\nimport {ViewModel} from \"../../ViewModel.js\";\n\nexport class InviteViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {invite, mediaRepository} = options;\n        this._invite = invite;\n        this._mediaRepository = mediaRepository;\n        this._onInviteChange = this._onInviteChange.bind(this);\n        this._error = null;\n        this._closeUrl = this.urlCreator.urlUntilSegment(\"session\");\n        this._invite.on(\"change\", this._onInviteChange);\n        this._inviter = null;\n        if (this._invite.inviter) {\n            this._inviter = new RoomMemberViewModel(this._invite.inviter, mediaRepository, this.platform);\n        }\n        this._roomDescription = this._createRoomDescription();\n    }\n\n    get kind() { return \"invite\"; }\n    get closeUrl() { return this._closeUrl; }\n    get name() { return this._invite.name; }\n    get id() { return this._invite.id; }\n    get isEncrypted() { return this._invite.isEncrypted; }\n    get isDirectMessage() { return this._invite.isDirectMessage; }\n    get inviter() { return this._inviter; }\n    get busy() { return this._invite.accepting || this._invite.rejecting; }\n\n    get error() {\n        if (this._error) {\n            return `Something went wrong: ${this._error.message}`;\n        }\n        return \"\";\n    }\n\n    get avatarLetter() {\n        return avatarInitials(this.name);\n    }\n\n    get avatarColorNumber() {\n        return getIdentifierColorNumber(this._invite.avatarColorId)\n    }\n\n    avatarUrl(size) {\n        return getAvatarHttpUrl(this._invite.avatarUrl, size, this.platform, this._mediaRepository);\n    }\n\n    _createRoomDescription() {\n        const parts = [];\n        if (this._invite.isPublic) {\n            parts.push(\"Public room\");\n        } else {\n            parts.push(\"Private room\");\n        }\n\n        if (this._invite.canonicalAlias) {\n            parts.push(this._invite.canonicalAlias);\n        }\n        return parts.join(\" • \")\n    }\n\n    get roomDescription() {\n        return this._roomDescription;\n    }\n\n    get avatarTitle() {\n        return this.name;\n    }\n\n    focus() {}\n\n    async accept() {\n        try {\n            await this._invite.accept();\n        } catch (err) {\n            this._error = err;\n            this.emitChange(\"error\");\n        }\n    }\n\n    async reject() {\n        try {\n            await this._invite.reject();\n        } catch (err) {\n            this._error = err;\n            this.emitChange(\"error\");\n        }\n    }\n\n    _onInviteChange() {\n        this.emitChange();\n    }\n\n    dispose() {\n        super.dispose();\n        this._invite.off(\"change\", this._onInviteChange);\n    }\n}\n\nclass RoomMemberViewModel {\n    constructor(member, mediaRepository, platform) {\n        this._member = member;\n        this._mediaRepository = mediaRepository;\n        this._platform = platform;\n    }\n\n    get id() {\n        return this._member.userId;\n    }\n\n    get name() {\n        return this._member.name;\n    }\n\n    get avatarLetter() {\n        return avatarInitials(this.name);\n    }\n\n    get avatarColorNumber() {\n        return getIdentifierColorNumber(this._member.userId);\n    }\n\n    avatarUrl(size) {\n        return getAvatarHttpUrl(this._member.avatarUrl, size, this._platform, this._mediaRepository);\n    }\n\n    get avatarTitle() {\n        return this.name;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {avatarInitials, getIdentifierColorNumber, getAvatarHttpUrl} from \"../../avatar.js\";\nimport {ViewModel} from \"../../ViewModel.js\";\n\nexport class RoomBeingCreatedViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {roomBeingCreated, mediaRepository} = options;\n        this._roomBeingCreated = roomBeingCreated;\n        this._mediaRepository = mediaRepository;\n        this._onRoomChange = this._onRoomChange.bind(this);\n        this._closeUrl = this.urlCreator.urlUntilSegment(\"session\");\n        this._roomBeingCreated.on(\"change\", this._onRoomChange);\n    }\n\n    get kind() { return \"roomBeingCreated\"; }\n    get closeUrl() { return this._closeUrl; }\n    get name() { return this._roomBeingCreated.name; }\n    get id() { return this._roomBeingCreated.id; }\n    get isEncrypted() { return this._roomBeingCreated.isEncrypted; }\n    get error() {\n        const {error} = this._roomBeingCreated;\n        if (error) {\n            if (error.name === \"ConnectionError\") {\n                return this.i18n`You seem to be offline`;\n            } else {\n                return error.message;\n            }\n        }\n        return \"\";\n    }\n    get avatarLetter() { return avatarInitials(this.name); }\n    get avatarColorNumber() { return getIdentifierColorNumber(this._roomBeingCreated.avatarColorId); }\n    get avatarTitle() { return this.name; }\n\n    avatarUrl(size) {\n        // allow blob url which doesn't need mxc => http resolution\n        return this._roomBeingCreated.avatarBlobUrl ??\n            getAvatarHttpUrl(this._roomBeingCreated.avatarUrl, size, this.platform, this._mediaRepository);\n    }\n\n    focus() {}\n\n    _onRoomChange() {\n        this.emitChange();\n    }\n\n    cancel() {\n        this._roomBeingCreated.cancel();\n        // navigate away from the room\n        this.navigation.applyPath(this.navigation.path.until(\"session\"));\n    }\n\n    dispose() {\n        super.dispose();\n        this._roomBeingCreated.off(\"change\", this._onRoomChange);\n    }\n}\n\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../../ViewModel.js\";\n\nexport class LightboxViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._eventId = options.eventId;\n        this._unencryptedImageUrl = null;\n        this._decryptedImage = null;\n        this._closeUrl = this.urlCreator.urlUntilSegment(\"room\");\n        this._eventEntry = null;\n        this._date = null;\n        this._subscribeToEvent(options.room, options.eventId);\n    }\n\n    _subscribeToEvent(room, eventId) {\n        const eventObservable = room.observeEvent(eventId);\n        this.track(eventObservable.subscribe(eventEntry => {\n            this._loadEvent(room, eventEntry);\n        }));\n        this._loadEvent(room, eventObservable.get());\n    }\n\n    async _loadEvent(room, eventEntry) {\n        if (!eventEntry) {\n            return;\n        }\n        const {mediaRepository} = room;\n        this._eventEntry = eventEntry;\n        const {content} = this._eventEntry;\n        this._date = this._eventEntry.timestamp ? new Date(this._eventEntry.timestamp) : null;\n        if (content.url) {\n            this._unencryptedImageUrl = mediaRepository.mxcUrl(content.url);\n            this.emitChange(\"imageUrl\");\n        } else if (content.file) {\n            this._decryptedImage = this.track(await mediaRepository.downloadEncryptedFile(content.file));\n            this.emitChange(\"imageUrl\");\n        }\n    }\n\n    get imageWidth() {\n        return this._eventEntry?.content?.info?.w;\n    }\n\n    get imageHeight() {\n        return this._eventEntry?.content?.info?.h;\n    }\n\n    get name() {\n        return this._eventEntry?.content?.body;\n    }\n\n    get sender() {\n        return this._eventEntry?.displayName;\n    }\n\n    get imageUrl() {\n        if (this._decryptedImage) {\n            return this._decryptedImage.url;\n        } else if (this._unencryptedImageUrl) {\n            return this._unencryptedImageUrl;\n        } else {\n            return \"\";\n        }\n    }\n\n    get date() {\n        return this._date && this._date.toLocaleDateString({}, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });\n    }\n\n    get time() {\n        return this._date && this._date.toLocaleTimeString({}, {hour: \"numeric\", minute: \"2-digit\"});\n    }\n\n    get closeUrl() {\n        return this._closeUrl;\n    }\n\n    close() {\n        this.platform.history.pushUrl(this.closeUrl);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../ViewModel.js\";\nimport {createEnum} from \"../../utils/enum\";\nimport {ConnectionStatus} from \"../../matrix/net/Reconnector\";\nimport {SyncStatus} from \"../../matrix/Sync.js\";\n\nconst SessionStatus = createEnum(\n    \"Disconnected\",\n    \"Connecting\",\n    \"FirstSync\",\n    \"Sending\",\n    \"Syncing\",\n    \"SyncError\"\n);\n\nexport class SessionStatusViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {sync, reconnector, session} = options;\n        this._sync = sync;\n        this._reconnector = reconnector;\n        this._status = this._calculateState(reconnector.connectionStatus.get(), sync.status.get());\n        this._session = session;\n        this._setupKeyBackupUrl = this.urlCreator.urlForSegment(\"settings\");\n        this._dismissSecretStorage = false;\n    }\n\n    start() {\n        const update = () => this._updateStatus();\n        this.track(this._sync.status.subscribe(update));\n        this.track(this._reconnector.connectionStatus.subscribe(update));\n        this.track(this._session.needsKeyBackup.subscribe(() => {\n            this.emitChange();\n        }));\n    }\n\n    get setupKeyBackupUrl () {\n        return this._setupKeyBackupUrl;\n    }\n\n    get isShown() {\n        return (this._session.needsKeyBackup.get() && !this._dismissSecretStorage) || this._status !== SessionStatus.Syncing;\n    }\n\n    get statusLabel() {\n        switch (this._status) {\n            case SessionStatus.Disconnected:{\n                const retryIn = Math.round(this._reconnector.retryIn / 1000);\n                return this.i18n`Disconnected, trying to reconnect in ${retryIn}s…`;\n            }\n            case SessionStatus.Connecting:\n                return this.i18n`Trying to reconnect now…`;\n            case SessionStatus.FirstSync:\n                return this.i18n`Catching up with your conversations…`;\n            case SessionStatus.SyncError:\n                return this.i18n`Sync failed because of ${this._sync.error}`;\n        }\n        if (this._session.needsKeyBackup.get()) {\n            return this.i18n`Set up session backup to decrypt older messages.`;\n        }\n        return \"\";\n    }\n\n    get isWaiting() {\n        switch (this._status) {\n            case SessionStatus.Connecting:\n            case SessionStatus.FirstSync:\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    _updateStatus() {\n        const newStatus = this._calculateState(\n            this._reconnector.connectionStatus.get(),\n            this._sync.status.get()\n        );\n        if (newStatus !== this._status) {\n            if (newStatus === SessionStatus.Disconnected) {\n                this._retryTimer = this.track(this.clock.createInterval(() => {\n                    this.emitChange(\"statusLabel\");\n                }, 1000));\n            } else {\n                this._retryTimer = this.disposeTracked(this._retryTimer);\n            }\n            this._status = newStatus;\n            this.emitChange();\n        }\n    }\n\n    _calculateState(connectionStatus, syncStatus) {\n        if (connectionStatus !== ConnectionStatus.Online) {\n            switch (connectionStatus) {\n                case ConnectionStatus.Reconnecting:\n                    return SessionStatus.Connecting;\n                case ConnectionStatus.Waiting:\n                    return SessionStatus.Disconnected;\n            }\n        } else if (syncStatus !== SyncStatus.Syncing) {\n            switch (syncStatus) {\n                // InitialSync should be awaited in the SessionLoadViewModel,\n                // but include it here anyway\n                case SyncStatus.InitialSync:\n                case SyncStatus.CatchupSync:\n                    return SessionStatus.FirstSync;\n                case SyncStatus.Stopped:\n                    return SessionStatus.SyncError;\n            }\n        } /* else if (session.pendingMessageCount) {\n            return SessionStatus.Sending;\n        } */ else {\n            return SessionStatus.Syncing;\n        }\n    }\n\n    get isConnectNowShown() {\n        return this._status === SessionStatus.Disconnected;\n    }\n\n    get isSecretStorageShown() {\n        // TODO: we need a model here where we can have multiple messages queued up and their buttons don't bleed into each other.\n        return this._status === SessionStatus.Syncing && this._session.needsKeyBackup.get() && !this._dismissSecretStorage;\n    }\n\n    get canDismiss() {\n        return this.isSecretStorageShown;\n    }\n\n    dismiss() {\n        if (this.isSecretStorageShown) {\n            this._dismissSecretStorage = true;\n            this.emitChange();\n        }\n    }\n\n    connectNow() {\n        if (this.isConnectNowShown) {\n            this._reconnector.tryNow();\n        }\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../ViewModel.js\";\nimport {addPanelIfNeeded} from \"../navigation/index.js\";\n\nfunction dedupeSparse(roomIds) {\n    return roomIds.map((id, idx) => {\n        if (roomIds.slice(0, idx).includes(id)) {\n            return undefined;\n        } else {\n            return id;\n        }\n    });\n}\n\nexport class RoomGridViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n\n        this._width = options.width;\n        this._height = options.height;\n        this._createRoomViewModelObservable = options.createRoomViewModelObservable;\n        this._selectedIndex = 0;\n        this._viewModelsObservables = [];\n        this._setupNavigation();\n    }\n\n    _setupNavigation() {\n        const focusTileIndex = this.navigation.observe(\"empty-grid-tile\");\n        this.track(focusTileIndex.subscribe(index => {\n            if (typeof index === \"number\") {\n                this._setFocusIndex(index);\n            }\n        }));\n        if (typeof focusTileIndex.get() === \"number\") {\n            this._selectedIndex = focusTileIndex.get();\n        }\n\n        const focusedRoom = this.navigation.observe(\"room\");\n        this.track(focusedRoom.subscribe(roomId => {\n            if (roomId) {\n                // as the room will be in the \"rooms\" observable\n                // (monitored by the parent vmo) as well,\n                // we only change the focus here and trust\n                // setRoomIds to have created the vmo already\n                this._setFocusRoom(roomId);\n            }\n        }));\n        // initial focus for a room is set by initializeRoomIdsAndTransferVM\n    }\n\n    roomViewModelAt(i) {\n        return this._viewModelsObservables[i]?.get();\n    }\n\n    get focusIndex() {\n        return this._selectedIndex;\n    }\n\n    get width() {\n        return this._width;\n    }\n\n    get height() {\n        return this._height;\n    }\n\n    _switchToRoom(roomId) {\n        let path = this.navigation.path.until(\"rooms\");\n        path = path.with(this.navigation.segment(\"room\", roomId));\n        path = addPanelIfNeeded(this.navigation, path);\n        this.navigation.applyPath(path);\n    }\n\n    focusTile(index) {\n        if (index === this._selectedIndex) {\n            return;\n        }\n        const vmo = this._viewModelsObservables[index];\n        if (vmo) {\n            this._switchToRoom(vmo.id);\n        } else {\n            this.navigation.push(\"empty-grid-tile\", index);\n        }\n    }\n\n    /** called from SessionViewModel */\n    initializeRoomIdsAndTransferVM(roomIds, existingRoomVM) {\n        roomIds = dedupeSparse(roomIds);\n        let transfered = false;\n        if (existingRoomVM) {\n            const index = roomIds.indexOf(existingRoomVM.id);\n            if (index !== -1) {\n                this._viewModelsObservables[index] = this.track(existingRoomVM);\n                existingRoomVM.subscribe(viewModel => this._refreshRoomViewModel(viewModel));\n                transfered = true;\n            }\n        }\n        this.setRoomIds(roomIds);\n        // now all view models exist, set the focus to the selected room\n        const focusedRoom = this.navigation.path.get(\"room\");\n        if (focusedRoom) {\n            const index = this._viewModelsObservables.findIndex(vmo => vmo && vmo.id === focusedRoom.value);\n            if (index !== -1) {\n                this._selectedIndex = index;\n            }\n        }\n        return transfered;\n    }\n\n    /** called from SessionViewModel */\n    setRoomIds(roomIds) {\n        roomIds = dedupeSparse(roomIds);\n        let changed = false;\n        const len = this._height * this._width;\n        for (let i = 0; i < len; i += 1) {\n            const newId = roomIds[i];\n            const vmo = this._viewModelsObservables[i];\n            // did anything change?\n            if ((!vmo && newId) || (vmo && vmo.id !== newId)) {\n                if (vmo) {\n                    this._viewModelsObservables[i] = this.disposeTracked(vmo);\n                }\n                if (newId) {\n                    const vmo = this._createRoomViewModelObservable(newId);\n                    this._viewModelsObservables[i] = this.track(vmo);\n                    vmo.subscribe(viewModel => this._refreshRoomViewModel(viewModel));\n                    vmo.initialize();\n                }\n                changed = true;\n            }\n        }\n        if (changed) {\n            this.emitChange();\n        }\n        return changed;\n    }\n\n    _refreshRoomViewModel(viewModel) {\n        this.emitChange();\n        viewModel?.focus();\n    }\n\n    /** called from SessionViewModel */\n    releaseRoomViewModel(roomId) {\n        const index = this._viewModelsObservables.findIndex(vmo => vmo && vmo.id === roomId);\n        if (index !== -1) {\n            const vmo = this._viewModelsObservables[index];\n            this.untrack(vmo);\n            vmo.unsubscribeAll();\n            this._viewModelsObservables[index] = null;\n            return vmo;\n        }\n    }\n\n    _setFocusIndex(idx) {\n        if (idx === this._selectedIndex || idx >= (this._width * this._height)) {\n            return;\n        }\n        this._selectedIndex = idx;\n        const vmo = this._viewModelsObservables[this._selectedIndex];\n        vmo?.get()?.focus();\n        this.emitChange(\"focusIndex\");\n    }\n\n    _setFocusRoom(roomId) {\n        const index = this._viewModelsObservables.findIndex(vmo => vmo?.id === roomId);\n        if (index >= 0) {\n            this._setFocusIndex(index);\n        }\n    }\n}\n\nimport {createNavigation} from \"../navigation/index.js\";\nimport {ObservableValue} from \"../../observable/ObservableValue\";\n\nexport function tests() { \n    class RoomVMMock {\n        constructor(id) {\n            this.id = id;\n            this.disposed = false;\n            this.focused = false;\n        }\n        dispose() {\n            this.disposed = true;\n        }\n        focus() {\n            this.focused = true;\n        }\n    }\n\n    class RoomViewModelObservableMock extends ObservableValue {\n        async initialize() {}\n        dispose() { this.get()?.dispose(); }\n        get id() { return this.get()?.id; }\n    }\n\n    function createNavigationForRoom(rooms, room) {\n        const navigation = createNavigation();\n        navigation.applyPath(navigation.pathFrom([\n            navigation.segment(\"session\", \"1\"),\n            navigation.segment(\"rooms\", rooms),\n            navigation.segment(\"room\", room),\n        ]));\n        return navigation;\n    }\n\n    function createNavigationForEmptyTile(rooms, idx) {\n        const navigation = createNavigation();\n        navigation.applyPath(navigation.pathFrom([\n            navigation.segment(\"session\", \"1\"),\n            navigation.segment(\"rooms\", rooms),\n            navigation.segment(\"empty-grid-tile\", idx),\n        ]));\n        return navigation;\n    }\n\n    return {\n        \"initialize with duplicate set of rooms\": assert => {\n            const navigation = createNavigationForRoom([\"c\", \"a\", \"b\", undefined, \"a\"], \"a\");\n            const gridVM = new RoomGridViewModel({\n                createRoomViewModelObservable: id => new RoomViewModelObservableMock(new RoomVMMock(id)),\n                navigation,\n                width: 3,\n                height: 2,\n            });\n            gridVM.initializeRoomIdsAndTransferVM(navigation.path.get(\"rooms\").value);\n            assert.equal(gridVM.focusIndex, 1);\n            assert.equal(gridVM.roomViewModelAt(0).id, \"c\");\n            assert.equal(gridVM.roomViewModelAt(1).id, \"a\");\n            assert.equal(gridVM.roomViewModelAt(2).id, \"b\");\n            assert.equal(gridVM.roomViewModelAt(3), undefined);\n            assert.equal(gridVM.roomViewModelAt(4), undefined);\n            assert.equal(gridVM.roomViewModelAt(5), undefined);\n        },\n        \"transfer room view model\": assert => {\n            const navigation = createNavigationForRoom([\"a\"], \"a\");\n            const gridVM = new RoomGridViewModel({\n                createRoomViewModelObservable: () => assert.fail(\"no vms should be created\"),\n                navigation,\n                width: 3,\n                height: 2,\n            });\n            const existingRoomVM = new RoomViewModelObservableMock(new RoomVMMock(\"a\"));\n            const transfered = gridVM.initializeRoomIdsAndTransferVM(navigation.path.get(\"rooms\").value, existingRoomVM);\n            assert.equal(transfered, true);\n            assert.equal(gridVM.focusIndex, 0);\n            assert.equal(gridVM.roomViewModelAt(0).id, \"a\");\n        },\n        \"reject transfer for non-matching room view model\": assert => {\n            const navigation = createNavigationForRoom([\"a\"], \"a\");\n            const gridVM = new RoomGridViewModel({\n                createRoomViewModelObservable: id => new RoomViewModelObservableMock(new RoomVMMock(id)),\n                navigation,\n                width: 3,\n                height: 2,\n            });\n            const existingRoomVM = new RoomViewModelObservableMock(new RoomVMMock(\"f\"));\n            const transfered = gridVM.initializeRoomIdsAndTransferVM(navigation.path.get(\"rooms\").value, existingRoomVM);\n            assert.equal(transfered, false);\n            assert.equal(gridVM.focusIndex, 0);\n            assert.equal(gridVM.roomViewModelAt(0).id, \"a\");\n        },\n        \"created & released room view model is not disposed\": assert => {\n            const navigation = createNavigationForRoom([\"a\"], \"a\");\n            const gridVM = new RoomGridViewModel({\n                createRoomViewModelObservable: id => new RoomViewModelObservableMock(new RoomVMMock(id)),\n                navigation,\n                width: 3,\n                height: 2,\n            });\n            const transfered = gridVM.initializeRoomIdsAndTransferVM(navigation.path.get(\"rooms\").value);\n            assert.equal(transfered, false);\n            const releasedVM = gridVM.releaseRoomViewModel(\"a\");\n            gridVM.dispose();\n            assert.equal(releasedVM.get().disposed, false);\n        },\n        \"transfered & released room view model is not disposed\": assert => {\n            const navigation = createNavigationForRoom([undefined, \"a\"], \"a\");\n            const gridVM = new RoomGridViewModel({\n                createRoomViewModelObservable: () => assert.fail(\"no vms should be created\"),\n                navigation,\n                width: 3,\n                height: 2,\n            });\n            const existingRoomVM = new RoomViewModelObservableMock(new RoomVMMock(\"a\"));\n            const transfered = gridVM.initializeRoomIdsAndTransferVM(navigation.path.get(\"rooms\").value, existingRoomVM);\n            assert.equal(transfered, true);\n            const releasedVM = gridVM.releaseRoomViewModel(\"a\");\n            gridVM.dispose();\n            assert.equal(releasedVM.get().disposed, false);\n        },\n        \"try release non-existing room view model is\": assert => {\n            const navigation = createNavigationForEmptyTile([undefined, \"b\"], 3);\n            const gridVM = new RoomGridViewModel({\n                createRoomViewModelObservable: id => new RoomViewModelObservableMock(new RoomVMMock(id)),\n                navigation,\n                width: 3,\n                height: 2,\n            });\n            gridVM.initializeRoomIdsAndTransferVM(navigation.path.get(\"rooms\").value);\n            const releasedVM = gridVM.releaseRoomViewModel(\"c\");\n            assert(!releasedVM);\n        },\n        \"initial focus is set to empty tile\": assert => {\n            const navigation = createNavigationForEmptyTile([\"a\"], 1);\n            const gridVM = new RoomGridViewModel({\n                createRoomViewModelObservable: id => new RoomViewModelObservableMock(new RoomVMMock(id)),\n                navigation,\n                width: 3,\n                height: 2,\n            });\n            gridVM.initializeRoomIdsAndTransferVM(navigation.path.get(\"rooms\").value);\n            assert.equal(gridVM.focusIndex, 1);\n            assert.equal(gridVM.roomViewModelAt(0).id, \"a\");\n        },\n        \"change room ids after creation\": assert => {\n            const navigation = createNavigationForRoom([\"a\", \"b\"], \"a\");\n            const gridVM = new RoomGridViewModel({\n                createRoomViewModelObservable: id => new RoomViewModelObservableMock(new RoomVMMock(id)),\n                navigation,\n                width: 3,\n                height: 2,\n            });\n            navigation.observe(\"rooms\").subscribe(roomIds => {\n                gridVM.setRoomIds(roomIds);\n            });\n            gridVM.initializeRoomIdsAndTransferVM(navigation.path.get(\"rooms\").value);\n            const oldA = gridVM.roomViewModelAt(0);\n            const oldB = gridVM.roomViewModelAt(1);\n            assert.equal(oldA.id, \"a\");\n            assert.equal(oldB.id, \"b\");\n            navigation.applyPath(navigation.path\n                .with(navigation.segment(\"rooms\", [\"b\", \"c\", \"b\"]))\n                .with(navigation.segment(\"room\", \"c\"))\n            );\n            assert.equal(oldA.disposed, true);\n            assert.equal(oldB.disposed, true);\n            assert.equal(gridVM.focusIndex, 1);\n            assert.equal(gridVM.roomViewModelAt(0).id, \"b\");\n            assert.equal(gridVM.roomViewModelAt(0).disposed, false);\n            assert.equal(gridVM.roomViewModelAt(1).id, \"c\");\n            assert.equal(gridVM.roomViewModelAt(1).focused, true);\n            assert.equal(gridVM.roomViewModelAt(2), undefined);\n        }\n    };\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../../ViewModel.js\";\nimport {KeyType} from \"../../../matrix/ssss/index\";\nimport {createEnum} from \"../../../utils/enum\";\n\nexport const Status = createEnum(\"Enabled\", \"SetupKey\", \"SetupPhrase\", \"Pending\", \"NewVersionAvailable\"); \nexport const BackupWriteStatus = createEnum(\"Writing\", \"Stopped\", \"Done\", \"Pending\"); \n\nexport class KeyBackupViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._session = options.session;\n        this._error = null;\n        this._isBusy = false;\n        this._dehydratedDeviceId = undefined;\n        this._status = undefined;\n        this._backupOperation = this._session.keyBackup.flatMap(keyBackup => keyBackup.operationInProgress);\n        this._progress = this._backupOperation.flatMap(op => op.progress);\n        this.track(this._backupOperation.subscribe(() => {\n            // see if needsNewKey might be set\n            this._reevaluateStatus();\n            this.emitChange(\"isBackingUp\");\n        }));\n        this.track(this._progress.subscribe(() => this.emitChange(\"backupPercentage\")));\n        this._reevaluateStatus();\n        this.track(this._session.keyBackup.subscribe(() => {\n            if (this._reevaluateStatus()) {\n                this.emitChange(\"status\");\n            }\n        }));\n    }\n\n    _reevaluateStatus() {\n        if (this._isBusy) {\n            return false;\n        }\n        let status;\n        const keyBackup = this._session.keyBackup.get();\n        if (keyBackup) {\n            status = keyBackup.needsNewKey ? Status.NewVersionAvailable : Status.Enabled;\n        } else if (keyBackup === null) {\n            status = this.showPhraseSetup() ? Status.SetupPhrase : Status.SetupKey;\n        } else {\n            status = Status.Pending;\n        }\n        const changed = status !== this._status;\n        this._status = status;\n        return changed;\n    }\n\n    get decryptAction() {\n        return this.i18n`Set up`;\n    }\n\n    get purpose() {\n        return this.i18n`set up key backup`;\n    }\n\n    offerDehydratedDeviceSetup() {\n        return true;\n    }\n\n    get dehydratedDeviceId() {\n        return this._dehydratedDeviceId;\n    }\n    \n    get isBusy() {\n        return this._isBusy;\n    }\n\n    get backupVersion() {\n        return this._session.keyBackup.get()?.version;\n    }\n\n    get backupWriteStatus() {\n        const keyBackup = this._session.keyBackup.get();\n        if (!keyBackup) {\n            return BackupWriteStatus.Pending;\n        } else if (keyBackup.hasStopped) {\n            return BackupWriteStatus.Stopped;\n        }\n        const operation = keyBackup.operationInProgress.get();\n        if (operation) {\n            return BackupWriteStatus.Writing;\n        } else if (keyBackup.hasBackedUpAllKeys) {\n            return BackupWriteStatus.Done;\n        } else {\n            return BackupWriteStatus.Pending;\n        }\n    }\n\n    get backupError() {\n        return this._session.keyBackup.get()?.error?.message;\n    }\n\n    get status() {\n        return this._status;\n    }\n\n    get error() {\n        return this._error?.message;\n    }\n\n    showPhraseSetup() {\n        if (this._status === Status.SetupKey) {\n            this._status = Status.SetupPhrase;\n            this.emitChange(\"status\");\n        }\n    }\n\n    showKeySetup() {\n        if (this._status === Status.SetupPhrase) {\n            this._status = Status.SetupKey;\n            this.emitChange(\"status\");\n        }\n    }\n\n    async _enterCredentials(keyType, credential, setupDehydratedDevice) {\n        if (credential) {\n            try {\n                this._isBusy = true;\n                this.emitChange(\"isBusy\");\n                const key = await this._session.enableSecretStorage(keyType, credential);\n                if (setupDehydratedDevice) {\n                    this._dehydratedDeviceId = await this._session.setupDehydratedDevice(key);\n                }\n            } catch (err) {\n                console.error(err);\n                this._error = err;\n                this.emitChange(\"error\");\n            } finally {\n                this._isBusy = false;\n                this._reevaluateStatus();\n                this.emitChange(\"\");\n            }\n        }\n    }\n\n    enterSecurityPhrase(passphrase, setupDehydratedDevice) {\n        this._enterCredentials(KeyType.Passphrase, passphrase, setupDehydratedDevice);\n    }\n\n    enterSecurityKey(securityKey, setupDehydratedDevice) {\n        this._enterCredentials(KeyType.RecoveryKey, securityKey, setupDehydratedDevice);\n    }\n\n    async disable() {\n        try {\n            this._isBusy = true;\n            this.emitChange(\"isBusy\");\n            await this._session.disableSecretStorage();\n        } catch (err) {\n            console.error(err);\n            this._error = err;\n            this.emitChange(\"error\");\n        } finally {\n            this._isBusy = false;\n            this._reevaluateStatus();\n            this.emitChange(\"\");\n        }\n    }\n\n    get isBackingUp() {\n        return !!this._backupOperation.get();\n    }\n\n    get backupPercentage() {\n        const progress = this._progress.get();\n        if (progress) {\n            return Math.round((progress.finished / progress.total) * 100);\n        }\n        return 0;\n    }\n\n    get backupInProgressLabel() {\n        const progress = this._progress.get();\n        if (progress) {\n            return this.i18n`${progress.finished} of ${progress.total}`;\n        }\n        return this.i18n`…`;\n    }\n\n    cancelBackup() {\n        this._backupOperation.get()?.abort();\n    }\n\n    startBackup() {\n        this._session.keyBackup.get()?.flush();\n    }\n}\n\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../../ViewModel.js\";\nimport {KeyBackupViewModel} from \"./KeyBackupViewModel.js\";\n\nclass PushNotificationStatus {\n    constructor() {\n        this.supported = null;\n        this.enabled = false;\n        this.updating = false;\n        this.enabledOnServer = null;\n        this.serverError = null;\n    }\n}\n\nfunction formatKey(key) {\n    const partLength = 4;\n    const partCount = Math.ceil(key.length / partLength);\n    let formattedKey = \"\";\n    for (let i = 0; i < partCount; i += 1) {\n        formattedKey += (formattedKey.length ? \" \" : \"\") + key.slice(i * partLength, (i + 1) * partLength);\n    }\n    return formattedKey;\n}\n\nexport class SettingsViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._updateService = options.updateService;\n        const {client} = options;\n        this._client = client;\n        this._keyBackupViewModel = this.track(new KeyBackupViewModel(this.childOptions({session: this._session})));\n        this._closeUrl = this.urlCreator.urlUntilSegment(\"session\");\n        this._estimate = null;\n        this.sentImageSizeLimit = null;\n        this.minSentImageSizeLimit = 400;\n        this.maxSentImageSizeLimit = 4000;\n        this.pushNotifications = new PushNotificationStatus();\n    }\n\n    get _session() {\n        return this._client.session;\n    }\n\n    async logout() {\n        this.navigation.push(\"logout\", this._client.sessionId);\n    }\n\n    setSentImageSizeLimit(size) {\n        if (size > this.maxSentImageSizeLimit || size < this.minSentImageSizeLimit) {\n            this.sentImageSizeLimit = null;\n            this.platform.settingsStorage.remove(\"sentImageSizeLimit\");\n        } else {\n            this.sentImageSizeLimit = Math.round(size);\n            this.platform.settingsStorage.setInt(\"sentImageSizeLimit\", size);\n        }\n        this.emitChange(\"sentImageSizeLimit\");\n    }\n\n    async load() {\n        this._estimate = await this.platform.estimateStorageUsage();\n        this.sentImageSizeLimit = await this.platform.settingsStorage.getInt(\"sentImageSizeLimit\");\n        this.pushNotifications.supported = await this.platform.notificationService.supportsPush();\n        this.pushNotifications.enabled = await this._session.arePushNotificationsEnabled();\n        this.emitChange(\"\");\n    }\n\n    get closeUrl() {\n        return this._closeUrl;\n    }\n\n    get fingerprintKey() {\n        const key = this._session.fingerprintKey;\n        if (!key) {\n            return null;\n        }\n        return formatKey(key);\n    }\n\n    get deviceId() {\n        return this._session.deviceId;\n    }\n\n    get userId() {\n        return this._session.userId;\n    }\n\n    get version() {\n        const {updateService} = this.platform; \n        if (updateService) {\n            return `${updateService.version} (${updateService.buildHash})`;\n        }\n        return this.i18n`development version`;\n    }\n\n    checkForUpdate() {\n        this.platform.updateService?.checkForUpdate();\n    }\n\n    get showUpdateButton() {\n        return !!this.platform.updateService;\n    }\n\n    get keyBackupViewModel() {\n        return this._keyBackupViewModel;\n    }\n\n    get storageQuota() {\n        return this._formatBytes(this._estimate?.quota);\n    }\n\n    get storageUsage() {\n        return this._formatBytes(this._estimate?.usage);\n    }\n\n    _formatBytes(n) {\n        if (typeof n === \"number\") {\n            return Math.round(n / (1024 * 1024)).toFixed(1) + \" MB\";\n        } else {\n            return this.i18n`unknown`;\n        }\n    }\n\n    async exportLogs() {\n        const logExport = await this.logger.export();\n        this.platform.saveFileAs(logExport.asBlob(), `hydrogen-logs-${this.platform.clock.now()}.json`);\n    }\n\n    async togglePushNotifications() {\n        this.pushNotifications.updating = true;\n        this.pushNotifications.enabledOnServer = null;\n        this.pushNotifications.serverError = null;\n        this.emitChange(\"pushNotifications.updating\");\n        try {\n            if (await this._session.enablePushNotifications(!this.pushNotifications.enabled)) {\n                this.pushNotifications.enabled = !this.pushNotifications.enabled;\n                if (this.pushNotifications.enabled) {\n                    this.platform.notificationService.showNotification(this.i18n`Push notifications are now enabled`);\n                }\n            }\n        } finally {\n        this.pushNotifications.updating = false;\n            this.emitChange(\"pushNotifications.updating\");\n        }\n    }\n\n    async checkPushEnabledOnServer() {\n        this.pushNotifications.enabledOnServer = null;\n        this.pushNotifications.serverError = null;\n        try {\n            this.pushNotifications.enabledOnServer = await this._session.checkPusherEnabledOnHomeserver();\n            this.emitChange(\"pushNotifications.enabledOnServer\");\n        } catch (err) {\n            this.pushNotifications.serverError = err;\n            this.emitChange(\"pushNotifications.serverError\");\n        }\n    }\n}\n\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../ViewModel.js\";\nimport {imageToInfo} from \"./common.js\";\nimport {RoomType} from \"../../matrix/room/common\";\n\nexport class CreateRoomViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {session} = options;\n        this._session = session;\n        this._name = undefined;\n        this._topic = undefined;\n        this._roomAlias = undefined;\n        this._isPublic = false;\n        this._isEncrypted = true;\n        this._isAdvancedShown = false;\n        this._isFederationDisabled = false;\n        this._avatarScaledBlob = undefined;\n        this._avatarFileName = undefined;\n        this._avatarInfo = undefined;\n    }\n\n    get isPublic() { return this._isPublic; }\n    get isEncrypted() { return this._isEncrypted; }\n    get canCreate() { return !!this._name; }\n    avatarUrl() { return this._avatarScaledBlob.url; }\n    get avatarTitle() { return this._name; }\n    get avatarLetter() { return \"\"; }\n    get avatarColorNumber() { return 0; }\n    get hasAvatar() { return !!this._avatarScaledBlob; }\n    get isFederationDisabled() { return this._isFederationDisabled; }\n    get isAdvancedShown() { return this._isAdvancedShown; }\n\n    setName(name) {\n        this._name = name;\n        this.emitChange(\"canCreate\");\n    }\n\n    setRoomAlias(roomAlias) {\n        this._roomAlias = roomAlias;\n    }\n\n    setTopic(topic) {\n        this._topic = topic;\n    }\n\n    setPublic(isPublic) {\n        this._isPublic = isPublic;\n        this.emitChange(\"isPublic\");\n    }\n\n    setEncrypted(isEncrypted) {\n        this._isEncrypted = isEncrypted;\n        this.emitChange(\"isEncrypted\");\n    }\n\n    setFederationDisabled(disable) {\n        this._isFederationDisabled = disable;\n        this.emitChange(\"isFederationDisabled\");\n    }\n\n    toggleAdvancedShown() {\n        this._isAdvancedShown = !this._isAdvancedShown;\n        this.emitChange(\"isAdvancedShown\");\n    }\n\n    create() {\n        let avatar;\n        if (this._avatarScaledBlob) {\n            avatar = {\n                info: this._avatarInfo,\n                name: this._avatarFileName,\n                blob: this._avatarScaledBlob\n            }\n        }\n        const roomBeingCreated = this._session.createRoom({\n            type: this.isPublic ? RoomType.Public : RoomType.Private,\n            name: this._name ?? undefined,\n            topic: this._topic ?? undefined,\n            isEncrypted: !this.isPublic && this._isEncrypted,\n            isFederationDisabled: this._isFederationDisabled,\n            alias: this.isPublic ? ensureAliasIsLocalPart(this._roomAlias) : undefined,\n            avatar,\n        });\n        this.navigation.push(\"room\", roomBeingCreated.id);\n    }\n\n    async selectAvatar() {\n        if (!this.platform.hasReadPixelPermission()) {\n            alert(\"Please allow canvas image data access, so we can scale your images down.\");\n            return;\n        }\n        if (this._avatarScaledBlob) {\n            this._avatarScaledBlob.dispose();\n        }\n        this._avatarScaledBlob = undefined;\n        this._avatarFileName = undefined;\n        this._avatarInfo = undefined;\n\n        const file = await this.platform.openFile(\"image/*\");\n        if (!file || !file.blob.mimeType.startsWith(\"image/\")) {\n            // allow to clear the avatar by not selecting an image\n            this.emitChange(\"hasAvatar\");\n            return;\n        }\n        let image = await this.platform.loadImage(file.blob);\n        const limit = 800;\n        if (image.maxDimension > limit) {\n            const scaledImage = await image.scale(limit);\n            image.dispose();\n            image = scaledImage;\n        }\n        this._avatarScaledBlob = image.blob;\n        this._avatarInfo = imageToInfo(image);\n        this._avatarFileName = file.name;\n        this.emitChange(\"hasAvatar\");\n    }\n}\n\nfunction ensureAliasIsLocalPart(roomAliasLocalPart) {\n    if (roomAliasLocalPart.startsWith(\"#\")) {\n        roomAliasLocalPart = roomAliasLocalPart.substr(1);\n    }\n    const colonIdx = roomAliasLocalPart.indexOf(\":\");\n    if (colonIdx !== -1) {\n        roomAliasLocalPart = roomAliasLocalPart.substr(0, colonIdx);\n    }\n    return roomAliasLocalPart;\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ObservableValue} from \"../../observable/ObservableValue\";\nimport {RoomStatus} from \"../../matrix/room/common\";\n\n/**\nDepending on the status of a room (invited, joined, archived, or none),\nwe want to show a different view with a different view model\nwhen showing a room. Furthermore, this logic is needed both in the \nsingle room view and in the grid view. So this logic is extracted here,\nand this observable updates with the right view model as the status for\na room changes.\n\nTo not have to track the subscription manually in the SessionViewModel and\nthe RoomGridViewModel, all subscriptions are removed in the dispose method.\nOnly when transferring a RoomViewModelObservable between the SessionViewModel\nand RoomGridViewModel, unsubscribeAll should be  called prior to doing\nthe transfer, so either parent view model don't keep getting updates for\nthe now transferred child view model.\n\nThis is also why there is an explicit initialize method, see comment there.\n*/\nexport class RoomViewModelObservable extends ObservableValue {\n    constructor(sessionViewModel, roomIdOrLocalId) {\n        super(null);\n        this._statusSubscription = null;\n        this._sessionViewModel = sessionViewModel;\n        this.id = roomIdOrLocalId;\n    }\n\n    /**\n    Separate initialize method rather than doing this onSubscribeFirst because \n    we don't want to run this again when transferring this value between\n    SessionViewModel and RoomGridViewModel, as onUnsubscribeLast and onSubscribeFirst\n    are called in that case.\n    */\n    async initialize() {\n        const {session} = this._sessionViewModel._client;\n        const statusObservable = await session.observeRoomStatus(this.id);\n        this.set(await this._statusToViewModel(statusObservable.get()));\n        this._statusSubscription = statusObservable.subscribe(async status => {\n            // first dispose existing VM, if any\n            this.get()?.dispose();\n            this.set(await this._statusToViewModel(status));\n        });\n    }\n\n    async _statusToViewModel(status) {\n        if (status & RoomStatus.Replaced) {\n            if (status & RoomStatus.BeingCreated) {\n                const {session} = this._sessionViewModel._client;\n                const roomBeingCreated = session.roomsBeingCreated.get(this.id);\n                this._sessionViewModel.notifyRoomReplaced(roomBeingCreated.id, roomBeingCreated.roomId);\n            } else {\n                throw new Error(\"Don't know how to replace a room with this status: \" + (status ^ RoomStatus.Replaced));\n            }\n        } else if (status & RoomStatus.BeingCreated) {\n            return this._sessionViewModel._createRoomBeingCreatedViewModel(this.id);\n        } else if (status & RoomStatus.Invited) {\n            return this._sessionViewModel._createInviteViewModel(this.id);\n        } else if (status & RoomStatus.Joined) {\n            return this._sessionViewModel._createRoomViewModelInstance(this.id);\n        } else if (status & RoomStatus.Archived) {\n            return await this._sessionViewModel._createArchivedRoomViewModel(this.id);\n        } else {\n            return this._sessionViewModel._createUnknownRoomViewModel(this.id);\n        }\n    }\n\n    dispose() {\n        if (this._statusSubscription) {\n            this._statusSubscription = this._statusSubscription();\n        }\n        this.unsubscribeAll();\n        this.get()?.dispose();\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../../ViewModel.js\";\nimport {avatarInitials, getIdentifierColorNumber, getAvatarHttpUrl} from \"../../avatar.js\";\n\nexport class RoomDetailsViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._room = options.room;\n        this._onRoomChange = this._onRoomChange.bind(this);\n        this._room.on(\"change\", this._onRoomChange);\n    }\n\n    get type() {\n        return \"room-details\";\n    }\n\n    get shouldShowBackButton() {\n        return false;\n    }\n\n    get previousSegmentName() {\n        return false;\n    }\n\n    get roomId() {\n        return this._room.id;\n    }\n\n    get canonicalAlias() {\n        return this._room.canonicalAlias;\n    }\n\n    get name() {\n        return this._room.name;\n    }\n\n    get isEncrypted() {\n        return !!this._room.isEncrypted;\n    }\n\n    get memberCount() {\n        return this._room.joinedMemberCount;\n    }\n\n    get avatarLetter() {\n        return avatarInitials(this.name);\n    }\n\n    get avatarColorNumber() {\n        return getIdentifierColorNumber(this._room.avatarColorId)\n    }\n\n    avatarUrl(size) {\n        return getAvatarHttpUrl(this._room.avatarUrl, size, this.platform, this._room.mediaRepository);\n    }\n\n    get avatarTitle() {\n        return this.name;\n    }\n\n    _onRoomChange() {\n        this.emitChange();\n    }\n\n    dispose() {\n        super.dispose();\n        this._room.off(\"change\", this._onRoomChange);\n    }\n\n    openPanel(segment) {\n        let path = this.navigation.path.until(\"room\");\n        path = path.with(this.navigation.segment(\"right-panel\", true));\n        path = path.with(this.navigation.segment(segment, true));\n        this.navigation.applyPath(path);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../../ViewModel.js\";\nimport {avatarInitials, getIdentifierColorNumber, getAvatarHttpUrl} from \"../../avatar.js\";\n\nexport class MemberTileViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._member = this._options.member;\n        this._mediaRepository = options.mediaRepository\n        this._previousName = null;\n        this._nameChanged = true;\n    }\n\n    get name() {\n        return `${this._member.name}${this._disambiguationPart}`;\n    }\n\n    get _disambiguationPart() {\n        return this._disambiguate ? ` (${this.userId})` : \"\";\n    }\n\n    get userId() {\n        return this._member.userId;\n    }\n\n    get previousName() {\n        return this._previousName;\n    }\n\n    get nameChanged() {\n        return this._nameChanged;\n    }\n\n    get detailsUrl() {\n        const roomId = this.navigation.path.get(\"room\").value;\n        return `${this.urlCreator.openRoomActionUrl(roomId)}/member/${this._member.userId}`;\n    }\n\n    _updatePreviousName(newName) {\n        const currentName = this._member.name;\n        if (currentName !== newName) {\n            this._previousName = currentName;\n            this._nameChanged = true;\n        } else {\n            this._nameChanged = false;\n        }\n    }\n\n    setDisambiguation(status) {\n        this._disambiguate = status;\n        this.emitChange();\n    }\n\n    updateFrom(newMember) {\n        this._updatePreviousName(newMember.name);\n        this._member = newMember;\n    }\n\n    get avatarLetter() {\n        return avatarInitials(this.name);\n    }\n\n    get avatarColorNumber() {\n        return getIdentifierColorNumber(this.userId)\n    }\n\n    avatarUrl(size) {\n        return getAvatarHttpUrl(this._member.avatarUrl, size, this.platform, this._mediaRepository);\n    }\n\n    get avatarTitle() {\n        return this.name;\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {PowerLevels} from \"../../../../matrix/room/PowerLevels.js\";\n\nexport function createMemberComparator(powerLevels) {\n    const collator = new Intl.Collator();\n    const removeCharacter = string => string.charAt(0) === \"@\"? string.slice(1) : string;\n\n    return function comparator(member, otherMember) {\n        const p1 = powerLevels.getUserLevel(member.userId);\n        const p2 = powerLevels.getUserLevel(otherMember.userId);\n        if (p1 !== p2) { return p2 - p1; }\n        const name = removeCharacter(member.name);\n        const otherName = removeCharacter(otherMember.name);\n        return collator.compare(name, otherName);\n    };\n}\n\nexport function tests() {\n\n    function createComparatorWithPowerLevel(map) {\n        let users = {};\n        for (const prop in map) {\n            Object.assign(users, {[prop]: map[prop]});\n        }\n        const powerLevelEvent = {\n            content: {users, users_default: 0}\n        };\n        return createMemberComparator(new PowerLevels({powerLevelEvent}));\n    }\n\n    return {\n        \"power_level(member1) > power_level(member2) returns value <= 0\": assert => {\n            const fn = createComparatorWithPowerLevel({\"@alice:hs.tld\": 50});\n            const member1 = {userId: \"@alice:hs.tld\", name: \"alice\"};\n            const member2 = {userId: \"@bob:hs.tld\", name: \"bob\"};\n            assert.strictEqual(fn(member1, member2) <= 0, true);\n        },\n\n        \"power_level(member1) < power_level(member2) returns value > 0\": assert => {\n            const fn = createComparatorWithPowerLevel({\"@alice:hs.tld\": 50});\n            const member1 = {userId: \"@bob:hs.tld\", name: \"bob\"};\n            const member2 = {userId: \"@alice:hs.tld\", name: \"alice\"};\n            assert.strictEqual(fn(member1, member2) > 0, true);\n        },\n\n        \"alphabetic compare on name\": assert => {\n            const fn = createComparatorWithPowerLevel();\n            const member1 = {userId: \"@bob:hs.tld\", name: \"bob\"};\n            const member2 = {userId: \"@alice:hs.tld\", name: \"alice\"};\n            assert.strictEqual(fn(member1, member2) > 0, true);\n            assert.strictEqual(fn(member2, member1) <= 0, true);\n        },\n\n        \"alphabetic compare with case (alice comes before Bob)\": assert => {\n            const fn = createComparatorWithPowerLevel();\n            const member1 = {userId: \"@bob:hs.tld\", name: \"Bob\"};\n            const member2 = {userId: \"@alice:hs.tld\", name: \"alice\"};\n            assert.strictEqual(fn(member1, member2) > 0, true);\n            assert.strictEqual(fn(member2, member1) <= 0, true);\n        },\n\n        \"equal powerlevel and same names returns 0\": assert => {\n            const fn = createComparatorWithPowerLevel({\"@bobby:hs.tld\": 50, \"@bob:hs.tld\": 50});\n            const member1 = {userId: \"@bob:hs.tld\", name: \"bob\"};\n            const member2 = {userId: \"@bobby:hs.tld\", name: \"bob\"};\n            assert.strictEqual(fn(member1, member2), 0);\n            assert.strictEqual(fn(member2, member1), 0);\n        },\n\n        \"(both_negative_powerlevel) power_level(member1) < power_level(member2) returns value > 0\": assert => {\n            const fn = createComparatorWithPowerLevel({\"@alice:hs.tld\": -100, \"@bob:hs.tld\": -50});\n            const member1 = {userId: \"@alice:hs.tld\", name: \"alice\"};\n            const member2 = {userId: \"@bob:hs.tld\", name: \"bob\"};\n            assert.strictEqual(fn(member1, member2) > 0, true);\n        },\n\n        \"(both_negative_powerlevel) power_level(member1) > power_level(member2) returns value <= 0\": assert => {\n            const fn = createComparatorWithPowerLevel({\"@alice:hs.tld\": -50, \"@bob:hs.tld\": -100});\n            const member1 = {userId: \"@alice:hs.tld\", name: \"alice\"};\n            const member2 = {userId: \"@bob:hs.tld\", name: \"bob\"};\n            assert.strictEqual(fn(member1, member2) <= 0, true);\n        },\n\n        \"(one_negative_powerlevel) power_level(member1) > power_level(member2) returns value <= 0\": assert => {\n            const fn = createComparatorWithPowerLevel({\"@alice:hs.tld\": 50, \"@bob:hs.tld\": -100});\n            const member1 = {userId: \"@alice:hs.tld\", name: \"alice\"};\n            const member2 = {userId: \"@bob:hs.tld\", name: \"bob\"};\n            assert.strictEqual(fn(member1, member2) <= 0, true);\n        },\n\n        \"(one_negative_powerlevel) power_level(member1) < power_level(member2) returns value > 0\": assert => {\n            const fn = createComparatorWithPowerLevel({\"@alice:hs.tld\": -100, \"@bob:hs.tld\": 50});\n            const member1 = {userId: \"@alice:hs.tld\", name: \"alice\"};\n            const member2 = {userId: \"@bob:hs.tld\", name: \"bob\"};\n            assert.strictEqual(fn(member1, member2) > 0, true);\n        },\n    };\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class Disambiguator {\n    constructor() {\n        this._map = new Map();\n    }\n\n    _unDisambiguate(vm, array) {\n        const idx = array.indexOf(vm);\n        if (idx !== -1) {\n            const [removed] = array.splice(idx, 1);\n            removed.setDisambiguation(false);\n        }\n    }\n\n    _handlePreviousName(vm) {\n        const previousName = vm.previousName;\n        if (typeof previousName !== \"string\") { return; }\n        const value = this._map.get(previousName);\n        if (Array.isArray(value)) {\n            this._unDisambiguate(vm, value);\n            if (value.length === 1) {\n                const vm = value[0];\n                vm.setDisambiguation(false);\n                this._map.set(previousName, vm);\n            }\n        } else {\n            this._map.delete(previousName);\n        }\n    }\n\n    _updateMap(vm) {\n        const name = vm.name;\n        const value = this._map.get(name);\n        if (value) {\n            if (Array.isArray(value)) {\n                if (value.findIndex(member => member.userId === vm.userId) !== -1) { return; }\n                value.push(vm);\n                return value;\n            } else if(vm.userId !== value.userId) {\n                const array = [value, vm]\n                this._map.set(name, array);\n                return array;\n            }\n        } else {\n            this._map.set(name, vm);\n        }\n    }\n\n    disambiguate(vm) {\n        if (!vm.nameChanged) { return; }\n        this._handlePreviousName(vm);\n        const value = this._updateMap(vm);\n        value?.forEach((vm) => vm.setDisambiguation(true));\n    }\n}\n\nexport function tests(){\n\n    class MockViewModel {\n        constructor(name, userId) {\n            this.name = name;\n            this.disambiguate = false;\n            this.userId = userId;\n            this.nameChanged = true;\n        }\n        \n        updateName(newName) {\n            if (this.name !== newName) {\n                this.previousName = this.name;\n                this.nameChanged = true;\n            }\n            else {\n                this.nameChanged = false;\n            }\n            this.name = newName;\n        }\n\n        setDisambiguation(status) {\n            this.disambiguate = status;\n        }\n    }\n\n    function createVmAndDisambiguator(nameList) {\n        const d = new Disambiguator();\n        const array = nameList.map(([name, id]) => new MockViewModel(name, id));\n        return [...array, d];\n    }\n\n    return {\n        \"Unique names\": assert => {\n            const [vm1, vm2, d] = createVmAndDisambiguator([[\"foo\", \"a\"], [\"bar\", \"b\"]]);\n            d.disambiguate(vm1);\n            d.disambiguate(vm2);\n            assert.strictEqual(vm1.disambiguate, false);\n            assert.strictEqual(vm2.disambiguate, false);\n        },\n\n        \"Same names are disambiguated\": assert => {\n            const [vm1, vm2, vm3, d] = createVmAndDisambiguator([[\"foo\", \"a\"], [\"foo\", \"b\"], [\"foo\", \"c\"]]);\n            d.disambiguate(vm1);\n            d.disambiguate(vm2);\n            d.disambiguate(vm3);\n            assert.strictEqual(vm1.disambiguate, true);\n            assert.strictEqual(vm2.disambiguate, true);\n            assert.strictEqual(vm3.disambiguate, true);\n        },\n\n        \"Name updates disambiguate\": assert => {\n            const [vm1, vm2, vm3, d] = createVmAndDisambiguator([[\"foo\", \"a\"], [\"bar\", \"b\"], [\"jar\", \"c\"]]);\n            d.disambiguate(vm1);\n            d.disambiguate(vm2);\n            d.disambiguate(vm3);\n            \n            vm2.updateName(\"foo\");\n            d.disambiguate(vm2);\n            assert.strictEqual(vm1.disambiguate, true);\n            assert.strictEqual(vm2.disambiguate, true);\n\n            vm1.updateName(\"bar\");\n            d.disambiguate(vm1);\n            assert.strictEqual(vm1.disambiguate, false);\n            assert.strictEqual(vm2.disambiguate, false);\n\n            vm3.updateName(\"foo\");\n            d.disambiguate(vm3);\n            vm1.updateName(\"foo\");\n            d.disambiguate(vm1);\n            assert.strictEqual(vm1.disambiguate, true);\n            assert.strictEqual(vm2.disambiguate, true);\n            assert.strictEqual(vm3.disambiguate, true);\n\n            vm2.updateName(\"bar\");\n            d.disambiguate(vm2);\n            assert.strictEqual(vm1.disambiguate, true);\n            assert.strictEqual(vm2.disambiguate, false);\n            assert.strictEqual(vm3.disambiguate, true);\n        },\n\n        \"Multiple disambiguate events\": assert => {\n            const [vm1, d] = createVmAndDisambiguator([[\"foo\", \"a\"]]);\n            d.disambiguate(vm1);\n            vm1.updateName(vm1.name);\n            d.disambiguate(vm1);\n            assert.strictEqual(vm1.disambiguate, false);\n        },\n\n        \"Empty names must un-disambiguate\": assert => {\n            const [vm1, vm2, d] = createVmAndDisambiguator([[\"\", \"a\"], [\"\", \"b\"]]);\n            d.disambiguate(vm1);\n            d.disambiguate(vm2);\n            vm1.updateName(\"foo\");\n            d.disambiguate(vm1);\n            assert.strictEqual(vm1.disambiguate, false);\n            assert.strictEqual(vm2.disambiguate, false);\n        }\n    };\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../../ViewModel.js\";\nimport {MemberTileViewModel} from \"./MemberTileViewModel.js\";\nimport {createMemberComparator} from \"./members/comparator.js\";\nimport {Disambiguator} from \"./members/disambiguator.js\";\n\nexport class MemberListViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const list = options.members;\n\n        const powerLevelsObservable = options.powerLevelsObservable;\n        this.track(powerLevelsObservable.subscribe(() => { /*resort based on new power levels here*/ }));\n\n        const powerLevels = powerLevelsObservable.get();\n        this.memberTileViewModels = this._mapTileViewModels(list.members.filterValues(member => member.membership === \"join\"))\n                                        .sortValues(createMemberComparator(powerLevels));\n        this.nameDisambiguator = new Disambiguator();\n        this.mediaRepository = options.mediaRepository;\n    }\n\n    get type() { return \"member-list\"; }\n\n    get shouldShowBackButton() { return true; }\n\n    get previousSegmentName() { return \"details\"; }\n\n    _mapTileViewModels(members) {\n        const mapper = (member, emitChange) => {\n            const mediaRepository = this.mediaRepository;\n            const vm = new MemberTileViewModel(this.childOptions({member, emitChange, mediaRepository}));\n            this.nameDisambiguator.disambiguate(vm);\n            return vm;\n        }\n        const updater = (vm, params, newMember) => {\n            vm.updateFrom(newMember);\n            this.nameDisambiguator.disambiguate(vm);\n        };\n        return members.mapValues(mapper, updater);\n    }\n\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../../ViewModel.js\";\nimport {RoomType} from \"../../../matrix/room/common\";\nimport {avatarInitials, getIdentifierColorNumber, getAvatarHttpUrl} from \"../../avatar.js\";\n\nexport class MemberDetailsViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._observableMember = options.observableMember;\n        this._mediaRepository = options.mediaRepository;\n        this._member = this._observableMember.get();\n        this._isEncrypted = options.isEncrypted;\n        this._powerLevelsObservable = options.powerLevelsObservable;\n        this._session = options.session;\n        this.track(this._powerLevelsObservable.subscribe(() => this._onPowerLevelsChange()));\n        this.track(this._observableMember.subscribe( () => this._onMemberChange()));\n    }\n\n    get name() { return this._member.name; }\n    get userId() { return this._member.userId; }\n\n    get type() { return \"member-details\"; }\n    get shouldShowBackButton() { return true; }\n    get previousSegmentName() { return \"members\"; }\n    \n    get role() {\n        if (this.powerLevel >= 100) { return this.i18n`Admin`; }\n        else if (this.powerLevel >= 50) { return this.i18n`Moderator`; }\n        else if (this.powerLevel === 0) { return this.i18n`Default`; }\n        else { return this.i18n`Custom (${this.powerLevel})`; }\n    }\n\n    _onMemberChange() {\n        this._member = this._observableMember.get();\n        this.emitChange(\"member\");\n    }\n\n    _onPowerLevelsChange() {\n        this.emitChange(\"role\");\n    }\n\n    get avatarLetter() {\n        return avatarInitials(this.name);\n    }\n\n    get avatarColorNumber() {\n        return getIdentifierColorNumber(this.userId)\n    }\n\n    avatarUrl(size) {\n        return getAvatarHttpUrl(this._member.avatarUrl, size, this.platform, this._mediaRepository);\n    }\n\n    get avatarTitle() {\n        return this.name;\n    }\n\n    get isEncrypted() {\n        return this._isEncrypted;\n    }\n\n    get powerLevel() {\n        return this._powerLevelsObservable.get()?.getUserLevel(this._member.userId);\n    }\n\n    get linkToUser() {\n        return `https://matrix.to/#/${encodeURIComponent(this._member.userId)}`;\n    }\n\n    async openDirectMessage() {\n        const room = this._session.findDirectMessageForUserId(this.userId);\n        let roomId = room?.id;\n        if (!roomId) {\n            const roomBeingCreated = await this._session.createRoom({\n                type: RoomType.DirectMessage,\n                invites: [this.userId]\n            });\n            roomId = roomBeingCreated.id;\n        }\n        this.navigation.push(\"room\", roomId);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../../ViewModel.js\";\nimport {RoomDetailsViewModel} from \"./RoomDetailsViewModel.js\";\nimport {MemberListViewModel} from \"./MemberListViewModel.js\";\nimport {MemberDetailsViewModel} from \"./MemberDetailsViewModel.js\";\n\nexport class RightPanelViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._room = options.room;\n        this._session = options.session;\n        this._members = null;\n        this._setupNavigation();\n    }\n\n    get activeViewModel() { return this._activeViewModel; }\n\n    async _getMemberListArguments() {\n        if (!this._members) {\n            this._members = await this._room.loadMemberList();\n            this.track(() => this._members.release());\n        }\n        const room = this._room;\n        const powerLevelsObservable = await this._room.observePowerLevels();\n        return {members: this._members, powerLevelsObservable, mediaRepository: room.mediaRepository};\n    }\n\n    async _getMemberDetailsArguments() {\n        const segment = this.navigation.path.get(\"member\"); \n        const userId = segment.value;\n        const observableMember = await this._room.observeMember(userId);\n        if (!observableMember) {\n            return false;\n        }\n        const isEncrypted = this._room.isEncrypted;\n        const powerLevelsObservable = await this._room.observePowerLevels();\n        return {\n            observableMember,\n            isEncrypted,\n            powerLevelsObservable,\n            mediaRepository: this._room.mediaRepository,\n            session: this._session\n        };\n    }\n\n    _setupNavigation() {\n        this._hookUpdaterToSegment(\"details\", RoomDetailsViewModel, () => { return {room: this._room}; });\n        this._hookUpdaterToSegment(\"members\", MemberListViewModel, () => this._getMemberListArguments());\n        this._hookUpdaterToSegment(\"member\", MemberDetailsViewModel, () => this._getMemberDetailsArguments(),\n            () => {\n                // If we fail to create the member details panel, fallback to memberlist\n                const url = `${this.urlCreator.urlUntilSegment(\"room\")}/members`;\n                this.urlCreator.pushUrl(url);\n            }\n        );\n    }\n\n    _hookUpdaterToSegment(segment, viewmodel, argCreator, failCallback) {\n        const observable = this.navigation.observe(segment);\n        const updater = this._setupUpdater(segment, viewmodel, argCreator, failCallback);\n        this.track(observable.subscribe(updater));\n    }\n\n    _setupUpdater(segment, viewmodel, argCreator, failCallback) {\n        const updater = async (skipDispose = false) => {\n            if (!skipDispose) {\n                this._activeViewModel = this.disposeTracked(this._activeViewModel);\n            }\n            const enable = !!this.navigation.path.get(segment)?.value;\n            if (enable) {\n                const args = await argCreator();\n                if (!args && failCallback) {\n                    failCallback();\n                    return;\n                }\n                this._activeViewModel = this.track(new viewmodel(this.childOptions(args)));\n            }\n            this.emitChange(\"activeViewModel\");\n        };\n        updater(true);\n        return updater;\n    }\n\n    closePanel() {\n        const path = this.navigation.path.until(\"room\");\n        this.navigation.applyPath(path);\n    }\n\n    showPreviousPanel() {\n        const segmentName = this.activeViewModel.previousSegmentName;\n        if (segmentName) {\n            let path = this.navigation.path.until(\"room\");\n            path = path.with(this.navigation.segment(\"right-panel\", true));\n            path = path.with(this.navigation.segment(segmentName, true));\n            this.navigation.applyPath(path);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {LeftPanelViewModel} from \"./leftpanel/LeftPanelViewModel.js\";\nimport {RoomViewModel} from \"./room/RoomViewModel.js\";\nimport {UnknownRoomViewModel} from \"./room/UnknownRoomViewModel.js\";\nimport {InviteViewModel} from \"./room/InviteViewModel.js\";\nimport {RoomBeingCreatedViewModel} from \"./room/RoomBeingCreatedViewModel.js\";\nimport {LightboxViewModel} from \"./room/LightboxViewModel.js\";\nimport {SessionStatusViewModel} from \"./SessionStatusViewModel.js\";\nimport {RoomGridViewModel} from \"./RoomGridViewModel.js\";\nimport {SettingsViewModel} from \"./settings/SettingsViewModel.js\";\nimport {CreateRoomViewModel} from \"./CreateRoomViewModel.js\";\nimport {ViewModel} from \"../ViewModel.js\";\nimport {RoomViewModelObservable} from \"./RoomViewModelObservable.js\";\nimport {RightPanelViewModel} from \"./rightpanel/RightPanelViewModel.js\";\n\nexport class SessionViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {client} = options;\n        this._client = this.track(client);\n        this._sessionStatusViewModel = this.track(new SessionStatusViewModel(this.childOptions({\n            sync: client.sync,\n            reconnector: client.reconnector,\n            session: client.session,\n        })));\n        this._leftPanelViewModel = this.track(new LeftPanelViewModel(this.childOptions({session: this._client.session})));\n        this._settingsViewModel = null;\n        this._roomViewModelObservable = null;\n        this._gridViewModel = null;\n        this._createRoomViewModel = null;\n        this._setupNavigation();\n    }\n\n    _setupNavigation() {\n        const gridRooms = this.navigation.observe(\"rooms\");\n        // this gives us a set of room ids in the grid\n        this.track(gridRooms.subscribe(roomIds => {\n            this._updateGrid(roomIds);\n        }));\n        if (gridRooms.get()) {\n            this._updateGrid(gridRooms.get());\n        }\n\n        const currentRoomId = this.navigation.observe(\"room\");\n        // this gives us the active room\n        this.track(currentRoomId.subscribe(roomId => {\n            if (!this._gridViewModel) {\n                this._updateRoom(roomId);\n            }\n            this._updateRightPanel();\n        }));\n        if (!this._gridViewModel) {\n            this._updateRoom(currentRoomId.get());\n        }\n\n        const settings = this.navigation.observe(\"settings\");\n        this.track(settings.subscribe(settingsOpen => {\n            this._updateSettings(settingsOpen);\n        }));\n        this._updateSettings(settings.get());\n\n        const createRoom = this.navigation.observe(\"create-room\");\n        this.track(createRoom.subscribe(createRoomOpen => {\n            this._updateCreateRoom(createRoomOpen);\n        }));\n        this._updateCreateRoom(createRoom.get());\n\n        const lightbox = this.navigation.observe(\"lightbox\");\n        this.track(lightbox.subscribe(eventId => {\n            this._updateLightbox(eventId);\n        }));\n        this._updateLightbox(lightbox.get());\n\n\n        const rightpanel = this.navigation.observe(\"right-panel\");\n        this.track(rightpanel.subscribe(() => this._updateRightPanel()));\n        this._updateRightPanel();\n    }\n\n    get id() {\n        return this._client.sessionId;\n    }\n\n    start() {\n        this._sessionStatusViewModel.start();\n    }\n\n    get activeMiddleViewModel() {\n        return this._roomViewModelObservable?.get() || this._gridViewModel || this._settingsViewModel || this._createRoomViewModel;\n    }\n\n    get roomGridViewModel() {\n        return this._gridViewModel;\n    }\n\n    get leftPanelViewModel() {\n        return this._leftPanelViewModel;\n    }\n\n    get sessionStatusViewModel() {\n        return this._sessionStatusViewModel;\n    }\n\n    get settingsViewModel() {\n        return this._settingsViewModel;\n    }\n\n    get currentRoomViewModel() {\n        return this._roomViewModelObservable?.get();\n    }\n\n    get rightPanelViewModel() {\n        return this._rightPanelViewModel;\n    }\n\n    get createRoomViewModel() {\n        return this._createRoomViewModel;\n    }\n\n    _updateGrid(roomIds) {\n        const changed = !(this._gridViewModel && roomIds);\n        const currentRoomId = this.navigation.path.get(\"room\");\n        if (roomIds) {\n            if (!this._gridViewModel) {\n                this._gridViewModel = this.track(new RoomGridViewModel(this.childOptions({\n                    width: 3,\n                    height: 2,\n                    createRoomViewModelObservable: roomId => new RoomViewModelObservable(this, roomId),\n                })));\n                // try to transfer the current room view model, so we don't have to reload the timeline\n                this._roomViewModelObservable?.unsubscribeAll();\n                if (this._gridViewModel.initializeRoomIdsAndTransferVM(roomIds, this._roomViewModelObservable)) {\n                    this._roomViewModelObservable = this.untrack(this._roomViewModelObservable);\n                } else if (this._roomViewModelObservable) {\n                    this._roomViewModelObservable = this.disposeTracked(this._roomViewModelObservable);\n                }\n            } else {\n                this._gridViewModel.setRoomIds(roomIds);\n            }\n        } else if (this._gridViewModel && !roomIds) {\n            // closing grid, try to show focused room in grid\n            if (currentRoomId) {\n                const vmo = this._gridViewModel.releaseRoomViewModel(currentRoomId.value);\n                if (vmo) {\n                    this._roomViewModelObservable = this.track(vmo);\n                    this._roomViewModelObservable.subscribe(() => {\n                        this.emitChange(\"activeMiddleViewModel\");\n                    });\n                }\n            }\n            this._gridViewModel = this.disposeTracked(this._gridViewModel);\n        }\n        if (changed) {\n            this.emitChange(\"activeMiddleViewModel\");\n        }\n    }\n\n    _createRoomViewModelInstance(roomId) {\n        const room = this._client.session.rooms.get(roomId);\n        if (room) {\n            const roomVM = new RoomViewModel(this.childOptions({room}));\n            roomVM.load();\n            return roomVM;\n        }\n        return null;\n    }\n\n    _createUnknownRoomViewModel(roomIdOrAlias) {\n        return new UnknownRoomViewModel(this.childOptions({\n            roomIdOrAlias,\n            session: this._client.session,\n        }));\n    }\n\n    async _createArchivedRoomViewModel(roomId) {\n        const room = await this._client.session.loadArchivedRoom(roomId);\n        if (room) {\n            const roomVM = new RoomViewModel(this.childOptions({room}));\n            roomVM.load();\n            return roomVM;\n        }\n        return null;\n    }\n\n    _createInviteViewModel(roomId) {\n        const invite = this._client.session.invites.get(roomId);\n        if (invite) {\n            return new InviteViewModel(this.childOptions({\n                invite,\n                mediaRepository: this._client.session.mediaRepository,\n            }));\n        }\n        return null;\n    }\n\n    _createRoomBeingCreatedViewModel(localId) {\n        const roomBeingCreated = this._client.session.roomsBeingCreated.get(localId);\n        if (roomBeingCreated) {\n            return new RoomBeingCreatedViewModel(this.childOptions({\n                roomBeingCreated,\n                mediaRepository: this._client.session.mediaRepository,\n            }));\n        }\n        return null;\n    }\n\n    _updateRoom(roomId) {\n        // opening a room and already open?\n        if (this._roomViewModelObservable?.id === roomId) {\n            return;\n        }\n        // close if needed\n        if (this._roomViewModelObservable) {\n            this._roomViewModelObservable = this.disposeTracked(this._roomViewModelObservable);\n        }\n        if (!roomId) {\n            // if clearing the activeMiddleViewModel rather than changing to a different one,\n            // emit so the view picks it up and show the placeholder\n            this.emitChange(\"activeMiddleViewModel\");\n            return;\n        }\n        const vmo = new RoomViewModelObservable(this, roomId);\n        this._roomViewModelObservable = this.track(vmo);\n        // subscription is unsubscribed in RoomViewModelObservable.dispose, and thus handled by track\n        this._roomViewModelObservable.subscribe(() => {\n            this.emitChange(\"activeMiddleViewModel\");\n        });\n        vmo.initialize();\n    }\n\n    _updateSettings(settingsOpen) {\n        if (this._settingsViewModel) {\n            this._settingsViewModel = this.disposeTracked(this._settingsViewModel);\n        }\n        if (settingsOpen) {\n            this._settingsViewModel = this.track(new SettingsViewModel(this.childOptions({\n                client: this._client,\n            })));\n            this._settingsViewModel.load();\n        }\n        this.emitChange(\"activeMiddleViewModel\");\n    }\n\n    _updateCreateRoom(createRoomOpen) {\n        if (this._createRoomViewModel) {\n            this._createRoomViewModel = this.disposeTracked(this._createRoomViewModel);\n        }\n        if (createRoomOpen) {\n            this._createRoomViewModel = this.track(new CreateRoomViewModel(this.childOptions({session: this._client.session})));\n        }\n        this.emitChange(\"activeMiddleViewModel\");\n    }\n\n    _updateLightbox(eventId) {\n        if (this._lightboxViewModel) {\n            this._lightboxViewModel = this.disposeTracked(this._lightboxViewModel);\n        }\n        if (eventId) {\n            const room = this._roomFromNavigation();\n            this._lightboxViewModel = this.track(new LightboxViewModel(this.childOptions({eventId, room})));\n        }\n        this.emitChange(\"lightboxViewModel\");\n    }\n\n    get lightboxViewModel() {\n        return this._lightboxViewModel;\n    }\n\n    _roomFromNavigation() {\n        const roomId = this.navigation.path.get(\"room\")?.value;\n        const room = this._client.session.rooms.get(roomId);\n        return room;\n    }\n\n    _updateRightPanel() {\n        this._rightPanelViewModel = this.disposeTracked(this._rightPanelViewModel);\n        const enable = !!this.navigation.path.get(\"right-panel\")?.value;\n        if (enable) {\n            const room = this._roomFromNavigation();\n            this._rightPanelViewModel = this.track(new RightPanelViewModel(this.childOptions({room, session: this._client.session})));\n        }\n        this.emitChange(\"rightPanelViewModel\");\n    }\n\n    notifyRoomReplaced(oldId, newId) {\n        this.navigation.push(\"room\", newId);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"./ViewModel.js\";\nimport {KeyType} from \"../matrix/ssss/index\";\nimport {Status} from \"./session/settings/KeyBackupViewModel.js\";\n\nexport class AccountSetupViewModel extends ViewModel {\n    constructor(accountSetup) {\n        super();\n        this._accountSetup = accountSetup;\n        this._dehydratedDevice = undefined;\n        this._decryptDehydratedDeviceViewModel = undefined;\n        if (this._accountSetup.encryptedDehydratedDevice) {\n            this._decryptDehydratedDeviceViewModel = new DecryptDehydratedDeviceViewModel(this, dehydratedDevice => {\n                this._dehydratedDevice = dehydratedDevice;\n                this._decryptDehydratedDeviceViewModel = undefined;\n                this.emitChange(\"deviceDecrypted\");\n            });\n        }\n    }\n\n    get decryptDehydratedDeviceViewModel() {\n        return this._decryptDehydratedDeviceViewModel;\n    }\n\n    get deviceDecrypted() {\n        return !!this._dehydratedDevice;\n    }\n\n    get dehydratedDeviceId() {\n        return this._accountSetup.encryptedDehydratedDevice.deviceId;\n    }\n\n    finish() {\n        this._accountSetup.finish(this._dehydratedDevice);\n    }\n}\n\n// this vm adopts the same shape as KeyBackupViewModel so the same view can be reused.\nclass DecryptDehydratedDeviceViewModel extends ViewModel {\n    constructor(accountSetupViewModel, decryptedCallback) {\n        super();\n        this._accountSetupViewModel = accountSetupViewModel;\n        this._isBusy = false;\n        this._status = Status.SetupKey;\n        this._error = undefined;\n        this._decryptedCallback = decryptedCallback;\n    }\n\n    get decryptAction() {\n        return this.i18n`Restore`;\n    }\n\n    get purpose() {\n        return this.i18n`claim your dehydrated device`;\n    }\n\n    get offerDehydratedDeviceSetup() {\n        return false;\n    }\n\n    get dehydratedDeviceId() {\n        return this._accountSetupViewModel._dehydratedDevice?.deviceId;\n    }\n    \n    get isBusy() {\n        return this._isBusy;\n    }\n\n    get backupVersion() { return 0; }\n\n    get status() {\n        return this._status;\n    }\n\n    get error() {\n        return this._error?.message;\n    }\n\n    showPhraseSetup() {\n        if (this._status === Status.SetupKey) {\n            this._status = Status.SetupPhrase;\n            this.emitChange(\"status\");\n        }\n    }\n\n    showKeySetup() {\n        if (this._status === Status.SetupPhrase) {\n            this._status = Status.SetupKey;\n            this.emitChange(\"status\");\n        }\n    }\n\n    async _enterCredentials(keyType, credential) {\n        if (credential) {\n            try {\n                this._isBusy = true;\n                this.emitChange(\"isBusy\");\n                const {encryptedDehydratedDevice} = this._accountSetupViewModel._accountSetup;\n                const dehydratedDevice = await encryptedDehydratedDevice.decrypt(keyType, credential);\n                this._decryptedCallback(dehydratedDevice);\n            } catch (err) {\n                console.error(err);\n                this._error = err;\n                this.emitChange(\"error\");\n            } finally {\n                this._isBusy = false;\n                this.emitChange(\"\");\n            }\n        }\n    }\n\n    enterSecurityPhrase(passphrase) {\n        this._enterCredentials(KeyType.Passphrase, passphrase);\n    }\n\n    enterSecurityKey(securityKey) {\n        this._enterCredentials(KeyType.RecoveryKey, securityKey);\n    }\n\n    disable() {}\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {AccountSetupViewModel} from \"./AccountSetupViewModel.js\";\nimport {LoadStatus} from \"../matrix/Client.js\";\nimport {SyncStatus} from \"../matrix/Sync.js\";\nimport {ViewModel} from \"./ViewModel.js\";\n\nexport class SessionLoadViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {client, ready, homeserver, deleteSessionOnCancel} = options;\n        this._client = client;\n        this._ready = ready;\n        this._homeserver = homeserver;\n        this._deleteSessionOnCancel = deleteSessionOnCancel;\n        this._loading = false;\n        this._error = null;\n        this.backUrl = this.urlCreator.urlForSegment(\"session\", true);\n        this._accountSetupViewModel = undefined;\n\n    }\n\n    async start() {\n        if (this._loading) {\n            return;\n        }\n        try {\n            this._loading = true;\n            this.emitChange(\"loading\");\n            this._waitHandle = this._client.loadStatus.waitFor(s => {\n                if (s === LoadStatus.AccountSetup) {\n                    this._accountSetupViewModel = new AccountSetupViewModel(this._client.accountSetup);\n                } else {\n                    this._accountSetupViewModel = undefined;\n                }\n                this.emitChange(\"loadLabel\");\n                // wait for initial sync, but not catchup sync\n                const isCatchupSync = s === LoadStatus.FirstSync &&\n                    this._client.sync.status.get() === SyncStatus.CatchupSync;\n                return isCatchupSync ||\n                    s === LoadStatus.LoginFailed ||\n                    s === LoadStatus.Error ||\n                    s === LoadStatus.Ready;\n            });\n            try {\n                await this._waitHandle.promise;\n            } catch (err) {\n                return; // aborted by goBack\n            }\n            // TODO: should we deal with no connection during initial sync \n            // and we're retrying as well here?\n            // e.g. show in the label what is going on wrt connectionstatus\n            // much like we will once you are in the app. Probably a good idea\n\n            // did it finish or get stuck at LoginFailed or Error?\n            const loadStatus = this._client.loadStatus.get();\n            const loadError = this._client.loadError;\n            if (loadStatus === LoadStatus.FirstSync || loadStatus === LoadStatus.Ready) {\n                const client = this._client;\n                // session container is ready,\n                // don't dispose it anymore when \n                // we get disposed\n                this._client = null;\n                this._ready(client);\n            }\n            if (loadError) {\n                console.error(\"session load error\", loadError);\n            }\n        } catch (err) {\n            this._error = err;\n            console.error(\"error thrown during session load\", err.stack);\n        } finally {\n            this._loading = false;\n            // loadLabel in case of client.loadError also gets updated through this\n            this.emitChange(\"loading\");\n        }\n    }\n\n\n    dispose() {\n        if (this._client) {\n            this._client.dispose();\n            this._client = null;\n        }\n        if (this._waitHandle) {\n            // rejects with AbortError\n            this._waitHandle.dispose();\n            this._waitHandle = null;\n        }\n    }\n\n    // to show a spinner or not\n    get loading() {\n        const client = this._client;\n        if (client && client.loadStatus.get() === LoadStatus.AccountSetup) {\n            return false;\n        }\n        return this._loading;\n    }\n\n    get loadLabel() {\n        const client = this._client;\n        const error = this._getError();\n        if (error || (client && client.loadStatus.get() === LoadStatus.Error)) {\n            return `Something went wrong: ${error && error.message}.`;\n        }\n\n        // Statuses related to login are handled by respective login view models\n        if (client) {\n            switch (client.loadStatus.get()) {\n                case LoadStatus.QueryAccount:\n                    return `Querying account encryption setup…`;\n                case LoadStatus.AccountSetup:\n                    return \"\"; // we'll show a header ing AccountSetupView\n                case LoadStatus.SessionSetup:\n                    return `Setting up your encryption keys…`;\n                case LoadStatus.Loading:\n                    return `Loading your conversations…`;\n                case LoadStatus.FirstSync:\n                    return `Getting your conversations from the server…`;\n                default:\n                    return this._client.loadStatus.get();\n            }\n        }\n\n        return `Preparing…`;\n    }\n\n    _getError() {\n        return this._error || this._client?.loadError; \n    }\n\n    get hasError() {\n        return !!this._getError();\n    }\n\n    async exportLogs() {\n        const logExport = await this.logger.export();\n        this.platform.saveFileAs(logExport.asBlob(), `hydrogen-logs-${this.platform.clock.now()}.json`);\n    }\n\n    async logout() {\n        await this._client.logout();\n        this.navigation.push(\"session\", true);\n    }\n\n    get accountSetupViewModel() {\n        return this._accountSetupViewModel;\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../ViewModel.js\";\nimport {LoginFailure} from \"../../matrix/Client.js\";\n\nexport class PasswordLoginViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {loginOptions, attemptLogin} = options;\n        this._loginOptions = loginOptions;\n        this._attemptLogin = attemptLogin;\n        this._isBusy = false;\n        this._errorMessage = \"\";\n    }\n\n    get isBusy() { return this._isBusy; }\n    get errorMessage() { return this._errorMessage; }\n\n    setBusy(status) {\n        this._isBusy = status;\n        this.emitChange(\"isBusy\");\n    }\n\n    _showError(message) {\n        this._errorMessage = message;\n        this.emitChange(\"errorMessage\");\n    }\n\n    async login(username, password) {\n        this._errorMessage = \"\";\n        this.emitChange(\"errorMessage\");\n        const status = await this._attemptLogin(this._loginOptions.password(username, password));\n        let error = \"\";\n        switch (status) {\n            case LoginFailure.Credentials:\n                error = this.i18n`Your username and/or password don't seem to be correct.`;\n                break;\n            case LoginFailure.Connection:\n                error = this.i18n`Can't connect to ${this._loginOptions.homeserver}.`;\n                break;\n            case LoginFailure.Unknown:\n                error = this.i18n`Something went wrong while checking your login and password.`;\n                break;\n        }\n        if (error) {\n            this._showError(error);\n        }\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../ViewModel.js\";\n\nexport class StartSSOLoginViewModel extends ViewModel{\n    constructor(options) {\n        super(options);\n        this._sso = options.loginOptions.sso;\n        this._isBusy = false;\n    }\n   \n    get isBusy() { return this._isBusy; }\n    \n    setBusy(status) {\n        this._isBusy = status;\n        this.emitChange(\"isBusy\");\n    }\n\n    async startSSOLogin() {\n        await this.platform.settingsStorage.setString(\"sso_ongoing_login_homeserver\", this._sso.homeserver);\n        const link = this._sso.createSSORedirectURL(this.urlCreator.createSSOCallbackURL());\n        this.platform.openUrl(link);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"../ViewModel.js\";\nimport {LoginFailure} from \"../../matrix/Client.js\";\n\nexport class CompleteSSOLoginViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {\n            loginToken,\n            client,\n            attemptLogin,\n        } = options;\n        this._loginToken = loginToken;\n        this._client = client;\n        this._attemptLogin = attemptLogin;\n        this._errorMessage = \"\";\n        this.performSSOLoginCompletion();\n    }\n\n    get errorMessage() { return this._errorMessage; }\n\n    _showError(message) {\n        this._errorMessage = message;\n        this.emitChange(\"errorMessage\");\n    }\n\n    async performSSOLoginCompletion() {\n        if (!this._loginToken) {\n            return;\n        }\n        const homeserver = await this.platform.settingsStorage.getString(\"sso_ongoing_login_homeserver\");\n        let loginOptions;\n        try {\n            loginOptions = await this._client.queryLogin(homeserver).result;\n        }\n        catch (err) {\n            this._showError(err.message);\n            return;\n        }\n        if (!loginOptions.token) {\n            this.navigation.push(\"session\");\n            return;\n        }\n        const status = await this._attemptLogin(loginOptions.token(this._loginToken));\n        let error = \"\";\n        switch (status) {\n            case LoginFailure.Credentials:\n                error = this.i18n`Your login token is invalid.`;\n                break;\n            case LoginFailure.Connection:\n                error = this.i18n`Can't connect to ${homeserver}.`;\n                break;\n            case LoginFailure.Unknown:\n                error = this.i18n`Something went wrong while checking your login token.`;\n                break;\n        }\n        if (error) {\n            this._showError(error);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {Client} from \"../../matrix/Client.js\";\nimport {ViewModel} from \"../ViewModel.js\";\nimport {PasswordLoginViewModel} from \"./PasswordLoginViewModel.js\";\nimport {StartSSOLoginViewModel} from \"./StartSSOLoginViewModel.js\";\nimport {CompleteSSOLoginViewModel} from \"./CompleteSSOLoginViewModel.js\";\nimport {LoadStatus} from \"../../matrix/Client.js\";\nimport {SessionLoadViewModel} from \"../SessionLoadViewModel.js\";\n\nexport class LoginViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        const {ready, defaultHomeserver, loginToken} = options;\n        this._ready = ready;\n        this._loginToken = loginToken;\n        this._client = new Client(this.platform);\n        this._loginOptions = null;\n        this._passwordLoginViewModel = null;\n        this._startSSOLoginViewModel = null;\n        this._completeSSOLoginViewModel = null;\n        this._loadViewModel = null;\n        this._loadViewModelSubscription = null;\n        this._homeserver = defaultHomeserver;\n        this._queriedHomeserver = null;\n        this._errorMessage = \"\";\n        this._hideHomeserver = false;\n        this._isBusy = false;\n        this._abortHomeserverQueryTimeout = null;\n        this._abortQueryOperation = null;\n        this._initViewModels();\n    }\n\n    get passwordLoginViewModel() { return this._passwordLoginViewModel; }\n    get startSSOLoginViewModel() { return this._startSSOLoginViewModel; }\n    get completeSSOLoginViewModel(){ return this._completeSSOLoginViewModel; }\n    get homeserver() { return this._homeserver; }\n    get resolvedHomeserver() { return this._loginOptions?.homeserver; }\n    get errorMessage() { return this._errorMessage; }\n    get showHomeserver() { return !this._hideHomeserver; }\n    get loadViewModel() {return this._loadViewModel; }\n    get isBusy() { return this._isBusy; }\n    get isFetchingLoginOptions() { return !!this._abortQueryOperation; }\n\n    goBack() {\n        this.navigation.push(\"session\");\n    }\n\n    async _initViewModels() {\n        if (this._loginToken) {\n            this._hideHomeserver = true;\n            this._completeSSOLoginViewModel = this.track(new CompleteSSOLoginViewModel(\n                this.childOptions(\n                    {\n                        client: this._client,\n                        attemptLogin: loginMethod => this.attemptLogin(loginMethod),\n                        loginToken: this._loginToken\n                    })));\n            this.emitChange(\"completeSSOLoginViewModel\");\n        }\n        else {\n            await this.queryHomeserver();\n        }\n    }\n\n    _showPasswordLogin() {\n        this._passwordLoginViewModel = this.track(new PasswordLoginViewModel(\n            this.childOptions({\n                loginOptions: this._loginOptions,\n                attemptLogin: loginMethod => this.attemptLogin(loginMethod)\n        })));\n        this.emitChange(\"passwordLoginViewModel\");\n    }\n\n    _showSSOLogin() {\n        this._startSSOLoginViewModel = this.track(\n            new StartSSOLoginViewModel(this.childOptions({loginOptions: this._loginOptions}))\n        );\n        this.emitChange(\"startSSOLoginViewModel\");\n    }\n\n    _showError(message) {\n        this._errorMessage = message;\n        this.emitChange(\"errorMessage\");\n    }\n\n    _setBusy(status) {\n        this._isBusy = status;\n        this._passwordLoginViewModel?.setBusy(status);\n        this._startSSOLoginViewModel?.setBusy(status);\n        this.emitChange(\"isBusy\");\n    }\n\n    async attemptLogin(loginMethod) {\n        this._setBusy(true);\n        this._client.startWithLogin(loginMethod, {inspectAccountSetup: true});\n        const loadStatus = this._client.loadStatus;\n        const handle = loadStatus.waitFor(status => status !== LoadStatus.Login);\n        await handle.promise;\n        this._setBusy(false);\n        const status = loadStatus.get();\n        if (status === LoadStatus.LoginFailed) {\n            return this._client.loginFailure;\n        }\n        this._hideHomeserver = true;\n        this.emitChange(\"hideHomeserver\");\n        this._disposeViewModels();\n        this._createLoadViewModel();\n        return null;\n    }\n\n    _createLoadViewModel() {\n        this._loadViewModelSubscription = this.disposeTracked(this._loadViewModelSubscription);\n        this._loadViewModel = this.disposeTracked(this._loadViewModel);\n        this._loadViewModel = this.track(\n            new SessionLoadViewModel(\n                this.childOptions({\n                    ready: (client) => {\n                        // make sure we don't delete the session in dispose when navigating away\n                        this._client = null;\n                        this._ready(client);\n                    },\n                    client: this._client,\n                    homeserver: this._homeserver\n                })\n            )\n        );\n        this._loadViewModel.start();\n        this.emitChange(\"loadViewModel\");\n        this._loadViewModelSubscription = this.track(\n            this._loadViewModel.disposableOn(\"change\", () => {\n                if (!this._loadViewModel.loading) {\n                    this._loadViewModelSubscription = this.disposeTracked(this._loadViewModelSubscription);\n                }\n                this._setBusy(false);\n            })\n        );\n    }\n\n    _disposeViewModels() {\n        this._startSSOLoginViewModel = this.disposeTracked(this._ssoLoginViewModel);\n        this._passwordLoginViewModel = this.disposeTracked(this._passwordLoginViewModel);\n        this._completeSSOLoginViewModel = this.disposeTracked(this._completeSSOLoginViewModel);\n        this.emitChange(\"disposeViewModels\");\n    }\n\n    async setHomeserver(newHomeserver) {\n        this._homeserver = newHomeserver;\n        // clear everything set by queryHomeserver\n        this._loginOptions = null;\n        this._queriedHomeserver = null;\n        this._showError(\"\");\n        this._disposeViewModels();\n        this._abortQueryOperation = this.disposeTracked(this._abortQueryOperation);\n        this.emitChange(); // multiple fields changing\n        // also clear the timeout if it is still running\n        this.disposeTracked(this._abortHomeserverQueryTimeout);\n        const timeout = this.clock.createTimeout(1000);\n        this._abortHomeserverQueryTimeout = this.track(() => timeout.abort());\n        try {\n            await timeout.elapsed();\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                return; // still typing, don't query\n            } else {\n                throw err;\n            }\n        }\n        this._abortHomeserverQueryTimeout = this.disposeTracked(this._abortHomeserverQueryTimeout);\n        this.queryHomeserver();\n    }\n    \n    async queryHomeserver() {\n        // don't repeat a query we've just done\n        if (this._homeserver === this._queriedHomeserver || this._homeserver === \"\") {\n            return;\n        }\n        this._queriedHomeserver = this._homeserver;\n        // given that setHomeserver already clears everything set here,\n        // and that is the only way to change the homeserver,\n        // we don't need to reset things again here.\n        // However, clear things set by setHomeserver:\n        // if query is called before the typing timeout hits (e.g. field lost focus),\n        // cancel the timeout so we don't query again.\n        this._abortHomeserverQueryTimeout = this.disposeTracked(this._abortHomeserverQueryTimeout);\n        // cancel ongoing query operation, if any\n        this._abortQueryOperation = this.disposeTracked(this._abortQueryOperation);\n        try {\n            const queryOperation = this._client.queryLogin(this._homeserver);\n            this._abortQueryOperation = this.track(() => queryOperation.abort());\n            this.emitChange(\"isFetchingLoginOptions\");\n            this._loginOptions = await queryOperation.result;\n            this.emitChange(\"resolvedHomeserver\");\n        }\n        catch (e) {\n            if (e.name === \"AbortError\") {\n                return; //aborted, bail out\n            } else {\n                this._loginOptions = null;\n            }\n        } finally {\n            this._abortQueryOperation = this.disposeTracked(this._abortQueryOperation);\n            this.emitChange(\"isFetchingLoginOptions\");\n        }\n        if (this._loginOptions) {\n            if (this._loginOptions.sso) { this._showSSOLogin(); }\n            if (this._loginOptions.password) { this._showPasswordLogin(); }\n            if (!this._loginOptions.sso && !this._loginOptions.password) {\n                this._showError(\"This homeserver supports neither SSO nor password based login flows\");\n            } \n        }\n        else {\n            this._showError(`Could not query login methods supported by ${this.homeserver}`);\n        }\n    }\n\n    dispose() {\n        super.dispose();\n        if (this._client) {\n            // if we move away before we're done with initial sync\n            // delete the session\n            this._client.deleteSession();\n        }\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ViewModel} from \"./ViewModel.js\";\nimport {Client} from \"../matrix/Client.js\";\n\nexport class LogoutViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._sessionId = options.sessionId;\n        this._busy = false;\n        this._showConfirm = true;\n        this._error = undefined;\n    }\n\n    get showConfirm() {\n        return this._showConfirm;\n    }\n\n    get busy() {\n        return this._busy;\n    }\n\n    get cancelUrl() {\n        return this.urlCreator.urlForSegment(\"session\", true);\n    }\n\n    async logout() {\n        this._busy = true;\n        this._showConfirm = false;\n        this.emitChange(\"busy\");\n        try {\n            const client = new Client(this.platform);\n            await client.startLogout(this._sessionId);\n            this.navigation.push(\"session\", true);\n        } catch (err) {\n            this._error = err;\n            this._busy = false;\n            this.emitChange(\"busy\");\n        }\n    }\n\n    get status() {\n        if (this._error) {\n            return this.i18n`Could not log out of device: ${this._error.message}`;\n        } else {\n            return this.i18n`Logging out… Please don't close the app.`;\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {SortedArray} from \"../observable/index.js\";\nimport {ViewModel} from \"./ViewModel.js\";\nimport {avatarInitials, getIdentifierColorNumber} from \"./avatar.js\";\n\nclass SessionItemViewModel extends ViewModel {\n    constructor(options, pickerVM) {\n        super(options);\n        this._pickerVM = pickerVM;\n        this._sessionInfo = options.sessionInfo;\n        this._isDeleting = false;\n        this._isClearing = false;\n        this._error = null;\n        this._exportDataUrl = null;\n    }\n\n    get error() {\n        return this._error && this._error.message;\n    }\n\n    get id() {\n        return this._sessionInfo.id;\n    }\n\n    get openUrl() {\n        return this.urlCreator.urlForSegment(\"session\", this.id);\n    }\n\n    get label() {\n        const {userId, comment} =  this._sessionInfo;\n        if (comment) {\n            return `${userId} (${comment})`;\n        } else {\n            return userId;\n        }\n    }\n\n    get sessionInfo() {\n        return this._sessionInfo;\n    }\n\n    get exportDataUrl() {\n        return this._exportDataUrl;\n    }\n\n    get avatarColorNumber() {\n        return getIdentifierColorNumber(this._sessionInfo.userId);\n    }\n\n    get avatarInitials() {\n        return avatarInitials(this._sessionInfo.userId);\n    }\n}\n\n\nexport class SessionPickerViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._sessions = new SortedArray((s1, s2) => s1.id.localeCompare(s2.id));\n        this._loadViewModel = null;\n        this._error = null;\n    }\n\n    // this loads all the sessions\n    async load() {\n        const sessions = await this.platform.sessionInfoStorage.getAll();\n        this._sessions.setManyUnsorted(sessions.map(s => {\n            return new SessionItemViewModel(this.childOptions({sessionInfo: s}), this);\n        }));\n    }\n\n    // for the loading of 1 picked session\n    get loadViewModel() {\n        return this._loadViewModel;\n    }\n\n    get sessions() {\n        return this._sessions;\n    }\n\n    get cancelUrl() {\n        return this.urlCreator.urlForSegment(\"login\");\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {Client} from \"../matrix/Client.js\";\nimport {SessionViewModel} from \"./session/SessionViewModel.js\";\nimport {SessionLoadViewModel} from \"./SessionLoadViewModel.js\";\nimport {LoginViewModel} from \"./login/LoginViewModel.js\";\nimport {LogoutViewModel} from \"./LogoutViewModel.js\";\nimport {SessionPickerViewModel} from \"./SessionPickerViewModel.js\";\nimport {ViewModel} from \"./ViewModel.js\";\n\nexport class RootViewModel extends ViewModel {\n    constructor(options) {\n        super(options);\n        this._error = null;\n        this._sessionPickerViewModel = null;\n        this._sessionLoadViewModel = null;\n        this._loginViewModel = null;\n        this._logoutViewModel = null;\n        this._sessionViewModel = null;\n        this._pendingClient = null;\n    }\n\n    async load() {\n        this.track(this.navigation.observe(\"login\").subscribe(() => this._applyNavigation()));\n        this.track(this.navigation.observe(\"session\").subscribe(() => this._applyNavigation()));\n        this.track(this.navigation.observe(\"sso\").subscribe(() => this._applyNavigation()));\n        this._applyNavigation(true);\n    }\n\n    async _applyNavigation(shouldRestoreLastUrl) {\n        const isLogin = this.navigation.path.get(\"login\");\n        const logoutSessionId = this.navigation.path.get(\"logout\")?.value;\n        const sessionId = this.navigation.path.get(\"session\")?.value;\n        const loginToken = this.navigation.path.get(\"sso\")?.value;\n        if (isLogin) {\n            if (this.activeSection !== \"login\") {\n                this._showLogin();\n            }\n        } else if (logoutSessionId) {\n            if (this.activeSection !== \"logout\") {\n                this._showLogout(logoutSessionId);\n            }\n        } else if (sessionId === true) {\n            if (this.activeSection !== \"picker\") {\n                this._showPicker();\n            }\n        } else if (sessionId) {\n            if (!this._sessionViewModel || this._sessionViewModel.id !== sessionId) {\n                // see _showLogin for where _pendingClient comes from\n                if (this._pendingClient && this._pendingClient.sessionId === sessionId) {\n                    const client = this._pendingClient;\n                    this._pendingClient = null;\n                    this._showSession(client);\n                } else {\n                    // this should never happen, but we want to be sure not to leak it\n                    if (this._pendingClient) {\n                        this._pendingClient.dispose();\n                        this._pendingClient = null;\n                    }\n                    this._showSessionLoader(sessionId);\n                }\n            }\n        } else if (loginToken) {\n            this.urlCreator.normalizeUrl();\n            if (this.activeSection !== \"login\") {\n                this._showLogin(loginToken);\n            }\n        }\n        else {\n            try {\n                if (!(shouldRestoreLastUrl && this.urlCreator.tryRestoreLastUrl())) {\n                    const sessionInfos = await this.platform.sessionInfoStorage.getAll();\n                    if (sessionInfos.length === 0) {\n                        this.navigation.push(\"login\");\n                    } else if (sessionInfos.length === 1) {\n                        this.navigation.push(\"session\", sessionInfos[0].id);\n                    } else {\n                        this.navigation.push(\"session\");\n                    }\n                }\n            } catch (err) {\n                this._setSection(() => this._error = err);\n            }\n        }\n    }\n\n    async _showPicker() {\n        this._setSection(() => {\n            this._sessionPickerViewModel = new SessionPickerViewModel(this.childOptions());\n        });\n        try {\n            await this._sessionPickerViewModel.load();\n        } catch (err) {\n            this._setSection(() => this._error = err);\n        }\n    }\n\n    _showLogin(loginToken) {\n        this._setSection(() => {\n            this._loginViewModel = new LoginViewModel(this.childOptions({\n                defaultHomeserver: this.platform.config[\"defaultHomeServer\"],\n                ready: client => {\n                    // we don't want to load the session container again,\n                    // but we also want the change of screen to go through the navigation\n                    // so we store the session container in a temporary variable that will be\n                    // consumed by _applyNavigation, triggered by the navigation change\n                    // \n                    // Also, we should not call _setSection before the navigation is in the correct state,\n                    // as url creation (e.g. in RoomTileViewModel)\n                    // won't be using the correct navigation base path.\n                    this._pendingClient = client;\n                    this.navigation.push(\"session\", client.sessionId);\n                },\n                loginToken\n            }));\n        });\n    }\n\n    _showLogout(sessionId) {\n        this._setSection(() => {\n            this._logoutViewModel = new LogoutViewModel(this.childOptions({sessionId}));\n        });\n    }\n\n    _showSession(client) {\n        this._setSection(() => {\n            this._sessionViewModel = new SessionViewModel(this.childOptions({client}));\n            this._sessionViewModel.start();\n        });\n    }\n\n    _showSessionLoader(sessionId) {\n        const client = new Client(this.platform);\n        client.startWithExistingSession(sessionId);\n        this._setSection(() => {\n            this._sessionLoadViewModel = new SessionLoadViewModel(this.childOptions({\n                client,\n                ready: client => this._showSession(client)\n            }));\n            this._sessionLoadViewModel.start();\n        });\n    }\n\n    get activeSection() {\n        if (this._error) {\n            return \"error\";\n        } else if (this._sessionViewModel) {\n            return \"session\";\n        } else if (this._loginViewModel) {\n            return \"login\";\n        } else if (this._logoutViewModel) {\n            return \"logout\";\n        } else if (this._sessionPickerViewModel) {\n            return \"picker\";\n        } else if (this._sessionLoadViewModel) {\n            return \"loading\";\n        } else {\n            return \"redirecting\";\n        }\n    }\n\n    _setSection(setter) {\n        // clear all members the activeSection depends on\n        this._error = null;\n        this._sessionPickerViewModel = this.disposeTracked(this._sessionPickerViewModel);\n        this._sessionLoadViewModel = this.disposeTracked(this._sessionLoadViewModel);\n        this._loginViewModel = this.disposeTracked(this._loginViewModel);\n        this._logoutViewModel = this.disposeTracked(this._logoutViewModel);\n        this._sessionViewModel = this.disposeTracked(this._sessionViewModel);\n        // now set it again\n        setter();\n        this._sessionPickerViewModel && this.track(this._sessionPickerViewModel);\n        this._sessionLoadViewModel && this.track(this._sessionLoadViewModel);\n        this._loginViewModel && this.track(this._loginViewModel);\n        this._logoutViewModel && this.track(this._logoutViewModel);\n        this._sessionViewModel && this.track(this._sessionViewModel);\n        this.emitChange(\"activeSection\");\n    }\n\n    get error() { return this._error; }\n    get sessionViewModel() { return this._sessionViewModel; }\n    get loginViewModel() { return this._loginViewModel; }\n    get logoutViewModel() { return this._logoutViewModel; }\n    get sessionPickerViewModel() { return this._sessionPickerViewModel; }\n    get sessionLoadViewModel() { return this._sessionLoadViewModel; }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// import {RecordRequester, ReplayRequester} from \"./matrix/net/request/replay\";\nimport {RootViewModel} from \"../../domain/RootViewModel.js\";\nimport {createNavigation, createRouter} from \"../../domain/navigation/index.js\";\n// Don't use a default export here, as we use multiple entries during legacy build,\n// which does not support default exports,\n// see https://github.com/rollup/plugins/tree/master/packages/multi-entry\nexport async function main(platform) {\n    try {\n        // to replay:\n        // const fetchLog = await (await fetch(\"/fetchlogs/constrainterror.json\")).json();\n        // const replay = new ReplayRequester(fetchLog, {delay: false});\n        // const request = replay.request;\n\n        // to record:\n        // const recorder = new RecordRequester(createFetchRequest(clock.createTimeout));\n        // const request = recorder.request;\n        // window.getBrawlFetchLog = () => recorder.log();\n        const navigation = createNavigation();\n        platform.setNavigation(navigation);\n        const urlRouter = createRouter({navigation, history: platform.history});\n        urlRouter.attach();\n        const vm = new RootViewModel({\n            platform,\n            // the only public interface of the router is to create urls,\n            // so we call it that in the view models\n            urlCreator: urlRouter,\n            navigation,\n        });\n        await vm.load();\n        platform.createAndMountRootView(vm);\n    } catch(err) {\n        console.error(`${err.message}:\\n${err.stack}`);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ConnectionError} from \"../matrix/error.js\";\nimport type {Timeout} from \"../platform/web/dom/Clock.js\"\nimport type {IAbortable} from \"./AbortableOperation\";\n\ntype TimeoutCreator = (ms: number) => Timeout;\n\nexport function abortOnTimeout(createTimeout: TimeoutCreator, timeoutAmount: number, requestResult: IAbortable, responsePromise: Promise<Response>) {\n    const timeout = createTimeout(timeoutAmount);\n    // abort request if timeout finishes first\n    let timedOut = false;\n    timeout.elapsed().then(\n        () => {\n            timedOut = true;\n            requestResult.abort();\n        },\n        () => {}    // ignore AbortError when timeout is aborted\n    );\n    // abort timeout if request finishes first\n    return responsePromise.then(\n        response => {\n            timeout.abort();\n            return response;\n        },\n        err => {\n            timeout.abort();\n            // map error to TimeoutError\n            if (err.name === \"AbortError\" && timedOut) {\n                throw new ConnectionError(`Request timed out after ${timeoutAmount}ms`, true);\n            } else {\n                throw err;\n            }\n        }\n    );\n}\n\n// because impunity only takes one entrypoint currently,\n// these tests aren't run by yarn test as that does not\n// include platform specific code,\n// and this file is only included by platform specific code,\n// see how to run in package.json and replace src/main.js with this file.\nimport {Clock as MockClock} from \"../mocks/Clock.js\";\nimport {Request as MockRequest} from \"../mocks/Request.js\";\nimport {AbortError} from \"../matrix/error.js\";\nexport function tests() {\n    return {\n        \"ConnectionError on timeout\": async assert => {\n            const clock = new MockClock();\n            const request = new MockRequest();\n            const promise = abortOnTimeout(clock.createTimeout, 10000, request, request.response());\n            clock.elapse(10000);\n            await assert.rejects(promise, ConnectionError);\n            assert(request.aborted);\n        },\n        \"Abort is canceled once response resolves\": async assert => {\n            const clock = new MockClock();\n            const request = new MockRequest();\n            const promise = abortOnTimeout(clock.createTimeout, 10000, request, request.response());\n            request.resolve(5);\n            clock.elapse(10000);\n            assert(!request.aborted);\n            assert.equal(await promise, 5);\n        },\n        \"AbortError from request is not mapped to ConnectionError\": async assert => {\n            const clock = new MockClock();\n            const request = new MockRequest();\n            const promise = abortOnTimeout(clock.createTimeout, 10000, request, request.response());\n            request.reject(new AbortError());\n            assert(!request.aborted);\n            assert.rejects(promise, AbortError);\n        }\n    }\n\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function addCacheBuster(urlStr, random = Math.random) {\n    // XHR doesn't have a good way to disable cache,\n    // so add a random query param\n    // see https://davidtranscend.com/blog/prevent-ie11-cache-ajax-requests/\n    if (urlStr.includes(\"?\")) {\n        urlStr = urlStr + \"&\";\n    } else {\n        urlStr = urlStr + \"?\";\n    }\n    return urlStr + `_cacheBuster=${Math.ceil(random() * Number.MAX_SAFE_INTEGER)}`;\n}\n\nexport function tests() {\n    return {\n        \"add cache buster\": assert => {\n            const random = () => 0.5;\n            assert.equal(addCacheBuster(\"http://foo\", random), \"http://foo?_cacheBuster=4503599627370496\");\n            assert.equal(addCacheBuster(\"http://foo?bar=baz\", random), \"http://foo?bar=baz&_cacheBuster=4503599627370496\");\n        }\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {\n    AbortError,\n    ConnectionError\n} from \"../../../../matrix/error.js\";\nimport {addCacheBuster} from \"./common.js\";\n\nclass RequestResult {\n    constructor(promise, xhr) {\n        this._promise = promise;\n        this._xhr = xhr;\n    }\n\n    abort() {\n        this._xhr.abort();\n    }\n\n    response() {\n        return this._promise;\n    }\n}\n\nfunction createXhr(url, {method, headers, timeout, format, uploadProgress}) {\n    const xhr = new XMLHttpRequest();\n\n    if (uploadProgress) {\n        xhr.upload.addEventListener(\"progress\", evt => uploadProgress(evt.loaded));\n    }\n\n    xhr.open(method, url);\n    \n    if (format === \"buffer\") {\n        // important to call this after calling open\n        xhr.responseType = \"arraybuffer\";\n    }\n    if (headers) {\n        for(const [name, value] of headers.entries()) {\n            try {\n                xhr.setRequestHeader(name, value);\n            } catch (err) {\n                console.info(`Could not set ${name} header: ${err.message}`);\n            }\n        }\n    }\n    if (timeout) {\n        xhr.timeout = timeout;\n    }\n\n    return xhr;\n}\n\nfunction xhrAsPromise(xhr, method, url) {\n    return new Promise((resolve, reject) => {\n        xhr.addEventListener(\"load\", () => resolve(xhr));\n        xhr.addEventListener(\"abort\", () => reject(new AbortError()));\n        xhr.addEventListener(\"error\", () => reject(new ConnectionError(`Error ${method} ${url}`)));\n        xhr.addEventListener(\"timeout\", () => reject(new ConnectionError(`Timeout ${method} ${url}`, true)));\n    });\n}\n\nexport function xhrRequest(url, options) {\n    let {cache, format, body, method} = options;\n    if (!cache) {\n        url = addCacheBuster(url);\n    }\n    const xhr = createXhr(url, options);\n    const promise = xhrAsPromise(xhr, method, url).then(xhr => {\n        const {status} = xhr;\n        let body = null;\n        if (format === \"buffer\") {\n            body = xhr.response;\n        } else if (xhr.getResponseHeader(\"Content-Type\") === \"application/json\") {\n            body = JSON.parse(xhr.responseText);\n        }\n        return {status, body};\n    });\n\n    // if a BlobHandle, take native blob\n    if (body?.nativeBlob) {\n        body = body.nativeBlob;\n    }\n    xhr.send(body || null);\n\n    return new RequestResult(promise, xhr);\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {\n    AbortError,\n    ConnectionError\n} from \"../../../../matrix/error.js\";\nimport {abortOnTimeout} from \"../../../../utils/timeout\";\nimport {addCacheBuster} from \"./common.js\";\nimport {xhrRequest} from \"./xhr.js\";\n\nclass RequestResult {\n    constructor(promise, controller) {\n        if (!controller) {\n            const abortPromise = new Promise((_, reject) => {\n                this._controller = {\n                    abort() {\n                        const err = new Error(\"fetch request aborted\");\n                        err.name = \"AbortError\";\n                        reject(err);\n                    }\n                };\n            });\n            this.promise = Promise.race([promise, abortPromise]);\n        } else {\n            this.promise = promise;\n            this._controller = controller;\n        }\n    }\n\n    abort() {\n        this._controller.abort();\n    }\n\n    response() {\n        return this.promise;\n    }\n}\n\nexport function createFetchRequest(createTimeout, serviceWorkerHandler) {\n    return function fetchRequest(url, requestOptions) {\n        if (serviceWorkerHandler?.haltRequests) {\n            // prevent any requests while waiting\n            // for the new service worker to get activated.\n            // Once this happens, the page will be reloaded\n            // by the serviceWorkerHandler so this is fine.\n            return new RequestResult(new Promise(() => {}), {});\n        }\n        // fetch doesn't do upload progress yet, delegate to xhr\n        if (requestOptions?.uploadProgress) {\n            return xhrRequest(url, requestOptions);\n        }\n        let {method, headers, body, timeout, format, cache = false} = requestOptions;\n        const controller = typeof AbortController === \"function\" ? new AbortController() : null;\n        // if a BlobHandle, take native blob\n        if (body?.nativeBlob) {\n            body = body.nativeBlob;\n        }\n        let options = {method, body};\n        if (controller) {\n            options = Object.assign(options, {\n                signal: controller.signal\n            });\n        }\n        if (!cache) {\n            url = addCacheBuster(url);\n        }\n        options = Object.assign(options, {\n            mode: \"cors\",\n            credentials: \"omit\",\n            referrer: \"no-referrer\",\n            // ideally we'd turn off cache here, but Safari interprets\n            // `Access-Control-Allow-Headers` strictly (only when fetch is\n            // intercepted by a service worker strangely enough), in that\n            // it gives a CORS error if Cache-Control is not present\n            // in the list of allowed headers (which it isn't commonly, at least not on matrix.org).\n            // With no-store or no-cache here, it does set `Cache-Control`\n            // so we don't do that, and prevent caching with `addCacheBuster`.\n            // We also hope the server responds with `Cache-Control: no-store` so\n            // we don't fill the http cache with api responses.\n            // \n            // cache: \"no-store\",\n            cache: \"default\",\n        });\n        if (headers) {\n            const fetchHeaders = new Headers();\n            for(const [name, value] of headers.entries()) {\n                fetchHeaders.append(name, value);\n            }\n            options.headers = fetchHeaders;\n        }\n        const promise = fetch(url, options).then(async response => {\n            const {status} = response;\n            let body;\n            try {\n                if (format === \"json\") {\n                    body = await response.json();\n                } else if (format === \"buffer\") {\n                    body = await response.arrayBuffer();\n                }\n            } catch (err) {\n                // some error pages return html instead of json, ignore error\n                if (!(err.name === \"SyntaxError\" && status >= 400)) {\n                    throw err;\n                }\n            }\n            return {status, body};\n        }, err => {\n            if (err.name === \"AbortError\") {\n                // map DOMException with name AbortError to our own AbortError type\n                // as we don't want DOMExceptions in the protocol layer.\n                throw new AbortError();\n            } else if (err instanceof TypeError) {\n                // Network errors are reported as TypeErrors, see\n                // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful\n                // this can either mean user is offline, server is offline, or a CORS error (server misconfiguration).\n                // \n                // One could check navigator.onLine to rule out the first\n                // but the 2 latter ones are indistinguishable from javascript.\n                throw new ConnectionError(`${method} ${url}: ${err.message}`);\n            }\n            throw err;\n        });\n        const result = new RequestResult(promise, controller);\n\n        if (timeout) {\n            result.promise = abortOnTimeout(createTimeout, timeout, result, result.promise);\n        }\n\n        return result;\n    }   \n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\ninterface ISessionInfo {\n    id: string;\n    deviceId: string;\n    userId: string;\n    homeserver: string;\n    homeServer: string; // deprecate this over time\n    accessToken: string;\n    lastUsed: number;\n}\n\n// todo: this should probably be in platform/types?\ninterface ISessionInfoStorage {\n    getAll(): Promise<ISessionInfo[]>;\n    updateLastUsed(id: string, timestamp: number): Promise<void>;\n    get(id: string): Promise<ISessionInfo | undefined>;\n    add(sessionInfo: ISessionInfo): Promise<void>;\n    delete(sessionId: string): Promise<void>;\n}\n\nexport class SessionInfoStorage implements ISessionInfoStorage {\n    private readonly _name: string;\n\n    constructor(name: string) {\n        this._name = name;\n    }\n\n    getAll(): Promise<ISessionInfo[]> {\n        const sessionsJson = localStorage.getItem(this._name);\n        if (sessionsJson) {\n            const sessions = JSON.parse(sessionsJson);\n            if (Array.isArray(sessions)) {\n                return Promise.resolve(sessions);\n            }\n        }\n        return Promise.resolve([]);\n    }\n\n    async updateLastUsed(id: string, timestamp: number): Promise<void> {\n        const sessions = await this.getAll();\n        if (sessions) {\n            const session = sessions.find(session => session.id === id);\n            if (session) {\n                session.lastUsed = timestamp;\n                localStorage.setItem(this._name, JSON.stringify(sessions));\n            }\n        }\n    }\n\n    async get(id: string): Promise<ISessionInfo | undefined> {\n        const sessions = await this.getAll();\n        if (sessions) {\n            return sessions.find(session => session.id === id);\n        }\n    }\n\n    async add(sessionInfo: ISessionInfo): Promise<void> {\n        const sessions = await this.getAll();\n        sessions.push(sessionInfo);\n        localStorage.setItem(this._name, JSON.stringify(sessions));\n    }\n\n    async delete(sessionId: string): Promise<void> {\n        let sessions = await this.getAll();\n        sessions = sessions.filter(s => s.id !== sessionId);\n        localStorage.setItem(this._name, JSON.stringify(sessions));\n    }\n    \n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class SettingsStorage {\n    constructor(prefix) {\n        this._prefix = prefix;\n    }\n\n    async setInt(key, value) {\n        this._set(key, value);\n    }\n\n    async getInt(key, defaultValue = 0) {\n        const value = window.localStorage.getItem(`${this._prefix}${key}`);\n        if (typeof value === \"string\") {\n            return parseInt(value, 10);\n        }\n        return defaultValue;\n    }\n\n    async setBool(key, value) {\n        this._set(key, value);\n    }\n\n    async getBool(key, defaultValue = false) {\n        const value = window.localStorage.getItem(`${this._prefix}${key}`);\n        if (typeof value === \"string\") {\n            return value === \"true\";\n        }\n        return defaultValue;\n    }\n\n    async setString(key, value) {\n        this._set(key, value);\n    }\n\n    async getString(key) {\n        return window.localStorage.getItem(`${this._prefix}${key}`);\n    }\n\n    async remove(key) {\n        window.localStorage.removeItem(`${this._prefix}${key}`);\n    }\n\n    async _set(key, value) {\n        window.localStorage.setItem(`${this._prefix}${key}`, value);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nexport class UTF8 {\n    constructor() {\n        this._encoder = null;\n        this._decoder = null;\n    }\n\n    encode(str) {\n        if (!this._encoder) {\n            this._encoder = new TextEncoder();\n        }\n        return this._encoder.encode(str);\n    }\n\n    decode(buffer) {\n        if (!this._decoder) {\n            this._decoder = new TextDecoder();\n        }\n        return this._decoder.decode(buffer);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport base64 from \"base64-arraybuffer\";\n\nexport class Base64 {\n    encodeUnpadded(buffer) {\n        const str = base64.encode(buffer);\n        const paddingIdx = str.indexOf(\"=\");\n        if (paddingIdx !== -1) {\n            return str.substr(0, paddingIdx);\n        } else {\n            return str;\n        }\n    }\n\n    encode(buffer) {\n        return base64.encode(buffer);\n    }\n\n    decode(str) {\n        return base64.decode(str);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport bs58 from \"bs58\";\n\nexport class Base58 {\n    encode(buffer) {\n        return bs58.encode(buffer);\n    }\n\n    decode(str) {\n        return bs58.decode(str);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {UTF8} from \"../dom/UTF8.js\";\nimport {Base64} from \"./Base64.js\";\nimport {Base58} from \"./Base58.js\";\n\nexport class Encoding {\n    constructor() {\n        this.utf8 = new UTF8();\n        this.base64 = new Base64();\n        this.base58 = new Base58();\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class OlmWorker {\n    constructor(workerPool) {\n        this._workerPool = workerPool;\n    }\n\n    megolmDecrypt(session, ciphertext) {\n        const sessionKey = session.export_session(session.first_known_index());\n        return this._workerPool.send({type: \"megolm_decrypt\", ciphertext, sessionKey});\n    }\n\n    async createAccountAndOTKs(account, otkAmount) {\n        // IE11 does not support getRandomValues in a worker, so we have to generate the values upfront.\n        let randomValues;\n        if (window.msCrypto) {\n            randomValues = [\n                window.msCrypto.getRandomValues(new Uint8Array(64)),\n                window.msCrypto.getRandomValues(new Uint8Array(otkAmount * 32)),\n            ];\n        }\n        const pickle = await this._workerPool.send({type: \"olm_create_account_otks\", randomValues, otkAmount}).response();\n        account.unpickle(\"\", pickle);\n    }\n\n    async createOutboundOlmSession(account, newSession, theirIdentityKey, theirOneTimeKey) {\n        const accountPickle = account.pickle(\"\");\n        let randomValues;\n        if (window.msCrypto) {\n            randomValues = [\n                window.msCrypto.getRandomValues(new Uint8Array(64)),\n            ];\n        }\n        const sessionPickle = await this._workerPool.send({type: \"olm_create_outbound\", accountPickle, theirIdentityKey, theirOneTimeKey, randomValues}).response();\n        newSession.unpickle(\"\", sessionPickle);\n    }\n\n    dispose() {\n        this._workerPool.dispose();\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {LogLevel, LogFilter} from \"./LogFilter\";\nimport type {BaseLogger} from \"./BaseLogger\";\nimport type {ISerializedItem, ILogItem, LogItemValues, LabelOrValues, FilterCreator, LogCallback} from \"./types\";\n\nexport class LogItem implements ILogItem {\n    public readonly start: number;\n    public logLevel: LogLevel;\n    public error?: Error;\n    public end?: number;\n    private _values: LogItemValues;\n    private _logger: BaseLogger;\n    private _filterCreator?: FilterCreator;\n    private _children?: Array<LogItem>;\n\n    constructor(labelOrValues: LabelOrValues, logLevel: LogLevel, logger: BaseLogger, filterCreator?: FilterCreator) {\n        this._logger = logger;\n        this.start = logger._now();\n        // (l)abel\n        this._values = typeof labelOrValues === \"string\" ? {l: labelOrValues} : labelOrValues;\n        this.logLevel = logLevel;\n        this._filterCreator = filterCreator;\n    }\n\n    /** start a new root log item and run it detached mode, see BaseLogger.runDetached */\n    runDetached(labelOrValues: LabelOrValues, callback: LogCallback<unknown>, logLevel?: LogLevel, filterCreator?: FilterCreator): ILogItem {\n        return this._logger.runDetached(labelOrValues, callback, logLevel, filterCreator);\n    }\n\n    /** start a new detached root log item and log a reference to it from this item */\n    wrapDetached(labelOrValues: LabelOrValues, callback: LogCallback<unknown>, logLevel?: LogLevel, filterCreator?: FilterCreator): void {\n        this.refDetached(this.runDetached(labelOrValues, callback, logLevel, filterCreator));\n    }\n\n    /** logs a reference to a different log item, usually obtained from runDetached.\n    This is useful if the referenced operation can't be awaited. */\n    refDetached(logItem: ILogItem, logLevel?: LogLevel): void {\n        logItem.ensureRefId();\n        this.log({ref: logItem.values.refId}, logLevel);\n    }\n\n    ensureRefId(): void {\n        if (!this._values.refId) {\n            this.set(\"refId\", this._logger._createRefId());\n        }\n    }\n\n    /**\n     * Creates a new child item and runs it in `callback`.\n     */\n    wrap<T>(labelOrValues: LabelOrValues, callback: LogCallback<T>, logLevel?: LogLevel, filterCreator?: FilterCreator): T {\n        const item = this.child(labelOrValues, logLevel, filterCreator);\n        return item.run(callback);\n    }\n\n    get duration(): number | undefined {\n        if (this.end) {\n            return this.end - this.start;\n        } else {\n            return undefined;\n        }\n    }\n\n    durationWithoutType(type: string): number | undefined {\n        const durationOfType = this.durationOfType(type);\n        if (this.duration && durationOfType) {\n            return this.duration - durationOfType;\n        }\n    }\n\n    durationOfType(type: string): number | undefined {\n        if (this._values.t === type) {\n            return this.duration;\n        } else if (this._children) {\n            return this._children.reduce((sum, c) => {\n                const duration = c.durationOfType(type);\n                return sum + (duration ?? 0);\n            }, 0);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * Creates a new child item that finishes immediately\n     * Finished items should not be modified anymore as they can be serialized\n     * at any stage, but using `set` on the return value in a synchronous way should still be safe.\n     */\n    log(labelOrValues: LabelOrValues, logLevel?: LogLevel): ILogItem {\n        const item = this.child(labelOrValues, logLevel);\n        item.end = item.start;\n        return item;\n    }\n\n    set(key: string | object, value?: unknown): ILogItem {\n        if(typeof key === \"object\") {\n            const values = key;\n            Object.assign(this._values, values);\n        } else {\n            this._values[key] = value;\n        }\n        return this;\n    }\n\n    serialize(filter: LogFilter, parentStartTime: number | undefined, forced: boolean): ISerializedItem | undefined {\n        if (this._filterCreator) {\n            try {\n                filter = this._filterCreator(new LogFilter(filter), this);\n            } catch (err) {\n                console.error(\"Error creating log filter\", err);\n            }\n        }\n        let children: Array<ISerializedItem> | null = null;\n        if (this._children) {\n            children = this._children.reduce((array: Array<ISerializedItem>, c) => {\n                const s = c.serialize(filter, this.start, false);\n                if (s) {\n                    if (array === null) {\n                        array = [];\n                    }\n                    array.push(s);\n                }\n                return array;\n            }, null);\n        }\n        if (filter && !filter.filter(this, children)) {\n            return;\n        }\n        // in (v)alues, (l)abel and (t)ype are also reserved.\n        const item: ISerializedItem = {\n            // (s)tart\n            s: typeof parentStartTime === \"number\" ? this.start - parentStartTime : this.start,\n            // (d)uration\n            d: this.duration,\n            // (v)alues\n            v: this._values,\n            // (l)evel\n            l: this.logLevel\n        };\n        if (this.error) {\n            // (e)rror\n            item.e = {\n                stack: this.error.stack,\n                name: this.error.name,\n                message: this.error.message.split(\"\\n\")[0]\n            };\n        }\n        if (forced) {\n            item.f = true;    //(f)orced\n        }\n        if (children) {\n            // (c)hildren\n            item.c = children;\n        }\n        return item;\n    }\n\n    /**\n     * You probably want to use `wrap` instead of this.\n     * \n     * Runs a callback passing this log item,\n     * recording the timing and any error.\n     *\n     * callback can return a Promise.\n     *\n     * Should only be called once.\n     * \n     * @param  {Function} callback [description]\n     * @return {[type]}            [description]\n     */\n    run<T>(callback: LogCallback<T>): T {\n        if (this.end !== undefined) {\n            console.trace(\"log item is finished, additional logs will likely not be recorded\");\n        }\n        try {\n            const result = callback(this);\n            if (result instanceof Promise) {\n                return result.then(promiseResult => {\n                    this.finish();\n                    return promiseResult;\n                }, err => {\n                    throw this.catch(err);\n                }) as unknown as T;\n            } else {\n                this.finish();\n                return result;\n            }\n        } catch (err) {\n            throw this.catch(err);\n        }\n    }\n\n    /**\n     * finished the item, recording the end time. After finishing, an item can't be modified anymore as it will be persisted.\n     * @internal shouldn't typically be called by hand. allows to force finish if a promise is still running when closing the app\n     */\n    finish(): void {\n        if (this.end === undefined) {\n            if (this._children) {\n                for(const c of this._children) {\n                    c.finish();\n                }\n            }\n            this.end = this._logger._now();\n        }\n    }\n\n    // expose log level without needing import everywhere\n    get level(): typeof LogLevel {\n        return LogLevel;\n    }\n\n    catch(err: Error): Error {\n        this.error = err;\n        this.logLevel = LogLevel.Error;\n        this.finish();\n        return err;\n    }\n\n    child(labelOrValues: LabelOrValues, logLevel?: LogLevel, filterCreator?: FilterCreator): LogItem {\n        if (this.end) {\n            console.trace(\"log item is finished, additional logs will likely not be recorded\");\n        }\n        if (!logLevel) {\n            logLevel = this.logLevel || LogLevel.Info;\n        }\n        const item = new LogItem(labelOrValues, logLevel, this._logger, filterCreator);\n        if (!this._children) {\n            this._children = [];\n        }\n        this._children.push(item);\n        return item;\n    }\n\n    get logger(): BaseLogger {\n        return this._logger;\n    }\n\n    get values(): LogItemValues {\n        return this._values;\n    }\n\n    get children(): Array<LogItem> | undefined {\n        return this._children;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {LogItem} from \"./LogItem\";\nimport {LogLevel, LogFilter} from \"./LogFilter\";\nimport type {ILogger, ILogExport, FilterCreator, LabelOrValues, LogCallback, ILogItem, ISerializedItem} from \"./types\";\nimport type {Platform} from \"../platform/web/Platform.js\";\n\nexport abstract class BaseLogger implements ILogger {\n    protected _openItems: Set<LogItem> = new Set();\n    protected _platform: Platform;\n    protected _serializedTransformer: (item: ISerializedItem) => ISerializedItem;\n\n    constructor({platform, serializedTransformer = (item: ISerializedItem) => item}) {\n        this._platform = platform;\n        this._serializedTransformer = serializedTransformer;\n    }\n\n    log(labelOrValues: LabelOrValues, logLevel: LogLevel = LogLevel.Info): void {\n        const item = new LogItem(labelOrValues, logLevel, this);\n        item.end = item.start;\n        this._persistItem(item, undefined, false);\n    }\n\n    /** if item is a log item, wrap the callback in a child of it, otherwise start a new root log item. */\n    wrapOrRun<T>(item: ILogItem | undefined, labelOrValues: LabelOrValues, callback: LogCallback<T>, logLevel?: LogLevel, filterCreator?: FilterCreator): T {\n        if (item) {\n            return item.wrap(labelOrValues, callback, logLevel, filterCreator);\n        } else {\n            return this.run(labelOrValues, callback, logLevel, filterCreator);\n        }\n    }\n\n    /** run a callback in detached mode,\n    where the (async) result or errors are not propagated but still logged.\n    Useful to pair with LogItem.refDetached.\n\n    @return {ILogItem} the log item added, useful to pass to LogItem.refDetached */\n    runDetached<T>(labelOrValues: LabelOrValues, callback: LogCallback<T>, logLevel?: LogLevel, filterCreator?: FilterCreator): ILogItem {\n        if (!logLevel) {\n            logLevel = LogLevel.Info;\n        }\n        const item = new LogItem(labelOrValues, logLevel, this);\n        this._run(item, callback, logLevel, false /* don't throw, nobody is awaiting */, filterCreator);\n        return item;\n    }\n\n    /** run a callback wrapped in a log operation.\n    Errors and duration are transparently logged, also for async operations.\n    Whatever the callback returns is returned here. */\n    run<T>(labelOrValues: LabelOrValues, callback: LogCallback<T>, logLevel?: LogLevel, filterCreator?: FilterCreator): T {\n        if (logLevel === undefined) {\n            logLevel = LogLevel.Info;\n        }\n        const item = new LogItem(labelOrValues, logLevel, this);\n        return this._run(item, callback, logLevel, true, filterCreator);\n    }\n\n    _run<T>(item: LogItem, callback: LogCallback<T>, logLevel: LogLevel, wantResult: true, filterCreator?: FilterCreator): T;\n    // we don't return if we don't throw, as we don't have anything to return when an error is caught but swallowed for the fire-and-forget case.\n    _run<T>(item: LogItem, callback: LogCallback<T>, logLevel: LogLevel, wantResult: false, filterCreator?: FilterCreator): void;\n    _run<T>(item: LogItem, callback: LogCallback<T>, logLevel: LogLevel, wantResult: boolean, filterCreator?: FilterCreator): T | void {\n        this._openItems.add(item);\n\n        const finishItem = () => {\n            let filter = new LogFilter();\n            if (filterCreator) {\n                try {\n                    filter = filterCreator(filter, item);\n                } catch (err) {\n                    console.error(\"Error while creating log filter\", err);\n                }\n            } else {\n                // if not filter is specified, filter out anything lower than the initial log level\n                filter = filter.minLevel(logLevel);\n            }\n            try {\n                this._persistItem(item, filter, false);\n            } catch (err) {\n                console.error(\"Could not persist log item\", err);\n            }\n            this._openItems.delete(item);\n        };\n\n        try {\n            let result = item.run(callback);\n            if (result instanceof Promise) {\n                result =  result.then(promiseResult => {\n                    finishItem();\n                    return promiseResult;\n                }, err => {\n                    finishItem();\n                    if (wantResult) {\n                        throw err;\n                    }\n                }) as unknown as T;\n                if (wantResult) {\n                    return result;\n                }\n            } else {\n                finishItem();\n                if(wantResult) {\n                    return result;\n                }\n            }\n        } catch (err) {\n            finishItem();\n            if (wantResult) {\n                throw err;\n            }\n        }\n    }\n\n    _finishOpenItems() {\n        for (const openItem of this._openItems) {\n            openItem.finish();\n            try {\n                // for now, serialize with an all-permitting filter\n                // as the createFilter function would get a distorted image anyway\n                // about the duration of the item, etc ...\n                // true for force finish\n                this._persistItem(openItem, new LogFilter(), true);\n            } catch (err) {\n                console.error(\"Could not serialize log item\", err);\n            }\n        }\n        this._openItems.clear();\n    }\n\n    abstract _persistItem(item: LogItem, filter?: LogFilter, forced?: boolean): void;\n\n    abstract export(): Promise<ILogExport | undefined>;\n\n    // expose log level without needing \n    get level(): typeof LogLevel {\n        return LogLevel;\n    }\n\n    _now(): number {\n        return this._platform.clock.now();\n    }\n\n    _createRefId(): number {\n        return Math.round(this._platform.random() * Number.MAX_SAFE_INTEGER);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {\n    openDatabase,\n    txnAsPromise,\n    reqAsPromise,\n    iterateCursor,\n    fetchResults,\n} from \"../matrix/storage/idb/utils\";\nimport {BaseLogger} from \"./BaseLogger\";\nimport type {Interval} from \"../platform/web/dom/Clock\";\nimport type {Platform} from \"../platform/web/Platform.js\";\nimport type {BlobHandle} from \"../platform/web/dom/BlobHandle.js\";\nimport type {ILogItem, ILogExport, ISerializedItem} from \"./types\";\nimport type {LogFilter} from \"./LogFilter\";\n\ntype QueuedItem = {\n    json: string;\n    id?: number;\n}\n\nexport class IDBLogger extends BaseLogger {\n    private readonly _name: string;\n    private readonly _limit: number;\n    private readonly _flushInterval: Interval;\n    private _queuedItems: QueuedItem[];\n\n    constructor(options: {name: string, flushInterval?: number, limit?: number, platform: Platform, serializedTransformer?: (item: ISerializedItem) => ISerializedItem}) {\n        super(options);\n        const {name, flushInterval = 60 * 1000, limit = 3000} = options;\n        this._name = name;\n        this._limit = limit;\n        this._queuedItems = this._loadQueuedItems();\n        // TODO: also listen for unload just in case sync keeps on running after pagehide is fired?\n        window.addEventListener(\"pagehide\", this, false);\n        this._flushInterval = this._platform.clock.createInterval(() => this._tryFlush(), flushInterval);\n    }\n\n    // TODO: move dispose to ILogger, listen to pagehide elsewhere and call dispose from there, which calls _finishAllAndFlush\n    dispose(): void {\n        window.removeEventListener(\"pagehide\", this, false);\n        this._flushInterval.dispose();\n    }\n\n    handleEvent(evt: Event): void {\n        if (evt.type === \"pagehide\") {\n            this._finishAllAndFlush();\n        }\n    }\n\n    async _tryFlush(): Promise<void> {\n        const db = await this._openDB();\n        try {\n            const txn = db.transaction([\"logs\"], \"readwrite\");\n            const logs = txn.objectStore(\"logs\");\n            const amount = this._queuedItems.length;\n            for(const i of this._queuedItems) {\n                logs.add(i);\n            }\n            const itemCount = await reqAsPromise(logs.count());\n            if (itemCount > this._limit) {\n                // delete an extra 10% so we don't need to delete every time we flush\n                let deleteAmount = (itemCount - this._limit) + Math.round(0.1 * this._limit);\n                await iterateCursor(logs.openCursor(), (_, __, cursor) => {\n                    cursor.delete();\n                    deleteAmount -= 1;\n                    return {done: deleteAmount === 0};\n                });\n            }\n            await txnAsPromise(txn);\n            this._queuedItems.splice(0, amount);\n        } catch (err) {\n            console.error(\"Could not flush logs\", err);\n        } finally {\n            try {\n                db.close();\n            } catch (e) {}\n        }\n    }\n\n    _finishAllAndFlush(): void {\n        this._finishOpenItems();\n        this.log({l: \"pagehide, closing logs\", t: \"navigation\"});\n        this._persistQueuedItems(this._queuedItems);\n    }\n\n    _loadQueuedItems(): QueuedItem[] {\n        const key = `${this._name}_queuedItems`;\n        try {\n            const json = window.localStorage.getItem(key);\n            if (json) {\n                window.localStorage.removeItem(key);\n                return JSON.parse(json);\n            }\n        } catch (err) {\n            console.error(\"Could not load queued log items\", err);\n        }\n        return [];\n    }\n\n    _openDB(): Promise<IDBDatabase> {\n        return openDatabase(this._name, db => db.createObjectStore(\"logs\", {keyPath: \"id\", autoIncrement: true}), 1);\n    }\n    \n    _persistItem(logItem: ILogItem, filter: LogFilter, forced: boolean): void {\n        const serializedItem = logItem.serialize(filter, undefined, forced);\n        if (serializedItem) {\n            const transformedSerializedItem = this._serializedTransformer(serializedItem);\n            this._queuedItems.push({\n                json: JSON.stringify(transformedSerializedItem)\n            });\n        }\n    }\n\n    _persistQueuedItems(items: QueuedItem[]): void {\n        try {\n            window.localStorage.setItem(`${this._name}_queuedItems`, JSON.stringify(items));\n        } catch (e) {\n            console.error(\"Could not persist queued log items in localStorage, they will likely be lost\", e);\n        }\n    }\n\n    async export(): Promise<ILogExport> {\n        const db = await this._openDB();\n        try {\n            const txn = db.transaction([\"logs\"], \"readonly\");\n            const logs = txn.objectStore(\"logs\");\n            const storedItems: QueuedItem[] = await fetchResults(logs.openCursor(), () => false);\n            const allItems = storedItems.concat(this._queuedItems);\n            return new IDBLogExport(allItems, this, this._platform);\n        } finally {\n            try {\n                db.close();\n            } catch (e) {}\n        }\n    }\n\n    async _removeItems(items: QueuedItem[]): Promise<void> {\n        const db = await this._openDB();\n        try {\n            const txn = db.transaction([\"logs\"], \"readwrite\");\n            const logs = txn.objectStore(\"logs\");\n            for (const item of items) {\n                if (typeof item.id === \"number\") {\n                    logs.delete(item.id);\n                } else {\n                    // assume the (non-persisted) object in each array will be the same\n                    const queuedIdx = this._queuedItems.indexOf(item);\n                    if (queuedIdx === -1) {\n                        this._queuedItems.splice(queuedIdx, 1);\n                    }\n                }\n            }\n            await txnAsPromise(txn);\n        } finally {\n            try {\n                db.close();\n            } catch (e) {}\n        }\n    }\n}\n\nclass IDBLogExport implements ILogExport {\n    private readonly _items: QueuedItem[];\n    private readonly _logger: IDBLogger;\n    private readonly _platform: Platform;\n\n    constructor(items: QueuedItem[], logger: IDBLogger, platform: Platform) {\n        this._items = items;\n        this._logger = logger;\n        this._platform = platform;\n    }\n    \n    get count(): number {\n        return this._items.length;\n    }\n\n    /**\n     * @return {Promise}\n     */\n    removeFromStore(): Promise<void> {\n        return this._logger._removeItems(this._items);\n    }\n\n    asBlob(): BlobHandle {\n        const log = {\n            formatVersion: 1,\n            appVersion: this._platform.updateService?.version,\n            items: this._items.map(i => JSON.parse(i.json))\n        };\n        const json = JSON.stringify(log);\n        const buffer: Uint8Array = this._platform.encoding.utf8.encode(json);\n        const blob: BlobHandle = this._platform.createBlob(buffer, \"application/json\");\n        return blob;\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {BaseLogger} from \"./BaseLogger\";\nimport {LogItem} from \"./LogItem\";\nimport type {ILogItem, LogItemValues, ILogExport} from \"./types\";\n\nexport class ConsoleLogger extends BaseLogger {\n    _persistItem(item: LogItem): void {\n        printToConsole(item);\n    }\n\n    async export(): Promise<ILogExport | undefined> {\n        return undefined;\n    }\n}\n\nconst excludedKeysFromTable = [\"l\", \"id\"];\nfunction filterValues(values: LogItemValues): LogItemValues | null {\n    return Object.entries(values)\n        .filter(([key]) => !excludedKeysFromTable.includes(key))\n        .reduce((obj: LogItemValues, [key, value]) => {\n            obj = obj || {};\n            obj[key] = value;\n            return obj;\n        }, null);\n}\n\nfunction printToConsole(item: LogItem): void {\n    const label = `${itemCaption(item)} (${item.duration}ms)`;\n    const filteredValues = filterValues(item.values);\n    const shouldGroup = item.children || filteredValues;\n    if (shouldGroup) {\n        if (item.error) {\n            console.group(label);\n        } else {\n            console.groupCollapsed(label);\n        }\n        if (item.error) {\n            console.error(item.error);\n        }\n    } else {\n        if (item.error) {\n            console.error(item.error);\n        } else {\n            console.log(label);\n        }\n    }\n    if (filteredValues) {\n        console.table(filteredValues);\n    }\n    if (item.children) {\n        for(const c of item.children) {\n            printToConsole(c);\n        }\n    }\n    if (shouldGroup) {\n        console.groupEnd();\n    }\n}\n\nfunction itemCaption(item: ILogItem): string {\n    if (item.values.t === \"network\") {\n        return `${item.values.method} ${item.values.url}`;\n    } else if (item.values.l && typeof item.values.id !== \"undefined\") {\n        return `${item.values.l} ${item.values.id}`;\n    } else if (item.values.l && typeof item.values.status !== \"undefined\") {\n        return `${item.values.l} (${item.values.status})`;\n    } else if (item.values.l && item.error) {\n        return `${item.values.l} failed`;\n    } else if (typeof item.values.ref !== \"undefined\") {\n        return `ref ${item.values.ref}`;\n    } else {\n        return item.values.l || item.values.type;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2021 Daniel Fedorin <danila.fedorin@gmail.com>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// DOM helper functions\n\nimport {ViewNode} from \"./types\";\n\nexport type ClassNames<T> = { [className: string]: boolean | ((value: T) => boolean) }\nexport type BasicAttributes<T> = { [attribute: string]: ClassNames<T> | boolean | string }\nexport type Child = string | Text | ViewNode;\n\nexport function isChildren(children: object | Child | Child[]): children is Child | Child[] {\n    // children should be an not-object (that's the attributes), or a domnode, or an array\n    return typeof children !== \"object\" || \"nodeType\" in children || Array.isArray(children);\n}\n\nexport function classNames<T>(obj: ClassNames<T>, value: T): string {\n    return Object.entries(obj).reduce((cn, [name, enabled]) => {\n        if (typeof enabled === \"function\") {\n            enabled = enabled(value);\n        }\n        if (enabled) {\n            return cn + (cn.length ? \" \" : \"\") + name;\n        } else {\n            return cn;\n        }\n    }, \"\");\n}\n\nexport function setAttribute(el: Element, name: string, value: string | boolean): void {\n    if (name === \"className\") {\n        name = \"class\";\n    }\n    if (value === false) {\n        el.removeAttribute(name);\n    } else {\n        if (value === true) {\n            value = name;\n        }\n        el.setAttribute(name, value);\n    }\n}\n\nexport function el(elementName: string, attributes?: BasicAttributes<never> | Child | Child[], children?: Child | Child[]): Element {\n    return elNS(HTML_NS, elementName, attributes, children);\n}\n\nexport function elNS(ns: string, elementName: string, attributes?: BasicAttributes<never> | Child | Child[], children?: Child | Child[]): Element {\n    if (attributes && isChildren(attributes)) {\n        children = attributes;\n        attributes = undefined;\n    }\n\n    const e = document.createElementNS(ns, elementName);\n\n    if (attributes) {\n        for (let [name, value] of Object.entries(attributes)) {\n            if (typeof value === \"object\") {\n                // Only className should ever be an object; be careful\n                // here anyway and ignore object-valued non-className attributes.\n                value = (value !== null && name === \"className\") ? classNames(value, undefined) : false;\n            }\n            setAttribute(e, name, value);\n        }\n    }\n\n    if (children) {\n        if (!Array.isArray(children)) {\n            children = [children];\n        }\n        for (let c of children) {\n            if (typeof c === \"string\") {\n                c = text(c);\n            }\n            e.appendChild(c);\n        }\n    }\n    return e;\n}\n\nexport function text(str: string): Text {\n    return document.createTextNode(str);\n}\n\nexport const HTML_NS: string = \"http://www.w3.org/1999/xhtml\";\nexport const SVG_NS: string = \"http://www.w3.org/2000/svg\";\n\nexport const TAG_NAMES = {\n    [HTML_NS]: [\n        \"br\", \"a\", \"ol\", \"ul\", \"li\", \"div\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n        \"p\", \"strong\", \"em\", \"span\", \"img\", \"section\", \"main\", \"article\", \"aside\", \"del\", \"blockquote\",\n        \"table\", \"thead\", \"tbody\", \"tr\", \"th\", \"td\", \"hr\",\n        \"pre\", \"code\", \"button\", \"time\", \"input\", \"textarea\", \"label\", \"form\", \"progress\", \"output\", \"video\"],\n    [SVG_NS]: [\"svg\", \"circle\"]\n} as const;\n\nexport const tag: { [tagName in typeof TAG_NAMES[string][number]]: (attributes?: BasicAttributes<never> | Child | Child[], children?: Child | Child[]) => Element } = {} as any;\n\nfor (const [ns, tags] of Object.entries(TAG_NAMES)) {\n    for (const tagName of tags) {\n        tag[tagName] = function(attributes, children) {\n            return elNS(ns, tagName, attributes, children);\n        }\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {IView, IMountArgs, ViewNode} from \"./types\";\nimport {tag} from \"./html\";\n\nexport function mountView(view: IView, mountArgs?: IMountArgs): ViewNode {\n    let node;\n    try {\n        node = view.mount(mountArgs);\n    } catch (err) {\n        node = errorToDOM(err);\n    }\n    return node;\n}\n\nexport function errorToDOM(error: Error): Element {\n    const stack = new Error().stack;\n    let callee: string | null = null;\n    if (stack) {\n        callee = stack.split(\"\\n\")[1];\n    }\n    return tag.div([\n        tag.h2(\"Something went wrong…\"),\n        tag.h3(error.message),\n        tag.p(`This occurred while running ${callee}.`),\n        tag.pre(error.stack),\n    ]);\n}\n\nexport function insertAt(parentNode: Element, idx: number, childNode: Node): void {\n    const isLast = idx === parentNode.childElementCount;\n    if (isLast) {\n        parentNode.appendChild(childNode);\n    } else {\n        const nextDomNode = parentNode.children[idx];\n        parentNode.insertBefore(childNode, nextDomNode);\n    }\n}\n\nexport function removeChildren(parentNode: Element): void {\n    parentNode.innerHTML = '';\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {el} from \"./html\";\nimport {mountView, insertAt} from \"./utils\";\nimport {SubscriptionHandle} from \"../../../../observable/BaseObservable\";\nimport {BaseObservableList as ObservableList, IListObserver} from \"../../../../observable/list/BaseObservableList\";\nimport {IView, IMountArgs} from \"./types\";\n\nexport interface IOptions<T, V> {\n    list: ObservableList<T>,\n    onItemClick?: (childView: V, evt: UIEvent) => void,\n    className?: string,\n    tagName?: string,\n    parentProvidesUpdates?: boolean\n}\n\nexport class ListView<T, V extends IView> implements IView, IListObserver<T> {\n\n    private _onItemClick?: (childView: V, evt: UIEvent) => void;\n    private _className?: string;\n    private _tagName: string;\n    private _root?: Element;\n    protected _subscription?: SubscriptionHandle;\n    protected _childCreator: (value: T) => V;\n    protected _mountArgs: IMountArgs;\n    protected _list: ObservableList<T>;\n    protected _childInstances?: V[];\n\n    constructor(\n        {list, onItemClick, className, tagName = \"ul\", parentProvidesUpdates = true}: IOptions<T, V>, \n        childCreator: (value: T) => V\n    ) {\n        this._onItemClick = onItemClick;\n        this._list = list;\n        this._className = className;\n        this._tagName = tagName;\n        this._root = undefined;\n        this._subscription = undefined;\n        this._childCreator = childCreator;\n        this._childInstances = undefined;\n        this._mountArgs = {parentProvidesUpdates};\n    }\n\n    root(): Element | undefined {\n        // won't be undefined when called between mount and unmount\n        return this._root;\n    }\n\n    update(attributes: IOptions<T, V>) {\n        if (attributes.list) {\n            if (this._subscription) {\n                this._unloadList();\n                while (this._root!.lastChild) {\n                    this._root!.lastChild.remove();\n                }\n            }\n            this._list = attributes.list;\n            this.loadList();\n        }\n    }\n\n    mount(): Element {\n        const attr: {[name: string]: any} = {};\n        if (this._className) {\n            attr.className = this._className;\n        }\n        const root = this._root = el(this._tagName, attr);\n        this.loadList();\n        if (this._onItemClick) {\n            root.addEventListener(\"click\", this);\n        }\n        return root;\n    }\n\n    handleEvent(evt: Event) {\n        if (evt.type === \"click\") {\n            this._handleClick(evt as UIEvent);\n        }\n    }\n\n    unmount(): void {\n        if (this._list) {\n            this._unloadList();\n        }\n    }\n\n    private _handleClick(event: UIEvent) {\n        if (event.target === this._root || !this._onItemClick) {\n            return;\n        }\n        let childNode = event.target as Element;\n        while (childNode.parentNode !== this._root) {\n            childNode = childNode.parentNode as Element;\n        }\n        const index = Array.prototype.indexOf.call(this._root!.childNodes, childNode);\n        const childView = this._childInstances![index];\n        if (childView) {\n            this._onItemClick(childView, event);\n        }\n    }\n\n    private _unloadList() {\n        this._subscription = this._subscription!();\n        for (let child of this._childInstances!) {\n            child.unmount();\n        }\n        this._childInstances = undefined;\n    }\n\n    protected loadList() {\n        if (!this._list) {\n            return;\n        }\n        this._subscription = this._list.subscribe(this);\n        this._childInstances = [];\n        const fragment = document.createDocumentFragment();\n        for (let item of this._list) {\n            const child = this._childCreator(item);\n            this._childInstances!.push(child);\n            fragment.appendChild(mountView(child, this._mountArgs));\n        }\n        this._root!.appendChild(fragment);\n    }\n\n    onReset() {\n        for (const child of this._childInstances!) {\n            child.root()!.remove();\n            child.unmount();\n        }\n        this._childInstances!.length = 0;\n    }\n\n    onAdd(idx: number, value: T) {\n        this.addChild(idx, value);\n    }\n\n    onRemove(idx: number, value: T) {\n        this.removeChild(idx);\n    }\n\n    onMove(fromIdx: number, toIdx: number, value: T) {\n        this.moveChild(fromIdx, toIdx);\n    }\n\n    onUpdate(i: number, value: T, params: any) {\n        this.updateChild(i, value, params);\n    }\n\n    protected addChild(childIdx: number, value: T) {\n        const child = this._childCreator(value);\n        this._childInstances!.splice(childIdx, 0, child);\n        insertAt(this._root!, childIdx, mountView(child, this._mountArgs));\n    }\n\n    protected removeChild(childIdx: number) {\n        const [child] = this._childInstances!.splice(childIdx, 1);\n        child.root()!.remove();\n        child.unmount();\n    }\n\n    protected moveChild(fromChildIdx: number, toChildIdx: number) {\n        const [child] = this._childInstances!.splice(fromChildIdx, 1);\n        this._childInstances!.splice(toChildIdx, 0, child);\n        child.root()!.remove();\n        insertAt(this._root!, toChildIdx, child.root()! as Element);\n    }\n\n    protected updateChild(childIdx: number, value: T, params: any) {\n        if (this._childInstances) {\n            const instance = this._childInstances![childIdx];\n            instance && instance.update(value, params);\n        }\n    }\n\n    // TODO: is this the list or view index? \n    protected recreateItem(index: number, value: T) {\n        if (this._childInstances) {\n            const child = this._childCreator(value);\n            if (!child) {\n                this.onRemove(index, value);\n            } else {\n                const [oldChild] = this._childInstances!.splice(index, 1, child);\n                this._root!.replaceChild(child.mount(this._mountArgs), oldChild.root()!);\n                oldChild.unmount();\n            }\n        }\n    }\n\n    public getChildInstanceByIndex(idx: number): V | undefined {\n        return this._childInstances?.[idx];\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\nCopyright 2021 Daniel Fedorin <danila.fedorin@gmail.com>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {IMountArgs, ViewNode, IView} from \"./types\";\n\nexport interface IObservableValue {\n    on?(event: \"change\", handler: (props?: string[]) => void): void;\n    off?(event: \"change\", handler: (props?: string[]) => void): void;\n}\n\nexport abstract class BaseUpdateView<T extends IObservableValue> implements IView {\n    protected _value: T\n    protected _boundUpdateFromValue: ((props?: string[]) => void) | null\n\n    abstract mount(args?: IMountArgs): ViewNode;\n    abstract root(): ViewNode | undefined;\n    abstract update(...any);\n\n    constructor(value :T) {\n        this._value = value;\n        // TODO: can avoid this if we adopt the handleEvent pattern in our EventListener\n        this._boundUpdateFromValue = null;\n    }\n\n    subscribeOnMount(options?: IMountArgs): void {\n        const parentProvidesUpdates = options && options.parentProvidesUpdates;\n        if (!parentProvidesUpdates) {\n            this._subscribe();\n        }\n    }\n\n    unmount(): void {\n        this._unsubscribe();\n    }\n\n    get value(): T {\n        return this._value;\n    }\n\n    _updateFromValue(changedProps?: string[]) {\n        this.update(this._value, changedProps);\n    }\n\n    _subscribe(): void {\n        if (typeof this._value?.on === \"function\") {\n            this._boundUpdateFromValue = this._updateFromValue.bind(this) as (props?: string[]) => void;\n            this._value.on(\"change\", this._boundUpdateFromValue);\n        }\n    }\n\n    _unsubscribe(): void {\n        if (this._boundUpdateFromValue) {\n            if (typeof this._value.off === \"function\") {\n                this._value.off(\"change\", this._boundUpdateFromValue);\n            }\n            this._boundUpdateFromValue = null;\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2021 Daniel Fedorin <danila.fedorin@gmail.com>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { setAttribute, text, isChildren, classNames, TAG_NAMES, HTML_NS, ClassNames, Child} from \"./html\";\nimport {mountView} from \"./utils\";\nimport {BaseUpdateView, IObservableValue} from \"./BaseUpdateView\";\nimport {IMountArgs, ViewNode, IView} from \"./types\";\n\nfunction objHasFns(obj: ClassNames<unknown>): obj is { [className: string]: boolean } {\n    for(const value of Object.values(obj)) {\n        if (typeof value === \"function\") {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport type RenderFn<T> = (t: Builder<T>, vm: T) => ViewNode;\ntype EventHandler = ((event: Event) => void);\ntype AttributeStaticValue = string | boolean;\ntype AttributeBinding<T> = (value: T) => AttributeStaticValue;\nexport type AttrValue<T> = AttributeStaticValue | AttributeBinding<T> | EventHandler | ClassNames<T>;\nexport type Attributes<T> = { [attribute: string]: AttrValue<T> };\ntype ElementFn<T> = (attributes?: Attributes<T> | Child | Child[], children?: Child | Child[]) => Element;\nexport type Builder<T> = TemplateBuilder<T> & { [tagName in typeof TAG_NAMES[string][number]]: ElementFn<T> };\n\n/**\n    Bindable template. Renders once, and allows bindings for given nodes. If you need\n    to change the structure on a condition, use a subtemplate (if)\n\n    supports\n        - event handlers (attribute fn value with name that starts with on)\n        - one way binding of attributes (other attribute fn value)\n        - one way binding of text values (child fn value)\n        - refs to get dom nodes\n        - className binding returning object with className => enabled map\n        - add subviews inside the template\n*/\n// TODO: should we rename this to BoundView or something? As opposed to StaticView ...\nexport abstract class TemplateView<T extends IObservableValue> extends BaseUpdateView<T> {\n    private _eventListeners?: { node: Element, name: string, fn: EventHandler, useCapture: boolean }[] = undefined;\n    private _bindings?: (() => void)[] = undefined;\n    private _root?: ViewNode = undefined;\n    // public because used by TemplateBuilder\n    _subViews?: IView[] = undefined;\n\n    _attach(): void {\n        if (this._eventListeners) {\n            for (let {node, name, fn, useCapture} of this._eventListeners) {\n                node.addEventListener(name, fn, useCapture);\n            }\n        }\n    }\n\n    _detach(): void {\n        if (this._eventListeners) {\n            for (let {node, name, fn, useCapture} of this._eventListeners) {\n                node.removeEventListener(name, fn, useCapture);\n            }\n        }\n    }\n\n    abstract render(t: Builder<T>, value: T): ViewNode;\n\n    mount(options?: IMountArgs): ViewNode {\n        const builder = new TemplateBuilder(this) as Builder<T>;\n        try {\n            this._root = this.render(builder, this._value);\n        } finally {\n            builder.close();\n        }\n        // takes care of update being called when needed\n        this.subscribeOnMount(options);\n        this._attach();\n        return this._root!;\n    }\n\n    unmount(): void {\n        this._detach();\n        super.unmount();\n        if (this._subViews) {\n            for (const v of this._subViews) {\n                v.unmount();\n            }\n        }\n    }\n\n    root(): ViewNode | undefined {\n        return this._root;\n    }\n\n    update(value: T, props?: string[]): void {\n        this._value = value;\n        if (this._bindings) {\n            for (const binding of this._bindings) {\n                binding();\n            }\n        }\n    }\n\n    _addEventListener(node: Element, name: string, fn: (event: Event) => void, useCapture: boolean = false): void {\n        if (!this._eventListeners) {\n            this._eventListeners = [];\n        }\n        this._eventListeners.push({node, name, fn, useCapture});\n    }\n\n    _addBinding(bindingFn: () => void): void {\n        if (!this._bindings) {\n            this._bindings = [];\n        }\n        this._bindings.push(bindingFn);\n    }\n\n    addSubView(view: IView): void {\n        if (!this._subViews) {\n            this._subViews = [];\n        }\n        this._subViews.push(view);\n    }\n\n    removeSubView(view: IView): void {\n        if (!this._subViews) { return; }\n        const idx = this._subViews.indexOf(view);\n        if (idx !== -1) {\n            this._subViews.splice(idx, 1);\n        }\n    }\n\n    updateSubViews(value: IObservableValue, props: string[]) {\n        if (this._subViews) {\n            for (const v of this._subViews) {\n                v.update(value, props);\n            }\n        }\n    }\n}\n\n// what is passed to render\nexport class TemplateBuilder<T extends IObservableValue> {\n    private _templateView: TemplateView<T>;\n    private _closed: boolean = false;\n\n    constructor(templateView: TemplateView<T>) {\n        this._templateView = templateView;\n    }\n\n    close(): void {\n        this._closed = true;\n    }\n\n    _addBinding(fn: () => void): void {\n        if (this._closed) {\n            console.trace(\"Adding a binding after render will likely cause memory leaks\");\n        }\n        this._templateView._addBinding(fn);\n    }\n\n    get _value(): T {\n        return this._templateView.value;\n    }\n\n    addEventListener(node: Element, name: string, fn: (event: Event) => void, useCapture: boolean = false): void {\n        this._templateView._addEventListener(node, name, fn, useCapture);\n    }\n\n    _addAttributeBinding(node: Element, name: string, fn: (value: T) => boolean | string): void {\n        let prevValue: string | boolean | undefined = undefined;\n        const binding = () => {\n            const newValue = fn(this._value);\n            if (prevValue !== newValue) {\n                prevValue = newValue;\n                setAttribute(node, name, newValue);\n            }\n        };\n        this._addBinding(binding);\n        binding();\n    }\n\n    _addClassNamesBinding(node: Element, obj: ClassNames<T>): void {\n        this._addAttributeBinding(node, \"className\", value => classNames(obj, value));\n    }\n\n    _addTextBinding(fn: (value: T) => string): Text {\n        const initialValue = fn(this._value);\n        const node = text(initialValue);\n        let prevValue = initialValue;\n        const binding = () => {\n            const newValue = fn(this._value);\n            if (prevValue !== newValue) {\n                prevValue = newValue;\n                node.textContent = newValue+\"\";\n            }\n        };\n\n        this._addBinding(binding);\n        return node;\n    }\n\n    _isEventHandler(key: string, value: AttrValue<T>): value is (event: Event) => void {\n        // This isn't actually safe, but it's incorrect to feed event handlers to\n        // non-on* attributes.\n        return key.startsWith(\"on\") && key.length > 2 && typeof value === \"function\";\n    }\n\n    _setNodeAttributes(node: Element, attributes: Attributes<T>): void {\n        for(let [key, value] of Object.entries(attributes)) {\n            // binding for className as object of className => enabled\n            if (typeof value === \"object\") {\n                if (key !== \"className\" || value === null) {\n                    // Ignore non-className objects.\n                    continue;\n                }\n                if (objHasFns(value)) {\n                    this._addClassNamesBinding(node, value);\n                } else {\n                    setAttribute(node, key, classNames(value, this._value));\n                }\n            } else if (this._isEventHandler(key, value)) {\n                const eventName = key.substr(2, 1).toLowerCase() + key.substr(3);\n                const handler = value;\n                this._templateView._addEventListener(node, eventName, handler);\n            } else if (typeof value === \"function\") {\n                this._addAttributeBinding(node, key, value);\n            } else {\n                setAttribute(node, key, value);\n            }\n        }\n    }\n\n    _setNodeChildren(node: Element, children: Child | Child[]): void{\n        if (!Array.isArray(children)) {\n            children = [children];\n        }\n        for (let child of children) {\n            if (typeof child === \"function\") {\n                child = this._addTextBinding(child);\n            } else if (typeof child === \"string\") {\n                // not a DOM node, turn into text\n                child = text(child);\n            }\n            node.appendChild(child);\n        }\n    }\n    \n    _addReplaceNodeBinding<R>(fn: (value: T) => R, renderNode: (old: ViewNode | null) => ViewNode): ViewNode {\n        let prevValue = fn(this._value);\n        let node = renderNode(null);\n\n        const binding = () => {\n            const newValue = fn(this._value);\n            if (prevValue !== newValue) {\n                prevValue = newValue;\n                const newNode = renderNode(node);\n                if (node.parentNode) {\n                    node.parentNode.replaceChild(newNode, node);\n                }\n                node = newNode;\n            }\n        };\n        this._addBinding(binding);\n        return node;\n    }\n\n    el(name: string, attributes?: Attributes<T> | Child | Child[], children?: Child | Child[]): ViewNode {\n        return this.elNS(HTML_NS, name, attributes, children);\n    }\n\n    elNS(ns: string, name: string, attributes?: Attributes<T> | Child | Child[], children?: Child | Child[]): ViewNode {\n        if (attributes !== undefined && isChildren(attributes)) {\n            children = attributes;\n            attributes = undefined;\n        }\n\n        const node = document.createElementNS(ns, name);\n        \n        if (attributes) {\n            this._setNodeAttributes(node, attributes);\n        }\n        if (children) {\n            this._setNodeChildren(node, children);\n        }\n\n        return node;\n    }\n\n    // this inserts a view, and is not a view factory for `if`, so returns the root element to insert in the template\n    // you should not call t.view() and not use the result (e.g. attach the result to the template DOM tree).\n    view(view: IView, mountOptions?: IMountArgs): ViewNode {\n        this._templateView.addSubView(view);\n        return mountView(view, mountOptions);\n    }\n\n    // map a value to a view, every time the value changes\n    mapView<R>(mapFn: (value: T) => R, viewCreator: (mapped: R) => IView | null): ViewNode {\n        return this._addReplaceNodeBinding(mapFn, (prevNode) => {\n            if (prevNode && prevNode.nodeType !== Node.COMMENT_NODE) {\n                const subViews = this._templateView._subViews;\n                if (subViews) {\n                    const viewIdx = subViews.findIndex(v => v.root() === prevNode);\n                    if (viewIdx !== -1) {\n                        const [view] = subViews.splice(viewIdx, 1);\n                        view.unmount();\n                    }\n                }\n            }\n            const view = viewCreator(mapFn(this._value));\n            if (view) {\n                return this.view(view);\n            } else {\n                return document.createComment(\"node binding placeholder\");\n            }\n        });\n    }\n\n    // Special case of mapView for a TemplateView.\n    // Always creates a TemplateView, if this is optional depending\n    // on mappedValue, use `if` or `mapView`\n    map<R>(mapFn: (value: T) => R, renderFn: (mapped: R, t: Builder<T>, vm: T) => ViewNode): ViewNode {\n        return this.mapView(mapFn, mappedValue => {\n            return new InlineTemplateView(this._value, (t, vm) => {\n                const rootNode = renderFn(mappedValue, t, vm);\n                if (!rootNode) {\n                    // TODO: this will confuse mapView which assumes that\n                    // a comment node means there is no view to clean up\n                    return document.createComment(\"map placeholder\");\n                }\n                return rootNode;\n            });\n        });\n    }\n\n    ifView(predicate: (value: T) => boolean, viewCreator: (value: T) => IView): ViewNode {\n        return this.mapView(\n            value => !!predicate(value),\n            enabled => enabled ? viewCreator(this._value) : null\n        );\n    }\n\n    // creates a conditional subtemplate\n    // use mapView if you need to map to a different view class\n    if(predicate: (value: T) => boolean, renderFn: (t: Builder<T>, vm: T) => ViewNode) {\n        return this.ifView(predicate, vm => new InlineTemplateView(vm, renderFn));\n    }\n\n    /** You probably are looking for something else, like map or mapView.\n    This is an escape hatch that allows you to do manual DOM manipulations\n    as a reaction to a binding change.\n    This should only be used if the side-effect won't add any bindings,\n    event handlers, ...\n    You should not call the TemplateBuilder (e.g. `t.xxx()`) at all from the side effect,\n    instead use tags from html.ts to help you construct any DOM you need. */\n    mapSideEffect<R>(mapFn: (value: T) => R, sideEffect: (newV: R, oldV: R | undefined) => void) {\n        let prevValue = mapFn(this._value);\n        const binding = () => {\n            const newValue = mapFn(this._value);\n            if (prevValue !== newValue) {\n                sideEffect(newValue, prevValue);\n                prevValue = newValue;\n            }\n        };\n        this._addBinding(binding);\n        sideEffect(prevValue, undefined);\n    }\n}\n\n\nfor (const [ns, tags] of Object.entries(TAG_NAMES)) {\n    for (const tag of tags) {\n        TemplateBuilder.prototype[tag] = function(attributes, children) {\n            return this.elNS(ns, tag, attributes, children);\n        };\n    }\n}\n\nexport class InlineTemplateView<T> extends TemplateView<T> {\n    private _render: RenderFn<T>;\n\n    constructor(value: T, render: RenderFn<T>) {\n        super(value);\n        this._render = render;\n    }\n\n    override render(t: Builder<T>, value: T): ViewNode {\n        return this._render(t, value);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {tag, text, classNames, setAttribute} from \"./general/html\";\n/**\n * @param  {Object} vm   view model with {avatarUrl, avatarColorNumber, avatarTitle, avatarLetter}\n * @param  {Number} size\n * @return {Element}\n */\nexport function renderStaticAvatar(vm, size, extraClasses = undefined) {\n    const hasAvatar = !!vm.avatarUrl(size);\n    let avatarClasses = classNames({\n        avatar: true,\n        [`size-${size}`]: true,\n        [`usercolor${vm.avatarColorNumber}`]: !hasAvatar\n    });\n    if (extraClasses) {\n        avatarClasses += ` ${extraClasses}`;\n    }\n    const avatarContent = hasAvatar ? renderImg(vm, size) : text(vm.avatarLetter);\n    const avatar = tag.div({className: avatarClasses}, [avatarContent]);\n    if (hasAvatar) {\n        setAttribute(avatar, \"data-avatar-letter\", vm.avatarLetter);\n        setAttribute(avatar, \"data-avatar-color\", vm.avatarColorNumber);\n    }\n    return avatar;\n}\n\nexport function renderImg(vm, size) {\n    const sizeStr = size.toString();\n    return tag.img({src: vm.avatarUrl(size), width: sizeStr, height: sizeStr, title: vm.avatarTitle});\n}\n\nfunction isAvatarEvent(e) {\n    const element = e.target;\n    const parent = element.parentElement;\n    return element.tagName === \"IMG\" && parent.classList.contains(\"avatar\");\n}\n\nexport function handleAvatarError(e) {\n    if (!isAvatarEvent(e)) { return; }\n    const parent = e.target.parentElement;\n    const avatarColorNumber = parent.getAttribute(\"data-avatar-color\");\n    parent.classList.add(`usercolor${avatarColorNumber}`);\n    const avatarLetter = parent.getAttribute(\"data-avatar-letter\");\n    parent.textContent = avatarLetter;\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseUpdateView} from \"./general/BaseUpdateView\";\nimport {renderStaticAvatar, renderImg} from \"./avatar.js\";\n\n/*\noptimization to not use a sub view when changing between img and text\nbecause there can be many many instances of this view\n*/\n\nexport class AvatarView extends BaseUpdateView {\n    /**\n     * @param  {ViewModel} value   view model with {avatarUrl, avatarColorNumber, avatarTitle, avatarLetter}\n     * @param  {Number} size\n     */\n    constructor(value, size) {\n        super(value);\n        this._root = null;\n        this._avatarUrl = null;\n        this._avatarTitle = null;\n        this._avatarLetter = null;\n        this._size = size;\n    }\n\n    _avatarUrlChanged() {\n        if (this.value.avatarUrl(this._size) !== this._avatarUrl) {\n            this._avatarUrl = this.value.avatarUrl(this._size);\n            return true;\n        }\n        return false;\n    }\n\n    _avatarTitleChanged() {\n        if (this.value.avatarTitle !== this._avatarTitle) {\n            this._avatarTitle = this.value.avatarTitle;\n            return true;\n        }\n        return false;\n    }\n\n    _avatarLetterChanged() {\n        if (this.value.avatarLetter !== this._avatarLetter) {\n            this._avatarLetter = this.value.avatarLetter;\n            return true;\n        }\n        return false;\n    }\n\n    mount(options) {\n        this._avatarUrlChanged();\n        this._avatarLetterChanged();\n        this._avatarTitleChanged();\n        this._root = renderStaticAvatar(this.value, this._size);\n        // takes care of update being called when needed\n        this.subscribeOnMount(options);\n        return this._root;\n    }\n\n    root() {\n        return this._root;\n    }\n\n    update(vm) {\n        // important to always call _...changed for every prop \n        if (this._avatarUrlChanged()) {\n            // avatarColorNumber won't change, it's based on room/user id\n            const bgColorClass = `usercolor${vm.avatarColorNumber}`;\n            if (vm.avatarUrl(this._size)) {\n                this._root.replaceChild(renderImg(vm, this._size), this._root.firstChild);\n                this._root.classList.remove(bgColorClass);\n            } else {\n                this._root.textContent = vm.avatarLetter;\n                this._root.classList.add(bgColorClass);\n            }\n        }\n        const hasAvatar = !!vm.avatarUrl(this._size);\n        if (this._avatarTitleChanged() && hasAvatar) {\n            const element = this._root.firstChild;\n            if (element.tagName === \"IMG\") {\n                element.setAttribute(\"title\", vm.avatarTitle);\n            }\n        }\n        if (this._avatarLetterChanged() && !hasAvatar) {\n            this._root.textContent = vm.avatarLetter;\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nlet container;\n\nexport function spinner(t, extraClasses = undefined) {\n    if (container === undefined) {\n        container = document.querySelector(\".hydrogen\");\n    }\n    const classes = Object.assign({\"spinner\": true}, extraClasses);\n    if (container?.classList.contains(\"legacy\")) {\n        return t.div({className: classes}, [\n            t.div(),\n            t.div(),\n            t.div(),\n            t.div(),\n        ]);\n    } else {\n        return t.svg({className: classes, viewBox:\"0 0 100 100\"}, \n            t.circle({cx:\"50%\", cy:\"50%\", r:\"45%\", pathLength:\"100\"})\n        );\n    }\n}\n\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\nimport {AvatarView} from \"../../AvatarView.js\";\nimport {spinner} from \"../../common.js\";\n\nexport class RoomTileView extends TemplateView {\n    render(t, vm) {\n        const classes = {\n            \"active\": vm => vm.isOpen,\n            \"hidden\": vm => vm.hidden\n        };\n        return t.li({\"className\": classes}, [\n            t.a({href: vm.url}, [\n                t.view(new AvatarView(vm, 32), {parentProvidesUpdates: true}),\n                t.div({className: \"description\"}, [\n                    t.div({className: {\"name\": true, unread: vm => vm.isUnread}}, vm => vm.name),\n                    t.map(vm => vm.busy, busy => {\n                        if (busy) {\n                            return spinner(t);\n                        } else {\n                            return t.div({\n                                className: {\n                                    badge: true,\n                                    highlighted: vm => vm.isHighlighted,\n                                    hidden: vm => !vm.badgeCount\n                                }\n                            }, vm => vm.badgeCount);\n                        }\n                    })\n                ])\n            ])\n        ]);\n    }\n\n    update(value, props) {\n        super.update(value);\n        // update the AvatarView as we told it to not subscribe itself with parentProvidesUpdates\n        this.updateSubViews(value, props);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ListView} from \"../../general/ListView\";\nimport {TemplateView} from \"../../general/TemplateView\";\nimport {RoomTileView} from \"./RoomTileView.js\";\n\nclass FilterField extends TemplateView {\n    render(t, options) {\n        const clear = () => {\n            filterInput.value = \"\";\n            filterInput.blur();\n            clearButton.blur();\n            options.clear();\n        };\n        const filterInput = t.input({\n            type: \"text\",\n            placeholder: options?.label,\n            \"aria-label\": options?.label,\n            autocomplete: options?.autocomplete,\n            enterkeyhint: 'search',\n            name: options?.name,\n            onInput: event => options.set(event.target.value),\n            onKeydown: event => {\n                if (event.key === \"Escape\" || event.key === \"Esc\") {\n                    clear();\n                }\n            },\n            onFocus: () => filterInput.select()\n        });\n        const clearButton = t.button({\n            onClick: clear,\n            title: options.i18n`Clear`,\n            \"aria-label\": options.i18n`Clear`\n        });\n        return t.div({className: \"FilterField\"}, [filterInput, clearButton]);\n    }\n}\n\nexport class LeftPanelView extends TemplateView {\n    render(t, vm) {\n        const gridButtonLabel = vm => {\n            return vm.gridEnabled ?\n                vm.i18n`Show single room` :\n                vm.i18n`Enable grid layout`;\n        };\n        const roomList = t.view(new ListView(\n            {\n                className: \"RoomList\",\n                list: vm.tileViewModels,\n            },\n            tileVM => new RoomTileView(tileVM)\n        ));\n        const utilitiesRow = t.div({className: \"utilities\"}, [\n            t.a({className: \"button-utility close-session\", href: vm.closeUrl, \"aria-label\": vm.i18n`Back to account list`, title: vm.i18n`Back to account list`}),\n            t.view(new FilterField({\n                i18n: vm.i18n,\n                label: vm.i18n`Filter rooms…`,\n                name: \"room-filter\",\n                autocomplete: true,\n                set: query => {\n                    // scroll up if we just started filtering\n                    if (vm.setFilter(query)) {\n                        roomList.scrollTop = 0;\n                    }\n                },\n                clear: () => vm.clearFilter()\n            })),\n            t.button({\n                onClick: () => vm.toggleGrid(),\n                className: {\n                    \"button-utility\": true,\n                    grid: true,\n                    on: vm => vm.gridEnabled\n                },\n                title: gridButtonLabel,\n                \"aria-label\": gridButtonLabel\n            }),\n            t.a({className: \"button-utility settings\", href: vm.settingsUrl, \"aria-label\": vm.i18n`Settings`, title: vm.i18n`Settings`}),\n            t.a({className: \"button-utility create\", href: vm.createRoomUrl, \"aria-label\": vm.i18n`Create room`, title: vm.i18n`Create room`}),\n        ]);\n\n        return t.div({className: \"LeftPanel\"}, [\n            utilitiesRow,\n            roomList\n        ]);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {tag} from \"./html\";\n\nexport class Popup {\n    constructor(view, closeCallback = null) {\n        this._view = view;\n        this._target = null;\n        this._arrangement = null;\n        this._scroller = null;\n        this._fakeRoot = null;\n        this._trackingTemplateView = null;\n        this._closeCallback = closeCallback;\n    }\n\n    _getPopupContainer() {\n        const appContainer = this._target.closest(\".hydrogen\");\n        let popupContainer = appContainer.querySelector(\".popupContainer\");\n        if (!popupContainer) {\n            popupContainer = tag.div({className: \"popupContainer\"});\n            appContainer.appendChild(popupContainer);\n        }\n        return popupContainer;\n    }\n\n    trackInTemplateView(templateView) {\n        this._trackingTemplateView = templateView;\n        this._trackingTemplateView.addSubView(this);\n    }\n\n    showRelativeTo(target, verticalPadding = 0) {\n        this._target = target;\n        this._verticalPadding = verticalPadding;\n        this._scroller = findScrollParent(this._target);\n        this._view.mount();\n        this._getPopupContainer().appendChild(this._popup);\n        this._position();\n        if (this._scroller) {\n            document.body.addEventListener(\"scroll\", this, true);\n        }\n        setTimeout(() => {\n            document.body.addEventListener(\"click\", this, false);\n        }, 10);\n    }\n\n    get isOpen() {\n        return !!this._view;\n    }\n\n    close() {\n        if (this._view) {\n            this._view.unmount();\n            this._trackingTemplateView.removeSubView(this);\n            if (this._scroller) {\n                document.body.removeEventListener(\"scroll\", this, true);\n            }\n            document.body.removeEventListener(\"click\", this, false);\n            this._popup.remove();\n            this._view = null;\n            if (this._closeCallback) {\n                this._closeCallback();\n            }\n        }\n    }\n\n    get _popup() {\n        return this._view.root();\n    }\n\n    handleEvent(evt) {\n        if (evt.type === \"scroll\") {\n            if(!this._position()) {\n                this.close();\n            }\n        } else if (evt.type === \"click\") {\n            this._onClick(evt);\n        }\n    }\n\n    _onClick() {\n        this.close();\n    }\n\n    _position() {\n        const targetPosition = this._target.getBoundingClientRect();\n        const popupWidth = this._popup.clientWidth;\n        const popupHeight = this._popup.clientHeight;\n        const viewport = (this._scroller ? this._scroller : document.documentElement).getBoundingClientRect();\n\n        if (\n            targetPosition.top > viewport.bottom ||\n            targetPosition.left > viewport.right ||\n            targetPosition.bottom < viewport.top ||\n            targetPosition.right < viewport.left\n        ) {\n            return false;\n        }\n        if (viewport.bottom >= targetPosition.bottom + popupHeight) {\n            // show below\n            this._popup.style.top = `${targetPosition.bottom + this._verticalPadding}px`;\n        } else if (viewport.top <= targetPosition.top - popupHeight) {\n            // show top\n            this._popup.style.top = `${targetPosition.top - popupHeight - this._verticalPadding}px`;\n        } else {\n            return false;\n        }\n        if (viewport.right >= targetPosition.right + popupWidth) {\n            // show right\n            this._popup.style.left = `${targetPosition.left}px`;\n        } else if (viewport.left <= targetPosition.left - popupWidth) {\n            // show left\n            this._popup.style.left = `${targetPosition.right - popupWidth}px`;\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    /* fake IView api, so it can be tracked by a template view as a subview */\n    root() {\n        return this._fakeRoot;\n    }\n\n    mount() {\n        this._fakeRoot = document.createComment(\"popup\");\n        return this._fakeRoot;\n    }\n\n    unmount() {\n        this.close();\n    }\n\n    update() {}\n}\n\nfunction findScrollParent(el) {\n    let parent = el;\n    do {\n        parent = parent.parentElement;\n        if (parent.scrollHeight > parent.clientHeight) {\n            // double check that overflow would allow a scrollbar\n            // because some elements, like a button with negative margin to increate the click target\n            // can cause the scrollHeight to be larger than the clientHeight in the parent\n            // see button.link class\n            const style = window.getComputedStyle(parent);\n            const overflowY = style.getPropertyValue(\"overflow-y\");\n            if (overflowY === \"auto\" || overflowY === \"scroll\") {\n                return parent;\n            }\n        }\n    } while (parent !== document.body);\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"./TemplateView\";\n\nexport class Menu extends TemplateView {\n    static option(label, callback) {\n        return new MenuOption(label, callback);\n    }\n\n    constructor(options) {\n        super();\n        this._options = options;\n    }\n\n    render(t) {\n        return t.ul({className: \"menu\", role: \"menu\"}, this._options.map(o => o.toDOM(t)));\n    }\n}\n\nclass MenuOption {\n    constructor(label, callback) {\n        this.label = label;\n        this.callback = callback;\n        this.icon = null;\n        this.destructive = false;\n    }\n\n    setIcon(className) {\n        this.icon = className;\n        return this;\n    }\n\n    setDestructive() {\n        this.destructive = true;\n        return this;\n    }\n\n    toDOM(t) {\n        const className = {\n            destructive: this.destructive,\n        };\n        if (this.icon) {\n            className.icon = true;\n            className[this.icon] = true;\n        }\n        return t.li({\n            className,\n        }, t.button({className:\"menu-item\", onClick: this.callback}, this.label));\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ListView} from \"../../../general/ListView\";\nimport {TemplateView} from \"../../../general/TemplateView\";\n\nexport class ReactionsView extends ListView {\n    constructor(reactionsViewModel) {\n        const options = {\n            className: \"Timeline_messageReactions\",\n            tagName: \"div\",\n            list: reactionsViewModel.reactions,\n            onItemClick: reactionView => reactionView.onClick(),\n        }\n        super(options, reactionVM => new ReactionView(reactionVM));\n    }\n}\n\nclass ReactionView extends TemplateView {\n    render(t, vm) {\n        return t.button({\n            className: {\n                active: vm => vm.isActive,\n                pending: vm => vm.isPending\n            },\n        }, [vm.key, \" \", vm => `${vm.count}`]);\n    }\n\n    onClick() {\n        this.value.toggle();\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {renderStaticAvatar} from \"../../../avatar.js\";\nimport {tag} from \"../../../general/html\";\nimport {mountView} from \"../../../general/utils\";\nimport {TemplateView} from \"../../../general/TemplateView\";\nimport {Popup} from \"../../../general/Popup.js\";\nimport {Menu} from \"../../../general/Menu.js\";\nimport {ReactionsView} from \"./ReactionsView.js\";\n\nexport class BaseMessageView extends TemplateView {\n    constructor(value, renderFlags, tagName = \"li\") {\n        super(value);\n        this._menuPopup = null;\n        this._tagName = tagName;\n        // TODO An enum could be nice to make code easier to read at call sites.\n        this._renderFlags = renderFlags;\n    }\n\n    get _interactive() { return this._renderFlags?.interactive ?? true; }\n    get _isReplyPreview() { return this._renderFlags?.reply; }\n\n    render(t, vm) {\n        const children = [this.renderMessageBody(t, vm)];\n        if (this._interactive) {\n            children.push(t.button({className: \"Timeline_messageOptions\"}, \"⋯\"));\n        }\n        const li = t.el(this._tagName, {className: {\n            \"Timeline_message\": true,\n            own: vm.isOwn,\n            unsent: vm.isUnsent,\n            unverified: vm.isUnverified,\n            disabled: !this._interactive,\n            continuation: vm => vm.isContinuation,\n        }}, children);\n        // given that there can be many tiles, we don't add\n        // unneeded DOM nodes in case of a continuation, and we add it\n        // with a side-effect binding to not have to create sub views,\n        // as the avatar or sender doesn't need any bindings or event handlers.\n        // don't use `t` from within the side-effect callback\n        t.mapSideEffect(vm => vm.isContinuation, (isContinuation, wasContinuation) => {\n            if (isContinuation && wasContinuation === false) {\n                li.removeChild(li.querySelector(\".Timeline_messageAvatar\"));\n                li.removeChild(li.querySelector(\".Timeline_messageSender\"));\n            } else if (!isContinuation && !this._isReplyPreview) {\n                const avatar = tag.a({href: vm.memberPanelLink, className: \"Timeline_messageAvatar\"}, [renderStaticAvatar(vm, 30)]);\n                const sender = tag.div({className: `Timeline_messageSender usercolor${vm.avatarColorNumber}`}, vm.displayName);\n                li.insertBefore(avatar, li.firstChild);\n                li.insertBefore(sender, li.firstChild);\n            }\n        });\n        // similarly, we could do this with a simple ifView,\n        // but that adds a comment node to all messages without reactions\n        let reactionsView = null;\n        t.mapSideEffect(vm => vm.reactions, reactions => {\n            if (reactions && this._interactive && !reactionsView) {\n                reactionsView = new ReactionsView(reactions);\n                this.addSubView(reactionsView);\n                li.appendChild(mountView(reactionsView));\n            } else if (!reactions && reactionsView) {\n                li.removeChild(reactionsView.root());\n                reactionsView.unmount();\n                this.removeSubView(reactionsView);\n                reactionsView = null;\n            }\n        });\n        return li;\n    }\n\n    /* This is called by the parent ListView, which just has 1 listener for the whole list */\n    onClick(evt) {\n        if (evt.target.className === \"Timeline_messageOptions\") {\n            this._toggleMenu(evt.target);\n        }\n    }\n\n    _toggleMenu(button) {\n        if (this._menuPopup && this._menuPopup.isOpen) {\n            this._menuPopup.close();\n        } else {\n            const options = this.createMenuOptions(this.value);\n            if (!options.length) {\n                return;\n            }\n            this.root().classList.add(\"menuOpen\");\n            const onClose = () => this.root().classList.remove(\"menuOpen\");\n            this._menuPopup = new Popup(new Menu(options), onClose);\n            this._menuPopup.trackInTemplateView(this);\n            this._menuPopup.showRelativeTo(button, 2);\n        }\n    }\n\n    createMenuOptions(vm) {\n        const options = [];\n        if (vm.canReact && vm.shape !== \"redacted\" && !vm.isPending) {\n            options.push(new QuickReactionsMenuOption(vm));\n            options.push(Menu.option(vm.i18n`Reply`, () => vm.startReply()));\n        }\n        if (vm.canAbortSending) {\n            options.push(Menu.option(vm.i18n`Cancel`, () => vm.abortSending()));\n        } else if (vm.canRedact) {\n            options.push(Menu.option(vm.i18n`Delete`, () => vm.redact()).setDestructive());\n        }\n        return options;\n    }\n\n    renderMessageBody() {}\n}\n\nclass QuickReactionsMenuOption {\n    constructor(vm) {\n        this._vm = vm;\n    }\n    toDOM(t) {\n        const emojiButtons = [\"👍\", \"👎\", \"😄\", \"🎉\", \"😕\", \"❤️\", \"🚀\", \"👀\"].map(emoji => {\n            return t.button({onClick: () => this._vm.react(emoji)}, emoji);\n        });\n        const customButton = t.button({onClick: () => {\n            const key = prompt(\"Enter your reaction (emoji)\");\n            if (key) {\n                this._vm.react(key);\n            }\n        }}, \"…\");\n        return t.li({className: \"quick-reactions\"}, [...emojiButtons, customButton]);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {renderStaticAvatar} from \"../../../avatar\";\nimport {TemplateView} from \"../../../general/TemplateView\";\nimport {viewClassForEntry} from \"../common\";\n\nexport class ReplyPreviewView extends TemplateView {\n    render(t, vm) {\n        const viewClass = viewClassForEntry(vm);\n        if (!viewClass) {\n            throw new Error(`Shape ${vm.shape} is unrecognized.`)\n        }\n        const view = new viewClass(vm, { reply: true, interactive: false });\n        return t.div(\n            { className: \"ReplyPreviewView\" },\n            t.blockquote([\n                t.a({ className: \"link\", href: vm.permaLink }, \"In reply to\"),\n                t.a({ className: \"pill\", href: vm.senderProfileLink }, [\n                    renderStaticAvatar(vm, 12, undefined, true),\n                    vm.displayName,\n                ]),\n                t.br(),\n                t.view(view),\n            ])\n        );\n    }\n}\n\nexport class ReplyPreviewError extends TemplateView {\n    render(t) {\n        return t.blockquote({ className: \"ReplyPreviewView\" }, [\n            t.div({ className: \"Timeline_messageBody statusMessage\" }, \"This reply could not be found.\")\n        ]);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {tag, text} from \"../../../general/html\";\nimport {BaseMessageView} from \"./BaseMessageView.js\";\nimport {ReplyPreviewError, ReplyPreviewView} from \"./ReplyPreviewView.js\";\n\nexport class TextMessageView extends BaseMessageView {\n    renderMessageBody(t, vm) {\n        const time = t.time({className: {hidden: !vm.date}}, vm.date + \" \" + vm.time);\n        const container = t.div({\n            className: {\n                \"Timeline_messageBody\": true,\n                statusMessage: vm => vm.shape === \"message-status\",\n            }\n        }, t.mapView(vm => vm.replyTile, replyTile => {\n            if (this._isReplyPreview) {\n                // if this._isReplyPreview = true, this is already a reply preview, don't nest replies for now.\n                return null;\n            }\n            else if (vm.isReply && !replyTile) {\n                return new ReplyPreviewError();\n            }\n            else if (replyTile) {\n                return new ReplyPreviewView(replyTile);\n            }\n            else {\n                return null;\n            }\n        }));\n\n        // exclude comment nodes as they are used by t.map and friends for placeholders\n        const shouldRemove = (element) => element?.nodeType !== Node.COMMENT_NODE && element.className !== \"ReplyPreviewView\";\n\n        t.mapSideEffect(vm => vm.body, body => {\n            while (shouldRemove(container.lastChild)) {\n                container.removeChild(container.lastChild);\n            }\n            for (const part of body.parts) {\n                container.appendChild(renderPart(part));\n            }\n            container.appendChild(time);\n        });\n\n        return container;\n    }\n}\n\nfunction renderList(listBlock) {\n    const items = listBlock.items.map(item => tag.li(renderParts(item)));\n    const start = listBlock.startOffset;\n    if (start) {\n        return tag.ol({ start }, items);\n    } else {\n        return tag.ul(items);\n    }\n}\n\nfunction renderImage(imagePart) {\n    const attributes = { src: imagePart.src };\n    if (imagePart.width) { attributes.width = imagePart.width }\n    if (imagePart.height) { attributes.height = imagePart.height }\n    if (imagePart.alt) { attributes.alt = imagePart.alt }\n    if (imagePart.title) { attributes.title = imagePart.title }\n    return tag.img(attributes);\n}\n\nfunction renderPill(pillPart) {\n    // The classes and structure are borrowed from avatar.js;\n    // We don't call renderStaticAvatar because that would require\n    // an intermediate object that has getAvatarUrl etc.\n    const classes = `avatar size-12 usercolor${pillPart.avatarColorNumber}`;\n    const avatar = tag.div({class: classes}, text(pillPart.avatarInitials));\n    const children = renderParts(pillPart.children);\n    children.unshift(avatar);\n    return tag.a({class: \"pill\", href: pillPart.href, rel: \"noopener\", target: \"_blank\"}, children);\n}\n\nfunction renderTable(tablePart) {\n    const children = [];\n    if (tablePart.head) {\n        const headers = tablePart.head\n            .map(cell => tag.th(renderParts(cell)));\n        children.push(tag.thead(tag.tr(headers)))\n    }\n    const rows = [];\n    for (const row of tablePart.body) {\n        const data = row.map(cell => tag.td(renderParts(cell)));\n        rows.push(tag.tr(data));\n    }\n    children.push(tag.tbody(rows));\n    return tag.table(children);\n}\n\n/**\n * Map from part to function that outputs DOM for the part\n */\nconst formatFunction = {\n    header: headerBlock => tag[\"h\" + Math.min(6,headerBlock.level)](renderParts(headerBlock.inlines)),\n    codeblock: codeBlock => tag.pre(tag.code(text(codeBlock.text))),\n    table: tableBlock => renderTable(tableBlock),\n    code: codePart => tag.code(text(codePart.text)),\n    text: textPart => text(textPart.text),\n    link: linkPart => tag.a({href: linkPart.url, className: \"link\", target: \"_blank\", rel: \"noopener\" }, renderParts(linkPart.inlines)),\n    pill: renderPill,\n    format: formatPart => tag[formatPart.format](renderParts(formatPart.children)),\n    rule: () => tag.hr(),\n    list: renderList,\n    image: renderImage,\n    newline: () => tag.br()\n};\n\nfunction renderPart(part) {\n    const f = formatFunction[part.type];\n    if (!f) {\n        return text(`[unknown part type ${part.type}]`);\n    }\n    return f(part);\n}\n\nfunction renderParts(parts) {\n    return Array.from(parts, renderPart);\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMessageView} from \"./BaseMessageView.js\";\n\nexport class BaseMediaView extends BaseMessageView {\n    renderMessageBody(t, vm) {\n        const heightRatioPercent = (vm.height / vm.width) * 100; \n        let spacerStyle = `padding-top: ${heightRatioPercent}%;`;\n        if (vm.platform.isIE11) {\n            // preserving aspect-ratio in a grid with padding percentages\n            // does not work in IE11, so we assume people won't use it\n            // with viewports narrower than 400px where thumbnails will get\n            // scaled. If they do, the thumbnail will still scale, but\n            // there will be whitespace underneath the picture\n            // An alternative would be to use position: absolute but that\n            // can slow down rendering, and was bleeding through the lightbox.\n            spacerStyle = `height: ${vm.height}px`;\n        }\n        const children = [\n            t.div({className: \"spacer\", style: spacerStyle}),\n            this.renderMedia(t, vm),\n            t.time(vm.date + \" \" + vm.time),\n        ];\n        if (vm.isPending) {\n            const sendStatus = t.div({\n                className: {\n                    sendStatus: true,\n                    hidden: vm => !vm.sendStatus\n                },\n            }, vm => vm.sendStatus);\n            const progress = t.progress({\n                min: 0,\n                max: 100,\n                value: vm => vm.uploadPercentage,\n                className: {hidden: vm => !vm.isUploading}\n            });\n            children.push(sendStatus, progress);\n        }\n        return t.div({className: \"Timeline_messageBody\"}, [\n            t.div({className: \"media\", style: `max-width: ${vm.width}px`}, children),\n            t.if(vm => vm.error, t => t.p({className: \"error\"}, vm.error))\n        ]);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMediaView} from \"./BaseMediaView.js\";\n\nexport class ImageView extends BaseMediaView {\n    renderMedia(t, vm) {\n        const img = t.img({\n            src: vm => vm.thumbnailUrl,\n            alt: vm => vm.label,\n            title: vm => vm.label,\n            style: `max-width: ${vm.width}px; max-height: ${vm.height}px;`\n        });\n        return vm.isPending ? img : t.a({href: vm.lightboxUrl}, img);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function domEventAsPromise(element, successEvent) {\n    return new Promise((resolve, reject) => {\n        let detach;\n        const handleError = evt => {\n            detach();\n            reject(evt.target.error);\n        };\n        const handleSuccess = () => {\n            detach();\n            resolve();\n        };\n        detach = () => {\n            element.removeEventListener(successEvent, handleSuccess);\n            element.removeEventListener(\"error\", handleError);\n        };\n        element.addEventListener(successEvent, handleSuccess);\n        element.addEventListener(\"error\", handleError);\n    });\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMediaView} from \"./BaseMediaView.js\";\nimport {domEventAsPromise} from \"../../../../dom/utils.js\";\n\nexport class VideoView extends BaseMediaView {\n    renderMedia(t) {\n        const video = t.video({\n            // provide empty data url if video is not decrypted yet.\n            // Chrome/Electron need this to enable the play button.\n            src: vm => vm.videoUrl || `data:${vm.mimeType},`,\n            title: vm => vm.label,\n            controls: true,\n            preload: \"none\",\n            poster: vm => vm.thumbnailUrl,\n            onPlay: this._onPlay.bind(this),\n            style: vm => `max-width: ${vm.width}px; max-height: ${vm.height}px;${vm.isPending ? \"z-index: -1\": \"\"}`\n        });\n\n        video.addEventListener(\"error\", this._onError.bind(this));\n\n        return video;\n    }\n\n    async _onPlay(evt) {\n        const vm = this.value;\n        // download and decrypt the video if needed,\n        if (!vm.videoUrl) {\n            try {\n                const video = evt.target;\n                // this will trigger the src to update\n                await vm.loadVideo();\n                // important to only listen for this after src has changed,\n                // or we get the error for the placeholder data url\n                const loadPromise = domEventAsPromise(video, \"loadeddata\");\n                // now, reload the video and play\n                video.load();\n                await loadPromise;\n                video.play();\n            } catch (err) {/* errors are already caught in error event handler */}\n        }  \n    }\n\n    _onError(evt) {\n        const vm = this.value;\n        const video = evt.target;\n        const err = video.error;\n        if (err instanceof window.MediaError && err.code === 4) {\n            if (!video.src.startsWith(\"data:\")) {\n                vm.setViewError(new Error(`this browser does not support videos of type ${vm.mimeType}.`));\n            } else {\n                // ignore placeholder url failing to load\n                return;\n            }\n        } else {\n            vm.setViewError(err);\n        }\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMessageView} from \"./BaseMessageView.js\";\n\nexport class FileView extends BaseMessageView {\n    renderMessageBody(t, vm) {\n        const children = [];\n        if (vm.isPending) {\n            children.push(vm => vm.label);\n        } else {\n            children.push(\n                t.button({className: \"link\", onClick: () => vm.download()}, vm => vm.label),\n                t.time(vm.date + \" \" + vm.time)\n            );\n        }\n        return t.p({className: \"Timeline_messageBody statusMessage\"}, children);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMessageView} from \"./BaseMessageView.js\";\n\nexport class LocationView extends BaseMessageView {\n    renderMessageBody(t, vm) {\n        return t.p({className: \"Timeline_messageBody statusMessage\"}, [\n            t.span(vm.label),\n            t.a({className: \"Timeline_locationLink\", href: vm.mapsLink, target: \"_blank\", rel: \"noopener\"}, vm.i18n`Open in maps`),\n            t.time(vm.date + \" \" + vm.time)\n        ]);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMessageView} from \"./BaseMessageView.js\";\n\nexport class MissingAttachmentView extends BaseMessageView {\n    renderMessageBody(t, vm) {\n        return t.p({className: \"Timeline_messageBody statusMessage\"}, vm.label);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../../general/TemplateView\";\n\nexport class AnnouncementView extends TemplateView {\n    render(t) {\n        return t.li({className: \"AnnouncementView\"}, t.div(vm => vm.announcement));\n    }\n    \n    /* This is called by the parent ListView, which just has 1 listener for the whole list */\n    onClick() {}\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseMessageView} from \"./BaseMessageView.js\";\nimport {Menu} from \"../../../general/Menu.js\";\n\nexport class RedactedView extends BaseMessageView {\n    renderMessageBody(t) {\n        return t.p({className: \"Timeline_messageBody statusMessage\"}, vm => vm.description);\n    }\n\n    createMenuOptions(vm) {\n        const options = super.createMenuOptions(vm);\n        if (vm.isRedacting) {\n            options.push(Menu.option(vm.i18n`Cancel`, () => vm.abortPendingRedaction()));\n        }\n        return options;\n    }\n}","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../../general/TemplateView\";\nimport {spinner} from \"../../../common.js\";\n\nexport class GapView extends TemplateView {\n    render(t) {\n        const className = {\n            GapView: true,\n            isLoading: vm => vm.isLoading,\n            isAtTop: vm => vm.isAtTop,\n        };\n        return t.li({className}, [\n            spinner(t),\n            t.div(vm => vm.isLoading ? vm.i18n`Loading more messages …` : vm.i18n`Not loading!`),\n            t.if(vm => vm.error, t => t.strong(vm => vm.error))\n        ]);\n    }\n\n    /* This is called by the parent ListView, which just has 1 listener for the whole list */\n    onClick() {}\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TextMessageView} from \"./timeline/TextMessageView.js\";\nimport {ImageView} from \"./timeline/ImageView.js\";\nimport {VideoView} from \"./timeline/VideoView.js\";\nimport {FileView} from \"./timeline/FileView.js\";\nimport {LocationView} from \"./timeline/LocationView.js\";\nimport {MissingAttachmentView} from \"./timeline/MissingAttachmentView.js\";\nimport {AnnouncementView} from \"./timeline/AnnouncementView.js\";\nimport {RedactedView} from \"./timeline/RedactedView.js\";\nimport {SimpleTile} from \"../../../../../domain/session/room/timeline/tiles/SimpleTile.js\";\nimport {GapView} from \"./timeline/GapView.js\";\n\nexport type TileView = GapView | AnnouncementView | TextMessageView |\n    ImageView | VideoView | FileView | LocationView | MissingAttachmentView | RedactedView;\n\n// TODO: this is what works for a ctor but doesn't actually check we constrain the returned ctors to the types above\ntype TileViewConstructor = (this: TileView, SimpleTile) => void;\nexport function viewClassForEntry(entry: SimpleTile): TileViewConstructor | undefined {\n    switch (entry.shape) {\n        case \"gap\":\n            return GapView;\n        case \"announcement\":\n            return AnnouncementView;\n        case \"message\":\n        case \"message-status\":\n            return TextMessageView;\n        case \"image\":\n            return ImageView;\n        case \"video\":\n            return VideoView;\n        case \"file\":\n            return FileView;\n        case \"location\":\n            return LocationView;\n        case \"missing-attachment\":\n            return MissingAttachmentView;\n        case \"redacted\":\n            return RedactedView;\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type {TileView} from \"./common\";\nimport {viewClassForEntry} from \"./common\";\nimport {ListView} from \"../../general/ListView\";\nimport {TemplateView, Builder} from \"../../general/TemplateView\";\nimport {IObservableValue} from \"../../general/BaseUpdateView\";\nimport {MissingAttachmentView} from \"./timeline/MissingAttachmentView.js\";\nimport {AnnouncementView} from \"./timeline/AnnouncementView.js\";\nimport {RedactedView} from \"./timeline/RedactedView.js\";\nimport {SimpleTile} from \"../../../../../domain/session/room/timeline/tiles/SimpleTile.js\";\nimport {BaseObservableList as ObservableList} from \"../../../../../observable/list/BaseObservableList\";\n\n//import {TimelineViewModel} from \"../../../../../domain/session/room/timeline/TimelineViewModel.js\";\nexport interface TimelineViewModel extends IObservableValue {\n    showJumpDown: boolean;\n    tiles: ObservableList<SimpleTile>;\n    setVisibleTileRange(start?: SimpleTile, end?: SimpleTile);\n}\n\nfunction bottom(node: HTMLElement): number {\n    return node.offsetTop + node.clientHeight;\n}\n\nfunction findFirstNodeIndexAtOrBelow(tiles: HTMLElement, top: number, startIndex: number = (tiles.children.length - 1)): number {\n    for (var i = startIndex; i >= 0; i--) {\n        const node = tiles.children[i] as HTMLElement;\n        if (node.offsetTop < top) {\n            return i;\n        }\n    }\n    // return first item if nothing matched before\n    return 0;\n}\n\nexport class TimelineView extends TemplateView<TimelineViewModel> {\n\n    private anchoredNode?: HTMLElement;\n    private anchoredBottom: number = 0;\n    private stickToBottom: boolean = true;\n    private tilesView?: TilesListView;\n    private resizeObserver?: ResizeObserver;\n\n    render(t: Builder<TimelineViewModel>, vm: TimelineViewModel) {\n        // assume this view will be mounted in the parent DOM straight away\n        requestAnimationFrame(() => {\n            // do initial scroll positioning\n            this.restoreScrollPosition();\n        });\n        this.tilesView = new TilesListView(vm.tiles, () => this.restoreScrollPosition());\n        const root = t.div({className: \"Timeline\"}, [\n            t.div({\n                className: \"Timeline_scroller bottom-aligned-scroll\",\n                onScroll: () => this.onScroll()\n            }, t.view(this.tilesView)),\n            t.button({\n                className: {\n                    \"Timeline_jumpDown\": true,\n                    hidden: vm => !vm.showJumpDown\n                },\n                title: \"Jump down\",\n                onClick: () => this.jumpDown()\n            })\n        ]);\n\n        if (typeof ResizeObserver === \"function\") {\n            this.resizeObserver = new ResizeObserver(() => {\n                this.restoreScrollPosition();\n            });\n            this.resizeObserver.observe(root);\n        }\n\n        return root;\n    }\n\n    private get scrollNode(): HTMLElement {\n        return (this.root()! as HTMLElement).firstElementChild! as HTMLElement;\n    }\n\n    private get tilesNode(): HTMLElement {\n        return this.tilesView!.root()! as HTMLElement;\n    }\n\n    private jumpDown() {\n        const {scrollNode} = this;\n        this.stickToBottom = true;\n        scrollNode.scrollTop = scrollNode.scrollHeight;\n    }\n\n    public unmount() {\n        super.unmount();\n        if (this.resizeObserver) {\n            this.resizeObserver.unobserve(this.root()! as Element);\n            this.resizeObserver = undefined;\n        }\n    }\n\n    private restoreScrollPosition() {\n        const {scrollNode, tilesNode} = this;\n\n        const missingTilesHeight = scrollNode.clientHeight - tilesNode.clientHeight;\n        if (missingTilesHeight > 0) {\n            tilesNode.style.setProperty(\"margin-top\", `${missingTilesHeight}px`);\n            // we don't have enough tiles to fill the viewport, so set all as visible\n            const len = this.value.tiles.length;\n            this.updateVisibleRange(0, len - 1);\n        } else {\n            tilesNode.style.removeProperty(\"margin-top\");\n            if (this.stickToBottom) {\n                scrollNode.scrollTop = scrollNode.scrollHeight;\n            } else if (this.anchoredNode) {\n                const newAnchoredBottom = bottom(this.anchoredNode!);\n                if (newAnchoredBottom !== this.anchoredBottom) {\n                    const bottomDiff = newAnchoredBottom - this.anchoredBottom;\n                    // scrollBy tends to create less scroll jumps than reassigning scrollTop as it does\n                    // not depend on reading scrollTop, which might be out of date as some platforms\n                    // run scrolling off the main thread.\n                    if (typeof scrollNode.scrollBy === \"function\") {\n                        scrollNode.scrollBy(0, bottomDiff);\n                    } else {\n                        scrollNode.scrollTop = scrollNode.scrollTop + bottomDiff;\n                    }\n                    this.anchoredBottom = newAnchoredBottom;\n                }\n            }\n            // TODO: should we be updating the visible range here as well as the range might have changed even though\n            // we restored the bottom tile\n        }\n    }\n\n    private onScroll(): void {\n        const {scrollNode, tilesNode} = this;\n        const {scrollHeight, scrollTop, clientHeight} = scrollNode;\n\n        let bottomNodeIndex;\n        this.stickToBottom = Math.abs(scrollHeight - (scrollTop + clientHeight)) < 1;\n        if (this.stickToBottom) {\n            const len = this.value.tiles.length;\n            bottomNodeIndex = len - 1;\n        } else {\n            const viewportBottom = scrollTop + clientHeight;\n            const anchoredNodeIndex = findFirstNodeIndexAtOrBelow(tilesNode, viewportBottom);\n            this.anchoredNode = tilesNode.childNodes[anchoredNodeIndex] as HTMLElement;\n            this.anchoredBottom = bottom(this.anchoredNode!);\n            bottomNodeIndex = anchoredNodeIndex;\n        }\n        let topNodeIndex = findFirstNodeIndexAtOrBelow(tilesNode, scrollTop, bottomNodeIndex);\n        this.updateVisibleRange(topNodeIndex, bottomNodeIndex);\n    }\n\n    private updateVisibleRange(startIndex: number, endIndex: number) {\n        // can be undefined, meaning the tiles collection is still empty\n        const firstVisibleChild = this.tilesView!.getChildInstanceByIndex(startIndex);\n        const lastVisibleChild = this.tilesView!.getChildInstanceByIndex(endIndex);\n        this.value.setVisibleTileRange(firstVisibleChild?.value, lastVisibleChild?.value);\n    }\n}\n\nclass TilesListView extends ListView<SimpleTile, TileView> {\n\n    private onChanged: () => void;\n\n    constructor(tiles: ObservableList<SimpleTile>, onChanged: () => void) {\n        const options = {\n            list: tiles,\n            onItemClick: (tileView, evt) => tileView.onClick(evt),\n        };\n        super(options, entry => {\n            const View = viewClassForEntry(entry);\n            if (View) {\n                return new View(entry);\n            }\n        });\n        this.onChanged = onChanged;\n    }\n\n    onReset() {\n        super.onReset();\n        this.onChanged();\n    }\n\n    onUpdate(index: number, value: SimpleTile, param: any) {\n        if (param === \"shape\") {\n            const ExpectedClass = viewClassForEntry(value);\n            const child = this.getChildInstanceByIndex(index);\n            if (!ExpectedClass || !(child instanceof ExpectedClass)) {\n                // shape was updated, so we need to recreate the tile view,\n                // the shape parameter is set in EncryptedEventTile.updateEntry\n                // (and perhaps elsewhere by the time you read this)\n                super.recreateItem(index, value);\n                return;\n            }\n        }\n        super.onUpdate(index, value, param);\n        this.onChanged();\n    }\n\n    onAdd(idx: number, value: SimpleTile) {\n        super.onAdd(idx, value);\n        this.onChanged();\n    }\n\n    onRemove(idx: number, value: SimpleTile) {\n        super.onRemove(idx, value);\n        this.onChanged();\n    }\n\n    onMove(fromIdx: number, toIdx: number, value: SimpleTile) {\n        super.onMove(fromIdx, toIdx, value);\n        this.onChanged();\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\nimport {spinner} from \"../../common.js\";\n\nexport class TimelineLoadingView extends TemplateView {\n    render(t, vm) {\n        return t.div({className: \"TimelineLoadingView\"}, [\n            spinner(t),\n            t.div(vm.isEncrypted ? vm.i18n`Loading encrypted messages…` : vm.i18n`Loading messages…`)\n        ]);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\nimport {Popup} from \"../../general/Popup.js\";\nimport {Menu} from \"../../general/Menu.js\";\nimport {viewClassForEntry} from \"./common\"\n\nexport class MessageComposer extends TemplateView {\n    constructor(viewModel) {\n        super(viewModel);\n        this._input = null;\n        this._attachmentPopup = null;\n        this._focusInput = null;\n        this._rafResizeHandle = undefined;\n    }\n\n    render(t, vm) {\n        this._input = t.textarea({\n            onKeydown: e => this._onKeyDown(e),\n            onInput: () => {\n                vm.setInput(this._input.value);\n                if (this._input.value) {\n                    this._adjustHeight();\n                } else {\n                    this._clearHeight();\n                }\n            },\n            placeholder: vm => vm.isEncrypted ? \"Send an encrypted message…\" : \"Send a message…\",\n            rows: \"1\"\n        });\n        this._focusInput = () => this._input.focus();\n        this.value.on(\"focus\", this._focusInput);\n        const replyPreview = t.map(vm => vm.replyViewModel, (rvm, t) => {\n            const View = rvm && viewClassForEntry(rvm);\n            if (!View) { return null; }\n            return t.div({\n                    className: \"MessageComposer_replyPreview\"\n                }, [\n                    t.span({ className: \"replying\" }, \"Replying\"),\n                    t.button({\n                        className: \"cancel\",\n                        onClick: () => this._clearReplyingTo()\n                    }, \"Close\"),\n                t.view(new View(rvm, { interactive: false }, \"div\"))\n                ])\n        });\n        const input = t.div({className: \"MessageComposer_input\"}, [\n            this._input,\n            t.button({\n                className: \"sendFile\",\n                title: vm.i18n`Pick attachment`,\n                onClick: evt => this._toggleAttachmentMenu(evt),\n            }, vm.i18n`Send file`),\n            t.button({\n                className: \"send\",\n                title: vm.i18n`Send`,\n                onClick: () => this._trySend(),\n            }, vm.i18n`Send`),\n        ]);\n        return t.div({ className: {\n            MessageComposer: true,\n            MessageComposer_canSend: vm => vm.canSend\n        } }, [replyPreview, input]);\n    }\n\n    unmount() {\n        if (this._focusInput) {\n            this.value.off(\"focus\", this._focusInput);\n        }\n        super.unmount();\n    }\n\n    _clearReplyingTo() {\n        this.value.clearReplyingTo();\n    }\n\n    async _trySend() {\n        this._input.focus();\n        // we clear the composer while enqueuing\n        // and restore it when that didn't work somehow\n        // to prevent the user from sending the message\n        // every time they hit enter while it's still enqueuing.\n        const {value} = this._input;\n        const restoreValue = () => {\n            this._input.value = value;\n            this._adjustHeight();\n        };\n        this._input.value = \"\";\n        this._clearHeight();\n        try {\n            if (!await this.value.sendMessage(value)) {\n                restoreValue();\n            }\n        } catch (err) {\n            restoreValue();\n            console.error(err);\n        }\n    }\n\n    _onKeyDown(event) {\n        if (event.key === \"Enter\" && !event.shiftKey) {\n            // don't insert newline into composer\n            event.preventDefault();\n            this._trySend();\n        }\n    }\n\n    _toggleAttachmentMenu(evt) {\n        if (this._attachmentPopup && this._attachmentPopup.isOpen) {\n            this._attachmentPopup.close();\n        } else {\n            const vm = this.value;\n            this._attachmentPopup = new Popup(new Menu([\n                Menu.option(vm.i18n`Send video`, () => vm.sendVideo()).setIcon(\"video\"),\n                Menu.option(vm.i18n`Send picture`, () => vm.sendPicture()).setIcon(\"picture\"),\n                Menu.option(vm.i18n`Send file`, () => vm.sendFile()).setIcon(\"file\"),\n            ]));\n            this._attachmentPopup.trackInTemplateView(this);\n            this._attachmentPopup.showRelativeTo(evt.target, 12);\n        }\n    }\n\n    _adjustHeight() {\n        if (this._rafResizeHandle) {\n            return;\n        }\n        this._rafResizeHandle = window.requestAnimationFrame(() => {\n            const scrollHeight = this._input.scrollHeight;\n            this._input.style.height = `${scrollHeight}px`;\n            this._rafResizeHandle = undefined;\n        });\n    }\n\n    _clearHeight() {\n        this._input.style.removeProperty(\"height\");\n    }\n\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\n\nexport class RoomArchivedView extends TemplateView {\n    render(t) {\n        return t.div({className: \"RoomArchivedView\"}, t.h3(vm => vm.description));\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\nimport {Popup} from \"../../general/Popup.js\";\nimport {Menu} from \"../../general/Menu.js\";\nimport {TimelineView} from \"./TimelineView\";\nimport {TimelineLoadingView} from \"./TimelineLoadingView.js\";\nimport {MessageComposer} from \"./MessageComposer.js\";\nimport {RoomArchivedView} from \"./RoomArchivedView.js\";\nimport {AvatarView} from \"../../AvatarView.js\";\n\nexport class RoomView extends TemplateView {\n    constructor(options) {\n        super(options);\n        this._optionsPopup = null;\n    }\n\n    render(t, vm) {\n        let bottomView;\n        if (vm.composerViewModel.kind === \"composer\") {\n            bottomView = new MessageComposer(vm.composerViewModel);\n        } else if (vm.composerViewModel.kind === \"archived\") {\n            bottomView = new RoomArchivedView(vm.composerViewModel);\n        }\n        return t.main({className: \"RoomView middle\"}, [\n            t.div({className: \"RoomHeader middle-header\"}, [\n                t.a({className: \"button-utility close-middle\", href: vm.closeUrl, title: vm.i18n`Close room`}),\n                t.view(new AvatarView(vm, 32)),\n                t.div({className: \"room-description\"}, [\n                    t.h2(vm => vm.name),\n                ]),\n                t.button({\n                    className: \"button-utility room-options\",\n                    \"aria-label\":vm.i18n`Room options`,\n                    onClick: evt => this._toggleOptionsMenu(evt)\n                })\n            ]),\n            t.div({className: \"RoomView_body\"}, [\n                t.div({className: \"RoomView_error\"}, vm => vm.error),\n                t.mapView(vm => vm.timelineViewModel, timelineViewModel => {\n                    return timelineViewModel ?\n                        new TimelineView(timelineViewModel) :\n                        new TimelineLoadingView(vm);    // vm is just needed for i18n\n                }),\n                t.view(bottomView),\n            ])\n        ]);\n    }\n\n    _toggleOptionsMenu(evt) {\n        if (this._optionsPopup && this._optionsPopup.isOpen) {\n            this._optionsPopup.close();\n        } else {\n            const vm = this.value;\n            const options = [];\n            options.push(Menu.option(vm.i18n`Room details`, () => vm.openDetailsPanel()))\n            if (vm.canLeave) {\n                options.push(Menu.option(vm.i18n`Leave room`, () => this._confirmToLeaveRoom()).setDestructive());\n            }\n            if (vm.canForget) {\n                options.push(Menu.option(vm.i18n`Forget room`, () => vm.forgetRoom()).setDestructive());\n            }\n            if (vm.canRejoin) {\n                options.push(Menu.option(vm.i18n`Rejoin room`, () => vm.rejoinRoom()));\n            }\n            if (!options.length) {\n                return;\n            }\n            this._optionsPopup = new Popup(new Menu(options));\n            this._optionsPopup.trackInTemplateView(this);\n            this._optionsPopup.showRelativeTo(evt.target, 10);\n        }\n    }\n\n    _confirmToLeaveRoom() {\n        if (confirm(this.value.i18n`Are you sure you want to leave \"${this.value.name}\"?`)) {\n            this.value.leaveRoom();\n        }\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\n\nexport class UnknownRoomView extends TemplateView {\n    render(t, vm) {\n        return t.main({className: \"UnknownRoomView middle\"}, t.div([\n            t.h2([\n                vm.i18n`You are currently not in ${vm.roomIdOrAlias}.`,\n                t.br(),\n                vm.i18n`Want to join it?`\n            ]),\n            t.button({\n                className: \"button-action primary\",\n                onClick: () => vm.join(),\n                disabled: vm => vm.busy,\n            }, vm.i18n`Join room`),\n            t.if(vm => vm.error, t => t.p({className: \"error\"}, vm.error))\n        ]));\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {tag} from \"../general/html\";\n\nexport class StaticView {\n    constructor(value, render = undefined) {\n        if (typeof value === \"function\" && !render) {\n            render = value;\n            value = null;\n        }\n        this._root = render ? render(tag, value) : this.render(tag, value);\n    }\n\n    mount() {\n        return this._root;\n    }\n\n    root() {\n        return this._root;\n    }\n\n    unmount() {}\n    update() {}\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {StaticView} from \"./StaticView\";\nimport {spinner} from \"../common.js\";\n\nexport class LoadingView extends StaticView {\n    constructor(label = \"Loading\") {\n        super(label, (t, label) => {\n            return t.div({ className: \"LoadingView\" }, [spinner(t), label]);\n        });\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\nimport {LoadingView} from \"../../general/LoadingView\";\nimport {AvatarView} from \"../../AvatarView\";\n\nexport class RoomBeingCreatedView extends TemplateView {\n    render(t, vm) {\n        return t.main({className: \"RoomView middle\"}, [\n            t.div({className: \"RoomHeader middle-header\"}, [\n                t.a({className: \"button-utility close-middle\", href: vm.closeUrl, title: vm.i18n`Close room`}),\n                t.view(new AvatarView(vm, 32)),\n                t.div({className: \"room-description\"}, [\n                    t.h2(vm => vm.name),\n                ])\n            ]),\n            t.div({className: \"RoomView_body\"}, [\n                t.mapView(vm => vm.error, error => {\n                    if (error) {\n                        return new ErrorView(vm);\n                    } else {\n                        return new LoadingView(vm.i18n`Setting up the room…`);\n                    }\n                })\n            ])\n        ]);\n    }\n}\n\nclass ErrorView extends TemplateView {\n    render(t,vm) {\n        return t.div({className: \"RoomBeingCreated_error centered-column\"}, [\n            t.h3(vm.i18n`Could not create the room, something went wrong:`),\n            t.div({className: \"RoomView_error form-group\"}, vm.error),\n            t.div({className: \"button-row\"},\n                t.button({\n                    className: \"button-action primary destructive\",\n                    onClick: () => vm.cancel()\n                }, vm.i18n`Cancel`))\n        ]);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\nimport {renderStaticAvatar} from \"../../avatar.js\";\n\nexport class InviteView extends TemplateView {\n    render(t, vm) {\n        let inviteNodes = [];\n        if (vm.isDirectMessage) {\n            inviteNodes.push(renderStaticAvatar(vm, 128, \"InviteView_dmAvatar\"));\n        }\n        let inviterNodes;\n        if (vm.isDirectMessage) {\n            inviterNodes = [t.strong(vm.name), ` (${vm.inviter?.id}) wants to chat with you.`];\n        } else if (vm.inviter) {\n            inviterNodes = [renderStaticAvatar(vm.inviter, 24), t.strong(vm.inviter.name), ` (${vm.inviter.id}) invited you.`];\n        } else {\n            inviterNodes = `You were invited to join.`;\n        }\n        inviteNodes.push(t.p({className: \"InviteView_inviter\"}, inviterNodes));\n        if (!vm.isDirectMessage) {\n            inviteNodes.push(t.div({className: \"InviteView_roomProfile\"}, [\n                renderStaticAvatar(vm, 64, \"InviteView_roomAvatar\"),\n                t.h3(vm.name),\n                t.p({className: \"InviteView_roomDescription\"}, vm.roomDescription)\n            ]));\n        }\n\n        return t.main({className: \"InviteView middle\"}, [\n            t.div({className: \"RoomHeader middle-header\"}, [\n                t.a({className: \"button-utility close-middle\", href: vm.closeUrl, title: vm.i18n`Close invite`}),\n                renderStaticAvatar(vm, 32),\n                t.div({className: \"room-description\"}, [\n                    t.h2(vm => vm.name),\n                ]),\n            ]),\n            t.if(vm => vm.error, t => t.div({className: \"RoomView_error\"}, vm => vm.error)),\n            t.div({className: \"InviteView_body\"}, [\n                t.div({className: \"InviteView_invite\"}, [\n                    ...inviteNodes,\n                    t.div({className: \"InviteView_buttonRow\"},\n                        t.button({\n                            className: \"button-action primary\",\n                            disabled: vm => vm.busy,\n                            onClick: () => vm.accept()\n                        }, vm.i18n`Accept`)\n                    ),\n                    t.div({className: \"InviteView_buttonRow\"},\n                        t.button({\n                            className: \"button-action primary destructive\",\n                            disabled: vm => vm.busy,\n                            onClick: () => vm.reject()\n                        }, vm.i18n`Reject`)\n                    ),\n                ])\n            ])\n        ]);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\nimport {spinner} from \"../../common.js\";\n\nexport class LightboxView extends TemplateView {\n    render(t, vm) {\n        const close = t.a({href: vm.closeUrl, title: vm.i18n`Close`, className: \"close\"});\n        const image = t.div({\n            role: \"img\",\n            \"aria-label\": vm => vm.name,\n            title: vm => vm.name,\n            className: {\n                picture: true,\n                hidden: vm => !vm.imageUrl,\n            },\n            style: vm => `background-image: url('${vm.imageUrl}'); max-width: ${vm.imageWidth}px; max-height: ${vm.imageHeight}px;`\n        });\n        const loading = t.div({\n            className: {\n                loading: true,\n                hidden: vm => !!vm.imageUrl\n            }\n        }, [\n            spinner(t),\n            t.div(vm.i18n`Loading image…`)\n        ]);\n        const details = t.div({\n            className: \"details\"\n        }, [t.strong(vm => vm.name), t.br(), \"uploaded by \", t.strong(vm => vm.sender), vm => ` at ${vm.time} on ${vm.date}.`]);\n        const dialog = t.div({\n            role: \"dialog\",\n            className: \"lightbox\",\n            onClick: evt => this.clickToClose(evt),\n            onKeydown: evt => this.closeOnEscKey(evt)\n        }, [image, loading, details, close]);\n        trapFocus(t, dialog);\n        return dialog;\n    }\n\n    clickToClose(evt) {\n        if (evt.target === this.root()) {\n            this.value.close();\n        }\n    }\n\n    closeOnEscKey(evt) {\n        if (evt.key === \"Escape\" || evt.key === \"Esc\") {\n            this.value.close();\n        }\n    }\n}\n\nfunction trapFocus(t, element) {\n    const elements = focusables(element);\n    const first = elements[0];\n    const last = elements[elements.length - 1];\n\n    t.addEventListener(element, \"keydown\", evt => {\n        if (evt.key === \"Tab\") {\n            if (evt.shiftKey) {\n                if (document.activeElement === first) {\n                    last.focus();\n                    evt.preventDefault();\n                }\n            } else {\n                if (document.activeElement === last) {\n                    first.focus();\n                    evt.preventDefault();\n                }\n            }\n        }\n    }, true);\n    Promise.resolve().then(() => {\n        first.focus();\n    });\n}\n\nfunction focusables(element) {\n    return element.querySelectorAll('a[href], button, textarea, input, select');\n}\n\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../general/TemplateView\";\nimport {spinner} from \"../common.js\";\n\nexport class SessionStatusView extends TemplateView {\n    render(t, vm) {\n        return t.div({className: {\n            \"SessionStatusView\": true,\n            \"hidden\": vm => !vm.isShown,\n        }}, [\n            spinner(t, {hidden: vm => !vm.isWaiting}),\n            t.p(vm => vm.statusLabel),\n            t.if(vm => vm.isConnectNowShown, t => t.button({className: \"link\", onClick: () => vm.connectNow()}, \"Retry now\")),\n            t.if(vm => vm.isSecretStorageShown, t => t.a({href: vm.setupKeyBackupUrl}, \"Go to settings\")),\n            t.if(vm => vm.canDismiss, t => t.div({className: \"end\"}, t.button({className: \"dismiss\", onClick: () => vm.dismiss()}))),\n        ]);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {RoomView} from \"./room/RoomView.js\";\nimport {RoomBeingCreatedView} from \"./room/RoomBeingCreatedView.js\";\nimport {InviteView} from \"./room/InviteView.js\";\nimport {TemplateView} from \"../general/TemplateView\";\nimport {StaticView} from \"../general/StaticView.js\";\n\nexport class RoomGridView extends TemplateView {\n    render(t, vm) {\n        const children = [];\n        for (let i = 0; i < (vm.height * vm.width); i+=1) {\n            children.push(t.div({\n                onClick: () => vm.focusTile(i),\n                onFocusin: () => vm.focusTile(i),\n                className: {\n                    \"container\": true,\n                    [`tile${i}`]: true,\n                    \"focused\": vm => vm.focusIndex === i\n                },\n            }, t.mapView(vm => vm.roomViewModelAt(i), roomVM => {\n                if (roomVM) {\n                    if (roomVM.kind === \"roomBeingCreated\") {\n                        return new RoomBeingCreatedView(roomVM);\n                    } else if (roomVM.kind === \"invite\") {\n                        return new InviteView(roomVM);\n                    } else {\n                        return new RoomView(roomVM);\n                    }\n                } else {\n                    return new StaticView(t => t.div({className: \"room-placeholder\"}, [\n                        t.h2({className: \"focused\"}, vm.i18n`Select a room on the left`),\n                        t.h2({className: \"unfocused\"}, vm.i18n`Click to select this tile`),\n                    ]));\n                }\n            })));\n        }\n        children.push(t.div({className: vm => `focus-ring tile${vm.focusIndex}`}));\n        return t.div({className: \"RoomGridView middle layout3x2\"}, children);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\n\nexport class KeyBackupSettingsView extends TemplateView {\n    render(t) {\n        return t.div([\n            t.map(vm => vm.status, (status, t, vm) => {\n                switch (status) {\n                    case \"Enabled\": return renderEnabled(t, vm);\n                    case \"NewVersionAvailable\": return renderNewVersionAvailable(t, vm);\n                    case \"SetupKey\": return renderEnableFromKey(t, vm);\n                    case \"SetupPhrase\": return renderEnableFromPhrase(t, vm);\n                    case \"Pending\": return t.p(vm.i18n`Waiting to go online…`);\n                }\n            }),\n            t.map(vm => vm.backupWriteStatus, (status, t, vm) => {\n                switch (status) {\n                    case \"Writing\": {\n                        const progress = t.progress({\n                            min: 0,\n                            max: 100,\n                            value: vm => vm.backupPercentage,\n                        });\n                        return t.div([`Backup in progress `, progress, \" \", vm => vm.backupInProgressLabel]);\n                    }\n                    case \"Stopped\": {\n                        let label;\n                        const error = vm.backupError;\n                        if (error) {\n                            label = `Backup has stopped because of an error: ${vm.backupError}`;\n                        } else {\n                            label = `Backup has stopped`;\n                        }\n                        return t.p(label, \" \", t.button({onClick: () => vm.startBackup()}, `Backup now`));\n                    }\n                    case \"Done\":\n                        return t.p(`All keys are backed up.`);\n                    default:\n                        return null;\n                }\n            })\n        ]);\n    }\n}\n\nfunction renderEnabled(t, vm) {\n    const items = [\n        t.p([vm.i18n`Key backup is enabled, using backup version ${vm.backupVersion}. `, t.button({onClick: () => vm.disable()}, vm.i18n`Disable`)])\n    ];\n    if (vm.dehydratedDeviceId) {\n        items.push(t.p(vm.i18n`A dehydrated device id was set up with id ${vm.dehydratedDeviceId} which you can use during your next login with your secret storage key.`));\n    }\n    return t.div(items);\n}\n\nfunction renderNewVersionAvailable(t, vm) {\n    const items = [\n        t.p([vm.i18n`A new backup version has been created from another device. Disable key backup and enable it again with the new key.`, t.button({onClick: () => vm.disable()}, vm.i18n`Disable`)])\n    ];\n    return t.div(items);\n}\n\nfunction renderEnableFromKey(t, vm) {\n    const useASecurityPhrase = t.button({className: \"link\", onClick: () => vm.showPhraseSetup()}, vm.i18n`use a security phrase`);\n    return t.div([\n        t.p(vm.i18n`Enter your secret storage security key below to ${vm.purpose}, which will enable you to decrypt messages received before you logged into this session. The security key is a code of 12 groups of 4 characters separated by a space that Element created for you when setting up security.`),\n        renderError(t),\n        renderEnableFieldRow(t, vm, vm.i18n`Security key`, (key, setupDehydratedDevice) => vm.enterSecurityKey(key, setupDehydratedDevice)),\n        t.p([vm.i18n`Alternatively, you can `, useASecurityPhrase, vm.i18n` if you have one.`]),\n    ]);\n}\n\nfunction renderEnableFromPhrase(t, vm) {\n    const useASecurityKey = t.button({className: \"link\", onClick: () => vm.showKeySetup()}, vm.i18n`use your security key`);\n    return t.div([\n        t.p(vm.i18n`Enter your secret storage security phrase below to ${vm.purpose}, which will enable you to decrypt messages received before you logged into this session. The security phrase is a freeform secret phrase you optionally chose when setting up security in Element. It is different from your password to login, unless you chose to set them to the same value.`),\n        renderError(t),\n        renderEnableFieldRow(t, vm, vm.i18n`Security phrase`, (phrase, setupDehydratedDevice) => vm.enterSecurityPhrase(phrase, setupDehydratedDevice)),\n        t.p([vm.i18n`You can also `, useASecurityKey, vm.i18n`.`]),\n    ]);\n}\n\nfunction renderEnableFieldRow(t, vm, label, callback) {\n    let setupDehydrationCheck;\n    const eventHandler = () => callback(input.value, setupDehydrationCheck?.checked || false);\n    const input = t.input({type: \"password\", disabled: vm => vm.isBusy, placeholder: label});\n    const children = [\n        t.p([\n            input,\n            t.button({disabled: vm => vm.isBusy, onClick: eventHandler}, vm.decryptAction),\n        ]),\n    ];\n    if (vm.offerDehydratedDeviceSetup) {\n        setupDehydrationCheck = t.input({type: \"checkbox\", id:\"enable-dehydrated-device\"});\n        const moreInfo = t.a({href: \"https://github.com/uhoreg/matrix-doc/blob/dehydration/proposals/2697-device-dehydration.md\", target: \"_blank\", rel: \"noopener\"}, \"more info\");\n        children.push(t.p([\n            setupDehydrationCheck,\n            t.label({for: setupDehydrationCheck.id}, [vm.i18n`Back up my device as well (`, moreInfo, \")\"])\n        ]));\n    }\n    return t.div({className: `row`}, [\n        t.div({className: \"label\"}, label),\n        t.div({className: \"content\"}, children),\n    ]);\n}\n\nfunction renderError(t) {\n    return t.if(vm => vm.error, (t, vm) => {\n        return t.div([\n            t.p({className: \"error\"}, vm => vm.i18n`Could not enable key backup: ${vm.error}.`),\n            t.p(vm.i18n`Try double checking that you did not mix up your security key, security phrase and login password as explained above.`)\n        ])\n    });\n}\n\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\nimport {KeyBackupSettingsView} from \"./KeyBackupSettingsView.js\"\n\nexport class SettingsView extends TemplateView {\n    render(t, vm) {\n        let version = vm.version;\n        if (vm.showUpdateButton) {\n            version = t.span([\n                vm.version,\n                t.button({onClick: () => vm.checkForUpdate()}, vm.i18n`Check for updates`)\n            ]);\n        }\n\n        const row = (t, label, content, extraClass = \"\") => {\n            return t.div({className: `row ${extraClass}`}, [\n                t.div({className: \"label\"}, label),\n                t.div({className: \"content\"}, content),\n            ]);\n        };\n\n        const settingNodes = [];\n\n        settingNodes.push(\n            t.h3(\"Session\"),\n            row(t, vm.i18n`User ID`, vm.userId),\n            row(t, vm.i18n`Session ID`, vm.deviceId, \"code\"),\n            row(t, vm.i18n`Session key`, vm.fingerprintKey, \"code\"),\n            row(t, \"\", t.button({\n                onClick: () => vm.logout(),\n                disabled: vm => vm.isLoggingOut\n            }, vm.i18n`Log out`)),\n        );\n        settingNodes.push(\n            t.h3(\"Key backup\"),\n            t.view(new KeyBackupSettingsView(vm.keyBackupViewModel))\n        );\n\n        settingNodes.push(\n            t.h3(\"Notifications\"),\n            t.map(vm => vm.pushNotifications.supported, (supported, t) => {\n                if (supported === null) {\n                    return t.p(vm.i18n`Loading…`);\n                } else if (supported) {\n                    const label = vm => vm.pushNotifications.enabled ?\n                        vm.i18n`Push notifications are enabled`:\n                        vm.i18n`Push notifications are disabled`;\n                    const buttonLabel = vm => vm.pushNotifications.enabled ?\n                        vm.i18n`Disable`:\n                        vm.i18n`Enable`;\n                    return row(t, label, t.button({\n                        onClick: () => vm.togglePushNotifications(),\n                        disabled: vm => vm.pushNotifications.updating\n                    }, buttonLabel));\n                } else {\n                    return t.p(vm.i18n`Push notifications are not supported on this browser`);\n                }\n            }),\n            t.if(vm => vm.pushNotifications.supported && vm.pushNotifications.enabled, t => {\n                return t.div([\n                    t.p([\n                        \"If you think push notifications are not being delivered, \",\n                        t.button({className: \"link\", onClick: () => vm.checkPushEnabledOnServer()}, \"check\"),\n                        \" if they got disabled on the server\"\n                    ]),\n                    t.map(vm => vm.pushNotifications.enabledOnServer, (enabled, t) => {\n                        if (enabled === true) {\n                            return t.p(\"Push notifications are still enabled on the server, so everything should be working. Sometimes notifications can get dropped if they can't be delivered within a given time.\");\n                        } else if (enabled === false) {\n                            return t.p(\"Push notifications have been disabled on the server, likely due to a bug. Please re-enable them by clicking Disable and then Enable again above.\");\n                        }\n                    }),\n                    t.map(vm => vm.pushNotifications.serverError, (err, t) => {\n                        if (err) {\n                            return t.p(\"Couldn't not check on server: \" + err.message);\n                        }\n                    })\n                ]);\n            })\n        );\n\n        settingNodes.push(\n            t.h3(\"Preferences\"),\n            row(t, vm.i18n`Scale down images when sending`, this._imageCompressionRange(t, vm)),\n        );\n        settingNodes.push(\n            t.h3(\"Application\"),\n            row(t, vm.i18n`Version`, version),\n            row(t, vm.i18n`Storage usage`, vm => `${vm.storageUsage} / ${vm.storageQuota}`),\n            row(t, vm.i18n`Debug logs`, t.button({onClick: () => vm.exportLogs()}, \"Export\")),\n            t.p([\"Debug logs contain application usage data including your username, the IDs or aliases of the rooms or groups you have visited, the usernames of other users and the names of files you send. They do not contain messages. For more information, review our \",\n                t.a({href: \"https://element.io/privacy\", target: \"_blank\", rel: \"noopener\"}, \"privacy policy\"), \".\"]),\n        );\n\n        return t.main({className: \"Settings middle\"}, [\n            t.div({className: \"middle-header\"}, [\n                t.a({className: \"button-utility close-middle\", href: vm.closeUrl, title: vm.i18n`Close settings`}),\n                t.h2(\"Settings\")\n            ]),\n            t.div({className: \"SettingsBody\"}, settingNodes)\n        ]);\n    }\n\n    _imageCompressionRange(t, vm) {\n        const step = 32;\n        const min = Math.ceil(vm.minSentImageSizeLimit / step) * step;\n        const max = (Math.floor(vm.maxSentImageSizeLimit / step) + 1) * step;\n        const updateSetting = evt => vm.setSentImageSizeLimit(parseInt(evt.target.value, 10));\n        return [t.input({\n            type: \"range\",\n            step,\n            min,\n            max,\n            value: vm => vm.sentImageSizeLimit || max,\n            onInput: updateSetting,\n            onChange: updateSetting,\n        }), \" \", t.output(vm => {\n            return vm.sentImageSizeLimit ? \n                vm.i18n`resize to ${vm.sentImageSizeLimit}px` :\n                vm.i18n`no resizing`;\n        })];\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../general/TemplateView\";\nimport {AvatarView} from \"../AvatarView\";\nimport {StaticView} from \"../general/StaticView\";\n\nexport class CreateRoomView extends TemplateView {\n    render(t, vm) {\n        return t.main({className: \"middle\"}, \n            t.div({className: \"CreateRoomView centered-column\"}, [\n                t.h2(\"Create room\"),\n                //t.div({className: \"RoomView_error\"}, vm => vm.error),\n                t.form({className: \"CreateRoomView_detailsForm form\", onChange: evt => this.onFormChange(evt), onSubmit: evt => this.onSubmit(evt)}, [\n                    t.div({className: \"vertical-layout\"}, [\n                        t.button({type: \"button\", className: \"CreateRoomView_selectAvatar\", onClick: () => vm.selectAvatar()},\n                            t.mapView(vm => vm.hasAvatar, hasAvatar => {\n                                if (hasAvatar) {\n                                    return new AvatarView(vm, 64);\n                                } else {\n                                    return new StaticView(undefined, t => {\n                                        return t.div({className: \"CreateRoomView_selectAvatarPlaceholder\"})\n                                    });\n                                }\n                            })\n                        ),\n                        t.div({className: \"stretch form-row text\"}, [\n                            t.label({for: \"name\"}, vm.i18n`Room name`),\n                            t.input({\n                                onInput: evt => vm.setName(evt.target.value),\n                                type: \"text\", name: \"name\", id: \"name\",\n                                placeholder: vm.i18n`Enter a room name`\n                            }),\n                        ]),\n                    ]),\n                    t.div({className: \"form-row text\"}, [\n                        t.label({for: \"topic\"}, vm.i18n`Topic (optional)`),\n                        t.textarea({\n                            onInput: evt => vm.setTopic(evt.target.value),\n                            name: \"topic\", id: \"topic\",\n                            placeholder: vm.i18n`Topic`\n                        }),\n                    ]),\n                    t.div({className: \"form-group\"}, [\n                        t.div({className: \"form-row check\"}, [\n                            t.input({type: \"radio\", name: \"isPublic\", id: \"isPrivate\", value: \"false\", checked: !vm.isPublic}),\n                            t.label({for: \"isPrivate\"}, vm.i18n`Private room, only upon invitation.`)\n                        ]),\n                        t.div({className: \"form-row check\"}, [\n                            t.input({type: \"radio\", name: \"isPublic\", id: \"isPublic\", value: \"true\", checked: vm.isPublic}),\n                            t.label({for: \"isPublic\"}, vm.i18n`Public room, anyone can join`)\n                        ]),\n                    ]),\n                    t.div({className: {\"form-row check\": true, hidden: vm => vm.isPublic}}, [\n                        t.input({type: \"checkbox\", name: \"isEncrypted\", id: \"isEncrypted\", checked: vm.isEncrypted}),\n                        t.label({for: \"isEncrypted\"}, vm.i18n`Enable end-to-end encryption`)\n                    ]),\n                    t.div({className: {\"form-row text\": true, hidden: vm => !vm.isPublic}}, [\n                        t.label({for: \"roomAlias\"}, vm.i18n`Room alias`),\n                        t.input({\n                            onInput: evt => vm.setRoomAlias(evt.target.value),\n                            type: \"text\", name: \"roomAlias\", id: \"roomAlias\",\n                            placeholder: vm.i18n`Room alias (<alias>, or #<alias> or #<alias>:hs.tld`}),\n                    ]),\n                    t.div({className: \"form-group\"}, [\n                        t.div(t.button({className: \"link\", type: \"button\", onClick: () => vm.toggleAdvancedShown()},\n                            vm => vm.isAdvancedShown ? vm.i18n`Hide advanced settings` : vm.i18n`Show advanced settings`)),\n                        t.div({className: {\"form-row check\": true, hidden: vm => !vm.isAdvancedShown}}, [\n                            t.input({type: \"checkbox\", name: \"isFederationDisabled\", id: \"isFederationDisabled\", checked: vm.isFederationDisabled}),\n                            t.label({for: \"isFederationDisabled\"}, [\n                                vm.i18n`Disable federation`,\n                                t.p({className: \"form-row-description\"}, vm.i18n`Can't be changed later. This will prevent people on other homeservers from joining the room. This is typically used when only people from your own organisation (if applicable) should be allowed in the room, and is otherwise not needed.`)\n                            ]),\n                        ]),\n                    ]),\n                    t.div({className: \"button-row\"}, [\n                        t.button({\n                            className: \"button-action primary\",\n                            type: \"submit\",\n                            disabled: vm => !vm.canCreate\n                        }, vm.i18n`Create room`),\n                    ]),\n                ])\n            ])\n        );\n    }\n\n    onFormChange(evt) {\n        switch (evt.target.name) {\n            case \"isEncrypted\":\n                this.value.setEncrypted(evt.target.checked);\n                break;\n            case \"isPublic\":\n                this.value.setPublic(evt.currentTarget.isPublic.value === \"true\");\n                break;\n            case \"isFederationDisabled\":\n                this.value.setFederationDisabled(evt.target.checked);\n                break;\n        }\n    }\n\n    onSubmit(evt) {\n        evt.preventDefault();\n        this.value.create();\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\nimport {classNames, tag} from \"../../general/html\";\nimport {AvatarView} from \"../../AvatarView.js\";\n\nexport class RoomDetailsView extends TemplateView {\n    render(t, vm) {\n        const encryptionString = () => vm.isEncrypted ? vm.i18n`On` : vm.i18n`Off`;\n        return t.div({className: \"RoomDetailsView\"}, [\n            t.div({className: \"RoomDetailsView_avatar\"},\n                [\n                    t.view(new AvatarView(vm, 52)),\n                    t.mapView(vm => vm.isEncrypted, isEncrypted => new EncryptionIconView(isEncrypted))\n                ]),\n            t.div({className: \"RoomDetailsView_name\"}, [t.h2(vm => vm.name)]),\n            this._createRoomAliasDisplay(vm),\n            t.div({className: \"RoomDetailsView_rows\"},\n                [\n                    this._createRightPanelButtonRow(t, vm.i18n`People`, { MemberCount: true }, vm => vm.memberCount,\n                    () => vm.openPanel(\"members\")),\n                    this._createRightPanelRow(t, vm.i18n`Encryption`, {EncryptionStatus: true}, encryptionString)\n                ])\n        ]);\n    }\n\n    _createRoomAliasDisplay(vm) {\n        return vm.canonicalAlias ? tag.div({className: \"RoomDetailsView_id\"}, [vm.canonicalAlias]) :\n            \"\";\n    }\n\n    _createRightPanelRow(t, label, labelClass, value) {\n        const labelClassString = classNames({RoomDetailsView_label: true, ...labelClass});\n        return t.div({className: \"RoomDetailsView_row\"}, [\n            t.div({className: labelClassString}, [label]),\n            t.div({className: \"RoomDetailsView_value\"}, value)\n        ]);\n    }\n\n    _createRightPanelButtonRow(t, label, labelClass, value, onClick) {\n        const labelClassString = classNames({RoomDetailsView_label: true, ...labelClass});\n        return t.button({className: \"RoomDetailsView_row\", onClick}, [\n            t.div({className: labelClassString}, [label]),\n            t.div({className: \"RoomDetailsView_value\"}, value)\n        ]);\n    }\n\n}\n\nclass EncryptionIconView extends TemplateView {\n    render(t, isEncrypted) {\n        return t.div({className: \"EncryptionIconView\"},\n            [t.div({className: isEncrypted ? \"EncryptionIconView_encrypted\" : \"EncryptionIconView_unencrypted\"})]);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// start is included in the range,\n// end is excluded,\n// so [2, 2[ means an empty range\nexport class Range {\n    constructor(\n        public readonly start: number,\n        public readonly end: number\n    ) {}\n\n    get length() {\n        return this.end - this.start;\n    }\n\n    contains(range: Range): boolean {\n        return range.start >= this.start && range.end <= this.end;\n    }\n\n    containsIndex(idx: number): boolean {\n        return idx >= this.start && idx < this.end;\n    }\n\n    toLocalIndex(idx: number) {\n        return idx - this.start;\n    }\n\n    intersects(range: Range): boolean {\n        return range.start < this.end && this.start < range.end;\n    }\n\n    forEachInIterator<T>(it: Iterator<T>, callback: ((T, i: number) => void)) {\n        let i = 0;\n        for (i = 0; i < this.start; i += 1) {\n            it.next();\n        }\n        for (i = 0; i < this.length; i += 1) {\n            const result = it.next();\n            if (result.done) {\n                break;\n            } else {\n                callback(result.value, this.start + i);\n            }\n        }\n    }\n\n    [Symbol.iterator](): Iterator<number> {\n        return new RangeIterator(this);\n    }\n\n    reverseIterable(): Iterable<number> {\n        return new ReverseRangeIterator(this);\n    }\n\n    clampIndex(idx: number, end = this.end - 1) {\n        return Math.min(Math.max(this.start, idx), end);\n    }\n\n    getIndexZone(idx): RangeZone {\n        if (idx < this.start) {\n            return RangeZone.Before;\n        } else if (idx < this.end) {\n            return RangeZone.Inside;\n        } else {\n            return RangeZone.After;\n        }\n    }\n}\n\nexport enum RangeZone {\n    Before = 1,\n    Inside,\n    After\n}\n\nclass RangeIterator implements Iterator<number> {\n    private idx: number;\n    constructor(private readonly range: Range) {\n        this.idx = range.start - 1;\n    }\n\n    next(): IteratorResult<number> {\n        if (this.idx < (this.range.end - 1)) {\n            this.idx += 1;\n            return {value: this.idx, done: false};\n        } else {\n            return {value: undefined, done: true};\n        }\n    }\n}\n\nclass ReverseRangeIterator implements Iterable<number>, Iterator<number> {\n    private idx: number;\n    constructor(private readonly range: Range) {\n        this.idx = range.end;\n    }\n\n    [Symbol.iterator]() {\n        return this;\n    }\n\n    next(): IteratorResult<number> {\n        if (this.idx > this.range.start) {\n            this.idx -= 1;\n            return {value: this.idx, done: false};\n        } else {\n            return {value: undefined, done: true};\n        }\n    }\n}\n\nexport function tests() {\n    return {\n        \"length\": assert => {\n            const a = new Range(2, 5);\n            assert.equal(a.length, 3);\n        },\n        \"iterator\": assert => {\n            assert.deepEqual(Array.from(new Range(2, 5)), [2, 3, 4]);\n        },\n        \"reverseIterable\": assert => {\n            assert.deepEqual(Array.from(new Range(2, 5).reverseIterable()), [4, 3, 2]);\n        },\n        \"containsIndex\": assert => {\n            const a = new Range(2, 5);\n            assert.equal(a.containsIndex(0), false);\n            assert.equal(a.containsIndex(1), false);\n            assert.equal(a.containsIndex(2), true);\n            assert.equal(a.containsIndex(3), true);\n            assert.equal(a.containsIndex(4), true);\n            assert.equal(a.containsIndex(5), false);\n            assert.equal(a.containsIndex(6), false);\n        },\n        \"intersects returns false for touching ranges\": assert => {\n            const a = new Range(2, 5);\n            const b = new Range(5, 10);\n            assert.equal(a.intersects(b), false);\n            assert.equal(b.intersects(a), false);\n        },\n        \"intersects returns false\": assert => {\n            const a = new Range(2, 5);\n            const b = new Range(50, 100);\n            assert.equal(a.intersects(b), false);\n            assert.equal(b.intersects(a), false);\n        },\n        \"intersects returns true for 1 overlapping item\": assert => {\n            const a = new Range(2, 5);\n            const b = new Range(4, 10);\n            assert.equal(a.intersects(b), true);\n            assert.equal(b.intersects(a), true);\n        },\n        \"contains beyond left edge\": assert => {\n            const a = new Range(2, 5);\n            const b = new Range(1, 3);\n            assert.equal(a.contains(b), false);\n        },\n        \"contains at left edge\": assert => {\n            const a = new Range(2, 5);\n            const b = new Range(2, 3);\n            assert.equal(a.contains(b), true);\n        },\n        \"contains between edges\": assert => {\n            const a = new Range(2, 5);\n            const b = new Range(3, 4);\n            assert.equal(a.contains(b), true);\n        },\n        \"contains at right edge\": assert => {\n            const a = new Range(2, 5);\n            const b = new Range(3, 5);\n            assert.equal(a.contains(b), true);\n        },\n        \"contains beyond right edge\": assert => {\n            const a = new Range(2, 5);\n            const b = new Range(4, 6);\n            assert.equal(a.contains(b), false);\n        },\n        \"contains for non-intersecting ranges\": assert => {\n            const a = new Range(2, 5);\n            const b = new Range(5, 6);\n            assert.equal(a.contains(b), false);\n        },\n        \"forEachInIterator with more values available\": assert => {\n            const callbackValues: {v: string, i: number}[] = [];\n            const values = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\n            const it = values[Symbol.iterator]();\n            new Range(2, 5).forEachInIterator(it, (v, i) => callbackValues.push({v, i}));\n            assert.deepEqual(callbackValues, [\n                {v: \"c\", i: 2},\n                {v: \"d\", i: 3},\n                {v: \"e\", i: 4},\n            ]);\n        },\n        \"forEachInIterator with fewer values available\": assert => {\n            const callbackValues: {v: string, i: number}[] = [];\n            const values = [\"a\", \"b\", \"c\"];\n            const it = values[Symbol.iterator]();\n            new Range(2, 5).forEachInIterator(it, (v, i) => callbackValues.push({v, i}));\n            assert.deepEqual(callbackValues, [\n                {v: \"c\", i: 2},\n            ]);\n        },\n        \"clampIndex\": assert => {\n            assert.equal(new Range(2, 5).clampIndex(0), 2);\n            assert.equal(new Range(2, 5).clampIndex(2), 2);\n            assert.equal(new Range(2, 5).clampIndex(3), 3);\n            assert.equal(new Range(2, 5).clampIndex(4), 4);\n            assert.equal(new Range(2, 5).clampIndex(5), 4);\n            assert.equal(new Range(2, 5).clampIndex(10), 4);\n        }\n    };\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {Range, RangeZone} from \"./Range\";\nimport {defaultObserverWith} from \"../../../../observable/list/BaseObservableList\";\n\nfunction skipOnIterator<T>(it: Iterator<T>, pos: number): boolean {\n    let i = 0;\n    while (i < pos) {\n        i += 1;\n        if(it.next().done) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction getIteratorValueAtIdx<T>(it: Iterator<T>, idx: number): undefined | T {\n    if (skipOnIterator(it, idx)) {\n        const result = it.next();\n        if (!result.done) {\n            return result.value;\n        }\n    }\n    return undefined;\n}\n\nexport enum ResultType {\n    Move,\n    Add,\n    Remove,\n    RemoveAndAdd,\n    UpdateRange\n}\n\nexport interface MoveResult {\n    type: ResultType.Move;\n    fromIdx: number;\n    toIdx: number\n}\n\ninterface AddResult<T> {\n    type: ResultType.Add;\n    newRange?: ListRange;\n    /** the list index of an item to add */\n    addIdx: number;\n    /** the value to add at addIdx */\n    value: T\n}\n\ninterface RemoveResult {\n    type: ResultType.Remove;\n    newRange?: ListRange;\n    /** the list index of an item to remove, before the add or remove event has been taken into account */\n    removeIdx: number;\n}\n\n// need to repeat the fields from RemoveResult and AddResult here\n// to make the discriminated union work\ninterface RemoveAndAddResult<T> {\n    type: ResultType.RemoveAndAdd;\n    newRange?: ListRange;\n    /** the list index of an item to remove, before the add or remove event has been taken into account */\n    removeIdx: number;\n    /** the list index of an item to add */\n    addIdx: number;\n    /** the value to add at addIdx */\n    value: T;\n}\n\ninterface UpdateRangeResult {\n    type: ResultType.UpdateRange;\n    newRange?: ListRange;\n}\n\nexport type AddRemoveResult<T> = AddResult<T> | RemoveResult | RemoveAndAddResult<T> | UpdateRangeResult;\n\nexport class ListRange extends Range {\n    constructor(\n        start: number,\n        end: number,\n        private _totalLength: number,\n        private _viewportItemCount: number = end - start\n    ) {\n        super(start, end);\n    }\n\n    expand(amount: number): ListRange {\n        // don't expand ranges that won't render anything\n        if (this.length === 0) {\n            return this;\n        }\n        const newStart = Math.max(0, this.start - amount);\n        const newEnd = Math.min(this.totalLength, this.end + amount);\n        return new ListRange(\n            newStart,\n            newEnd,\n            this.totalLength,\n            this._viewportItemCount\n        );\n    }\n\n    get totalLength(): number {\n        return this._totalLength;\n    }\n\n    get viewportItemCount(): number {\n        return this._viewportItemCount;\n    }\n\n    static fromViewport(listLength: number, itemHeight: number, listHeight: number, scrollTop: number) {\n        const topCount = Math.min(Math.max(0, Math.floor(scrollTop / itemHeight)), listLength);\n        const itemsAfterTop = listLength - topCount;\n        const viewportItemCount = listHeight !== 0 ? Math.ceil(listHeight / itemHeight) : 0;\n        const renderCount = Math.min(viewportItemCount, itemsAfterTop);\n        return new ListRange(topCount, topCount + renderCount, listLength, viewportItemCount);\n    }\n\n    queryAdd<T>(idx: number, value: T, list: Iterable<T>): AddRemoveResult<T> {\n        const maxAddIdx = this.viewportItemCount > this.length ? this.end : this.end - 1;\n        if (idx <= maxAddIdx) {\n            // use maxAddIdx to allow to grow the range by one at a time\n            // if the viewport isn't filled yet\n            const addIdx = this.clampIndex(idx, maxAddIdx);\n            const addValue = addIdx === idx ? value : getIteratorValueAtIdx(list[Symbol.iterator](), addIdx)!;\n            return this.createAddResult<T>(addIdx, addValue);\n        } else {\n            // if the add happened after the range, we only update the range with the new length\n            return {type: ResultType.UpdateRange, newRange: this.deriveRange(1, 0)};\n        }\n    }\n\n    queryRemove<T>(idx: number, list: Iterable<T>): AddRemoveResult<T> {\n        if (idx < this.end) {\n            const removeIdx = this.clampIndex(idx);\n            return this.createRemoveResult(removeIdx, list);\n        } else {\n            return {type: ResultType.UpdateRange, newRange: this.deriveRange(-1, 0)};\n        }\n    }\n\n    queryMove<T>(fromIdx: number, toIdx: number, value: T, list: Iterable<T>): MoveResult | AddRemoveResult<T> | undefined {\n        const fromZone = this.getIndexZone(fromIdx);\n        const toZone = this.getIndexZone(toIdx);\n        if (fromZone === toZone) {\n            if (fromZone === RangeZone.Before || fromZone === RangeZone.After) {\n                return;\n            } else if (fromZone === RangeZone.Inside) {\n                return {type: ResultType.Move, fromIdx, toIdx};\n            }\n        } else {\n            const addIdx = this.clampIndex(toIdx);\n            const removeIdx = this.clampIndex(fromIdx);\n            const addValue = addIdx === toIdx ? value : getIteratorValueAtIdx(list[Symbol.iterator](), addIdx)!;\n            return {type: ResultType.RemoveAndAdd, removeIdx, addIdx, value: addValue};\n        }\n    }\n\n    private createAddResult<T>(addIdx: number, value: T): AddRemoveResult<T> {\n        // if the view port isn't filled yet, we don't remove\n        if (this.viewportItemCount > this.length) {\n            return {type: ResultType.Add, addIdx, value, newRange: this.deriveRange(1, 1)};\n        } else {\n            const removeIdx = this.clampIndex(Number.MAX_SAFE_INTEGER);\n            return {type: ResultType.RemoveAndAdd, removeIdx, addIdx, value, newRange: this.deriveRange(1, 0)};\n        }\n    }\n\n    private createRemoveResult<T>(removeIdx: number, list: Iterable<T>): AddRemoveResult<T> {\n        if (this.end < this.totalLength) {\n            // we have items below the range, we can add one from there to fill the viewport\n            const addIdx = this.clampIndex(Number.MAX_SAFE_INTEGER);\n            // we assume the value has already been removed from the list,\n            // so we can just look up the next value which is already at the same idx\n            const value = getIteratorValueAtIdx(list[Symbol.iterator](), addIdx)!;\n            return {type: ResultType.RemoveAndAdd, removeIdx, value, addIdx, newRange: this.deriveRange(-1, 0)};\n        } else if (this.start !== 0) {\n            // move the range 1 item up so we still display a viewport full of items\n            const newRange = this.deriveRange(-1, 0, 1);\n            const addIdx = newRange.start;\n            // we assume the value has already been removed from the list,\n            // so we can just look up the next value which is already at the same idx\n            const value = getIteratorValueAtIdx(list[Symbol.iterator](), addIdx)!;\n            return {type: ResultType.RemoveAndAdd, removeIdx, value, addIdx, newRange};\n        } else {\n            // we can't add at the bottom nor top, already constrained\n            return {type: ResultType.Remove, removeIdx, newRange: this.deriveRange(-1, 0)};\n        }\n    }\n\n    private deriveRange(totalLengthInc: number, viewportItemCountDecr: number, startDecr: number = 0): ListRange {\n        const start = this.start - startDecr;\n        const totalLength = this.totalLength + totalLengthInc;\n        // prevent end being larger than totalLength\n        const end = Math.min(Math.max(start, this.end - startDecr + viewportItemCountDecr), totalLength);\n        return new ListRange(\n            start,\n            end,\n            totalLength,\n            this.viewportItemCount\n        );\n    }\n}\n\nimport {ObservableArray} from \"../../../../observable/list/ObservableArray\";\n\nexport function tests() {\n    return {\n        \"fromViewport\": assert => {\n            const range = ListRange.fromViewport(10, 20, 90, 30);\n            assert.equal(range.start, 1);\n            assert.equal(range.end, 6);\n            assert.equal(range.totalLength, 10);\n        },\n        \"fromViewport at end\": assert => {\n            const itemHeight = 20;\n            const range = ListRange.fromViewport(10, itemHeight, 3 * itemHeight, 7 * itemHeight);\n            assert.equal(range.start, 7);\n            assert.equal(range.end, 10);\n            assert.equal(range.totalLength, 10);\n        },\n        \"fromViewport with not enough items to fill viewport\": assert => {\n            const itemHeight = 20;\n            const range = ListRange.fromViewport(5, itemHeight, 8 * itemHeight, 0);\n            assert.equal(range.start, 0);\n            assert.equal(range.end, 5);\n            assert.equal(range.totalLength, 5);\n            assert.equal(range.length, 5);\n            assert.equal(range.viewportItemCount, 8);\n        },\n        \"expand at start of list\": assert => {\n            const range = new ListRange(1, 5, 10);\n            const expanded = range.expand(2);\n            assert.equal(expanded.start, 0);\n            assert.equal(expanded.end, 7);\n            assert.equal(expanded.totalLength, 10);\n            assert.equal(expanded.length, 7);\n        },\n        \"expand at end of list\": assert => {\n            const range = new ListRange(7, 9, 10);\n            const expanded = range.expand(2);\n            assert.equal(expanded.start, 5);\n            assert.equal(expanded.end, 10);\n            assert.equal(expanded.totalLength, 10);\n            assert.equal(expanded.length, 5);\n        },\n        \"expand in middle of list\": assert => {\n            const range = new ListRange(4, 6, 10);\n            const expanded = range.expand(2);\n            assert.equal(expanded.start, 2);\n            assert.equal(expanded.end, 8);\n            assert.equal(expanded.totalLength, 10);\n            assert.equal(expanded.length, 6);\n        },\n        \"queryAdd with addition before range\": assert => {\n            const list = new ObservableArray([\"b\", \"c\", \"d\", \"e\"]);\n            const range = new ListRange(1, 3, list.length);\n            let added = false;\n            list.subscribe(defaultObserverWith({\n                onAdd(idx, value) {\n                    added = true;\n                    const result = range.queryAdd(idx, value, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.RemoveAndAdd,\n                        removeIdx: 2,\n                        addIdx: 1,\n                        value: \"b\",\n                        newRange: new ListRange(1, 3, 5)\n                    });\n                }\n            }));\n            list.insert(0, \"a\");\n            assert(added);\n        },\n        \"queryAdd with addition within range\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"d\", \"e\"]);\n            const range = new ListRange(1, 3, list.length);\n            let added = false;\n            list.subscribe(defaultObserverWith({\n                onAdd(idx, value) {\n                    added = true;\n                    const result = range.queryAdd(idx, value, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.RemoveAndAdd,\n                        removeIdx: 2,\n                        addIdx: 2,\n                        value: \"c\",\n                        newRange: new ListRange(1, 3, 5)\n                    });\n                }\n            }));\n            list.insert(2, \"c\");\n            assert(added);\n        },\n        \"queryAdd with addition after range\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"c\", \"d\"]);\n            const range = new ListRange(1, 3, list.length);\n            let added = false;\n            list.subscribe(defaultObserverWith({\n                onAdd(idx, value) {\n                    added = true;\n                    const result = range.queryAdd(idx, value, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.UpdateRange,\n                        newRange: new ListRange(1, 3, 5)\n                    });\n                }\n            }));\n            list.insert(4, \"e\");\n            assert(added);\n        },\n        \"queryAdd with too few items to fill viewport grows the range\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"d\"]);\n            const viewportItemCount = 4;\n            const range = new ListRange(0, 3, list.length, viewportItemCount);\n            let added = false;\n            list.subscribe(defaultObserverWith({\n                onAdd(idx, value) {\n                    added = true;\n                    const result = range.queryAdd(idx, value, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.Add,\n                        newRange: new ListRange(0, 4, 4),\n                        addIdx: 2,\n                        value: \"c\"\n                    });\n                }\n            }));\n            list.insert(2, \"c\");\n            assert(added);\n        },\n        \"queryRemove with removal before range\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"c\", \"d\", \"e\"]);\n            const range = new ListRange(1, 3, list.length);\n            let removed = false;\n            list.subscribe(defaultObserverWith({\n                onRemove(idx) {\n                    removed = true;\n                    const result = range.queryRemove(idx, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.RemoveAndAdd,\n                        removeIdx: 1,\n                        addIdx: 2,\n                        value: \"d\",\n                        newRange: new ListRange(1, 3, 4)\n                    });\n                }\n            }));\n            list.remove(0);\n            assert(removed);\n        },\n        \"queryRemove with removal within range\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"c\", \"d\", \"e\"]);\n            const range = new ListRange(1, 3, list.length);\n            let removed = false;\n            list.subscribe(defaultObserverWith({\n                onRemove(idx) {\n                    removed = true;\n                    const result = range.queryRemove(idx, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.RemoveAndAdd,\n                        removeIdx: 2,\n                        addIdx: 2,\n                        value: \"d\",\n                        newRange: new ListRange(1, 3, 4)\n                    });\n                    assert.equal(list.length, 4);\n                }\n            }));\n            list.remove(2);\n            assert(removed);\n        },\n        \"queryRemove with removal after range\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"c\", \"d\", \"e\"]);\n            const range = new ListRange(1, 3, list.length);\n            let removed = false;\n            list.subscribe(defaultObserverWith({\n                onRemove(idx) {\n                    removed = true;\n                    const result = range.queryRemove(idx, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.UpdateRange,\n                        newRange: new ListRange(1, 3, 4)\n                    });\n                }\n            }));\n            list.remove(3);\n            assert(removed);\n        },\n        \"queryRemove at bottom of range moves range one up\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"c\"]);\n            const range = new ListRange(1, 3, list.length);\n            let removed = false;\n            list.subscribe(defaultObserverWith({\n                onRemove(idx) {\n                    removed = true;\n                    const result = range.queryRemove(idx, list);\n                    assert.deepEqual(result, {\n                        newRange: new ListRange(0, 2, 2),\n                        type: ResultType.RemoveAndAdd,\n                        removeIdx: 2,\n                        addIdx: 0,\n                        value: \"a\"\n                    });\n                }\n            }));\n            list.remove(2);\n            assert(removed);\n        },\n        \"queryRemove with range on full length shrinks range\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"c\"]);\n            const range = new ListRange(0, 3, list.length);\n            let removed = false;\n            list.subscribe(defaultObserverWith({\n                onRemove(idx) {\n                    removed = true;\n                    const result = range.queryRemove(idx, list);\n                    assert.deepEqual(result, {\n                        newRange: new ListRange(0, 2, 2, 3),\n                        type: ResultType.Remove,\n                        removeIdx: 2,\n                    });\n                }\n            }));\n            list.remove(2);\n            assert(removed);\n        },\n        \"queryMove with move inside range\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"c\", \"d\", \"e\"]);\n            const range = new ListRange(1, 4, list.length);\n            let moved = false;\n            list.subscribe(defaultObserverWith({\n                onMove(fromIdx, toIdx, value) {\n                    moved = true;\n                    const result = range.queryMove(fromIdx, toIdx, value, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.Move,\n                        fromIdx: 2,\n                        toIdx: 3\n                    });\n                }\n            }));\n            list.move(2, 3);\n            assert(moved);\n        },\n        \"queryMove with move from before to inside range\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"c\", \"d\", \"e\"]);\n            const range = new ListRange(2, 5, list.length);\n            let moved = false;\n            list.subscribe(defaultObserverWith({\n                onMove(fromIdx, toIdx, value) {\n                    moved = true;\n                    const result = range.queryMove(fromIdx, toIdx, value, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.RemoveAndAdd,\n                        removeIdx: 2,\n                        addIdx: 3,\n                        value: \"a\"\n                    });\n                }\n            }));\n            list.move(0, 3); // move \"a\" to after \"d\"\n            assert(moved);\n        },\n        \"queryMove with move from after to inside range\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"c\", \"d\", \"e\"]);\n            const range = new ListRange(0, 3, list.length);\n            let moved = false;\n            list.subscribe(defaultObserverWith({\n                onMove(fromIdx, toIdx, value) {\n                    moved = true;\n                    const result = range.queryMove(fromIdx, toIdx, value, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.RemoveAndAdd,\n                        removeIdx: 2,\n                        addIdx: 1,\n                        value: \"e\"\n                    });\n                }\n            }));\n            list.move(4, 1); // move \"e\" to before \"b\"\n            assert(moved);\n        },\n        \"queryMove with move inside range to after\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"c\", \"d\", \"e\"]);\n            const range = new ListRange(0, 3, list.length);\n            let moved = false;\n            list.subscribe(defaultObserverWith({\n                onMove(fromIdx, toIdx, value) {\n                    moved = true;\n                    const result = range.queryMove(fromIdx, toIdx, value, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.RemoveAndAdd,\n                        removeIdx: 1,\n                        addIdx: 2,\n                        value: \"d\"\n                    });\n                }\n            }));\n            list.move(1, 3); // move \"b\" to after \"d\"\n            assert(moved);\n        },\n        \"queryMove with move inside range to before\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"c\", \"d\", \"e\"]);\n            const range = new ListRange(2, 5, list.length);\n            let moved = false;\n            list.subscribe(defaultObserverWith({\n                onMove(fromIdx, toIdx, value) {\n                    moved = true;\n                    const result = range.queryMove(fromIdx, toIdx, value, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.RemoveAndAdd,\n                        removeIdx: 3,\n                        addIdx: 2,\n                        value: \"b\"\n                    });\n                }\n            }));\n            list.move(3, 0); // move \"d\" to before \"a\"\n            assert(moved);\n        },\n        \"queryMove with move from before range to after\": assert => {\n            const list = new ObservableArray([\"a\", \"b\", \"c\", \"d\", \"e\"]);\n            const range = new ListRange(1, 4, list.length);\n            let moved = false;\n            list.subscribe(defaultObserverWith({\n                onMove(fromIdx, toIdx, value) {\n                    moved = true;\n                    const result = range.queryMove(fromIdx, toIdx, value, list);\n                    assert.deepEqual(result, {\n                        type: ResultType.RemoveAndAdd,\n                        removeIdx: 1,\n                        addIdx: 3,\n                        value: \"e\"\n                    });\n                }\n            }));\n            list.move(0, 4); // move \"a\" to after \"e\"\n            assert(moved);\n        },\n        // would be good to test here what multiple mutations look like with executing the result of queryXXX\n        // on an array, much like we do in the view.\n    };\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {tag} from \"./html\";\nimport {removeChildren, mountView} from \"./utils\";\nimport {ListRange, ResultType, AddRemoveResult} from \"./ListRange\";\nimport {ListView, IOptions as IParentOptions} from \"./ListView\";\nimport {IView} from \"./types\";\n\nexport interface IOptions<T, V> extends IParentOptions<T, V> {\n    itemHeight: number;\n    overflowItems?: number;\n}\n\nexport class LazyListView<T, V extends IView> extends ListView<T, V> {\n    private renderRange?: ListRange;\n    private height?: number;\n    private itemHeight: number;\n    private overflowItems: number;\n    private scrollContainer?: HTMLElement;\n\n    constructor(\n        {itemHeight, overflowItems = 20, ...options}: IOptions<T, V>, \n        childCreator: (value: T) => V\n    ) {\n        super(options, childCreator);\n        this.itemHeight = itemHeight;\n        this.overflowItems = overflowItems;\n    }\n\n    handleEvent(e: Event) {\n        if (e.type === \"scroll\") {\n            this.handleScroll();\n        } else {\n            super.handleEvent(e);\n        }\n    }\n\n    handleScroll() {\n        const visibleRange = this._getVisibleRange();\n        // don't contain empty ranges\n        // as it will prevent clearing the list\n        // once it is scrolled far enough out of view\n        if (visibleRange.length !== 0 && !this.renderRange!.contains(visibleRange)) {\n            const prevRenderRange = this.renderRange!;\n            this.renderRange = visibleRange.expand(this.overflowItems);\n            this.renderUpdate(prevRenderRange, this.renderRange);\n        }\n    }\n    \n    // override\n    async loadList() {\n        /*\n        Wait two frames for the return from mount() to be inserted into DOM.\n        This should be enough, but if this gives us trouble we can always use\n        MutationObserver.\n        */\n        await new Promise(r => requestAnimationFrame(r));\n        await new Promise(r => requestAnimationFrame(r));\n\n        if (!this._list) {\n            return;\n        }\n        this._subscription = this._list.subscribe(this);\n        const visibleRange = this._getVisibleRange();\n        this.renderRange = visibleRange.expand(this.overflowItems);\n        this._childInstances = [];\n        this.reRenderFullRange(this.renderRange);\n    }\n\n    private _getVisibleRange() {\n        const {clientHeight, scrollTop} = this.root()!;\n        if (clientHeight === 0) {\n            throw new Error(\"LazyListView height is 0\");\n        }\n        return ListRange.fromViewport(this._list.length, this.itemHeight, clientHeight, scrollTop);\n    }\n\n    private reRenderFullRange(range: ListRange) {\n        removeChildren(this._listElement!);\n        const fragment = document.createDocumentFragment();\n        const it = this._list[Symbol.iterator]();\n        this._childInstances!.length = 0;\n        range.forEachInIterator(it, item => {\n            const child = this._childCreator(item);\n            this._childInstances!.push(child);\n            fragment.appendChild(mountView(child, this._mountArgs));\n        });\n        this._listElement!.appendChild(fragment);\n        this.adjustPadding(range);\n    }\n\n    private renderUpdate(prevRange: ListRange, newRange: ListRange) {\n        if (newRange.intersects(prevRange)) {\n            // remove children in reverse order so child index isn't affected by previous removals\n            for (const idxInList of prevRange.reverseIterable()) {\n                if (!newRange.containsIndex(idxInList)) {\n                    const localIdx = idxInList - prevRange.start;\n                    this.removeChild(localIdx);\n                }\n            }\n            // use forEachInIterator instead of for loop as we need to advance\n            // the list iterator to the start of the range first\n            newRange.forEachInIterator(this._list[Symbol.iterator](), (item, idxInList) => {\n                if (!prevRange.containsIndex(idxInList)) {\n                    const localIdx = idxInList - newRange.start;\n                    this.addChild(localIdx, item);\n                }\n            });\n            this.adjustPadding(newRange);\n        } else {\n            this.reRenderFullRange(newRange);\n        }\n    }\n\n    private adjustPadding(range: ListRange) {\n        const paddingTop = range.start * this.itemHeight;\n        const paddingBottom = (range.totalLength - range.end) * this.itemHeight;\n        const style = this._listElement!.style;\n        style.paddingTop = `${paddingTop}px`;\n        style.paddingBottom = `${paddingBottom}px`;\n    }\n\n    mount() {\n        const listElement = super.mount();\n        this.scrollContainer = tag.div({className: \"LazyListParent\"}, listElement) as HTMLElement;\n        this.scrollContainer.addEventListener(\"scroll\", this);\n        return this.scrollContainer;\n    }\n\n    unmount() {\n        this.root()!.removeEventListener(\"scroll\", this);\n        this.scrollContainer = undefined;\n        super.unmount();\n    }\n\n    root(): Element | undefined {\n        return this.scrollContainer;\n    }\n\n    private get _listElement(): HTMLElement | undefined {\n        return super.root() as HTMLElement | undefined;\n    }\n\n    onAdd(idx: number, value: T) {\n        const result = this.renderRange!.queryAdd(idx, value, this._list);\n        this.applyRemoveAddResult(result);\n    }\n\n    onRemove(idx: number, value: T) {\n        const result = this.renderRange!.queryRemove(idx, this._list);\n        this.applyRemoveAddResult(result);\n    }\n\n    onMove(fromIdx: number, toIdx: number, value: T) {\n        const result = this.renderRange!.queryMove(fromIdx, toIdx, value, this._list);\n        if (result) {\n            if (result.type === ResultType.Move) {\n                this.moveChild(\n                    this.renderRange!.toLocalIndex(result.fromIdx),\n                    this.renderRange!.toLocalIndex(result.toIdx)\n                );\n            } else {\n                this.applyRemoveAddResult(result);\n            }\n        }\n    }\n\n    onUpdate(i: number, value: T, params: any) {\n        if (this.renderRange!.containsIndex(i)) {\n            this.updateChild(this.renderRange!.toLocalIndex(i), value, params);\n        }\n    }\n\n    private applyRemoveAddResult(result: AddRemoveResult<T>) {\n        // order is important here, the new range can have a different start\n        if (result.type === ResultType.Remove || result.type === ResultType.RemoveAndAdd) {\n            this.removeChild(this.renderRange!.toLocalIndex(result.removeIdx));\n        }\n        if (result.newRange) {\n            this.renderRange = result.newRange;\n            this.adjustPadding(this.renderRange)\n        }\n        if (result.type === ResultType.Add || result.type === ResultType.RemoveAndAdd) {\n            this.addChild(this.renderRange!.toLocalIndex(result.addIdx), result.value);\n        }\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\nimport {AvatarView} from \"../../AvatarView.js\";\n\nexport class MemberTileView extends TemplateView {\n    render(t, vm) {\n        return t.li({ className: \"MemberTileView\" },\n            t.a({ href: vm.detailsUrl },\n            [\n                t.view(new AvatarView(vm, 32)),\n                t.div({ className: \"MemberTileView_name\" }, (vm) => vm.name),\n            ])\n        );\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {LazyListView} from \"../../general/LazyListView\";\nimport {MemberTileView} from \"./MemberTileView.js\";\n\nexport class MemberListView extends LazyListView {\n    constructor(vm) {\n        super({\n            list: vm.memberTileViewModels,\n            className: \"MemberListView\",\n            itemHeight: 40\n        }, tileViewModel => new MemberTileView(tileViewModel));\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {AvatarView} from \"../../AvatarView.js\";\nimport {TemplateView} from \"../../general/TemplateView\";\n\nexport class MemberDetailsView extends TemplateView {\n    render(t, vm) {\n        return t.div({className: \"MemberDetailsView\"},\n            [   t.view(new AvatarView(vm, 128)),\n                t.div({className: \"MemberDetailsView_name\"}, t.h2(vm => vm.name)),\n                t.div({className: \"MemberDetailsView_id\"}, vm.userId),\n                this._createSection(t, vm.i18n`Role`, vm => vm.role),\n                this._createSection(t, vm.i18n`Security`, vm.isEncrypted ?\n                    vm.i18n`Messages in this room are end-to-end encrypted.` :\n                    vm.i18n`Messages in this room are not end-to-end encrypted.`\n                ),\n                this._createOptions(t, vm)\n            ]);\n    }\n\n    _createSection(t, label, value) {\n        return t.div({ className: \"MemberDetailsView_section\" },\n            [\n                t.div({className: \"MemberDetailsView_label\"}, label),\n                t.div({className: \"MemberDetailsView_value\"}, value)\n            ]);\n    }\n\n    _createOptions(t, vm) {\n        return t.div({ className: \"MemberDetailsView_section\" },\n            [\n                t.div({className: \"MemberDetailsView_label\"}, vm.i18n`Options`),\n                t.div({className: \"MemberDetailsView_options\"},\n                    [\n                        t.a({href: vm.linkToUser, target: \"_blank\", rel: \"noopener\"}, vm.i18n`Open Link to User`),\n                        t.button({className: \"text\", onClick: () => vm.openDirectMessage()}, vm.i18n`Open direct message`)\n                    ])\n            ]);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../../general/TemplateView\";\nimport {RoomDetailsView} from \"./RoomDetailsView.js\";\nimport {MemberListView} from \"./MemberListView.js\";\nimport {LoadingView} from \"../../general/LoadingView.js\";\nimport {MemberDetailsView} from \"./MemberDetailsView.js\";\n\nexport class RightPanelView extends TemplateView {\n    render(t) {\n        return t.div({ className: \"RightPanelView\" },\n            [\n                t.ifView(vm => vm.activeViewModel, vm => new ButtonsView(vm)),\n                t.mapView(vm => vm.activeViewModel, vm => this._viewFromType(vm))\n            ]\n        );\n    }\n\n    _viewFromType(vm) {\n        const type = vm?.type;\n        switch (type) {\n            case \"room-details\":\n                return new RoomDetailsView(vm);\n            case \"member-list\":\n                return new MemberListView(vm);\n            case \"member-details\":\n                return new MemberDetailsView(vm);\n            default:\n                return new LoadingView();\n        }\n    }\n}\n\nclass ButtonsView extends TemplateView {\n    render(t, vm) {\n        return t.div({ className: \"RightPanelView_buttons\" },\n            [\n            t.button({\n                className: {\n                    \"back\": true,\n                    \"button-utility\": true,\n                    \"hide\": !vm.activeViewModel.shouldShowBackButton\n                }, onClick: () => vm.showPreviousPanel()}),\n            t.button({className: \"close button-utility\", onClick: () => vm.closePanel()})\n        ]);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {LeftPanelView} from \"./leftpanel/LeftPanelView.js\";\nimport {RoomView} from \"./room/RoomView.js\";\nimport {UnknownRoomView} from \"./room/UnknownRoomView.js\";\nimport {RoomBeingCreatedView} from \"./room/RoomBeingCreatedView.js\";\nimport {InviteView} from \"./room/InviteView.js\";\nimport {LightboxView} from \"./room/LightboxView.js\";\nimport {TemplateView} from \"../general/TemplateView\";\nimport {StaticView} from \"../general/StaticView.js\";\nimport {SessionStatusView} from \"./SessionStatusView.js\";\nimport {RoomGridView} from \"./RoomGridView.js\";\nimport {SettingsView} from \"./settings/SettingsView.js\";\nimport {CreateRoomView} from \"./CreateRoomView.js\";\nimport {RightPanelView} from \"./rightpanel/RightPanelView.js\";\n\nexport class SessionView extends TemplateView {\n    render(t, vm) {\n        return t.div({\n            className: {\n                \"SessionView\": true,\n                \"middle-shown\": vm => !!vm.activeMiddleViewModel,\n                \"right-shown\": vm => !!vm.rightPanelViewModel\n            },\n        }, [\n            t.view(new SessionStatusView(vm.sessionStatusViewModel)),\n            t.view(new LeftPanelView(vm.leftPanelViewModel)),\n            t.mapView(vm => vm.activeMiddleViewModel, () => {\n                if (vm.roomGridViewModel) {\n                    return new RoomGridView(vm.roomGridViewModel);\n                } else if (vm.settingsViewModel) {\n                    return new SettingsView(vm.settingsViewModel);\n                } else if (vm.createRoomViewModel) {\n                    return new CreateRoomView(vm.createRoomViewModel);\n                } else if (vm.currentRoomViewModel) {\n                    if (vm.currentRoomViewModel.kind === \"invite\") {\n                        return new InviteView(vm.currentRoomViewModel);\n                    } else if (vm.currentRoomViewModel.kind === \"room\") {\n                        return new RoomView(vm.currentRoomViewModel);\n                    } else if (vm.currentRoomViewModel.kind === \"roomBeingCreated\") {\n                        return new RoomBeingCreatedView(vm.currentRoomViewModel);\n                    } else {\n                        return new UnknownRoomView(vm.currentRoomViewModel);\n                    }\n                } else {\n                    return new StaticView(t => t.div({className: \"room-placeholder\"}, t.h2(vm.i18n`Choose a room on the left side.`)));\n                }\n            }),\n            t.mapView(vm => vm.lightboxViewModel, lightboxViewModel => lightboxViewModel ? new LightboxView(lightboxViewModel) : null),\n            t.mapView(vm => vm.rightPanelViewModel, rightPanelViewModel => rightPanelViewModel ? new RightPanelView(rightPanelViewModel) : null)\n        ]);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport function hydrogenGithubLink(t) {\n    if (DEFINE_VERSION && DEFINE_GLOBAL_HASH) {\n        return t.a({target: \"_blank\",\n            href: `https://github.com/vector-im/hydrogen-web/releases/tag/v${DEFINE_VERSION}`},\n            `Hydrogen v${DEFINE_VERSION} (${DEFINE_GLOBAL_HASH}) on Github`);\n    } else {\n        return t.a({target: \"_blank\", href: \"https://github.com/vector-im/hydrogen-web\"},\n            \"Hydrogen on Github\");\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../general/TemplateView\";\n\nexport class PasswordLoginView extends TemplateView {\n    render(t, vm) {\n        const disabled = vm => !!vm.isBusy;\n        const username = t.input({\n            id: \"username\",\n            type: \"text\",\n            placeholder: vm.i18n`Username`,\n            disabled\n        });\n        const password = t.input({\n            id: \"password\",\n            type: \"password\",\n            placeholder: vm.i18n`Password`,\n            disabled\n        });\n        \n        return t.div({className: \"PasswordLoginView form\"}, [\n            t.if(vm => vm.error, t => t.div({ className: \"error\" }, vm => vm.error)),\n            t.form({\n                onSubmit: evnt => {\n                    evnt.preventDefault();\n                    vm.login(username.value, password.value);\n                }\n            }, [\n                t.if(vm => vm.errorMessage, (t, vm) => t.p({className: \"error\"}, vm.i18n(vm.errorMessage))),\n                t.div({ className: \"form-row text\" }, [t.label({ for: \"username\" }, vm.i18n`Username`), username]),\n                t.div({ className: \"form-row text\" }, [t.label({ for: \"password\" }, vm.i18n`Password`), password]),\n                t.div({ className: \"button-row\" }, [\n                    t.button({\n                        className: \"button-action primary\",\n                        type: \"submit\",\n                        disabled\n                    }, vm.i18n`Log In`),\n                ]),\n            ])\n        ]);\n    }\n}\n\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../general/TemplateView\";\nimport {KeyBackupSettingsView} from \"../session/settings/KeyBackupSettingsView.js\";\n\nexport class AccountSetupView extends TemplateView {\n    render(t, vm) {\n        return t.div({className: \"Settings\" /* hack for now to get the layout right*/}, [\n            t.h3(vm.i18n`Restore your encrypted history?`),\n            t.ifView(vm => vm.decryptDehydratedDeviceViewModel, vm => new KeyBackupSettingsView(vm.decryptDehydratedDeviceViewModel)),\n            t.map(vm => vm.deviceDecrypted, (decrypted, t) => {\n                if (decrypted) {\n                    return t.p(vm.i18n`That worked out, you're good to go!`);\n                } else {\n                    return t.p(vm.i18n`This will claim the dehydrated device ${vm.dehydratedDeviceId}, and will set up a new one.`);\n                }\n            }),\n            t.div({ className: \"button-row\" }, [\n                t.button({\n                    className: \"button-action primary\",\n                    onClick: () => { vm.finish(); },\n                    type: \"button\",\n                }, vm => vm.deviceDecrypted ? vm.i18n`Continue` : vm.i18n`Continue without restoring`),\n            ]),\n        ]);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../general/TemplateView\";\nimport {spinner} from \"../common.js\";\nimport {AccountSetupView} from \"./AccountSetupView.js\";\n\n/** a view used both in the login view and the loading screen\nto show the current state of loading the session.\nJust a spinner and a label, meant to be used as a paragraph */\nexport class SessionLoadStatusView extends TemplateView {\n    render(t) {\n        const exportLogsButtonIfFailed = t.if(vm => vm.hasError, (t, vm) => {\n            return t.button({\n                onClick: () => vm.exportLogs()\n            }, vm.i18n`Export logs`);\n        });\n        const logoutButtonIfFailed = t.if(vm => vm.hasError, (t, vm) => {\n            return t.button({\n                onClick: () => vm.logout()\n            }, vm.i18n`Log out`);\n        });\n        return t.div({className: \"SessionLoadStatusView\"}, [\n            t.p({className: \"status\"}, [\n                spinner(t, {hidden: vm => !vm.loading}),\n                t.p(vm => vm.loadLabel),\n                exportLogsButtonIfFailed,\n                logoutButtonIfFailed\n            ]),\n            t.ifView(vm => vm.accountSetupViewModel, vm => new AccountSetupView(vm.accountSetupViewModel)),\n        ]);\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../general/TemplateView\";\nimport {SessionLoadStatusView} from \"./SessionLoadStatusView.js\";\n\nexport class CompleteSSOView extends TemplateView {\n    render(t) {\n        return t.div({ className: \"CompleteSSOView\" },\n            [\n                t.p({ className: \"CompleteSSOView_title\" }, \"Finishing up your SSO Login\"),\n                t.if(vm => vm.errorMessage, (t, vm) => t.p({className: \"error\"}, vm.i18n(vm.errorMessage))),\n                t.mapView(vm => vm.loadViewModel, loadViewModel => loadViewModel ? new SessionLoadStatusView(loadViewModel) : null),\n            ]\n        );\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../general/TemplateView\";\nimport {hydrogenGithubLink} from \"./common.js\";\nimport {PasswordLoginView} from \"./PasswordLoginView.js\";\nimport {CompleteSSOView} from \"./CompleteSSOView.js\";\nimport {SessionLoadStatusView} from \"./SessionLoadStatusView.js\";\nimport {spinner} from \"../common.js\";\n\nexport class LoginView extends TemplateView {\n    render(t, vm) {\n        const disabled = vm => vm.isBusy;\n\n        return t.div({className: \"PreSessionScreen\"}, [\n            t.button({\n                className: \"button-utility LoginView_back\",\n                onClick: () => vm.goBack(),\n                disabled\n            }),\n            t.div({className: \"logo\"}),\n            t.h1([vm.i18n`Sign In`]),\n            t.mapView(vm => vm.completeSSOLoginViewModel, vm => vm ? new CompleteSSOView(vm) : null),\n            t.if(vm => vm.showHomeserver, (t, vm) => t.div({ className: \"LoginView_sso form-row text\" },\n                [\n                    t.label({for: \"homeserver\"}, vm.i18n`Homeserver`),\n                    t.input({\n                        id: \"homeserver\",\n                        type: \"text\",\n                        placeholder: vm.i18n`Your matrix homeserver`,\n                        value: vm.homeserver,\n                        disabled,\n                        onInput: event => vm.setHomeserver(event.target.value),\n                        onChange: () => vm.queryHomeserver(),\n                    }),\n                    t.p({className: {\n                        LoginView_forwardInfo: true,\n                        hidden: vm => !vm.resolvedHomeserver\n                    }}, vm => vm.i18n`You will connect to ${vm.resolvedHomeserver}.`),\n                    t.if(vm => vm.errorMessage, (t, vm) => t.p({className: \"error\"}, vm.i18n(vm.errorMessage))),\n                ]\n            )),\n            t.if(vm => vm.isFetchingLoginOptions, t => t.div({className: \"LoginView_query-spinner\"}, [spinner(t), t.p(\"Fetching available login options...\")])),\n            t.mapView(vm => vm.passwordLoginViewModel, vm => vm ? new PasswordLoginView(vm): null),\n            t.if(vm => vm.passwordLoginViewModel && vm.startSSOLoginViewModel, t => t.p({className: \"LoginView_separator\"}, vm.i18n`or`)),\n            t.mapView(vm => vm.startSSOLoginViewModel, vm => vm ? new StartSSOLoginView(vm) : null),\n            t.mapView(vm => vm.loadViewModel, loadViewModel => loadViewModel ? new SessionLoadStatusView(loadViewModel) : null),\n            // use t.mapView rather than t.if to create a new view when the view model changes too\n            t.p(hydrogenGithubLink(t))\n        ]);\n    }\n}\n\nclass StartSSOLoginView extends TemplateView {\n    render(t, vm) {\n        return t.div({ className: \"StartSSOLoginView\" },\n            t.button({\n                className: \"StartSSOLoginView_button button-action secondary\",\n                type: \"button\",\n                onClick: () => vm.startSSOLogin(),\n                disabled: vm => vm.isBusy\n            }, vm.i18n`Log in with SSO`)\n        );\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView, InlineTemplateView} from \"./general/TemplateView\";\nimport {spinner} from \"./common.js\";\n\nexport class LogoutView extends TemplateView {\n    render(t, vm) {\n        const confirmView = new InlineTemplateView(vm, t => {\n            return t.div([\n                t.p(\"Are you sure you want to log out?\"),\n                t.div({ className: \"button-row\" }, [\n                    t.a({\n                        className: \"button-action\",\n                        type: \"submit\",\n                        href: vm.cancelUrl,\n                    }, [\"Cancel\"]),\n                    t.button({\n                        className: \"button-action primary destructive\",\n                        type: \"submit\",\n                        onClick: () => vm.logout(),\n                    }, vm.i18n`Log out`)\n                ]),\n            ]);\n        });\n        const progressView = new InlineTemplateView(vm, t => {\n            return t.p({className: \"status\", hidden: vm => !vm.showStatus}, [\n                spinner(t, {hidden: vm => !vm.busy}), t.span(vm => vm.status)\n            ]);\n        });\n\n        return t.div({className: \"LogoutScreen\"}, [\n            t.div({className: \"content\"}, [\n                t.mapView(vm => vm.showConfirm, showConfirm => {\n                    return showConfirm ? confirmView : progressView;\n                })\n            ]),\n        ]);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {TemplateView} from \"../general/TemplateView\";\nimport {SessionLoadStatusView} from \"./SessionLoadStatusView.js\";\n\nexport class SessionLoadView extends TemplateView {\n    render(t, vm) {\n        return t.div({className: \"PreSessionScreen\"}, [\n            t.div({className: \"logo\"}),\n            t.div({className: \"SessionLoadView\"}, [\n                t.view(new SessionLoadStatusView(vm))\n            ]),\n            t.div({className: {\"button-row\": true, hidden: vm => vm.loading}},\n                t.a({className: \"button-action primary\", href: vm.backUrl}, vm.i18n`Go back`))\n        ]);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {ListView} from \"../general/ListView\";\nimport {TemplateView} from \"../general/TemplateView\";\nimport {hydrogenGithubLink} from \"./common.js\";\nimport {SessionLoadStatusView} from \"./SessionLoadStatusView.js\";\n\nclass SessionPickerItemView extends TemplateView {\n    _onDeleteClick() {\n        if (confirm(\"Are you sure?\")) {\n            this.value.delete();\n        }\n    }\n\n    _onClearClick() {\n        if (confirm(\"Are you sure?\")) {\n            this.value.clear();\n        }\n    }\n\n    render(t, vm) {\n        return t.li([\n            t.a({className: \"session-info\", href: vm.openUrl}, [\n                t.div({className: `avatar usercolor${vm.avatarColorNumber}`}, vm => vm.avatarInitials),\n                t.div({className: \"user-id\"}, vm => vm.label),\n            ])\n        ]);\n    }\n}\n\nexport class SessionPickerView extends TemplateView {\n    render(t, vm) {\n        const sessionList = new ListView({\n            list: vm.sessions,\n            parentProvidesUpdates: false,\n        }, sessionInfo => {\n            return new SessionPickerItemView(sessionInfo);\n        });\n\n        return t.div({className: \"PreSessionScreen\"}, [\n            t.div({className: \"logo\"}),\n            t.div({className: \"SessionPickerView\"}, [\n                t.h1([\"Continue as …\"]),\n                t.view(sessionList),\n                t.div({className: \"button-row\"}, [\n                    t.a({\n                        className: \"button-action primary\",\n                        href: vm.cancelUrl\n                    }, vm.i18n`Sign In`)\n                ]),\n                t.ifView(vm => vm.loadViewModel, () => new SessionLoadStatusView(vm.loadViewModel)),\n                t.p(hydrogenGithubLink(t))\n            ])\n        ]);\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {SessionView} from \"./session/SessionView.js\";\nimport {LoginView} from \"./login/LoginView\";\nimport {LogoutView} from \"./LogoutView.js\";\nimport {SessionLoadView} from \"./login/SessionLoadView.js\";\nimport {SessionPickerView} from \"./login/SessionPickerView.js\";\nimport {TemplateView} from \"./general/TemplateView\";\nimport {StaticView} from \"./general/StaticView.js\";\n\nexport class RootView extends TemplateView {\n    render(t, vm) {\n        return t.mapView(vm => vm.activeSection, activeSection => {\n            switch (activeSection) {\n                case \"error\":\n                    return new StaticView(t => {\n                        return t.div({className: \"StatusView\"}, [\n                            t.h1(\"Something went wrong\"),\n                            t.p(vm.errorText),\n                        ])\n                    });\n                case \"session\":\n                    return new SessionView(vm.sessionViewModel);\n                case \"login\":\n                    return new LoginView(vm.loginViewModel);\n                case \"logout\":\n                    return new LogoutView(vm.logoutViewModel);\n                case \"picker\":\n                    return new SessionPickerView(vm.sessionPickerViewModel);\n                case \"redirecting\":\n                    return new StaticView(t => t.p(\"Redirecting...\"));\n                case \"loading\":\n                    return new SessionLoadView(vm.sessionLoadViewModel);\n                default:\n                    throw new Error(`Unknown section: ${vm.activeSection}`);\n            }\n        });\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {AbortError} from \"../../../utils/error\";\n\nclass Timeout {\n    constructor(ms) {\n        this._reject = null;\n        this._handle = null;\n        this._promise = new Promise((resolve, reject) => {\n            this._reject = reject;\n            this._handle = setTimeout(() => {\n                this._reject = null;\n                resolve();\n            }, ms);\n        });\n    }\n\n    elapsed() {\n        return this._promise;\n    }\n\n    abort() {\n        if (this._reject) {\n            this._reject(new AbortError());\n            clearTimeout(this._handle);\n            this._handle = null;\n            this._reject = null;\n        }\n    }\n\n    dispose() {\n        this.abort();\n    }\n}\n\nclass Interval {\n    constructor(ms, callback) {\n        this._handle = setInterval(callback, ms);\n    }\n\n    dispose() {\n        if (this._handle) {\n            clearInterval(this._handle);\n            this._handle = null;\n        }\n    }\n}\n\nclass TimeMeasure {\n    constructor() {\n        this._start = window.performance.now();\n    }\n\n    measure() {\n        return window.performance.now() - this._start;\n    }\n}\n\nexport class Clock {\n    createMeasure() {\n        return new TimeMeasure();\n    }\n\n    createTimeout(ms) {\n        return new Timeout(ms);\n    }\n\n    createInterval(callback, ms) {\n        return new Interval(ms, callback);\n    }\n\n    now() {\n        return Date.now();\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// 3 (imaginary) interfaces are implemented here:\n// - OfflineAvailability (done by registering the sw)\n// - UpdateService (see checkForUpdate method, and should also emit events rather than showing confirm dialog here)\n// - ConcurrentAccessBlocker (see preventConcurrentSessionAccess method)\nexport class ServiceWorkerHandler {\n    constructor() {\n        this._waitingForReply = new Map();\n        this._messageIdCounter = 0;\n        this._navigation = null;\n        this._registration = null;\n        this._registrationPromise = null;\n        this._currentController = null;\n        this.haltRequests = false;\n    }\n\n    setNavigation(navigation) {\n        this._navigation = navigation;\n    }\n\n    registerAndStart(path) {\n        this._registrationPromise = (async () => {\n            navigator.serviceWorker.addEventListener(\"message\", this);\n            navigator.serviceWorker.addEventListener(\"controllerchange\", this);\n            this._registration = await navigator.serviceWorker.register(path);\n            await navigator.serviceWorker.ready;\n            this._currentController = navigator.serviceWorker.controller;\n            this._registration.addEventListener(\"updatefound\", this);\n            this._registrationPromise = null;\n            // do we have a new service worker waiting to activate?\n            if (this._registration.waiting && this._registration.active) {\n                this._proposeUpdate();\n            }\n            console.log(\"Service Worker registered\");\n        })();\n    }\n\n    _onMessage(event) {\n        const {data} = event;\n        const replyTo = data.replyTo;\n        if (replyTo) {\n            const resolve = this._waitingForReply.get(replyTo);\n            if (resolve) {\n                this._waitingForReply.delete(replyTo);\n                resolve(data.payload);\n            }\n        }\n        if (data.type === \"hasSessionOpen\") {\n            const hasOpen = this._navigation.observe(\"session\").get() === data.payload.sessionId;\n            event.source.postMessage({replyTo: data.id, payload: hasOpen});\n        } else if (data.type === \"hasRoomOpen\") {\n            const hasSessionOpen = this._navigation.observe(\"session\").get() === data.payload.sessionId;\n            const hasRoomOpen = this._navigation.observe(\"room\").get() === data.payload.roomId;\n            event.source.postMessage({replyTo: data.id, payload: hasSessionOpen && hasRoomOpen});\n        } else if (data.type === \"closeSession\") {\n            const {sessionId} = data.payload;\n            this._closeSessionIfNeeded(sessionId).finally(() => {\n                event.source.postMessage({replyTo: data.id});\n            });\n        } else if (data.type === \"haltRequests\") {\n            // this flag is read in fetch.js\n            this.haltRequests = true;\n            event.source.postMessage({replyTo: data.id});\n        } else if (data.type === \"openRoom\") {\n            this._navigation.push(\"room\", data.payload.roomId);\n        }\n    }\n\n    _closeSessionIfNeeded(sessionId) {\n        const currentSession = this._navigation?.path.get(\"session\");\n        if (sessionId && currentSession?.value === sessionId) {\n            return new Promise(resolve => {\n                const unsubscribe = this._navigation.pathObservable.subscribe(path => {\n                    const session = path.get(\"session\");\n                    if (!session || session.value !== sessionId) {\n                        unsubscribe();\n                        resolve();\n                    }\n                });\n                this._navigation.push(\"session\");\n            });\n        } else {\n            return Promise.resolve();\n        }\n    }\n\n    async _proposeUpdate() {\n        if (document.hidden) {\n            return;\n        }\n        const version = await this._sendAndWaitForReply(\"version\", null, this._registration.waiting);\n        if (confirm(`Version ${version.version} (${version.buildHash}) is available. Reload to apply?`)) {\n            // prevent any fetch requests from going to the service worker\n            // from any client, so that it is not kept active\n            // when calling skipWaiting on the new one\n            await this._sendAndWaitForReply(\"haltRequests\");\n            // only once all requests are blocked, ask the new\n            // service worker to skipWaiting\n            this._send(\"skipWaiting\", null, this._registration.waiting);\n        }\n    }\n\n    handleEvent(event) {\n        switch (event.type) {\n            case \"message\":\n                this._onMessage(event);\n                break;\n            case \"updatefound\":\n                this._registration.installing.addEventListener(\"statechange\", this);\n                break;\n            case \"statechange\": {\n                if (event.target.state === \"installed\") {\n                    this._proposeUpdate();\n                    event.target.removeEventListener(\"statechange\", this);\n                }\n                break;\n            }\n            case \"controllerchange\":\n                if (!this._currentController) {\n                    // Clients.claim() in the SW can trigger a controllerchange event\n                    // if we had no SW before. This is fine,\n                    // and now our requests will be served from the SW.\n                    this._currentController = navigator.serviceWorker.controller;\n                } else {\n                    // active service worker changed,\n                    // refresh, so we can get all assets \n                    // (and not only some if we would not refresh)\n                    // up to date from it\n                    document.location.reload();\n                }\n                break;\n        }\n    }\n\n    async _send(type, payload, worker = undefined) {\n        if (this._registrationPromise) {\n            await this._registrationPromise;\n        }\n        if (!worker) {\n            worker = this._registration.active;\n        }\n        worker.postMessage({type, payload});\n    }\n\n    async _sendAndWaitForReply(type, payload, worker = undefined) {\n        if (this._registrationPromise) {\n            await this._registrationPromise;\n        }\n        if (!worker) {\n            worker = this._registration.active;\n        }\n        this._messageIdCounter += 1;\n        const id = this._messageIdCounter;\n        const promise = new Promise(resolve => {\n            this._waitingForReply.set(id, resolve);\n        });\n        worker.postMessage({type, id, payload});\n        return await promise;\n    }\n\n    async checkForUpdate() {\n        if (this._registrationPromise) {\n            await this._registrationPromise;\n        }\n        this._registration.update();\n    }\n\n    get version() {\n        return DEFINE_VERSION;\n    }\n\n    get buildHash() {\n        return DEFINE_GLOBAL_HASH;\n    }\n\n    async preventConcurrentSessionAccess(sessionId) {\n        return this._sendAndWaitForReply(\"closeSession\", {sessionId});\n    }\n\n    async getRegistration() {\n        if (this._registrationPromise) {\n            await this._registrationPromise;\n        }\n        return this._registration;\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class NotificationService {\n    constructor(serviceWorkerHandler, pushConfig) {\n        this._serviceWorkerHandler = serviceWorkerHandler;\n        this._pushConfig = pushConfig;\n    }\n\n    async enablePush(pusherFactory, defaultPayload) {\n        const registration = await this._serviceWorkerHandler?.getRegistration();\n        if (registration?.pushManager) {\n            const subscription = await registration.pushManager.subscribe({\n                userVisibleOnly: true,\n                applicationServerKey: this._pushConfig.applicationServerKey,\n            });\n            const subscriptionData = subscription.toJSON();\n            const pushkey = subscriptionData.keys.p256dh;\n            const data = {\n                endpoint: subscriptionData.endpoint,\n                auth: subscriptionData.keys.auth,\n                // don't deliver unread count push messages\n                // as we don't want to show a notification in this case\n                events_only: true,\n                default_payload: defaultPayload\n            };\n            return pusherFactory.httpPusher(\n                this._pushConfig.gatewayUrl,\n                this._pushConfig.appId,\n                pushkey,\n                data\n            );\n        }\n    }\n\n    async disablePush() {\n        const registration = await this._serviceWorkerHandler?.getRegistration();\n        if (registration?.pushManager) {\n            const subscription = await registration.pushManager.getSubscription();\n            if (subscription) {\n                await subscription.unsubscribe();\n            }\n        }\n    }\n\n    async isPushEnabled() {\n        const registration = await this._serviceWorkerHandler?.getRegistration();\n        if (registration?.pushManager) {\n            const subscription = await registration.pushManager.getSubscription();\n            return !!subscription;\n        }\n        return false;\n    }\n\n    async supportsPush() {\n        if (!this._pushConfig) {\n            return false;\n        }\n        const registration = await this._serviceWorkerHandler?.getRegistration();\n        return registration && \"pushManager\" in registration;\n    }\n\n    async enableNotifications() {\n        if (\"Notification\" in window) {\n            return (await Notification.requestPermission()) === \"granted\";\n        }\n        return false;\n    }\n\n    async supportsNotifications() {\n        return \"Notification\" in window;\n    }\n\n    async areNotificationsEnabled() {\n        if (\"Notification\" in window) {\n            return Notification.permission === \"granted\";\n        } else {\n            return false;\n        }\n    }\n\n    async showNotification(title, body = undefined) {\n        if (\"Notification\" in window) {\n            new Notification(title, {body});\n            return;\n        }\n        // Chrome on Android does not support the Notification constructor\n        const registration = await this._serviceWorkerHandler?.getRegistration();\n        registration?.showNotification(title, {body});\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableValue} from \"../../../observable/ObservableValue\";\n\nexport class History extends BaseObservableValue {\n    handleEvent(event) {\n        if (event.type === \"hashchange\") {\n            this.emit(this.get());\n            this._storeHash(this.get());\n        }\n    }\n\n    get() {\n        /*\n        All URLS in Hydrogen will use <root>/#/segment/value/...\n        But for SSO, we need to handle <root>/?loginToken=<TOKEN>\n        Handle that as a special case for now.\n        */\n        if (document.location.search.includes(\"loginToken\")) {\n            return document.location.search;\n        }\n        return document.location.hash;\n    }\n\n    /** does not emit */\n    replaceUrlSilently(url) {\n        window.history.replaceState(null, null, url);\n        this._storeHash(url);\n    }\n\n    /** does not emit */\n    pushUrlSilently(url) {\n        window.history.pushState(null, null, url);\n        this._storeHash(url);\n    }\n\n    pushUrl(url) {\n        document.location.hash = url;\n    }\n\n    urlAsPath(url) {\n        if (url.startsWith(\"#\")) {\n            return url.substr(1);\n        } else {\n            return url;\n        }\n    }\n\n    pathAsUrl(path) {\n        return `#${path}`;\n    }\n\n    onSubscribeFirst() {\n        window.addEventListener('hashchange', this);\n    }\n\n    onUnsubscribeLast() {\n        window.removeEventListener('hashchange', this);\n    }\n\n    _storeHash(hash) {\n        window.localStorage?.setItem(\"hydrogen_last_url_hash\", hash);\n    }\n\n    getLastUrl() {\n        return window.localStorage?.getItem(\"hydrogen_last_url_hash\");\n    }\n}\n","/*\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BaseObservableValue} from \"../../../observable/ObservableValue\";\n\nexport class OnlineStatus extends BaseObservableValue {\n    constructor() {\n        super();\n        this._onOffline = this._onOffline.bind(this);\n        this._onOnline = this._onOnline.bind(this);\n    }\n\n    _onOffline() {\n        this.emit(false);\n    }\n\n    _onOnline() {\n        this.emit(true);\n    }\n\n    get() {\n        return navigator.onLine;\n    }\n\n    onSubscribeFirst() {\n        window.addEventListener('offline', this._onOffline);\n        window.addEventListener('online', this._onOnline);\n    }\n\n    onUnsubscribeLast() {\n        window.removeEventListener('offline', this._onOffline);\n        window.removeEventListener('online', this._onOnline);\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport base64 from \"base64-arraybuffer\";\n\n// turn IE11 result into promise\nfunction subtleCryptoResult(promiseOrOp, method) {\n    if (promiseOrOp instanceof Promise) {\n        return promiseOrOp;\n    } else {\n        return new Promise((resolve, reject) => {\n            promiseOrOp.oncomplete = e => resolve(e.target.result);\n            promiseOrOp.onerror = () => reject(new Error(\"Crypto error on \" + method));\n        });\n    }\n}\n\nclass HMACCrypto {\n    constructor(subtleCrypto) {\n        this._subtleCrypto = subtleCrypto;\n    }\n    /**\n     * [hmac description]\n     * @param  {BufferSource} key\n     * @param  {BufferSource} mac\n     * @param  {BufferSource} data\n     * @param  {HashName} hash\n     * @return {boolean}\n     */\n    async verify(key, mac, data, hash) {\n        const opts = {\n            name: 'HMAC',\n            hash: {name: hashName(hash)},\n        };\n        const hmacKey = await subtleCryptoResult(this._subtleCrypto.importKey(\n            'raw',\n            key,\n            opts,\n            false,\n            ['verify'],\n        ), \"importKey\");\n        const isVerified = await subtleCryptoResult(this._subtleCrypto.verify(\n            opts,\n            hmacKey,\n            mac,\n            data,\n        ), \"verify\");\n        return isVerified;\n    }\n\n    async compute(key, data, hash) {\n        const opts = {\n            name: 'HMAC',\n            hash: {name: hashName(hash)},\n        };\n        const hmacKey = await subtleCryptoResult(this._subtleCrypto.importKey(\n            'raw',\n            key,\n            opts,\n            false,\n            ['sign'],\n        ), \"importKey\");\n        const buffer = await subtleCryptoResult(this._subtleCrypto.sign(\n            opts,\n            hmacKey,\n            data,\n        ), \"sign\");\n        return new Uint8Array(buffer);\n    }\n}\n\nclass DeriveCrypto {\n    constructor(subtleCrypto, crypto, cryptoExtras) {\n        this._subtleCrypto = subtleCrypto;\n        this._crypto = crypto;\n        this._cryptoExtras = cryptoExtras;\n    }\n    /**\n     * [pbkdf2 description]\n     * @param  {BufferSource} password\n     * @param  {Number} iterations\n     * @param  {BufferSource} salt\n     * @param  {HashName} hash\n     * @param  {Number} length  the desired length of the generated key, in bits (not bytes!)\n     * @return {BufferSource}\n     */\n    async pbkdf2(password, iterations, salt, hash, length) {\n        if (!this._subtleCrypto.deriveBits) {\n            throw new Error(\"PBKDF2 is not supported\");\n        }\n        const key = await subtleCryptoResult(this._subtleCrypto.importKey(\n            'raw',\n            password,\n            {name: 'PBKDF2'},\n            false,\n            ['deriveBits'],\n        ), \"importKey\");\n        const keybits = await subtleCryptoResult(this._subtleCrypto.deriveBits(\n            {\n                name: 'PBKDF2',\n                salt,\n                iterations,\n                hash: hashName(hash),\n            },\n            key,\n            length,\n        ), \"deriveBits\");\n        return new Uint8Array(keybits);\n    }\n\n    /**\n     * [hkdf description]\n     * @param  {BufferSource} key    [description]\n     * @param  {BufferSource} salt   [description]\n     * @param  {BufferSource} info   [description]\n     * @param  {HashName} hash the hash to use\n     * @param  {Number} length desired length of the generated key in bits (not bytes!)\n     * @return {[type]}        [description]\n     */\n    async hkdf(key, salt, info, hash, length) {\n        if (!this._subtleCrypto.deriveBits) {\n            return this._cryptoExtras.hkdf(this._crypto, key, salt, info, hash, length);\n        }\n        const hkdfkey = await subtleCryptoResult(this._subtleCrypto.importKey(\n            'raw',\n            key,\n            {name: \"HKDF\"},\n            false,\n            [\"deriveBits\"],\n        ), \"importKey\");\n        const keybits = await subtleCryptoResult(this._subtleCrypto.deriveBits({\n                name: \"HKDF\",\n                salt,\n                info,\n                hash: hashName(hash),\n            },\n            hkdfkey,\n            length,\n        ), \"deriveBits\");\n        return new Uint8Array(keybits);\n    }\n}\n\nclass AESCrypto {\n    constructor(subtleCrypto, crypto) {\n        this._subtleCrypto = subtleCrypto;\n        this._crypto = crypto;\n    }\n    /**\n     * [decrypt description]\n     * @param  {BufferSource} key        [description]\n     * @param  {Object} jwkKey        [description]\n     * @param  {BufferSource} iv         [description]\n     * @param  {BufferSource} data [description]\n     * @param  {Number}       counterLength the size of the counter, in bits\n     * @return {BufferSource}            [description]\n     */\n    async decryptCTR({key, jwkKey, iv, data, counterLength = 64}) {\n        const opts = {\n            name: \"AES-CTR\",\n            counter: iv,\n            length: counterLength,\n        };\n        let aesKey;\n        try {\n            const selectedKey = key || jwkKey;\n            const format = jwkKey ? \"jwk\" : \"raw\";\n            aesKey = await subtleCryptoResult(this._subtleCrypto.importKey(\n                format,\n                selectedKey,\n                opts,\n                false,\n                ['decrypt'],\n            ), \"importKey\");\n        } catch (err) {\n            throw new Error(`Could not import key for AES-CTR decryption: ${err.message}`);\n        }\n        try {\n            const plaintext = await subtleCryptoResult(this._subtleCrypto.decrypt(\n                // see https://developer.mozilla.org/en-US/docs/Web/API/AesCtrParams\n                opts,\n                aesKey,\n                data,\n            ), \"decrypt\");\n            return new Uint8Array(plaintext);\n        } catch (err) {\n            throw new Error(`Could not decrypt with AES-CTR: ${err.message}`);\n        }\n    }\n\n    async encryptCTR({key, jwkKey, iv, data}) {\n        const opts = {\n            name: \"AES-CTR\",\n            counter: iv,\n            length: 64,\n        };\n        let aesKey;\n        const selectedKey = key || jwkKey;\n        const format = jwkKey ? \"jwk\" : \"raw\";\n        try {\n            aesKey = await subtleCryptoResult(this._subtleCrypto.importKey(\n                format,\n                selectedKey,\n                opts,\n                false,\n                ['encrypt'],\n            ), \"importKey\");\n        } catch (err) {\n            throw new Error(`Could not import key for AES-CTR encryption: ${err.message}`);\n        }\n        try {\n            const ciphertext = await subtleCryptoResult(this._subtleCrypto.encrypt(\n                // see https://developer.mozilla.org/en-US/docs/Web/API/AesCtrParams\n                opts,\n                aesKey,\n                data,\n            ), \"encrypt\");\n            return new Uint8Array(ciphertext);\n        } catch (err) {\n            throw new Error(`Could not encrypt with AES-CTR: ${err.message}`);\n        }\n    }\n\n    /**\n     * Generate a CTR key\n     * @param  {String} format \"raw\" or \"jwk\"\n     * @param  {Number} length 128 or 256\n     * @return {Promise<Object>}        an object for jwk, or a BufferSource for raw\n     */\n    async generateKey(format, length = 256) {\n        const cryptoKey = await subtleCryptoResult(this._subtleCrypto.generateKey(\n            {\"name\": \"AES-CTR\", length}, true, [\"encrypt\", \"decrypt\"]));\n        return subtleCryptoResult(this._subtleCrypto.exportKey(format, cryptoKey));\n    }\n\n    async generateIV() {\n        return generateIV(this._crypto);\n    }\n}\n\nfunction generateIV(crypto) {\n    const randomBytes = crypto.getRandomValues(new Uint8Array(8));\n    const ivArray = new Uint8Array(16);\n    for (let i = 0; i < randomBytes.length; i += 1) {\n        ivArray[i] = randomBytes[i];\n    }\n    return ivArray;\n}\n\nfunction jwkKeyToRaw(jwkKey) {\n    if (jwkKey.alg !== \"A256CTR\") {\n        throw new Error(`Unknown algorithm: ${jwkKey.alg}`);\n    }\n    if (!jwkKey.key_ops.includes(\"decrypt\")) {\n        throw new Error(`decrypt missing from key_ops`);\n    }\n    if (jwkKey.kty !== \"oct\") {\n        throw new Error(`Invalid key type, \"oct\" expected: ${jwkKey.kty}`);\n    }\n    // convert base64-url to normal base64\n    const base64UrlKey = jwkKey.k;\n    const base64Key = base64UrlKey.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    return base64.decode(base64Key);\n}\n\nfunction encodeUnpaddedBase64(buffer) {\n    const str = base64.encode(buffer);\n    const paddingIdx = str.indexOf(\"=\");\n    if (paddingIdx !== -1) {\n        return str.substr(0, paddingIdx);\n    } else {\n        return str;\n    }\n}\n\nfunction encodeUrlBase64(buffer) {\n    const unpadded = encodeUnpaddedBase64(buffer);\n    return unpadded.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\nfunction rawKeyToJwk(key) {\n    return {\n        \"alg\": \"A256CTR\",\n        \"ext\": true,\n        \"k\": encodeUrlBase64(key),\n        \"key_ops\": [\n            \"encrypt\",\n            \"decrypt\"\n        ],\n        \"kty\": \"oct\"\n    };\n}\n\n\nclass AESLegacyCrypto {\n    constructor(aesjs, crypto) {\n        this._aesjs = aesjs;\n        this._crypto = crypto;\n    }\n    /**\n     * [decrypt description]\n     * @param  {BufferSource} key        [description]\n     * @param  {BufferSource} iv         [description]\n     * @param  {BufferSource} ciphertext [description]\n     * @param  {Number}       counterLength the size of the counter, in bits\n     * @return {BufferSource}            [description]\n     */\n    async decryptCTR({key, jwkKey, iv, data, counterLength = 64}) {\n        if (counterLength !== 64) {\n            throw new Error(`Unsupported counter length: ${counterLength}`);\n        }\n        if (jwkKey) {\n            key = jwkKeyToRaw(jwkKey);\n        }\n        const aesjs = this._aesjs;\n        var aesCtr = new aesjs.ModeOfOperation.ctr(new Uint8Array(key), new aesjs.Counter(new Uint8Array(iv)));\n        return aesCtr.decrypt(new Uint8Array(data));\n    }\n\n    async encryptCTR({key, jwkKey, iv, data}) {\n        if (jwkKey) {\n            key = jwkKeyToRaw(jwkKey);\n        }\n        const aesjs = this._aesjs;\n        var aesCtr = new aesjs.ModeOfOperation.ctr(new Uint8Array(key), new aesjs.Counter(new Uint8Array(iv)));\n        return aesCtr.encrypt(new Uint8Array(data));\n    }\n\n    /**\n     * Generate a CTR key\n     * @param  {String} format \"raw\" or \"jwk\"\n     * @param  {Number} length 128 or 256\n     * @return {Promise<Object>}        an object for jwk, or a BufferSource for raw\n     */\n    async generateKey(format, length = 256) {\n        let key = crypto.getRandomValues(new Uint8Array(length / 8));\n        if (format === \"jwk\") {\n            key = rawKeyToJwk(key);\n        }\n        return key;\n    }\n\n    async generateIV() {\n        return generateIV(this._crypto);\n    }\n}\n\nfunction hashName(name) {\n    if (name !== \"SHA-256\" && name !== \"SHA-512\") {\n        throw new Error(`Invalid hash name: ${name}`);\n    }\n    return name;\n}\n\nexport class Crypto {\n    constructor(cryptoExtras) {\n        const crypto = window.crypto || window.msCrypto;\n        const subtleCrypto = crypto.subtle || crypto.webkitSubtle;\n        this._subtleCrypto = subtleCrypto;\n        // not exactly guaranteeing AES-CTR support\n        // but in practice IE11 doesn't have this\n        if (!subtleCrypto.deriveBits && cryptoExtras?.aesjs) {\n            this.aes = new AESLegacyCrypto(cryptoExtras.aesjs, crypto);\n        } else {\n            this.aes = new AESCrypto(subtleCrypto, crypto);\n        }\n        this.hmac = new HMACCrypto(subtleCrypto);\n        this.derive = new DeriveCrypto(subtleCrypto, this, cryptoExtras);\n    }\n\n    /**\n     * [digest description]\n     * @param  {HashName} hash\n     * @param  {BufferSource} data\n     * @return {BufferSource}\n     */\n    async digest(hash, data) {\n        return await subtleCryptoResult(this._subtleCrypto.digest(hashName(hash), data));\n    }\n\n    digestSize(hash) {\n        switch (hashName(hash)) {\n            case \"SHA-512\": return 64;\n            case \"SHA-256\": return 32;\n            default: throw new Error(`Not implemented for ${hashName(hash)}`);\n        }\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport async function estimateStorageUsage() {\n    if (navigator?.storage?.estimate) {\n        const {quota, usage} = await navigator.storage.estimate();\n        return {quota, usage};\n    } else {\n        return {quota: null, usage: null};\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {AbortError} from \"../../../utils/error\";\n\nclass WorkerState {\n    constructor(worker) {\n        this.worker = worker;\n        this.busy = false;\n    }\n\n    attach(pool) {\n        this.worker.addEventListener(\"message\", pool);\n        this.worker.addEventListener(\"error\", pool);\n    }\n\n    detach(pool) {\n        this.worker.removeEventListener(\"message\", pool);\n        this.worker.removeEventListener(\"error\", pool);\n    }\n}\n\nclass Request {\n    constructor(message, pool) {\n        this._promise = new Promise((_resolve, _reject) => {\n            this._resolve = _resolve;\n            this._reject = _reject;\n        });\n        this._message = message;\n        this._pool = pool;\n        this._worker = null;\n    }\n\n    abort() {\n        if (this._isNotDisposed) {\n            this._pool._abortRequest(this);\n            this._dispose();\n        }\n    }\n\n    response() {\n        return this._promise;\n    }\n\n    _dispose() {\n        this._reject = null;\n        this._resolve = null;\n    }\n\n    get _isNotDisposed() {\n        return this._resolve && this._reject;\n    }\n}\n\nexport class WorkerPool {\n    // TODO: extract DOM specific bits and write unit tests\n    constructor(path, amount) {\n        this._workers = [];\n        for (let i = 0; i < amount ; ++i) {\n            const worker = new WorkerState(new Worker(path));\n            worker.attach(this);\n            this._workers[i] = worker;\n        }\n        this._requests = new Map();\n        this._counter = 0;\n        this._pendingFlag = false;\n        this._init = null;\n\n    }\n\n    init() {\n        const promise = new Promise((resolve, reject) => {\n            this._init = {resolve, reject};\n        });\n        this.sendAll({type: \"ping\"})\n            .then(this._init.resolve, this._init.reject)\n            .finally(() => {\n                this._init = null;\n            });\n        return promise;\n    }\n\n    handleEvent(e) {\n        if (e.type === \"message\") {\n            const message = e.data;\n            const request = this._requests.get(message.replyToId);\n            if (request) {\n                request._worker.busy = false;\n                if (request._isNotDisposed) {\n                    if (message.type === \"success\") {\n                        request._resolve(message.payload);\n                    } else if (message.type === \"error\") {\n                        const err = new Error(message.message);\n                        err.stack = message.stack;\n                        request._reject(err);\n                    }\n                    request._dispose();\n                }\n                this._requests.delete(message.replyToId);\n            }\n            this._sendPending();\n        } else if (e.type === \"error\") {\n            if (this._init) {\n                this._init.reject(new Error(\"worker error during init\"));\n            }\n            console.error(\"worker error\", e);\n        }\n    }\n\n    _getPendingRequest() {\n        for (const r of this._requests.values()) {\n            if (!r._worker) {\n                return r;\n            }\n        }\n    }\n\n    _getFreeWorker() {\n        for (const w of this._workers) {\n            if (!w.busy) {\n                return w;\n            }\n        }\n    }\n\n    _sendPending() {\n        this._pendingFlag = false;\n        let success;\n        do {\n            success = false;\n            const request = this._getPendingRequest();\n            if (request) {\n                const worker = this._getFreeWorker();\n                if (worker) {\n                    this._sendWith(request, worker);\n                    success = true;\n                }\n            }\n        } while (success);\n    }\n\n    _sendWith(request, worker) {\n        request._worker = worker;\n        worker.busy = true;\n        worker.worker.postMessage(request._message);\n    }\n\n    _enqueueRequest(message) {\n        this._counter += 1;\n        message.id = this._counter;\n        const request = new Request(message, this);\n        this._requests.set(message.id, request);\n        return request;\n    }\n\n    send(message) {\n        const request = this._enqueueRequest(message);\n        const worker = this._getFreeWorker();\n        if (worker) {\n            this._sendWith(request, worker);\n        }\n        return request;\n    }\n\n    // assumes all workers are free atm\n    sendAll(message) {\n        const promises = this._workers.map(worker => {\n            const request = this._enqueueRequest(Object.assign({}, message));\n            this._sendWith(request, worker);\n            return request.response();\n        });\n        return Promise.all(promises);\n    }\n\n    dispose() {\n        for (const w of this._workers) {\n            w.detach(this);\n            w.worker.terminate();\n        }\n    }\n\n    _trySendPendingInNextTick() {\n        if (!this._pendingFlag) {\n            this._pendingFlag = true;\n            Promise.resolve().then(() => {\n                this._sendPending();\n            });\n        }\n    }\n\n    _abortRequest(request) {\n        request._reject(new AbortError());\n        if (request._worker) {\n            request._worker.busy = false;\n        }\n        this._requests.delete(request._message.id);\n        // allow more requests to be aborted before trying to send other pending\n        this._trySendPendingInNextTick();\n    }\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {BlobHandle} from \"./BlobHandle.js\";\nimport {domEventAsPromise} from \"./utils.js\";\n\nexport class ImageHandle {\n    static async fromBlob(blob) {\n        const img = await loadImgFromBlob(blob);\n        const {width, height} = img;\n        return new ImageHandle(blob, width, height, img);\n    }\n\n    constructor(blob, width, height, imgElement) {\n        this.blob = blob;\n        this.width = width;\n        this.height = height;\n        this._domElement = imgElement;\n    }\n\n    get maxDimension() {\n        return Math.max(this.width, this.height);\n    }\n\n    async _getDomElement() {\n        if (!this._domElement) {\n            this._domElement = await loadImgFromBlob(this.blob);\n        }\n        return this._domElement;\n    }\n\n    async scale(maxDimension) {\n        const aspectRatio = this.width / this.height;\n        const scaleFactor = Math.min(1, maxDimension / (aspectRatio >= 1 ? this.width : this.height));\n        const scaledWidth = Math.round(this.width * scaleFactor);\n        const scaledHeight = Math.round(this.height * scaleFactor);\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = scaledWidth;\n        canvas.height = scaledHeight;\n        const ctx = canvas.getContext(\"2d\");\n        const drawableElement = await this._getDomElement();\n        ctx.drawImage(drawableElement, 0, 0, scaledWidth, scaledHeight);\n        let mimeType = this.blob.mimeType === \"image/jpeg\" ? \"image/jpeg\" : \"image/png\";\n        let nativeBlob;\n        if (canvas.toBlob) {\n            nativeBlob = await new Promise(resolve => canvas.toBlob(resolve, mimeType));\n        } else if (canvas.msToBlob) {\n            // TODO: provide a mimetype override in blob handle for this case\n            mimeType = \"image/png\";\n            nativeBlob = canvas.msToBlob();\n        } else {\n            throw new Error(\"canvas can't be turned into blob\");\n        }\n        const blob = BlobHandle.fromBlob(nativeBlob);\n        return new ImageHandle(blob, scaledWidth, scaledHeight, null);\n    }\n\n    dispose() {\n        this.blob.dispose();\n    }\n}\n\nexport class VideoHandle extends ImageHandle {\n    get duration() {\n        if (typeof this._domElement.duration === \"number\") {\n            return Math.round(this._domElement.duration * 1000);\n        }\n        return undefined;\n    }\n\n    static async fromBlob(blob) {\n        const video = await loadVideoFromBlob(blob);\n        const {videoWidth, videoHeight} = video;\n        return new VideoHandle(blob, videoWidth, videoHeight, video);\n    }\n}\n\nexport function hasReadPixelPermission() {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = 1;\n    const ctx = canvas.getContext(\"2d\");\n    const rgb = [\n        Math.round(Math.random() * 255),\n        Math.round(Math.random() * 255),\n        Math.round(Math.random() * 255),\n    ]\n    ctx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;\n    ctx.fillRect(0, 0, 1, 1);\n    const data = ctx.getImageData(0, 0, 1, 1).data;\n    return data[0] === rgb[0] && data[1] === rgb[1] && data[2] === rgb[2];\n}\n\nasync function loadImgFromBlob(blob) {\n    const img = document.createElement(\"img\");\n    const loadPromise = domEventAsPromise(img, \"load\");\n    img.src = blob.url;\n    await loadPromise;\n    return img;\n}\n\nasync function loadVideoFromBlob(blob) {\n    const video = document.createElement(\"video\");\n    video.muted = true;\n    const loadPromise = domEventAsPromise(video, \"loadedmetadata\");\n    video.src = blob.url;\n    video.load();\n    await loadPromise;\n    // seek to the first 1/10s to make sure that drawing the video\n    // on a canvas won't give a blank image\n    const seekPromise = domEventAsPromise(video, \"seeked\");\n    // needed for safari to reliably fire the seeked event,\n    // somewhat hacky but using raf for example didn't do the trick\n    await new Promise(r => setTimeout(r, 200));\n    video.currentTime = 0.1;\n    await seekPromise;\n    return video;\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport async function downloadInIframe(container, iframeSrc, blobHandle, filename, isIOS) {\n    let iframe = container.querySelector(\"iframe.downloadSandbox\");\n    if (!iframe) {\n        iframe = document.createElement(\"iframe\");\n        iframe.setAttribute(\"sandbox\", \"allow-scripts allow-downloads allow-downloads-without-user-activation\");\n        iframe.setAttribute(\"src\", iframeSrc);\n        iframe.className = \"hidden downloadSandbox\";\n        container.appendChild(iframe);\n        let detach;\n        await new Promise((resolve, reject) => {\n            detach = () => {\n                iframe.removeEventListener(\"load\", resolve);\n                iframe.removeEventListener(\"error\", reject);    \n            }\n            iframe.addEventListener(\"load\", resolve);\n            iframe.addEventListener(\"error\", reject);\n        });\n        detach();\n    }\n    if (isIOS) {\n        // iOS can't read a blob in a sandboxed iframe,\n        // see https://github.com/vector-im/hydrogen-web/issues/244\n        const buffer = await blobHandle.readAsBuffer();\n        iframe.contentWindow.postMessage({\n            type: \"downloadBuffer\",\n            buffer,\n            mimeType: blobHandle.mimeType,\n            filename: filename\n        }, \"*\");\n    } else {\n        iframe.contentWindow.postMessage({\n            type: \"downloadBlob\",\n            blob: blobHandle.nativeBlob,\n            filename: filename\n        }, \"*\");\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport DOMPurify from \"dompurify\"\n\nclass HTMLParseResult {\n    constructor(bodyNode) {\n        this._bodyNode = bodyNode;\n    }\n\n    get rootNodes() {\n        return Array.from(this._bodyNode.childNodes);\n    }\n    \n    getChildNodes(node) {\n        return Array.from(node.childNodes);\n    }\n\n    getAttributeNames(node) {\n        return Array.from(node.getAttributeNames());\n    }\n\n    getAttributeValue(node, attr) {\n        return node.getAttribute(attr);\n    }\n\n    isTextNode(node) { \n        return node.nodeType === Node.TEXT_NODE;\n    }\n\n    getNodeText(node) {\n        return node.textContent;\n    }\n\n    isElementNode(node) {\n        return node.nodeType === Node.ELEMENT_NODE;\n    }\n\n    getNodeElementName(node) {\n        return node.tagName;\n    }\n}\n\nconst sanitizeConfig = {\n    ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|xxx|mxc):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))/i,\n    FORBID_TAGS: ['mx-reply'],\n    KEEP_CONTENT: false,\n}\n\nexport function parseHTML(html) {\n    // If DOMPurify uses DOMParser, can't we just get the built tree from it\n    // instead of re-parsing?\n    const sanitized = DOMPurify.sanitize(html, sanitizeConfig);\n    const bodyNode = new DOMParser().parseFromString(sanitized, \"text/html\").body;\n    return new HTMLParseResult(bodyNode);\n}\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {createFetchRequest} from \"./dom/request/fetch.js\";\nimport {xhrRequest} from \"./dom/request/xhr.js\";\nimport {StorageFactory} from \"../../matrix/storage/idb/StorageFactory\";\nimport {SessionInfoStorage} from \"../../matrix/sessioninfo/localstorage/SessionInfoStorage\";\nimport {SettingsStorage} from \"./dom/SettingsStorage.js\";\nimport {Encoding} from \"./utils/Encoding.js\";\nimport {OlmWorker} from \"../../matrix/e2ee/OlmWorker.js\";\nimport {IDBLogger} from \"../../logging/IDBLogger\";\nimport {ConsoleLogger} from \"../../logging/ConsoleLogger\";\nimport {RootView} from \"./ui/RootView.js\";\nimport {Clock} from \"./dom/Clock.js\";\nimport {ServiceWorkerHandler} from \"./dom/ServiceWorkerHandler.js\";\nimport {NotificationService} from \"./dom/NotificationService.js\";\nimport {History} from \"./dom/History.js\";\nimport {OnlineStatus} from \"./dom/OnlineStatus.js\";\nimport {Crypto} from \"./dom/Crypto.js\";\nimport {estimateStorageUsage} from \"./dom/StorageEstimate.js\";\nimport {WorkerPool} from \"./dom/WorkerPool.js\";\nimport {BlobHandle} from \"./dom/BlobHandle.js\";\nimport {hasReadPixelPermission, ImageHandle, VideoHandle} from \"./dom/ImageHandle.js\";\nimport {downloadInIframe} from \"./dom/download.js\";\nimport {Disposables} from \"../../utils/Disposables\";\nimport {parseHTML} from \"./parsehtml.js\";\nimport {handleAvatarError} from \"./ui/avatar.js\";\n\nfunction addScript(src) {\n    return new Promise(function (resolve, reject) {\n        var s = document.createElement(\"script\");\n        s.setAttribute(\"src\", src );\n        s.onload=resolve;\n        s.onerror=reject;\n        document.body.appendChild(s);\n    });\n}\n\nasync function loadOlm(olmPaths) {\n    // make crypto.getRandomValues available without\n    // a prefix on IE11, needed by olm to work\n    if (window.msCrypto && !window.crypto) {\n        window.crypto = window.msCrypto;\n    }\n    if (olmPaths) {\n        if (window.WebAssembly) {\n            await addScript(olmPaths.wasmBundle);\n            await window.Olm.init({locateFile: () => olmPaths.wasm});\n        } else {\n            await addScript(olmPaths.legacyBundle);\n            await window.Olm.init();\n        }\n        return window.Olm;\n    }\n    return null;\n}\n// turn asset path to absolute path if it isn't already\n// so it can be loaded independent of base\nfunction assetAbsPath(assetPath) {\n    if (!assetPath.startsWith(\"/\")) {\n        return new URL(assetPath, document.location.href).pathname;\n    }\n    return assetPath;\n}\n\nasync function loadOlmWorker(assetPaths) {\n    const workerPool = new WorkerPool(assetPaths.worker, 4);\n    await workerPool.init();\n    await workerPool.sendAll({\n        type: \"load_olm\",\n        path: assetAbsPath(assetPaths.olm.legacyBundle)\n    });\n    const olmWorker = new OlmWorker(workerPool);\n    return olmWorker;\n}\n\n// needed for mobile Safari which shifts the layout viewport up without resizing it\n// when the keyboard shows (see https://bugs.webkit.org/show_bug.cgi?id=141832)\nfunction adaptUIOnVisualViewportResize(container) {\n    if (!window.visualViewport) {\n        return;\n    }\n    const handler = () => {\n        const sessionView = container.querySelector('.SessionView');\n        if (!sessionView) {\n            return;\n        }\n\n        const scrollable = container.querySelector('.bottom-aligned-scroll');\n        let scrollTopBefore, heightBefore, heightAfter;\n\n        if (scrollable) {\n            scrollTopBefore = scrollable.scrollTop;\n            heightBefore = scrollable.offsetHeight;\n        }\n\n        // Ideally we'd use window.visualViewport.offsetTop but that seems to occasionally lag\n        // behind (last tested on iOS 14.4 simulator) so we have to compute the offset manually\n        const offsetTop = sessionView.offsetTop + sessionView.offsetHeight - window.visualViewport.height;\n\n        container.style.setProperty('--ios-viewport-height', window.visualViewport.height.toString() + 'px');\n        container.style.setProperty('--ios-viewport-top', offsetTop.toString() + 'px');\n\n        if (scrollable) {\n            heightAfter = scrollable.offsetHeight;\n            scrollable.scrollTop = scrollTopBefore + heightBefore - heightAfter;\n        }\n    };\n    window.visualViewport.addEventListener('resize', handler);\n    return () => {\n        window.visualViewport.removeEventListener('resize', handler);\n    };\n}\n\nexport class Platform {\n    constructor(container, assetPaths, config, options = null, cryptoExtras = null) {\n        this._container = container;\n        this._assetPaths = assetPaths;\n        this._config = config;\n        this.settingsStorage = new SettingsStorage(\"hydrogen_setting_v1_\");\n        this.clock = new Clock();\n        this.encoding = new Encoding();\n        this.random = Math.random;\n        this._createLogger(options?.development);\n        this.history = new History();\n        this.onlineStatus = new OnlineStatus();\n        this._serviceWorkerHandler = null;\n        if (assetPaths.serviceWorker && \"serviceWorker\" in navigator) {\n            this._serviceWorkerHandler = new ServiceWorkerHandler();\n            this._serviceWorkerHandler.registerAndStart(assetPaths.serviceWorker);\n        }\n        this.notificationService = new NotificationService(this._serviceWorkerHandler, config.push);\n        this.crypto = new Crypto(cryptoExtras);\n        this.storageFactory = new StorageFactory(this._serviceWorkerHandler);\n        this.sessionInfoStorage = new SessionInfoStorage(\"hydrogen_sessions_v1\");\n        this.estimateStorageUsage = estimateStorageUsage;\n        if (typeof fetch === \"function\") {\n            this.request = createFetchRequest(this.clock.createTimeout, this._serviceWorkerHandler);\n        } else {\n            this.request = xhrRequest;\n        }\n        const isIE11 = !!window.MSInputMethodContext && !!document.documentMode;\n        this.isIE11 = isIE11;\n        // From https://stackoverflow.com/questions/9038625/detect-if-device-is-ios/9039885\n        const isIOS = /iPad|iPhone|iPod/.test(navigator.platform) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) && !window.MSStream;\n        this.isIOS = isIOS;\n        this._disposables = new Disposables();\n        this._olmPromise = undefined;\n        this._workerPromise = undefined;\n    }\n\n    _createLogger(isDevelopment) {\n        // Make sure that loginToken does not end up in the logs\n        const transformer = (item) => {\n            if (item.e?.stack) {\n                item.e.stack = item.e.stack.replace(/\\/\\?loginToken=(.+)/, \"?loginToken=<snip>\");\n            }\n            return item;\n        };\n        if (isDevelopment) {\n            this.logger = new ConsoleLogger({platform: this});\n        } else {\n            this.logger = new IDBLogger({name: \"hydrogen_logs\", platform: this, serializedTransformer: transformer});\n        }\n    }\n\n    get updateService() {\n        return this._serviceWorkerHandler;\n    }\n\n    loadOlm() {\n        if (!this._olmPromise) {\n            this._olmPromise = loadOlm(this._assetPaths.olm);\n        }\n        return this._olmPromise;\n    }\n\n    get config() {\n        return this._config;\n    }\n\n    async loadOlmWorker() {\n        if (!window.WebAssembly) {\n            if (!this._workerPromise) {\n                this._workerPromise = loadOlmWorker(this._assetPaths);\n            }\n            return this._workerPromise;\n        }\n    }\n\n    createAndMountRootView(vm) {\n        if (this.isIE11) {\n            this._container.className += \" legacy\";\n        }\n        if (this.isIOS) {\n            this._container.className += \" ios\";\n            const disposable = adaptUIOnVisualViewportResize(this._container);\n            if (disposable) {\n                this._disposables.track(disposable);\n            }\n        }\n        this._container.addEventListener(\"error\", handleAvatarError, true);\n        this._disposables.track(() => this._container.removeEventListener(\"error\", handleAvatarError, true));\n        window.__hydrogenViewModel = vm;\n        const view = new RootView(vm);\n        this._container.appendChild(view.mount());\n    }\n\n    setNavigation(navigation) {\n        this._serviceWorkerHandler?.setNavigation(navigation);\n    }\n\n    createBlob(buffer, mimetype) {\n        return BlobHandle.fromBuffer(buffer, mimetype);\n    }\n\n    saveFileAs(blobHandle, filename) {\n        if (navigator.msSaveBlob) {\n            navigator.msSaveBlob(blobHandle.nativeBlob, filename);\n        } else {\n            downloadInIframe(this._container, this._assetPaths.downloadSandbox, blobHandle, filename, this.isIOS);\n        }\n    }\n\n    openFile(mimeType = null) {\n        const input = document.createElement(\"input\");\n        input.setAttribute(\"type\", \"file\");\n        input.className = \"hidden\";\n        if (mimeType) {\n            input.setAttribute(\"accept\", mimeType);\n        }\n        const promise = new Promise(resolve => {\n            const checkFile = () => {\n                input.removeEventListener(\"change\", checkFile, true);\n                const file = input.files[0];\n                this._container.removeChild(input);\n                if (file) {\n                    resolve({name: file.name, blob: BlobHandle.fromBlob(file)});\n                } else {\n                    resolve();\n                }\n            }\n            input.addEventListener(\"change\", checkFile, true);\n        });\n        // IE11 needs the input to be attached to the document\n        this._container.appendChild(input);\n        input.click();\n        return promise;\n    }\n\n    openUrl(url) {\n        location.href = url;\n    }\n\n    parseHTML(html) {\n        return parseHTML(html);\n    }\n\n    async loadImage(blob) {\n        return ImageHandle.fromBlob(blob);\n    }\n\n    async loadVideo(blob) {\n        return VideoHandle.fromBlob(blob);\n    }\n\n    hasReadPixelPermission() {\n        return hasReadPixelPermission();\n    }\n\n    get devicePixelRatio() {\n        return window.devicePixelRatio || 1;\n    }\n\n    get version() {\n        return DEFINE_VERSION;\n    }\n\n    dispose() {\n        this._disposables.dispose();\n    }\n}\n\nimport {LogItem} from \"../../logging/LogItem\";\nexport function tests() {\n    return {\n        \"loginToken should not be in logs\": (assert) => {\n            const transformer = (item) => {\n                if (item.e?.stack) {\n                    item.e.stack = item.e.stack.replace(/(?<=\\/\\?loginToken=).+/, \"<snip>\");\n                }\n                return item;\n            };\n            const logger = {\n                _queuedItems: [],\n                _serializedTransformer: transformer,\n                _now: () => {}\n            };\n            logger.persist = IDBLogger.prototype._persistItem.bind(logger);\n            const logItem = new LogItem(\"test\", 1, logger);\n            logItem.error = new Error();\n            logItem.error.stack = \"main http://localhost:3000/src/main.js:55\\n<anonymous> http://localhost:3000/?loginToken=secret:26\"\n            logger.persist(logItem, null, false);\n            const item = logger._queuedItems.pop();\n            console.log(item);\n            assert.strictEqual(item.json.search(\"secret\"), -1);\n        }\n    };\n}\n","export default \"{\\n  \\\"push\\\": {\\n    \\\"appId\\\": \\\"io.element.hydrogen.web\\\",\\n    \\\"gatewayUrl\\\": \\\"https://matrix.org\\\",\\n    \\\"applicationServerKey\\\": \\\"BC-gpSdVHEXhvHSHS0AzzWrQoukv2BE7KzpoPO_FfPacqOo3l1pdqz7rSgmB04pZCWaHPz7XRe6fjLaC-WPDopM\\\"\\n  },\\n  \\\"defaultHomeServer\\\": \\\"boba.best\\\"\\n}\\n\"","export default \"__VITE_ASSET__48a866e9__\"","export default \"__VITE_ASSET__bdb9a925__\"","// @ts-ignore\nimport _downloadSandboxPath from \"../../assets/download-sandbox.html?url\";\n// @ts-ignore\nimport _workerPath from \"../../worker/main.js?url\";\n// @ts-ignore\nimport olmWasmPath from \"@matrix-org/olm/olm.wasm?url\";\n// @ts-ignore\nimport olmJsPath from \"@matrix-org/olm/olm.js?url\";\n// @ts-ignore\nimport olmLegacyJsPath from \"@matrix-org/olm/olm_legacy.js?url\";\n\nexport default {\n    downloadSandbox: _downloadSandboxPath,\n    worker: _workerPath,\n    olm: {\n        wasm: olmWasmPath,\n        legacyBundle: olmLegacyJsPath,\n        wasmBundle: olmJsPath,\n    }\n};\n","\n            import {main} from \"./main\";\n            import {Platform} from \"./Platform\";\n            import configJSON from \"./assets/config.json?raw\";\n            import assetPaths from \"./sdk/paths/vite\";\n            if (true) {\n                assetPaths.serviceWorker = \"sw.js\";\n            }\n            const platform = new Platform(\n                document.body,\n                assetPaths,\n                JSON.parse(configJSON),\n                {development: false}\n            );\n            main(platform);\n        "],"names":["Request","anotherjson","EVENT_TYPE","encodeKey","Range","decodeKey","MEMBER_EVENT_TYPE","NullLoggerInstance","EVENT_ENCRYPTED_TYPE","POWERLEVELS_EVENT_TYPE","Session","DecryptionChanges","DecryptionPreparation","Curve25519.Algorithm","Curve25519.BackupEncryption","OlmDecryption","OlmEncryption","MegOlmKeyLoader","MegOlmEncryption","MegOlmDecryption","ssssKeyFromCredential","ssssWriteKey","ssssRemoveKey","E2EEAccount","createSSSSKeyFromDehydratedDeviceKey","ssssReadKey","RequestResult","base64","DOMPurify"],"mappings":"+sBAgB8B,EAAgC,MACpD,GAAM,YACD,KAAS,KACZ,GAAS,QAEV,QAAO,OAAO,GCLzB,YAA6B,EAAY,CACrC,GAAI,CACA,MAAO,IAAI,KAAI,GAAY,YAC7B,CACE,MAAO,IAAI,KAAI,WAAW,KAAc,QAIhD,kBAAoC,EAAY,EAAS,CACrD,KAAM,GAAiB,CAAC,OAAQ,OAAQ,QAAS,IAAO,OAAQ,OAChE,GAAI,CACA,KAAM,GAAe,GAAG,8BACxB,MAAO,MAAM,GAAQ,EAAc,GAAgB,iBAC9C,EAAP,CACE,GAAI,EAAI,OAAS,kBAIb,MAAO,MAEP,KAAM,IAKX,kBAAgC,EAAY,EAAS,OACxD,EAAa,GAAoB,GACjC,KAAM,GAAoB,KAAM,IAAqB,EAAY,GACjE,GAAI,GAAqB,EAAkB,SAAW,IAAK,CACvD,KAAM,CAAC,QAAQ,EACT,EAAsB,KAAK,kBAAL,cAAuB,SACnD,AAAI,MAAO,IAAwB,UAC/B,GAAa,GAAoB,IAGzC,MAAO,kBCnCqB,MAAM,IAC9B,OAAe,OACR,sBCEyB,CAAjC,aApBP,gBAqBkC,GAAI,KAElC,kBAAyB,EAIzB,mBAA0B,EAI1B,UAAU,EAAgC,aACjC,UAAU,IAAI,GACf,KAAK,UAAU,OAAS,QACnB,mBAEF,IACI,KAAK,YAAY,GAIhC,YAAY,EAAwB,CAC5B,SACK,UAAU,OAAO,GAClB,KAAK,UAAU,OAAS,QACnB,qBAMjB,gBAAuB,CACf,KAAK,UAAU,OAAS,SACnB,UAAU,aACV,wBAIT,mBAA4B,OACrB,MAAK,UAAU,OAAS,mBCtCc,GAAmC,CACpF,KAAK,EAAa,UACH,KAAK,MAAK,YACf,GAMV,QAAQ,EAAkD,OAClD,GAAU,KAAK,OACR,GAAI,IAAsB,QAAQ,QAAQ,KAAK,QAE/C,GAAI,IAAc,KAAM,GAIvC,QAAW,EAAgG,OAChG,IAAI,IAA6B,KAAM,IAStD,QAAiD,CAK7C,YAAY,EAAoC,EAAkC,MACzE,SAAW,GAAI,SAAQ,CAAC,EAAS,IAAW,MACxC,QAAU,OACV,cAAgB,EAAW,UAAU,GAAK,CACvC,EAAU,UACL,QAAU,OACP,QACH,kBAMjB,UAAsB,OACf,MAAK,SAGhB,SAAU,CACF,KAAK,qBACA,qBACA,cAAgB,MAErB,KAAK,eACA,QAAQ,GAAI,SACZ,QAAU,OAK3B,QAAyD,CACrD,YAAmB,EAAqB,gBACxC,SAAU,kBAG0B,GAAuB,CAG3D,YAAY,EAAiB,cAEpB,OAAS,EAGlB,KAAS,OACE,MAAK,OAGhB,IAAI,EAAgB,CACZ,IAAU,KAAK,cACV,OAAS,OACT,KAAK,KAAK,0BAKqB,EAAmB,CAG/D,YAAY,EAAiB,EAA0B,OAC7C,QACD,cAAgB,EAGzB,mBAAoB,OACV,yBACD,iCAIqC,GAAmC,CAIjF,YACqB,EACA,EACnB,qCAIF,mBAAoB,OACV,yBACD,mBAAqB,KAAK,qBAC3B,KAAK,0BACA,mBAAqB,KAAK,sBAIvC,kBAAmB,OACT,wBACD,mBAAqB,KAAK,OAAO,UAAU,IAAM,MAC7C,gCACA,KAAK,KAAK,cAEd,2BAGD,0BAA2B,MACzB,GAAc,KAAK,OAAO,SAC5B,EAAa,MACP,GAAS,KAAK,OAAO,MACvB,EAAQ,CACH,KAAK,0BACD,mBAAqB,EAAO,UAAU,IAAM,KAAK,KAAK,KAAK,iBAMxE,KAAK,0BACA,mBAAqB,KAAK,sBAIvC,KAAqB,MACX,GAAc,KAAK,OAAO,SAC5B,CAAC,cAGC,GAAS,KAAK,OAAO,SACpB,kBAAQ,eClJ4C,CAK/D,YAAY,EAAkB,MACrB,WAAa,YACZ,GAA+B,SAC5B,WAAa,EACX,QAEN,UAAY,GAAI,GAA+B,aAC9C,GAAgC,AAAC,GAAgB,MAC9C,UAAU,IAAI,SAElB,OAAS,EAAI,EAAc,MAGhC,WAA+C,OACxC,MAAK,UAGhB,OAAQ,eACC,qBAAY,aACZ,WAAa,QCD1B,KAAM,IAAyB,CAC3B,aAAc,GACd,YAAa,GACb,YAAa,GAEb,YAAa,GACb,aAAc,GACd,YAAa,GACb,kBAAmB,GACnB,YAAa,GAEb,YAAa,GACb,aAAc,GACd,YAAa,GACb,aAAc,GACd,YAAa,GACb,aAAc,GACd,YAAa,GACb,cAAe,GACf,iBAAkB,GAClB,aAAc,GACd,eAAgB,IAGd,GAAmB,2BAElB,QAAiB,CACpB,YAAY,EAAM,EAAS,KAAM,CAC7B,KAAK,MAAQ,EACb,KAAK,QAAU,EACf,KAAK,KAAO,WAGT,YAAW,EAAQ,EAAU,CAChC,SAAW,EAAW,EAAS,MAAM,KAAK,GAAG,OAAS,GACjD,GAAuB,IACxB,GAAW,IAER,GAAI,IAAW,GAAI,MAAK,CAAC,GAAS,CAAC,KAAM,IAAY,SAGzD,UAAS,EAAM,CAElB,MAAO,IAAI,IAAW,MAGtB,aAAa,CACb,MAAO,MAAK,WAGV,eAAe,CACjB,GAAI,KAAK,QACL,MAAO,MAAK,QACT,CACH,KAAM,GAAS,GAAI,YACb,EAAU,GAAI,SAAQ,CAAC,EAAS,IAAW,CAC7C,EAAO,iBAAiB,OAAQ,GAAO,EAAQ,EAAI,OAAO,SAC1D,EAAO,iBAAiB,QAAS,GAAO,EAAO,EAAI,OAAO,UAE9D,SAAO,kBAAkB,KAAK,OACvB,MAIX,MAAM,CACN,MAAK,MAAK,MACL,MAAK,KAAO,IAAI,gBAAgB,KAAK,QAEnC,KAAK,QAGZ,OAAO,CACP,MAAO,MAAK,MAAM,QAGlB,WAAW,CACX,MAAO,MAAK,MAAM,MAAQ,GAG9B,SAAU,CACN,AAAI,KAAK,MACL,KAAI,gBAAgB,KAAK,MACzB,KAAK,KAAO,mBC3GU,EAA8B,OACrD,QAAO,QAAQ,GAAe,IAChC,OAAO,CAAC,EAAG,KAAW,IAAU,QAChC,IAAI,CAAC,CAAC,EAAM,KACL,OAAO,IAAU,aACT,KAAK,UAAU,IAEpB,GAAG,mBAAmB,MAAS,mBAAmB,OAE5D,KAAK,iBAGa,EAAwC,IAC3D,YAAgB,IAAY,MACtB,GAAO,QACN,CACH,SAAU,EAAK,SACf,KAAM,WAEH,MAAO,IAAS,SAAU,MAC3B,GAAO,KAAK,UAAU,SACrB,CACH,SAAU,mBACV,KAAM,aAGJ,IAAI,OAAM,sBAAwB,GClCzC,gBAA2B,MAAM,CACpC,YAAY,EAAS,EAAO,CACxB,MAAM,GAAG,MAAY,EAAM,WAC3B,KAAK,MAAQ,KAGb,OAAO,CACP,MAAO,gBAIR,gBAA8B,MAAM,CACvC,YAAY,EAAQ,EAAK,EAAM,EAAQ,CACnC,MAAM,GAAG,EAAO,EAAK,MAAQ,QAAa,KAAU,KACpD,KAAK,QAAU,EAAO,EAAK,QAAU,KACrC,KAAK,eAAiB,EAAO,EAAK,eAAiB,EACnD,KAAK,WAAa,KAGlB,OAAO,CACP,MAAO,mBAMR,gBAA8B,MAAM,CACvC,YAAY,EAAS,EAAW,CAC5B,MAAM,GAAW,mBACjB,KAAK,UAAY,KAGjB,OAAO,CACP,MAAO,2BCjB8C,CAMzD,YAAY,EAAgB,EAAa,EAA8B,EAAoC,IACnG,MACA,iBAAS,IAAK,MACR,GAAS,iBAAS,MAClB,EAAO,MAAM,CAAE,EAAG,UAAW,MAAK,UAAW,EAAO,MAAM,WAE/D,KAAO,OACP,eAAiB,OACjB,SAAW,EAAc,WAAW,KAAK,GAAY,uBACjD,IAAI,SAAU,EAAS,QAExB,EAAS,QAAU,KAAO,EAAS,OAAS,KAAO,qBAAS,qBAAT,cAA6B,SAAS,EAAS,2BAC7F,SACE,EAAS,QAEZ,EAAS,QAAU,IAAK,MAClB,GAAM,GAAI,IAAgB,0CAC3B,MAAM,GACL,UACC,EAAS,QAAU,KAAO,CAAC,MAAS,OAAT,cAAe,SAAS,MACpD,GAAM,GAAI,IAAgB,qBAAqB,EAAS,sHACzD,MAAM,GACL,MACH,MACG,GAAM,GAAI,IAAgB,EAAQ,EAAK,EAAS,KAAM,EAAS,yBAChE,IAAI,UAAW,EAAI,oBACnB,MAAM,GACL,IAGf,GAAO,IAGF,EAAI,OAAS,cAAgB,KAAK,eAAgB,MAqB5C,GAAM,GAAI,IAAgB,yEAC3B,MAAM,GACL,YAEF,GAAI,OAAS,+BACR,IAAI,UAAW,EAAI,uBAEvB,MAAM,GACL,IAKlB,OAAc,OACN,KAAK,yBACA,eAAM,IAAI,UAAW,SACrB,eAAe,aAEf,eAAiB,QAI9B,UAAyB,OACd,MAAK,cAGV,eAAgC,OAE3B,AADU,MAAM,MAAK,eAAe,YAC3B,QC7FxB,KAAM,IAAe,qBACf,GAAe,qBACf,GAAqB,yDAiBA,CAMvB,YAAY,CAAC,aAAY,cAAa,UAAS,eAAuB,MAG7D,YAAc,OACd,aAAe,OACf,WAAa,OACb,aAAe,EAGhB,KAAK,EAAgB,EAAiB,GAAsB,OACzD,MAAK,YAAc,EAAS,EAG/B,aAAa,EAAuB,EAAa,EAAmC,EAA4B,EAA8B,EAA0C,MACtL,GAAc,GAAkB,KAChC,GAAG,KAAO,OACZ,QACE,GAAwC,GAAI,QAC9C,KACQ,IAAI,gBAAiB,UAAU,OAEnC,IAAI,SAAU,oBAClB,EAAM,MACA,GAAU,GAAW,KACnB,IAAI,eAAgB,EAAQ,YACtB,EAAQ,UAGpB,GAAgB,KAAK,WAAW,EAAK,CACvC,SACA,UACA,KAAM,EACN,QAAS,iBAAS,QAClB,eAAgB,iBAAS,eACzB,OAAQ,OACR,MAAO,IAAW,QAGhB,EAAY,GAAI,IAAkB,EAAQ,EAAK,EAAe,SAEhE,MAAK,gBACK,WAAW,MAAM,GAAO,CAK1B,EAAI,OAAS,wBACR,aAAa,gBAAgB,QAKvC,EAGH,iBAAiB,EAAuB,EAAa,EAAmC,EAA4B,EAAkD,OACnK,MAAK,aAAa,EAAQ,EAAK,EAAa,EAAM,GAGrD,eAAe,EAAuB,EAAa,EAAmC,EAA4B,EAAkD,OACjK,MAAK,aAAa,EAAQ,EAAK,EAAa,EAAM,EAAS,KAAK,cAGnE,MAAM,EAAgB,EAAkC,EAA2B,EAAkD,OAClI,MAAK,eAAe,OAAQ,KAAK,KAAK,EAAQ,kBAAS,SAAU,IAAe,EAAa,EAAM,GAGtG,KAAK,EAAgB,EAAkC,EAA4B,EAAkD,OAClI,MAAK,eAAe,MAAO,KAAK,KAAK,EAAQ,kBAAS,SAAU,IAAe,EAAa,EAAM,GAGrG,KAAK,EAAgB,EAAmC,EAA4B,EAAkD,OACnI,MAAK,eAAe,MAAO,KAAK,KAAK,EAAQ,kBAAS,SAAU,IAAe,EAAa,EAAM,GAG7G,KAAK,EAAe,EAAgB,EAAiB,EAAkD,OAC5F,MAAK,KAAK,QAAS,CAAC,QAAO,UAAS,UAAS,OAAW,GAGnE,QAAQ,EAAgB,EAAiB,EAAe,EAAoC,OACjF,MAAK,KAAK,UAAU,mBAAmB,cAAmB,mBAAmB,KAAY,CAAC,SAAQ,UAI7G,SAAS,EAAgB,EAA6B,EAAkD,OAC7F,MAAK,KAAK,UAAU,mBAAmB,cAAoB,EAAQ,OAAW,GAIzF,QAAQ,EAAgB,EAA6B,EAAkD,OAC5F,MAAK,KAAK,UAAU,mBAAmB,aAAmB,EAAQ,OAAW,GAGxF,KAAK,EAAgB,EAAmB,EAAe,EAA8B,EAAkD,OAC5H,MAAK,KAAK,UAAU,mBAAmB,WAAgB,mBAAmB,MAAc,mBAAmB,KAAU,GAAI,EAAS,GAG7I,OAAO,EAAgB,EAAiB,EAAe,EAA8B,EAAkD,OAC5H,MAAK,KAAK,UAAU,mBAAmB,aAAkB,mBAAmB,MAAY,mBAAmB,KAAU,GAAI,EAAS,GAG7I,QAAQ,EAAgB,EAAqB,EAAiB,EAAkD,OACrG,MAAK,MAAM,UAAU,mBAAmB,cAAmB,mBAAmB,MAAgB,mBAAmB,KACpH,GAAI,GAAI,GAGhB,MAAM,EAAgB,EAAmB,EAAkB,EAAkD,OAClG,MAAK,KAAK,UAAU,mBAAmB,YAAiB,mBAAmB,MAAc,mBAAmB,KAAa,GAAI,OAAW,GAGnJ,eAAoC,OACzB,MAAK,iBAAiB,MAAO,KAAK,KAAK,WAGlD,SAAS,EAAyB,EAAkB,EAAkC,EAA4B,EAAwB,GAAO,EAA8B,GAAwB,GAC3L,mBAAqB,CAAC,UACxB,GAAY,CACd,OACA,WACA,2BAA4B,EAC5B,cAAe,SAEf,OAEK,SAAW,GAEb,KAAK,iBAAkB,OAAQ,KAAK,KAAK,YAAa,IAAe,OAAW,EAAM,GAGjG,cAAc,EAAkB,EAAkB,EAAkC,EAAkD,OAC3H,MAAK,iBAAiB,OAAQ,KAAK,KAAK,UAAW,OAAW,CACnE,KAAQ,mBACR,WAAc,CACZ,KAAQ,YACR,KAAQ,GAEV,SAAY,EACZ,4BAA+B,GAC9B,GAGP,WAAW,EAAoB,EAAe,EAAkC,EAAkD,OACvH,MAAK,iBAAiB,OAAQ,KAAK,KAAK,UAAW,OAAW,CACnE,KAAQ,gBACR,WAAc,CACZ,KAAQ,aAEV,MAAS,EACT,OAAU,EACV,4BAA+B,GAC9B,GAGP,aAAa,EAAgB,EAA6B,EAAkD,OACjG,MAAK,MAAM,SAAS,mBAAmB,YAAkB,GAAI,EAAQ,GAGhF,SAAS,EAAkD,OAChD,MAAK,iBAAiB,MAAO,GAAG,KAAK,sCAAuC,OAAW,OAAW,GAG7G,WAAW,EAA4B,EAA8B,EAAkD,IAC/G,GAAO,qBACP,OACO,EAAO,IAAI,mBAAmB,MAElC,KAAK,MAAM,EAAM,GAAI,EAAS,GAGzC,UAAU,EAAmC,EAAkD,OACpF,MAAK,MAAM,cAAe,GAAI,EAAc,GAGvD,UAAU,EAA8B,EAAkD,OAC/E,MAAK,MAAM,cAAe,GAAI,EAAS,GAGlD,aAAa,EAAc,EAA8B,EAAe,EAAkD,OAC/G,MAAK,KAAK,iBAAiB,mBAAmB,MAAS,mBAAmB,KAAU,GAAI,EAAS,GAG5G,gBAAgB,EAAkB,EAAkD,IAC5E,GAAc,SACd,OACc,IAAI,mBAAmB,MAElC,KAAK,KAAK,qBAAqB,IAAe,OAAW,OAAW,GAG/E,yBAAyB,EAAiB,EAAgB,EAAmB,EAAkD,OACpH,MAAK,KAAK,mBAAmB,mBAAmB,MAAW,mBAAmB,KAAc,CAAC,WAAU,OAAW,GAG7H,uBAAuB,EAAiB,EAA8B,EAAkD,OAC7G,MAAK,KAAK,kBAAmB,CAAC,WAAU,EAAS,GAG5D,iBAAiB,EAAY,EAAkB,EAAkD,OACtF,MAAK,eAAe,OAAQ,GAAG,KAAK,sCAAuC,CAAC,YAAW,EAAM,GAGxG,UAAU,EAA6B,EAAkD,OAC9E,MAAK,MAAM,eAAgB,GAAI,EAAQ,GAGlD,WAAW,EAAkD,OAClD,MAAK,KAAK,WAAY,OAAW,OAAW,GAGvD,KAAK,EAAgB,EAAkD,OAC5D,MAAK,MAAM,UAAU,mBAAmB,UAAgB,GAAI,GAAI,GAG3E,cAAc,EAAuB,EAAkD,OAC5E,MAAK,MAAM,SAAS,mBAAmB,KAAkB,GAAI,GAAI,GAG5E,MAAM,EAAgB,EAAkD,OAC7D,MAAK,MAAM,UAAU,mBAAmB,WAAiB,GAAI,GAAI,GAG5E,OAAO,EAAgB,EAAkD,OAC9D,MAAK,MAAM,UAAU,mBAAmB,YAAkB,GAAI,GAAI,GAG7E,OAAO,EAAkD,OAC9C,MAAK,MAAM,UAAW,GAAI,GAAI,GAGzC,oBAAoB,EAA8B,GAAwB,UAC9D,OAAS,GACV,KAAK,KAAK,qBAAsB,OAAW,OAAW,GAGjE,uBAAuB,EAA8B,EAA8B,GAAwB,UAC/F,OAAS,GACV,KAAK,KAAK,qBAAsB,GAAI,EAAS,GAGxD,sBAAsB,EAAkB,EAA8B,GAAwB,UAClF,OAAS,GACV,KAAK,MAAM,2BAA4B,GAAI,CAAC,UAAW,GAAW,GAG7E,QAAQ,EAAgB,EAAkD,OAC/D,MAAK,KAAK,YAAY,mBAAmB,MAGpD,WAAW,EAA8B,EAAkD,OAChF,MAAK,MAAM,cAAe,GAAI,EAAS,GAGlD,eAAe,EAAmB,EAAc,EAA8B,EAAkD,OACrH,MAAK,KAAK,SAAS,mBAAmB,mBAA2B,mBAAmB,KAAS,GAAI,EAAS,IC5RzH,GAAW,IAAX,UAAW,EAAX,WAA6B,KAAR,UAAV,qBAEwB,CAO/B,YAAY,EAA+B,aANT,kBACP,SAMjB,GAAQ,SACT,OAAS,OACT,SAAW,OACX,eAAiB,OACjB,KAAO,GAAK,EAAI,SAGnB,eAA8B,MAC3B,SAAW,KAAK,eAAe,KAAK,aACrC,MACM,MAAK,SAAS,eAEd,GAAO,EAAI,KAAK,cACjB,SAAW,KAAK,IAAI,KAAK,KAAM,SAChC,MAEA,cAAiB,SACX,gBAGL,SAAW,QAIxB,OAAc,CACN,KAAK,eACA,SAAS,QAItB,OAAc,MACL,SAAW,KAAK,YAChB,WAGL,YAAoB,OACb,MAAK,aC5CR,IAAL,UAAK,EAAL,sFAAK,qBAYa,CASrB,YAAY,CAAC,aAAY,gBAAe,gBAAqB,MACpD,cAAgB,OAChB,YAAc,OACd,mBAAqB,OAErB,OAAS,GAAI,GAAgB,QAC7B,gBAAkB,MAGvB,uBAAoD,OAC7C,MAAK,qBAGZ,mBAAsD,OAC/C,MAAK,UAGZ,UAAkB,OACd,MAAK,OAAO,QAAU,EACf,KAAK,YAAY,UAAY,KAAK,YAAY,UAElD,OAGL,iBAAgB,EAAqC,IACnD,CAAC,KAAK,gBAAiB,MAClB,gBAAkB,QAEjB,GAA2B,KAAK,eAAiB,KAAK,cAAc,UAAU,GAAU,CACtF,QACK,cAIT,MACM,MAAK,eAAe,SACrB,WAGG,MAAM,WAEV,YAIC,gBAAkB,KAKnC,QAAe,CACP,KAAK,kBAEA,YAAY,QAIjB,UAAU,EAA+B,CACzC,IAAU,KAAK,OAAO,QAClB,IAAU,OACL,YAAc,KAAK,0BAEnB,YAAc,UAElB,OAAO,IAAI,SAIV,gBAAe,EAAqC,UACzD,kBAAoB,YACpB,YAAY,QAEV,CAAC,KAAK,sBACL,MACK,UAAU,QAIT,GAAkB,EAAM,SAAS,CAAC,QAAS,WAC5C,kBAAoB,KAAM,GAAgB,gBAC1C,UAAU,SACV,MACD,EAAI,OAAS,uBACR,UAAU,QACT,MAAK,YAAY,yBAEjB,KCzGnB,kBAAiC,EAAU,EAAkB,EAAM,CACtE,GAAI,IAAS,QAAa,EAAK,MAAQ,QAAa,EAAK,KAAO,QACzD,EAAK,SAAW,QAAa,EAAK,OAAO,SAAW,OACxD,KAAM,IAAI,OAAM,qEAGnB,KAAM,CAAC,UAAU,EACX,CAAC,UAAU,EAAS,SAC1B,GAAI,GAAU,EAAO,OAAO,EAAK,IAE7B,EAAuB,EAAO,OAAO,EAAO,OAAO,EAAK,OAAO,SAEnE,KAAM,GAAe,KAAM,GAAO,OAAO,UAAW,GACpD,GAAI,EAAO,OAAO,GAAI,YAAW,KAAkB,EAC/C,KAAM,IAAI,OAAM,6BAEpB,GAAI,GACJ,MAAI,GAAK,GAAK,MAAQ,EAAK,GAAK,KAE5B,EAAgB,GAGhB,EAAgB,IAGI,KAAM,GAAO,IAAI,WAAW,CAChD,OAAQ,EAAK,IACb,GAAI,EACJ,KAAM,EACN,kBAKD,kBAAiC,EAAU,EAAM,CACpD,KAAM,CAAC,UAAU,EACX,CAAC,UAAU,EAAS,SACpB,EAAK,KAAM,GAAO,IAAI,aACtB,EAAM,KAAM,GAAO,IAAI,YAAY,MAAO,KAC1C,EAAS,KAAM,GAAK,eACpB,EAAa,KAAM,GAAO,IAAI,WAAW,CAAC,OAAQ,EAAK,KAAI,KAAM,IACjE,EAAS,KAAM,GAAO,OAAO,UAAW,GAC9C,MAAO,CACH,KAAM,EAAS,WAAW,EAAY,4BACtC,KAAM,CACF,EAAG,KACH,MACA,GAAI,EAAO,eAAe,GAC1B,OAAQ,CACJ,OAAQ,EAAO,eAAe,cCpDjB,CAIzB,YAAY,CAAC,aAAY,YAAoD,MACpE,YAAc,OACd,UAAY,EAGrB,gBAAgB,EAAa,EAAe,EAAgB,EAAyC,MAC3F,GAAQ,KAAK,aAAa,MAC5B,EAAO,MACD,CAAC,EAAY,GAAW,QAEvB,AADS,GAAG,KAAK,0CAA0C,mBAAmB,MAAe,mBAAmB,KACtG,IAAM,GAAkB,CAAC,MAAO,KAAK,MAAM,GAAQ,OAAQ,KAAK,MAAM,GAAS,iBAE7F,MAGX,OAAO,EAA4B,MACzB,GAAQ,KAAK,aAAa,MAC5B,EAAO,MACD,CAAC,EAAY,GAAW,QACvB,GAAG,KAAK,yCAAyC,mBAAmB,MAAe,mBAAmB,gBAEtG,MAIP,aAAa,EAA8B,MACzC,GAAS,eACX,GAAI,WAAW,GACR,EAAI,OAAO,EAAO,QAAQ,MAAM,IAAK,GAErC,UAIT,uBAAsB,EAA0B,EAAiB,GAA4B,MACzF,GAAM,KAAK,OAAO,EAAU,KAC5B,CAAC,KAAM,GAAmB,KAAM,MAAK,UAAU,QAAQ,EAAK,CAAC,OAAQ,MAAO,OAAQ,SAAU,UAAQ,WACtG,EAAkB,KAAM,IAAkB,KAAK,UAAW,EAAiB,SAC1E,MAAK,UAAU,WAAW,EAAiB,EAAU,eAG1D,uBAAsB,EAAgB,EAAkB,EAAiB,GAA4B,MACjG,GAAM,KAAK,OAAO,GAClB,CAAC,KAAM,GAAU,KAAM,MAAK,UAAU,QAAQ,EAAK,CAAC,OAAQ,MAAO,OAAQ,SAAU,UAAQ,iBAC5F,MAAK,UAAU,WAAW,EAAQ,QAGvC,oBAAmB,EAAqB,EAAiB,GAA4B,aACnF,GAAQ,KACD,KAAK,sBAAsB,EAAQ,KAAM,GAEzC,KAAK,sBAAsB,EAAQ,IAAM,KAAQ,OAAR,cAAc,SAAU,ICrDpF,QAA4C,CAWxC,YAAY,EAAoB,EAAa,MACpC,WAAa,OACb,KAAO,OACP,iBAAmB,GAAI,SAAQ,CAAC,EAAS,IAAW,MAChD,gBAAkB,OAClB,eAAiB,IAI9B,OAAc,OACN,KAAK,oBACA,eAAe,cAEf,eAAe,GAAI,YACnB,uCAAqB,GAAI,KAItC,UAAyB,OACd,MAAK,iBAGhB,cAAgC,OACxB,MAAK,cACE,KAAK,cAAc,eAEzB,MAAK,4BACD,qBAAuB,GAAI,SAAQ,CAAC,EAAS,IAAW,MACpD,oBAAsB,OACtB,mBAAqB,KAG3B,KAAK,2BAGV,kBAAiB,EAAQ,cACtB,eAAiB,OAChB,GAAW,KAAM,SAAK,iBAAL,cAAqB,iBACvC,gBAAgB,QACf,GAAe,KAAM,SAAK,iBAAL,cAAqB,qBAC3C,oBAAoB,MAGzB,gBAAgB,OACT,MAAK,gBAIpB,QAA2B,CAGvB,YAAY,EAA6B,MAChC,WAAa,GAK1B,SAAW,KAAc,QAAO,oBAAoB,GAAc,WAC1D,IAAe,eAAiB,CAAC,EAAW,WAAW,UAClC,UAAU,GAAc,YAAY,EAAM,OACpD,MAAK,WAAW,cAAc,EAAY,aAK/B,CAO1B,YAAY,CAAE,QAAO,SAAiD,gBAJ3B,GAAI,mBAC5B,iBACA,GAAI,IAAqB,WAGnC,OAAS,OACT,OAAS,KAGd,QAAuB,OAChB,MAAK,SAGhB,MAAa,MACJ,SAAW,YACL,KAAW,MAAK,YACf,aAEP,UAAU,QAGnB,OAAc,MACL,SAAW,GAGZ,cAAc,EAAc,EAAsB,MAChD,GAAU,GAAIA,IAAQ,EAAM,eAC7B,QAAQ,GACN,OAGG,SAAQ,EAAiC,MAC9C,UAAU,IAAI,MACf,IACI,QACG,CAAC,KAAK,aACL,MACM,GAAgB,KAAK,OACvB,EAAQ,YACV,MAAM,KAAK,OAAQ,EAAQ,WAEvB,GAAQ,iBAAiB,gBAE1B,MAED,YAAe,KACf,EAAI,UAAY,mBAEZ,OAAO,cAAc,EAAI,qBACnB,MAAK,OACN,cAAc,EAAI,gBAClB,UAEA,OACY,GAAI,IACb,KAAK,OAAO,qBAGd,GAAW,oBAElB,GACK,eAAe,WAK/B,KAAK,YACG,qBAGP,UAAU,OAAO,KCzJlC,KAAM,IAAsB,IAEf,EAAa,GACtB,cACA,cACA,UACA,WAGJ,YAAyB,EAAc,OACnC,GAAI,CACA,KAAM,GAAS,oBAAc,WAAd,cAAwB,OACvC,MAAO,OAAM,QAAQ,IAAW,EAAO,SAAW,OACpD,CACE,MAAO,IAqBR,QAAW,CACd,YAAY,CAAC,QAAO,UAAS,UAAS,UAAS,CAC3C,KAAK,OAAS,EACd,KAAK,QAAU,EACf,KAAK,SAAW,EAChB,KAAK,SAAW,EAChB,KAAK,gBAAkB,KACvB,KAAK,QAAU,GAAI,GAAgB,EAAW,SAC9C,KAAK,OAAS,QAGd,SAAS,CACT,MAAO,MAAK,WAIZ,QAAQ,CACR,MAAO,MAAK,OAGhB,OAAQ,CAEJ,GAAI,KAAK,QAAQ,QAAU,EAAW,QAClC,OAEJ,KAAK,OAAS,KACd,GAAI,GAAY,KAAK,SAAS,UAC9B,AAAI,EACA,KAAK,QAAQ,IAAI,EAAW,aAE5B,KAAK,QAAQ,IAAI,EAAW,aAEhC,KAAK,UAAU,QAGb,WAAU,EAAW,CAEvB,KAAM,KAAK,QAAQ,QAAU,EAAW,SAAS,CAC7C,GAAI,GACA,EACA,EAAsB,KAAK,QAAQ,QAAU,EAAW,aAAe,KAAK,QAAQ,QAAU,EAAW,YAC7G,KAAM,MAAK,QAAQ,IAAI,OAAQ,KAAM,IAAO,CACxC,EAAI,IAAI,QAAS,GACjB,EAAI,IAAI,SAAU,KAAK,QAAQ,OAC/B,GAAI,CAYA,KAAM,GAAU,KAAK,QAAQ,QAAU,EAAW,QAAU,GAAsB,EAC5E,EAAa,KAAM,MAAK,aAAa,EAAW,EAAS,GAC/D,EAAY,EAAW,UACvB,EAAa,EAAW,WACxB,EAAiB,EAAW,eAE5B,AAAI,KAAK,QAAQ,QAAU,EAAW,SAAW,EAAW,oBACxD,KAAK,QAAQ,IAAI,EAAW,aAE5B,KAAK,QAAQ,IAAI,EAAW,eAE3B,EAAP,CAEE,GAAI,EAAI,OAAS,mBAAqB,EAAI,UAEtC,OAEJ,KAAK,OAAS,EACV,EAAI,OAAS,cAGb,GAAI,MAAQ,EACZ,EAAI,SAAW,EAAI,MAAM,OAE7B,EAAI,IAAI,WAAY,IACpB,KAAK,QAAQ,IAAI,EAAW,SAEhC,AAAI,KAAK,QAAQ,QAAU,EAAW,SAMlC,KAAM,GAAI,KAAK,qBAAsB,GAAO,KAAK,uBAAuB,EAAgB,EAAY,KAG5G,KAAK,QAAQ,MAAM,KACnB,CAAC,EAAQ,IACD,EAAI,oBAAoB,YAAc,KAAQ,EAAI,OAAS,EACpD,EAAO,SAAS,EAAI,MAAM,QAE1B,EAAO,SAAS,EAAI,MAAM,aAM3C,wBAAuB,EAAgB,EAAY,EAAK,CAC1D,KAAM,GAAgB,KAAK,QAAQ,QAAU,EAAW,YAClD,EAAkB,UAAY,CAChC,GAAI,CACA,KAAM,GAAI,KAAK,UAAW,GAAO,KAAK,SAAS,mBAAmB,EAAgB,EAAe,GAAM,EAAI,MAAM,aACnH,OAMA,EAAgB,AAHiB,EAAW,OAAO,GAC9C,EAAG,KAAK,wBAAwB,EAAG,UAEO,IAAI,KAAM,IAAM,CACjE,GAAI,CACA,KAAM,GAAI,KAAK,OAAQ,GAAO,EAAG,KAAK,mBAAmB,EAAG,QAAS,GAAM,EAAI,MAAM,aACvF,KAMN,KAAM,SAAQ,IAAI,EAAc,OAAO,SAGrC,cAAa,EAAW,EAAS,EAAK,OACxC,GAAI,CAAC,gBAAgB,KAAK,SAC1B,AAAI,MAAO,IAAiB,UACxB,MAAK,gBAAkB,KAAK,OAAO,aAAa,KAAK,SAAS,KAAK,GAAI,CAAC,KAAM,CAAC,MAAO,CAAC,kBAAmB,MAAS,CAAC,QACpH,EAAgB,MAAM,MAAK,gBAAgB,YAAY,WAE3D,KAAM,GAAsB,EAAW,GAAK,IAC5C,KAAK,gBAAkB,KAAK,OAAO,KAAK,EAAW,EAAc,EAAS,CAAC,QAAS,EAAqB,QACzG,KAAM,GAAW,KAAM,MAAK,gBAAgB,WAEtC,EAAgB,CAAC,EACjB,EAAe,GAAI,IACnB,EAAe,KAAK,cAAc,EAAS,OAC3C,CAAC,aAAY,sBAAsB,KAAM,MAAK,oBAChD,EAAS,MAAO,EAAc,EAAe,GAEjD,GAAI,CAEA,EAAa,KAAO,KAAM,GAAI,KAAK,iBAAkB,IAAM,KAAK,SAAS,eAAe,IACxF,KAAM,GAAI,KAAK,UAAW,GAAO,KAAK,aAAa,EAAc,EAAY,EAAU,IACvF,KAAM,GAAI,KAAK,mBAAoB,GAAO,QAAQ,IAAI,EAAW,IAAI,GAC1D,EAAG,KAAK,iBAAiB,EAAG,YAAa,MAEpD,KAAM,GAAI,KAAK,QAAS,KAAM,IAAO,KAAK,WACtC,EAAc,EAAc,EAAY,EACxC,EAAU,EAAc,EAAe,YAE3C,EAAa,UAGjB,EAAI,KAAK,QAAS,GAAO,KAAK,WAC1B,EAAc,EAAc,EAAY,EAAoB,IAEhE,KAAM,GAAiB,KAAS,YAAT,cAAoB,OAC3C,MAAO,CACH,UAAW,EAAS,WACpB,aACA,eAAgB,EAAa,QAC7B,oBAAqB,MAAM,QAAQ,IAAmB,EAAe,OAAS,GAItF,qBAAsB,CAClB,KAAM,GAAa,KAAK,SAAS,WACjC,MAAO,MAAK,SAAS,QAAQ,CACzB,EAAW,YACX,EAAW,qBAEX,EAAW,kBAGX,EAAW,sBAIb,cAAa,EAAc,EAAY,EAAU,EAAK,SACxD,KAAM,GAAa,KAAM,MAAK,sBAC9B,EAAa,YAAc,KAAM,GAAI,KAAK,UAAW,GAAO,KAAK,SAAS,YACtE,EAAU,EAAa,KAAM,EAAY,IAE7C,KAAM,GAAgB,KAAa,cAAb,cAA0B,cAGhD,GAAI,EAAe,CACf,KAAM,CAAC,kBAAkB,OAAO,UAChC,SAAW,KAAU,GAAc,OAE/B,GAAI,CADqB,OAAS,QAAT,cAAgB,OAAQ,EAAe,KAAK,EAAS,MAAM,KAAM,IACnE,CACnB,GAAI,GAAO,KAAK,SAAS,MAAM,IAAI,GACnC,AAAI,GACA,EAAW,KAAK,GAAI,IAAqB,EAAM,GAAO,GAAI,EAAK,cAM/E,KAAM,SAAQ,IAAI,EAAW,IAAI,KAAM,IAAM,CACzC,KAAM,GAAU,iBAAe,IAAI,EAAG,KAAK,IAC3C,EAAG,YAAc,KAAM,GAAI,KAAK,OAAQ,KAAM,IAGtC,GAAG,WACH,KAAM,GAAG,KAAK,KAAK,KAAM,EAAY,GAElC,EAAG,KAAK,YACX,EAAG,aAAc,EAAG,WAAY,EAAS,EAAY,IAC1D,EAAI,MAAM,WAIjB,KAAM,GAAW,gBAGf,YAAW,EAAc,EAAc,EAAY,EAAoB,EAAU,EAAc,EAAe,EAAK,CACrH,KAAM,GAAU,KAAM,MAAK,eAC3B,GAAI,CACA,EAAa,QAAU,KAAM,GAAI,KAAK,UAAW,GAAO,KAAK,SAAS,UAClE,EAAU,EAAc,EAAa,YAAa,EAAS,IAC/D,KAAM,SAAQ,IAAI,EAAa,IAAI,KAAM,IAAM,CAC3C,EAAG,QAAU,KAAM,GAAI,KAAK,SAAU,GAAO,EAAG,OAAO,UACnD,EAAG,WAAY,EAAG,aAAc,EAAS,OAEjD,KAAM,SAAQ,IAAI,EAAW,IAAI,KAAM,IAAM,CACzC,EAAG,QAAU,KAAM,GAAI,KAAK,OAAQ,GAAO,EAAG,KAAK,UAC/C,EAAG,aAAc,EAAe,EAAG,YAAa,EAAS,OAIjE,KAAM,SAAQ,IAAI,EAAmB,IAAI,KAAM,IAAO,OAClD,KAAM,GAAiB,KAAI,YAAJ,cAAe,eACtC,EAAI,QAAU,KAAM,GAAI,KAAK,eAAgB,GAAO,EAAI,aAAa,UACjE,EAAgB,EAAI,aAAc,EAAI,WAAY,EAAS,aAE/D,EAAN,CAIE,QAAQ,MAAM,GACR,EAAQ,SAAS,GAE3B,KAAM,GAAQ,SAAS,GAG3B,WAAW,EAAc,EAAc,EAAY,EAAoB,EAAK,CACxE,EAAI,KAAK,UAAW,GAAO,KAAK,SAAS,UAAU,EAAa,QAAS,GAAM,EAAI,MAAM,QACzF,OAAQ,KAAO,GACX,EAAI,KAAK,eAAgB,GAAO,CAC5B,EAAI,aAAa,UAAU,EAAI,QAAS,GACxC,EAAI,aAAa,WAClB,EAAI,MAAM,QAEjB,OAAQ,KAAM,GACV,EAAI,KAAK,OAAQ,GAAO,EAAG,KAAK,UAAU,EAAG,QAAS,GAAM,EAAI,MAAM,QAE1E,OAAQ,KAAM,GACV,EAAI,KAAK,SAAU,GAAO,EAAG,OAAO,UAAU,EAAG,QAAS,GAAM,EAAI,MAAM,QAE9E,KAAK,SAAS,oCAAoC,EAAc,EAAY,EAAoB,GAGpG,cAAe,CACX,KAAM,GAAa,KAAK,SAAS,WACjC,MAAO,MAAK,SAAS,aAAa,CAC9B,EAAW,QACX,EAAW,YACX,EAAW,oBACX,EAAW,QACX,EAAW,UACX,EAAW,YACX,EAAW,eACX,EAAW,kBACX,EAAW,kBACX,EAAW,cACX,EAAW,eACX,EAAW,wBACX,EAAW,iBAGX,EAAW,sBACX,EAAW,WACX,EAAW,YAEX,EAAW,YACX,EAAW,4BAIb,qBAAoB,EAAc,EAAc,EAAe,EAAK,CACtE,KAAM,GAAa,GACb,EAAqB,GAC3B,GAAI,EAAc,CACd,KAAM,GAAiB,CAAC,OAAQ,SAChC,SAAU,KAAc,GAAgB,CACpC,KAAM,GAAoB,EAAa,GACvC,GAAI,EACA,SAAW,CAAC,EAAQ,IAAiB,QAAO,QAAQ,GAAoB,CAGpE,GAAI,GAAiB,GAAgB,GACjC,SAEJ,KAAM,GAAS,KAAK,SAAS,QAAQ,IAAI,GAGzC,AAAI,GACA,EAAa,KAAK,GAAI,IAAuB,EAAQ,GAAO,KAAM,IAEtE,KAAM,GAAY,KAAK,qBAAqB,EAAQ,EAAc,EAAY,GAC9E,AAAI,GACA,EAAW,KAAK,GAEpB,KAAM,GAAM,KAAM,MAAK,6BAA6B,EAAQ,EAAW,EAAc,EAAY,EAAe,GAChH,AAAI,GACA,EAAmB,KAAK,KAM5C,MAAO,CAAC,aAAY,sBAGxB,qBAAqB,EAAQ,EAAc,EAAY,EAAe,CAClE,GAAI,GAAY,GACZ,EAAO,KAAK,SAAS,MAAM,IAAI,GAYnC,GAJI,CAAC,GAAS,KAAe,QAAW,GAAiB,IAAe,UACpE,GAAO,KAAK,SAAS,iBAAiB,GACtC,EAAY,IAEZ,EACA,MAAO,IAAI,IACP,EAAM,EAAW,EAAc,QAIrC,8BAA6B,EAAQ,EAAW,EAAc,EAAY,EAAe,EAAK,CAChG,GAAI,GAmBJ,GAlBA,AAAI,kBAAW,YAAa,CAAC,EAIzB,EAAe,KAAK,SAAS,+BAA+B,GACrD,IAAe,SACtB,CAAI,EAGA,EAAe,KAAK,SAAS,+BAA+B,GAM5D,EAAe,KAAM,MAAK,SAAS,iBAAiB,EAAQ,IAGhE,EACA,MAAO,IAAI,IACP,EAAc,EAAW,EAAc,GAInD,cAAc,EAAc,CACxB,KAAM,GAAe,GACrB,GAAI,iBAAc,OACd,SAAW,CAAC,EAAQ,IAAiB,QAAO,QAAQ,EAAa,QAAS,CACtE,GAAI,GAAS,KAAK,SAAS,QAAQ,IAAI,GACnC,EAAc,GAClB,AAAK,GACD,GAAS,KAAK,SAAS,aAAa,GACpC,EAAc,IAElB,EAAa,KAAK,GAAI,IAAuB,EAAQ,EAAa,EAAc,WAGxF,MAAO,GAGX,MAAO,CACH,AAAI,KAAK,QAAQ,QAAU,EAAW,SAGtC,MAAK,QAAQ,IAAI,EAAW,SACxB,KAAK,iBACL,MAAK,gBAAgB,QACrB,KAAK,gBAAkB,QAKnC,QAA8B,CAC1B,aAAc,CACV,KAAK,KAAO,KACZ,KAAK,YAAc,KACnB,KAAK,QAAU,KAGnB,SAAU,OACN,QAAK,OAAL,QAAW,WAInB,QAA2B,CACvB,YAAY,EAAM,EAAW,EAAc,EAAY,CACnD,KAAK,KAAO,EACZ,KAAK,UAAY,EACjB,KAAK,aAAe,EACpB,KAAK,WAAa,EAClB,KAAK,YAAc,KACnB,KAAK,QAAU,QAGf,KAAK,CACL,MAAO,MAAK,KAAK,MAGjB,YAAY,CACZ,MAAO,MAAK,WAAa,KAAK,aAAe,UAG7C,eAAe,CACf,MAAO,CAAC,KAAK,WAAa,KAAK,aAAe,UAG9C,iBAAiB,OACjB,MAAO,QAAK,UAAL,cAAc,gBAK7B,QAAmC,CAC/B,YAAY,EAAc,EAAW,EAAc,EAAY,EAAe,CAC1E,KAAK,aAAe,EACpB,KAAK,UAAY,EACjB,KAAK,aAAe,EACpB,KAAK,WAAa,EAClB,KAAK,cAAgB,EACrB,KAAK,QAAU,QAGf,KAAK,CACL,MAAO,MAAK,aAAa,MAGzB,YAAY,CACZ,MAAQ,MAAK,WAAa,KAAK,gBAAkB,KAAK,aAAe,WAGrE,eAAe,CACf,MAAO,MAAK,aAAe,QAInC,QAA6B,CACzB,YAAY,EAAQ,EAAa,EAAc,EAAY,CACvD,KAAK,OAAS,EACd,KAAK,YAAc,EACnB,KAAK,WAAa,EAClB,KAAK,aAAe,EACpB,KAAK,QAAU,QAGf,KAAK,CACL,MAAO,MAAK,OAAO,MAGnB,YAAY,CACZ,MAAO,MAAK,eAGZ,eAAe,CACf,MAAO,MAAK,aAAe,kBCvgBN,CAGzB,aAAc,MACL,gBAAkB,GAG3B,KAAwB,EAAS,EAAoB,MAC3C,GAAW,KAAK,gBAAgB,GAClC,KACS,QAAQ,GAAK,EAAE,IAIhC,aAAgC,EAAS,EAAqC,aACrE,GAAG,EAAM,GACP,IAAM,MACJ,IAAI,EAAM,IAIvB,GAAsB,EAAS,EAA+B,IACtD,GAAW,KAAK,gBAAgB,GAC/B,SACI,yBAAyB,QACzB,gBAAgB,GAAQ,EAAW,GAAI,QAEvC,IAAI,GAGjB,IAAuB,EAAS,EAA+B,MACrD,GAAW,KAAK,gBAAgB,GAClC,MACS,OAAO,GACZ,EAAS,OAAS,UACX,MAAK,gBAAgB,QACvB,0BAA0B,KAK3C,yBAA4C,EAAe,EAE3D,0BAA6C,EAAe,GC3CzD,KAAM,IAAmB,GAAW,OAAQ,WAAY,SAGlD,EAA0B,QAC1B,GAAgB,+BAChB,EAAmB,uBAEzB,eAA8B,MAAM,CACvC,YAAY,EAAM,EAAO,EAAa,KAAM,CACxC,MAAM,oBAAoB,IAAO,EAAa,KAAK,KAAK,UAAU,GAAc,MAChF,KAAK,KAAO,EACZ,KAAK,MAAQ,EACb,KAAK,QAAU,GAIhB,KAAM,IAAsB,UAE5B,YAAgC,EAAS,EAAQ,EAAe,EAAY,EAAO,EAAM,OAAW,SACvG,KAAM,GAAQ,OAAO,OAAO,GAAI,GAChC,MAAO,GAAM,SACb,MAAO,GAAM,WACb,KAAM,GAAgBC,GAAY,UAAU,GACtC,EAAY,uBAAO,aAAP,cAAoB,KAApB,cAA8B,GAAG,MAAuB,KAC1E,GAAI,CACA,GAAI,CAAC,EACD,KAAM,IAAI,OAAM,gBAGpB,SAAQ,eAAe,EAAY,EAAe,GAC3C,SACF,EAAP,CACE,GAAI,EAAK,CACL,KAAM,GAAU,EAAI,IAAI,CAAC,EAAG,+BAAgC,aAAY,gBAAe,cACvF,EAAQ,MAAQ,EAChB,EAAQ,SAAW,EAAI,MAAM,KAEjC,MAAO,IAIR,aAAqC,CACxC,MAAO,CACH,KAAQ,oBACR,UAAa,GACb,QAAW,CACP,UAAa,EACb,mBAAsB,OACtB,qBAAwB,MChDpC,YAA8B,EAAM,EAAiB,EAAe,EAAe,EAAW,CAC1F,MAAI,GAAgB,QAChB,GAAO,EAAgB,OAAO,CAAC,EAAM,IAC1B,GAAqB,EAAM,EAC9B,EAAe,EAAe,GACnC,IAEA,EAGJ,YAA2B,EAAc,EAAU,EAAO,SAC7D,KAAM,GAAc,oBAAc,QAAd,cAAqB,OAEzC,AAAI,MAAM,QAAQ,IACd,GAAQ,EAAY,OAAO,EAAU,IAEzC,KAAM,GAAiB,oBAAc,WAAd,cAAwB,OAE/C,MAAI,OAAM,QAAQ,IACd,GAAQ,EAAe,OAAO,CAAC,EAAM,IAC7B,OAAO,GAAM,WAAc,UAC3B,GAAQ,EAAS,EAAO,IAErB,GACR,IAEA,EAGX,YAA2B,EAAM,EAAc,EAAY,EAAW,CAClE,AAAI,EAAa,SACb,GAAO,GAAc,EAAM,EAAa,UAExC,IAAe,EAAK,YACpB,GAAO,EAAK,gBACZ,EAAK,WAAa,GAElB,EAAa,cACb,GAAO,EAAa,aAAa,OAAO,OAAO,GAAwB,IAK3E,EAAO,GAAkB,EAAc,CAAC,EAAM,IAAU,GAAkB,EAAM,EAAO,GAAY,GACnG,KAAM,GAAsB,EAAa,qBACzC,MAAI,IACA,GAAO,GAA0B,EAAM,IAGpC,EAGX,YAAmC,EAAM,EAAqB,CAC1D,KAAM,GAAiB,EAAoB,iBAAmB,EAC9D,AAAI,IAAmB,EAAK,gBACxB,GAAO,EAAK,gBACZ,EAAK,eAAiB,GAE1B,KAAM,GAAoB,EAAoB,mBAC9C,MAAI,KAAsB,EAAK,mBAC3B,GAAO,EAAK,gBACZ,EAAK,kBAAoB,GAEtB,EAGX,YAAgC,EAAM,EAAO,OACzC,GAAI,kBAAO,QAAS,QAAS,CACzB,GAAI,GAAO,oBAAO,UAAP,cAAgB,KAC3B,AAAI,EAAC,GAAQ,MAAM,QAAQ,IAAS,MAAO,IAAS,WAChD,GAAO,MAEX,EAAO,EAAK,gBACZ,EAAK,KAAO,EAEhB,MAAO,GAGJ,YAA2B,EAAM,EAAO,EAAW,WACtD,GAAI,EAAM,OAAS,gBACf,EAAO,EAAK,gBACZ,EAAK,qBAAuB,EAAM,yBAC3B,EAAM,OAAS,oBAAqB,CAC3C,KAAM,GAAY,KAAM,UAAN,cAAe,UACjC,AAAI,CAAC,EAAK,YAAc,IAAc,GAClC,GAAO,EAAK,gBACZ,EAAK,WAAa,EAAM,iBAErB,EAAM,OAAS,cAAe,CACrC,KAAM,GAAU,KAAM,UAAN,cAAe,KAC/B,AAAI,IAAY,EAAK,MACjB,GAAO,EAAK,gBACZ,EAAK,KAAO,WAET,EAAM,OAAS,gBAAiB,CACvC,KAAM,GAAS,KAAM,UAAN,cAAe,IAC9B,AAAI,IAAW,EAAK,WAChB,GAAO,EAAK,gBACZ,EAAK,UAAY,WAEd,EAAM,OAAS,yBAA0B,CAChD,KAAM,GAAU,EAAM,QACtB,EAAO,EAAK,gBACZ,EAAK,eAAiB,EAAQ,cACvB,EAAM,OAAS,gBAAiB,CACvC,KAAM,GAAU,EAAM,QACtB,GAAI,EAAQ,YAAc,IAAQ,EAAQ,aAAe,UAAY,CAAC,EAAK,gBAAiB,CACxF,GAAI,GACJ,AAAI,EAAM,SAAW,EACjB,EAAQ,EAAM,UACP,EAAM,YAAc,GAC3B,GAAQ,EAAM,QAEd,GACA,GAAO,EAAK,gBACZ,EAAK,gBAAkB,GACvB,EAAK,SAAW,OAEjB,AAAI,GAAQ,aAAe,SAAW,EAAK,iBAAmB,EAAK,WAAa,EAAM,WACzF,GAAO,EAAK,gBACZ,EAAK,gBAAkB,GACvB,EAAK,SAAW,MAGxB,MAAO,GAGX,YAA8B,EAAM,EAAY,EAAe,EAAe,EAAW,CACrF,MAAI,GAAW,YAAc,kBACrB,GAAC,EAAK,sBAAwB,EAAW,UAAY,EAAK,uBAC1D,GAAO,EAAK,gBACZ,EAAK,qBAAuB,EAAW,WAEvC,CAAC,GAAiB,EAAW,SAAW,GAAa,GACrD,GAAO,EAAK,gBACZ,EAAK,SAAW,KAGjB,EAGX,YAAuB,EAAM,EAAS,CAClC,KAAM,GAAS,EAAQ,YACjB,EAAY,EAAQ,yBACpB,EAAc,EAAQ,0BAI5B,MAAI,IAAU,MAAM,QAAQ,IACxB,GAAO,EAAK,gBACZ,EAAK,OAAS,GAEd,OAAO,UAAU,IACjB,GAAO,EAAK,gBACZ,EAAK,YAAc,GAEnB,OAAO,UAAU,IACjB,GAAO,EAAK,gBACZ,EAAK,UAAY,GAEd,EAGJ,QAAkB,CACrB,YAAY,EAAM,EAAQ,CACtB,KAAK,OAAS,EAAO,EAAK,OAAS,EACnC,KAAK,KAAO,EAAO,EAAK,KAAO,KAC/B,KAAK,qBAAuB,EAAO,EAAK,qBAAuB,KAC/D,KAAK,SAAW,EAAO,EAAK,SAAW,GACvC,KAAK,WAAa,EAAO,EAAK,WAAa,KAC3C,KAAK,WAAa,EAAO,EAAK,WAAa,KAC3C,KAAK,YAAc,EAAO,EAAK,YAAc,EAC7C,KAAK,UAAY,EAAO,EAAK,UAAY,EACzC,KAAK,OAAS,EAAO,EAAK,OAAS,KACnC,KAAK,eAAiB,EAAO,EAAK,eAAiB,KACnD,KAAK,kBAAoB,EAAO,EAAK,kBAAoB,GACzD,KAAK,kBAAoB,EAAO,EAAK,kBAAoB,GACzD,KAAK,UAAY,EAAO,EAAK,UAAY,KACzC,KAAK,kBAAoB,EAAO,EAAK,kBAAoB,EACzD,KAAK,eAAiB,EAAO,EAAK,eAAiB,EACnD,KAAK,KAAO,EAAO,EAAK,KAAO,KAC/B,KAAK,gBAAkB,EAAO,EAAK,gBAAkB,GACrD,KAAK,SAAW,EAAO,EAAK,SAAW,KACvC,KAAK,OAAS,IAGlB,KAAK,EAAO,CAER,MAAO,AADO,QAAO,oBAAoB,MAC5B,OAAO,CAAC,EAAM,IACnB,KAAS,UACL,KAAK,KAAU,EAAM,IACrB,GAAK,GAAQ,KAAK,IAGnB,GACR,IAGP,eAAgB,CACZ,MAAI,MAAK,OACE,KAEA,GAAI,IAAY,MAI/B,WAAY,CACR,MAAO,QAAO,QAAQ,MAAM,OAAO,CAAC,EAAK,CAAC,EAAK,KACvC,KAAQ,UAAY,IAAU,MAC9B,GAAI,GAAO,GAER,GACR,IAGP,qBAAqB,EAAiB,EAAe,EAAe,EAAW,CAC3E,MAAO,IAAqB,KAAM,EAAiB,EAAe,EAAe,GAGrF,kBAAkB,EAAc,EAAY,EAAW,CACnD,MAAO,IAAkB,KAAM,EAAc,EAAY,MAGzD,cAAc,CACd,MAAO,CAAC,KAAK,MAAQ,CAAC,KAAK,gBAAkB,KAAK,QAAU,KAAK,OAAO,OAAS,EAGrF,UAAU,EAAS,CACf,MAAO,MAAK,aAAe,QAAU,EAAQ,aAAe,QAI7D,QAAkB,CACxB,YAAY,EAAQ,CACb,KAAK,MAAQ,KACb,KAAK,aAAa,GAAI,IAAY,KAAM,OAGxC,OAAO,CACP,MAAO,MAAK,MAGhB,iBAAiB,EAAK,CAClB,KAAM,GAAO,GAAI,IAAY,KAAK,OAClC,SAAK,SAAW,GAChB,EAAK,kBAAoB,EACzB,EAAK,eAAiB,EACtB,EAAI,YAAY,IAAI,EAAK,aAClB,EAGX,uBAAuB,EAAO,EAAK,CAC/B,KAAM,GAAO,GAAI,IAAY,KAAK,OAClC,SAAK,kBAAoB,EACzB,EAAI,YAAY,IAAI,EAAK,aAClB,EAGX,uBAAuB,EAAO,EAAK,CAC/B,KAAM,GAAO,GAAI,IAAY,KAAK,OAClC,SAAK,kBAAoB,EACzB,EAAI,YAAY,IAAI,EAAK,aAClB,EAGd,UAAU,EAAM,EAAK,CACpB,GAAI,IAAS,KAAK,MACR,SAAI,YAAY,IAAI,EAAK,aAClB,EAKf,kBAAkB,EAAM,EAAK,CACzB,GAAI,IAAS,KAAK,MACd,SAAI,oBAAoB,IAAI,EAAK,aAC1B,OAIT,mBAAkB,EAAM,EAAS,CACnC,GAAI,IAAS,KAAK,MACd,MAAO,GAEX,KAAM,GAAM,KAAM,GAAQ,aAAa,CACnC,EAAQ,WAAW,cAEvB,GAAI,CACA,EAAI,YAAY,IAAI,EAAK,mBACpB,EAAP,CACE,QAAI,QACE,EAEV,YAAM,GAAI,WACV,KAAK,aAAa,GACX,GAGX,aAAa,EAAM,CACf,KAAK,MAAQ,EAGb,KAAK,MAAM,OAAS,QAGrB,MAAK,EAAS,CACb,KAAK,aAAa,GAAI,IAAY,QCrT9B,GAAL,UAAK,EAAL,WACO,sBACE,0BACE,oCACQ,gCACZ,wBACI,+BACG,qCACG,wCACA,oCACJ,iCACC,oCACE,iCACL,qCACS,+CACC,kDACE,uCACb,2BACC,gBAlBN,gBAqBC,IAAsC,OAAO,OAAO,mBAE/B,MAAM,CAIpC,YAAY,EAAiB,EAAsB,KAAM,OAC/C,GACF,SACK,QAAU,EAAM,WAEpB,MAAQ,KAGb,OAAe,OACR,qBAIF,GAAY,IACjB,gBAAwB,OAEjB,OAGP,mBAA2B,OAEpB,gBAGP,gBAAwB,OAEjB,qBCjDO,CAClB,YACW,EACA,EACT,qCAGF,iBAA4B,OAEjB,IAAI,GAAS,KAAK,WAAa,EAAG,EAAU,kBAGvD,oBAAoB,EAAgC,OAC5C,GAAU,UACH,KAAK,UAEL,KAAK,cAIpB,aAAwB,OACb,IAAI,GAAS,KAAK,WAAY,KAAK,WAAa,GAG3D,SAAoB,OACT,IAAI,GAAS,KAAK,WAAY,KAAK,WAAa,aAGhD,SAAmB,OACnB,IAAI,GAAS,EAAU,cAAe,EAAU,yBAGhD,SAAmB,OACnB,IAAI,GAAS,EAAU,cAAe,EAAU,yBAGhD,iBAA2B,OAC3B,GAAS,mBAAmB,EAAU,qBAG1C,oBAAmB,EAA8B,OAC7C,IAAI,GAAS,EAAY,EAAU,kBAG9C,UAAmB,OACR,IAAI,KAAK,cAAc,KAAK,cAGvC,OAAO,EAA0B,OACtB,MAAK,aAAe,kBAAO,aAAc,KAAK,aAAe,kBAAO,kBCnDtE,IAAsB,OAAO,yBAMV,CAC5B,YACuB,EACrB,4BAOF,QAAQ,EAA+B,OAC/B,MAAK,aAAe,EAAW,WACxB,KAAK,WAAa,EAAW,WAC7B,KAAK,aAAe,GACpB,EACA,EAAW,aAAe,GAC1B,GAGA,KAAK,oBAAoB,QAAQ,KAAK,WAAY,EAAW,YAI5E,YAAuB,OACZ,IAAI,GAAS,KAAK,WAAY,KAAK,yBChCL,EAAO,aAGzC,MAAM,WAAN,cAAgB,eAAgB,EAAM,kBAGpC,GAAiB,+BAEH,EAAO,aACvB,CAAC,CAAC,qBAAO,WAAP,cAAiB,qBAGlB,GAAL,UAAK,EAAL,UACI,GAAP,wBACe,GAAf,2BACU,GAAV,qBACS,GAAT,sBACW,IAAX,wBACW,IAAX,aANQ,cASA,GAAL,UAAK,EAAL,wFAAK,WCnBL,KAAM,IAAgB,aAChB,GAA2B,eAEjC,YAA0B,EAAU,EAAK,CAC5C,MAAO,CACH,eAAgB,CACZ,SAAY,EACZ,MACA,SAAY,KAKjB,YAA2B,EAAU,OACxC,MAAO,GAAS,UAAY,MAAS,mBAAT,cAA2B,UAGpD,YAA2B,EAAU,EAAQ,CAChD,AAAI,EAAS,WAAa,OACtB,EAAS,SAAW,EACb,EAAS,kBAChB,GAAS,iBAAiB,SAAW,GAItC,YAA2B,EAAO,CACxC,GAAI,EAAM,OAAS,EACZ,MAAO,GAAM,QACV,CACH,KAAM,GAAW,GAAY,GAC7B,GAAI,EACA,MAAO,IAAkB,GAGjC,MAAO,MAGJ,YAAgC,EAAS,CAC5C,MAAO,kBAAU,gBAGd,YAAqB,EAAO,CAClC,MAAO,IAAuB,EAAM,SC5C9B,QAAwB,CAC3B,aAAc,CAGV,KAAK,SAAW,MAGhB,iBAAiB,CACjB,MAAO,MAAK,SAAS,OAAO,CAAC,EAAI,IACzB,EAAE,YACK,EAEJ,KAAK,IAAI,EAAE,UAAW,GAC9B,OAAO,qBAGV,kBAAkB,CAClB,MAAO,MAAK,SAAS,KAAK,GAAK,CAAC,EAAE,gBAGlC,iBAAiB,CACjB,MAAO,MAAK,SAAS,KAAK,GAAK,EAAE,gBAGjC,QAAQ,CACR,MAAO,MAAK,SAAS,OAAO,CAAC,EAAO,IACzB,EAAS,GAAE,YAAc,GAAK,GACtC,GAGP,IAAI,EAAO,CACP,KAAK,SAAS,KAAK,GAGvB,OAAO,EAAO,CACV,KAAM,GAAM,KAAK,SAAS,QAAQ,GAClC,MAAI,KAAQ,GACD,GAEX,MAAK,SAAS,OAAO,EAAK,GACnB,OAGP,eAAe,CACf,KAAM,GAAY,KAAK,SAAS,OAAO,CAAC,EAAW,IAC3C,CAAC,GAAa,EAAE,aAAa,WAAa,EAAU,aAAa,WAC1D,EAEJ,EACR,MACH,MAAI,GACO,CAAC,EAAU,YAEf,MAGP,UAAU,CACV,MAAO,MAAK,SAAS,SAAW,GCzDxC,YAAoB,EAAQ,CACxB,MAAO,GAAO,QAAQ,KAAM,SAAS,QAAQ,KAAM,QAAQ,QAAQ,KAAM,QAG7E,YAAsC,EAAS,CAC3C,OAAQ,OACC,SACD,MAAO,mBACN,UACD,MAAO,qBACN,UACD,MAAO,oBACN,UACD,MAAO,sBAEf,MAAO,MAGX,YAAwB,EAAS,CAC7B,MAAO,KAAY,UAAY,KAAO,GAG1C,YAA6B,EAAU,EAAS,EAAM,EAAe,CACjE,MAAO,CACH,UACA,OACA,OAAU,yBACV,eAAkB,EAClB,eAAgB,CACZ,gBAAiB,CACb,SAAY,KAMrB,YAA4B,EAAO,EAAS,EAAM,CAErD,KAAM,GAAa,GAA6B,EAAM,QAAQ,SACxD,EAAS,GAAe,EAAM,QAAQ,SACtC,EAAS,EAAM,OACf,EAAO,EAAM,aAAe,EAE5B,EAAgB,GAAc,EAAM,QAAQ,gBAC7C,EAAM,QAAQ,MAAQ,GAAW,EAAM,QAAQ,OAAU,GACxD,EAAoB,qCAAqC,iCAC3B,MAAW,cACxC,4BAGD,EAAY,AADA,IAAc,EAAM,QAAQ,MAAQ,IAC1B,MAAM;AAAA,GAClC,EAAU,GAAK,KAAK,KAAU,MAAW,EAAU,KAGnD,KAAM,GAAU,AAFM,EAAU,KAAK;AAAA,KAEL;AAAA;AAAA,EAAS,EACnC,EAAmB,EAAoB,GAAW,GACxD,MAAO,IAAoB,EAAM,GAAI,EAAS,EAAS,GChDpD,gBAA6B,GAAU,CAC1C,YAAY,EAAoB,CAC5B,MAAM,GACN,KAAK,mBAAqB,KAC1B,KAAK,oBAAsB,KAC3B,KAAK,cAAgB,KACrB,KAAK,mBAAqB,QAG1B,UAAU,OACV,MAAO,CAAC,CAAC,SAAK,WAAL,cAAgB,qBAGzB,cAAc,CACd,MAAO,CAAC,CAAC,KAAK,sBAGd,aAAa,CACb,MAAO,MAAK,eAGZ,cAAc,CACd,MAAO,MAAK,YAAc,KAG1B,kBAAkB,OAClB,MAAI,MAAK,mBACE,QAAK,mBAAmB,GAAG,UAA3B,cAAoC,OAExC,KAGX,gBAAgB,EAAO,CACnB,KAAK,cAAgB,EACrB,EAAM,gBAAgB,MAG1B,gBAAgB,EAAO,CACnB,AAAK,KAAK,oBACN,MAAK,mBAAqB,IAE9B,KAAK,mBAAmB,KAAK,MAG7B,oBAAoB,CACpB,MAAO,MAAK,sBAGZ,eAAe,CACf,MAAO,MAAK,cAUhB,iBAAiB,EAAO,CACpB,GAAI,EAAM,YAAc,GAAkB,EAAM,cAAc,KAAK,KAK/D,GAJK,KAAK,oBACN,MAAK,mBAAqB,IAE9B,KAAK,mBAAmB,KAAK,GACzB,KAAK,mBAAmB,SAAW,EACnC,MAAO,iBAER,CACH,KAAM,GAAgB,EAAM,gBAAkB,EAC9C,GAAI,EAAc,cAAc,KAAK,KAC7B,EAAc,SAAS,WAAa,IAChC,KAAK,sBAAsB,GAC3B,MAAO,sBAW3B,oBAAoB,EAAO,OACvB,GAAI,EAAM,YAAc,GAAkB,EAAM,cAAc,KAAK,KAAO,KAAK,mBAAoB,CAC/F,KAAM,GAAc,KAAK,mBAAmB,OAE5C,GADA,KAAK,mBAAqB,KAAK,mBAAmB,OAAO,GAAK,IAAM,GAChE,KAAK,mBAAmB,SAAW,GACnC,MAAK,mBAAqB,KACtB,IAAgB,GAChB,MAAO,iBAGZ,CACH,KAAM,GAAgB,EAAM,gBAAkB,EAC9C,GAAI,EAAc,cAAc,KAAK,KAC7B,MAAc,WAAd,cAAwB,YAAa,IAA4B,KAAK,qBAClE,KAAK,yBAAyB,GAC9B,MAAO,sBAO3B,sBAAsB,EAAO,CACzB,AAAK,KAAK,qBACN,MAAK,oBAAsB,GAAI,MAEnC,KAAM,CAAC,OAAQ,GAAM,gBAAkB,GAAO,SAC9C,GAAI,EAAK,CACL,GAAI,GAAa,KAAK,oBAAoB,IAAI,GAC9C,MAAK,IACD,GAAa,GAAI,IACjB,KAAK,oBAAoB,IAAI,EAAK,IAEtC,EAAW,IAAI,GACR,GAEX,MAAO,GAGX,yBAAyB,EAAO,CAC5B,KAAM,CAAC,OAAQ,GAAM,gBAAkB,GAAO,SAC9C,GAAI,EAAK,CACL,GAAI,GAAa,KAAK,oBAAoB,IAAI,GAC9C,MAAI,GAAW,OAAO,IAAU,EAAW,SACvC,KAAK,oBAAoB,OAAO,GAEhC,KAAK,oBAAoB,OAAS,GAClC,MAAK,oBAAsB,MAExB,GAEX,MAAO,QAGL,wBAAwB,CAC1B,GAAI,KAAK,mBACL,SAAW,KAAO,MAAK,mBACnB,KAAM,GAAI,aAAa,WAO/B,mBAAmB,CACnB,MAAI,MAAK,mBACE,KAAK,mBAAmB,GAE5B,KAGX,SAAS,EAAK,CACV,MAAO,IAAiB,KAAK,GAAI,GAGrC,MAAM,EAAS,EAAM,CACjB,MAAO,IAAmB,KAAM,EAAS,GAI7C,cAAc,EAAI,CACd,MAAO,IAAM,KAAK,iBAAmB,EAGzC,eAAe,EAAK,WAChB,KAAM,GAAqB,YAAK,cAAL,cAAmB,KAAnB,cAAyB,KAAM,GACpD,EAAoB,QAAK,qBAAL,cAAyB,IAAI,GACjD,EAAe,kBAAmB,eAAgB,GAOxD,MAAQ,IAAuB,EAAC,GAAqB,IAChD,CAAC,GAAsB,KAG5B,WAAW,CACX,MAAO,IAAuB,KAAK,YAGnC,qBAAqB,CACrB,MAAO,MAAK,uBAGZ,cAAc,CACd,MAAO,OCpMR,gBAAgC,GAAe,CAClD,YAAY,CAAC,eAAc,SAAQ,QAAO,kBAAiB,CACvD,MAAM,MACN,KAAK,cAAgB,EAErB,KAAK,QAAU,EAIf,KAAK,WAAa,EAAM,MAAS,KAAM,EAAa,YACpD,KAAK,gBAAkB,KAGvB,aAAa,CACb,MAAO,OAGP,aAAa,CACb,MAAO,MAAK,cAAc,cAG1B,UAAU,CACV,MAAO,MAAK,cAAc,WAG1B,QAAQ,CACR,MAAO,SAGP,YAAY,CACZ,MAAO,MAAK,cAAc,aAG1B,WAAW,CACX,MAAO,SAGP,SAAS,OACT,MAAO,QAAK,UAAL,cAAc,UAGrB,cAAc,OACd,MAAO,QAAK,UAAL,cAAc,QAGrB,YAAY,OACZ,MAAO,QAAK,UAAL,cAAc,aAGrB,YAAY,CACZ,MAAO,MAAK,cAGZ,YAAY,CACZ,MAAO,MAGP,KAAK,CACL,MAAO,MAAK,cAAc,SAG1B,eAAe,CACf,MAAO,MAAK,cAGhB,cAAe,EAIf,cAAc,EAAI,CACd,MAAI,IAAM,IAAO,KAAK,cAAc,aACzB,GAEJ,MAAM,cAAc,MAG3B,iBAAiB,CACjB,MAAO,MAAK,cAAc,kBAG1B,iBAAiB,CACjB,MAAO,MAAK,mBAGZ,iBAAiB,OACjB,MAAI,MAAK,QACE,QAAK,cAAc,iBAAnB,OAAqC,KAAK,cAAc,aAE5D,MCvFR,KAAM,GAAa,GACtB,UACA,wBACA,uBACA,aACA,UACA,OACA,SAGE,GAA2B,CAAE,gBAE5B,QAAmB,CACtB,YAAY,CAAC,OAAM,SAAQ,aAAY,eAAc,CACjD,KAAK,MAAQ,EACb,KAAK,aAAe,EACpB,KAAK,YAAc,EACnB,KAAK,yBAA2B,EAChC,KAAK,SAAW,GAChB,KAAK,QAAU,EAAW,QAC1B,KAAK,aAAe,KACpB,KAAK,uBAAyB,EAC1B,KAAK,cACL,MAAK,uBAAyB,OAAO,OAAO,KAAK,cAAc,OAAO,CAAC,EAAG,IAAM,EAAI,EAAE,KAAM,OAIhG,SAAS,CAAE,MAAO,MAAK,MAAM,UAC7B,aAAa,CAAE,MAAO,MAAK,MAAM,cACjC,YAAY,CAAE,MAAO,MAAK,MAAM,aAChC,QAAQ,CAAE,MAAO,MAAK,MAAM,SAC5B,WAAW,CAAE,MAAO,MAAK,MAAM,YAC/B,UAAU,CAAE,MAAO,MAAK,MAAM,WAC9B,eAAe,CAAE,MAAO,MAAK,MAAM,gBACnC,iBAAiB,CACjB,KAAM,GAAW,GAAuB,KAAK,SAC7C,MAAI,GAEO,GAAkB,GAElB,KAAK,MAAM,eAI1B,kBAAkB,EAAS,CACvB,KAAM,GAAW,GAAuB,KAAK,SAC7C,AAAI,EACA,GAAkB,EAAU,GAE5B,KAAK,MAAM,eAAiB,KAIhC,OAAO,CAAE,MAAO,MAAK,MAEzB,cAAc,EAAK,CACf,MAAO,MAAK,cAAgB,KAAK,aAAa,MAG9C,eAAe,CACf,MAAO,CAAC,KAAK,UAAY,CAAC,KAAK,WAG/B,kBAAkB,CAClB,MAAO,MAAK,MAAM,iBAAmB,CAAC,KAAK,WAG3C,cAAc,CACd,MAAO,MAAK,MAAM,aAAe,CAAC,KAAK,WAGvC,uBAAuB,CACvB,MAAO,MAAK,aAAe,CAAC,KAAK,aAGrC,eAAgB,CACZ,KAAK,QAAU,EAAW,WAC1B,KAAK,YAAY,aAGjB,uBAAuB,CACvB,KAAM,GAAU,OAAO,OAAO,GAAI,KAAK,MAAM,SAC7C,SAAW,KAAS,IAChB,MAAO,GAAQ,GAEnB,MAAO,GAGX,uBAAuB,EAAM,CACzB,KAAM,GAAU,KAAK,MAAM,QAC3B,SAAW,KAAS,IAChB,AAAI,EAAQ,KAAW,QACnB,GAAK,GAAS,EAAQ,IAKlC,aAAa,EAAM,EAAS,CACxB,KAAK,uBAAuB,GAC5B,KAAK,MAAM,mBAAqB,EAChC,KAAK,MAAM,iBAAmB,EAC9B,KAAK,MAAM,gBAAkB,GAGjC,SAAS,EAAO,CACZ,KAAK,QAAU,EAAW,MAC1B,KAAK,OAAS,EACd,KAAK,YAAY,UAGrB,YAAa,CACT,KAAK,QAAU,EAAW,QAC1B,KAAK,YAAY,aAGjB,SAAS,CAAE,MAAO,MAAK,WACvB,QAAQ,CAAE,MAAO,MAAK,UAEtB,oBAAoB,CACpB,MAAO,MAAK,UAAY,EAAW,SAAW,KAAK,UAAY,EAAW,QAG1E,wBAAwB,CACxB,MAAO,MAAK,0BAGZ,uBAAuB,CACvB,MAAO,MAAK,cAAgB,OAAO,OAAO,KAAK,cAAc,OAAO,CAAC,EAAG,IAAM,EAAI,EAAE,UAAW,QAG7F,mBAAkB,EAAO,EAAK,CAChC,GAAI,CAAC,KAAK,YACN,OAEJ,GAAI,CAAC,KAAK,aACN,KAAM,IAAI,OAAM,uBAEpB,GAAI,KAAK,gBAAiB,CACtB,KAAK,QAAU,EAAW,sBAC1B,KAAK,YAAY,UACjB,SAAW,KAAc,QAAO,OAAO,KAAK,cAKxC,GAJA,KAAM,GAAI,KAAK,UAAW,IACtB,GAAI,IAAI,OAAQ,EAAW,MACpB,EAAW,YAElB,KAAK,QACL,KAAM,IAAI,GAItB,KAAK,QAAU,EAAW,qBAC1B,KAAK,YAAY,UACjB,KAAM,GAAU,OAAO,QAAQ,KAAK,cAEpC,EAAQ,KAAK,CAAC,EAAG,GAAK,EAAG,KAAQ,EAAG,KAAO,EAAG,MAC9C,SAAW,CAAC,EAAS,IAAe,GAChC,KAAM,GAAI,KAAK,SAAU,GACrB,GAAI,IAAI,OAAQ,EAAW,MACpB,EAAW,OAAO,EAAO,IAAM,CAClC,KAAK,YAAY,yBAClB,KAEP,EAAW,eAAe,EAAS,KAAK,SAE5C,KAAK,MAAM,YAAc,QAGvB,QAAQ,OACV,GAAI,CAAC,KAAK,SAAU,CAEhB,GADA,KAAK,SAAW,GACZ,KAAK,aACL,SAAW,KAAc,QAAO,OAAO,KAAK,cACxC,EAAW,QAGnB,QAAK,eAAL,QAAmB,QACnB,KAAM,MAAK,+BAIf,UAAU,CACV,MAAO,MAAK,cAGV,MAAK,EAAO,EAAK,CACnB,KAAK,QAAU,EAAW,QAC1B,KAAK,YAAY,UACjB,KAAM,GAAY,KAAK,MAAM,oBAAsB,KAAK,MAAM,UACxD,EAAU,KAAK,MAAM,kBAAoB,KAAK,MAAM,QAC1D,AAAI,IAAc,EACd,KAAK,aAAe,EAAM,OAClB,KAAK,OACL,KAAK,MAAM,eACX,KAAK,MACL,EACA,CAAC,QAGT,KAAK,aAAe,EAAM,KAClB,KAAK,OACL,EACA,KAAK,MACL,EACA,CAAC,QAGb,KAAM,GAAW,KAAM,MAAK,aAAa,WACzC,KAAK,aAAe,KAEpB,KAAK,MAAM,SAAW,EAAS,SAC/B,EAAI,IAAI,KAAM,KAAK,MAAM,UACzB,KAAK,QAAU,EAAW,KAC1B,KAAK,YAAY,UAGrB,SAAU,CACN,GAAI,KAAK,aACL,SAAW,KAAc,QAAO,OAAO,KAAK,cACxC,EAAW,WC1NpB,eAAyB,GAAe,CAC3C,YAAY,EAAY,EAAoB,CACxC,MAAM,GACN,KAAK,YAAc,EACnB,KAAK,iBAAmB,KACxB,KAAK,kBAAoB,KAG7B,OAAQ,CACJ,KAAM,GAAQ,GAAI,GAAW,KAAK,YAAa,KAAK,qBACpD,SAAM,WAAW,MACV,EAGX,WAAW,EAAO,CACd,AAAI,EAAM,mBAAqB,CAAC,KAAK,mBACjC,MAAK,kBAAoB,EAAM,mBAE/B,EAAM,kBAAoB,CAAC,KAAK,kBAChC,MAAK,iBAAmB,EAAM,kBAElC,KAAK,mBAAqB,EAAM,kBAChC,KAAK,cAAgB,EAAM,gBAG3B,QAAQ,CACR,MAAO,MAAK,YAAY,SAGxB,aAAa,CACb,MAAO,MAAK,YAAY,cAGxB,aAAa,CACb,MAAO,MAAK,YAAY,cAGxB,UAAU,SACV,MAAO,YAAK,oBAAL,cAAwB,QAAxB,cAA+B,UAAW,KAAK,YAAY,MAAM,WAGxE,cAAc,CAEd,MAAO,IAA6B,KAAK,YAAY,UAGrD,YAAY,SACZ,MAAO,YAAK,oBAAL,cAAwB,QAAxB,cAA+B,OAAQ,KAAK,YAAY,MAAM,QAGrE,WAAW,CACX,MAAO,MAAK,YAAY,MAAM,aAG9B,SAAS,CACT,MAAO,MAAK,YAAY,MAAM,UAG9B,cAAc,CACd,MAAO,MAAK,YAAY,eAGxB,YAAY,CACZ,MAAO,MAAK,YAAY,aAGxB,YAAY,CACZ,MAAO,MAAK,YAAY,MAAM,oBAG9B,KAAK,CACL,MAAO,MAAK,YAAY,MAAM,SAGlC,oBAAoB,EAAQ,CACxB,KAAK,kBAAoB,KAGzB,cAAc,CACd,MAAO,MAAK,YAAY,MAAM,OAAS,sBAGvC,cAAc,OACd,MAAO,CAAC,CAAC,SAAK,oBAAL,cAAwB,UAGjC,aAAa,OACb,MAAO,MAAK,aAAe,SAAK,oBAAL,cAAwB,eAGnD,eAAe,OACf,MAAO,MAAK,aAAe,SAAK,oBAAL,cAAwB,cAGvD,mBAAmB,EAAK,CACpB,KAAK,iBAAmB,KAGxB,kBAAkB,CAClB,MAAO,MAAK,oBAGZ,iBAAiB,CACjB,MAAO,IAAkB,KAAK,UAG9B,aAAa,CACb,MAAO,OAAM,YAAc,GAAW,KAAK,YAAY,UAGvD,kBAAkB,SAClB,KAAM,GAAiB,QAAK,YAAY,MAAM,WAAvB,cAAiC,iBACxD,MAAI,GACO,KAAe,UAAf,cAAwB,OAG5B,MAAM,mBAGb,cAAc,CACd,MAAO,MAAK,YAAY,eAGxB,WAAW,CACX,KAAM,GAAkB,KAAK,YAAY,MAAM,QAE/C,MAAO,AADkB,IAAmB,GAAuB,IACxC,GAAuB,KAAK,YAIvD,iBAAiB,CACjB,MAAI,MAAK,QACE,KAAK,eAET,MC1IR,YAA0B,EAAK,EAAQ,EAAO,CACjD,MAAO,CACH,WAAY,EAAI,WAChB,WAAY,EAAI,WAChB,SACA,MAAO,GAIR,YAA2B,EAAO,EAAO,EAAW,CACvD,AAAI,EAAU,UACV,EAAM,KAAK,GAEX,EAAM,QAAQ,GAIf,YAA2B,EAAO,EAAY,EAAW,CAC5D,MAAI,GAAU,UACH,EAAM,OAAO,GAEb,EAAW,OAAO,GCnB1B,KAAMC,GAAa,gBAEnB,OAAiB,CACpB,YAAY,EAAM,CACd,KAAK,MAAQ,QAGV,YAAW,EAAQ,EAAQ,EAAY,CAC1C,MAAO,IAAI,GAAW,CAAC,SAAQ,SAAQ,qBAGpC,iBAAgB,EAAQ,EAAa,CACxC,KAAM,GAAS,iBAAa,UAC5B,GAAI,MAAO,IAAW,SAClB,OAEJ,KAAM,GAAU,EAAY,QACtB,EAAc,GAA6B,GAC3C,EAAa,iBAAS,WAGtB,EAAc,kBAAS,cAAe,kBAAa,aACnD,EAAY,kBAAS,aAAc,kBAAa,YACtD,MAAO,MAAK,yBAAyB,EAAQ,EAAQ,EAAY,EAAa,SAM3E,0BAAyB,EAAQ,EAAa,CACjD,KAAM,GAAS,GAAe,EAAY,UAC1C,GAAI,MAAO,IAAW,SAClB,OAEJ,KAAM,GAAU,GAA6B,GAC7C,MAAO,MAAK,yBAAyB,EAAQ,EACzC,iBAAS,WACT,iBAAS,YACT,iBAAS,kBAIV,0BAAyB,EAAQ,EAAQ,EAAY,EAAa,EAAW,CAChF,GAAI,MAAO,IAAe,SAG1B,MAAO,IAAI,GAAW,CAClB,SACA,SACA,aACA,YACA,mBAIJ,aAAa,CACb,MAAO,MAAK,MAAM,cAMlB,cAAc,CACd,MAAO,MAAK,MAAM,eAMlB,OAAO,CACP,MAAO,MAAK,MAAM,aAAe,KAAK,MAAM,UAM5C,YAAY,CACZ,MAAO,MAAK,MAAM,aAGlB,SAAS,CACT,MAAO,MAAK,MAAM,UAGlB,SAAS,CACT,MAAO,MAAK,MAAM,OAGtB,WAAY,CACR,MAAO,MAAK,MAGhB,OAAO,EAAO,CACV,KAAM,GAAO,KAAK,MACZ,EAAY,EAAM,MACxB,MAAO,GAAK,SAAW,EAAU,QAC7B,EAAK,SAAW,EAAU,QAC1B,EAAK,aAAe,EAAU,YAC9B,EAAK,cAAgB,EAAU,aAC/B,EAAK,YAAc,EAAU,WAIlC,QAAmB,CACtB,YAAY,EAAQ,EAAoB,CACpC,KAAK,OAAS,EACd,KAAK,mBAAqB,KAG1B,SAAS,CACT,MAAO,MAAK,OAAO,UAGnB,SAAS,CACT,MAAO,MAAK,OAAO,UAGnB,aAAa,CACb,MAAO,MAAK,OAAO,cAGnB,UAAU,CACV,MAAO,MAAK,qBAAuB,QAAU,KAAK,aAAe,UAajE,YAAY,CACZ,MAAO,MAAK,qBAAuB,QAAU,KAAK,aAAe,QC1IlE,YAA2B,EAAI,CAClC,MAAO,OAAO,IAAO,SAazB,KAAM,IAAuB,CACzB,WAAY,OAAQ,UAAW,UAAW,SAAU,YAAa,aACjE,UAAW,WAAY,oBACzB,OAAO,SAAS,EAAK,EAAK,CACxB,SAAI,GAAO,EAAU,GACtB,IAGG,GAA2B,CAC7B,gBAAiB,CAAC,WAAc,GAChC,gBAAiB,CAAC,QAAW,GAC7B,oBAAqB,CAAC,UAAa,GACnC,sBAAuB,CAAC,IAAO,EAAG,OAAU,EAAG,eAAkB,EACzC,KAAQ,EAAG,OAAU,EAAG,cAAiB,EACzC,MAAS,EAAG,cAAiB,GAErD,iBAAkB,CAAC,QAAW,IAI3B,YAAqB,EAAgB,EAAe,CACvD,SAAW,KAAO,QAAO,KAAK,GAC1B,AAAK,GAAqB,IACtB,MAAO,GAAc,GAG7B,KAAM,CAAE,WAAY,EACd,EAAU,GAAyB,EAAc,MACvD,SAAW,KAAO,QAAO,KAAK,GAC1B,AAAK,kBAAU,KACX,MAAO,GAAQ,GAGvB,EAAc,SAAW,EAAc,UAAY,GACnD,EAAc,SAAS,iBAAmB,ECtB9C,YAAsC,EAAS,EAAM,CACjD,KAAM,GAAiB,GACvB,KAAO,GAAkB,EAAQ,aAAa,CAC1C,KAAM,GAAW,EAAK,IAAI,EAAQ,YAClC,GAAI,CAAC,EACD,MAEJ,GAAI,EAAS,SAAW,EAAQ,GAC5B,KAAM,IAAI,OAAM,qBAAqB,EAAS,4BAA4B,EAAQ,MAEtF,EAAK,OAAO,EAAQ,YACpB,EAAe,QAAQ,GACvB,EAAU,EAEd,MAAO,GAGX,YAAqC,EAAS,EAAM,CAChD,KAAM,GAAiB,GACvB,KAAO,GAAkB,EAAQ,SAAS,CACtC,KAAM,GAAO,EAAK,IAAI,EAAQ,QAC9B,GAAI,CAAC,EACD,MAEJ,GAAI,EAAK,aAAe,EAAQ,GAC5B,KAAM,IAAI,OAAM,iBAAiB,EAAK,4BAA4B,EAAQ,MAE9E,EAAK,OAAO,EAAQ,QACpB,EAAe,KAAK,GACpB,EAAU,EAEd,MAAO,GAIX,YAAuB,EAAW,CAC9B,KAAM,GAAO,GAAI,KACjB,OAAQ,KAAK,GACT,EAAK,IAAI,EAAE,GAAI,GAGnB,KAAM,GAAU,GAChB,KAAM,EAAK,MAAM,CACb,KAAM,GAAU,EAAK,SAAS,OAAO,MACrC,EAAK,OAAO,EAAQ,IAEpB,KAAM,GAAmB,GAA6B,EAAS,GACzD,EAAe,GAA4B,EAAS,GACpD,EAAS,EAAiB,OAAO,EAAS,GAChD,EAAQ,KAAK,GAEjB,MAAO,GAAQ,IAAI,GAAK,GAAI,IAAO,IAGvC,QAAe,CACX,YAAY,EAAI,EAAY,EAAQ,CAChC,KAAK,GAAK,EACV,KAAK,WAAa,EAClB,KAAK,OAAS,GAItB,QAAa,CACT,YAAY,EAAiB,CACzB,KAAK,eAAiB,GAAI,KAC1B,EAAgB,QAAQ,CAAC,EAAG,IAAM,CAC9B,KAAK,eAAe,IAAI,EAAE,GAAI,KAItC,QAAQ,EAAK,EAAK,CACd,KAAM,GAAa,KAAK,eAAe,IAAI,GAC3C,GAAI,IAAe,OACf,KAAM,IAAI,OAAM,YAAY,+BAEhC,KAAM,GAAa,KAAK,eAAe,IAAI,GAC3C,GAAI,IAAe,OACf,KAAM,IAAI,OAAM,aAAa,+BAEjC,MAAO,GAAa,KAGpB,cAAc,CACd,MAAO,MAAK,eAAe,QAI5B,gBAA2B,MAAM,IAChC,OAAO,CAAE,MAAO,gBAMjB,QAAyB,CAC5B,YAAY,EAAW,CACnB,KAAK,eAAiB,EAAU,OAAO,CAAC,EAAK,IAAO,GAAI,IAAI,EAAE,GAAI,GAAW,GAAO,GAAI,MACxF,KAAK,QAAQ,GAGjB,WAAW,EAAI,CACX,KAAM,GAAS,KAAK,YAAY,IAAI,GACpC,GAAI,IAAW,OACX,KAAM,IAAI,IAAa,uBAAuB,KAElD,MAAO,GAGX,QAAQ,EAAK,EAAK,CACd,GAAI,IAAQ,EACR,MAAO,GAEX,KAAM,GAAU,KAAK,WAAW,GAC1B,EAAU,KAAK,WAAW,GAChC,GAAI,IAAY,EACZ,KAAM,IAAI,IAAa,GAAG,SAAW,gDAEzC,MAAO,GAAQ,QAAQ,EAAK,GAGhC,QAAQ,EAAW,CACf,KAAM,GAAU,GAAc,GAC9B,KAAK,YAAc,GAAI,KACvB,OAAQ,KAAU,GACd,OAAQ,KAAM,GAAO,YACjB,KAAK,YAAY,IAAI,EAAI,GAMrC,IAAI,EAAU,CACV,KAAM,GAAO,GAAI,IAAS,EAAS,GAAI,EAAS,WAAY,EAAS,QACrE,KAAK,eAAe,IAAI,EAAS,GAAI,GACrC,KAAK,QAAQ,KAAK,eAAe,UAIrC,OAAO,EAAI,EAAY,CACnB,KAAM,GAAW,GAAI,IAAS,EAAI,EAAY,MACxC,EAAe,KAAK,eAAe,IAAI,GAC7C,AAAI,GACA,GAAa,OAAS,GAE1B,KAAK,eAAe,IAAI,EAAI,GAC5B,KAAK,QAAQ,KAAK,eAAe,UAIrC,QAAQ,EAAI,EAAQ,CAChB,KAAM,GAAW,GAAI,IAAS,EAAI,KAAM,GAClC,EAAe,KAAK,eAAe,IAAI,GAC7C,AAAI,GACA,GAAa,WAAa,GAE9B,KAAK,eAAe,IAAI,EAAI,GAC5B,KAAK,QAAQ,KAAK,eAAe,WCtMvB,AAAC,WAA2B,CAE1C,KAAM,GAAU,SAAS,cAAc,QAAQ,QAE/C,MAAO,IAAW,EAAQ,UAAY,EAAQ,SAAS,iBACjD,gBACA,cCaV,YAAqB,EAA2C,OACrD,eAAiB,GACpB,GAAG,EAAO,YAAY,QAAQ,EAAO,OACrC,EAAO,KAGf,YAAyB,EAA2C,qBACzD,eAAiB,GACpB,WAAO,cAAP,cAAoB,cAApB,cAAiC,KAAjC,cAAqC,KACrC,QAAO,cAAP,cAAoB,KAApB,cAAwB,qBAGF,GAAa,CAIvC,YAAY,EAAiB,EAA8D,EAA6B,KAAM,MACpH,GAAU,GAAkB,UAAY,GAAkB,EAAe,OAAS,EAClF,EAAY,EAAS,GAAY,GAAU,GAC3C,EAAe,EAAS,GAAgB,GAAU,MACpD,GAAc,GAAG,QAAc,KAAgB,IAC/C,OACe,KACX,MAAO,GAAM,MAAS,cACP,UAAU,EAAM,UAE/B,MAAO,GAAM,MAAS,cACP,UAAU,EAAM,WAGnC,OACe,EAAM,eAEnB,EAAa,QACd,UAAY,OACZ,aAAe,mBAIS,GAAS,CAG1C,YAAY,EAAmB,MACrB,GAAU,EAAW,OACrB,EAAS,EAAQ,OACjB,EAAQ,EAAQ,YAChB,oBAAqB,EAAQ,QAC9B,WAAa,EAGtB,yBAA0B,MACjB,WAAW,kCAIoB,GAAS,CACjD,YAAY,EAAgB,EAAmC,EAAqB,EAAe,OACzF,GAAG,KAAU,EAAO,IAAI,GAAK,KAAK,UAAU,IAAI,KAAK,gBAAiB,EAAQ,SCrD/E,IAAO,CAAE,KAAM,IACf,EAAW,CAAE,KAAM,gBA+BH,EAAmB,MACtC,GAAM,EAAE,SAAS,UAChB,IAAI,OAAO,EAAI,EAAI,QAAU,cASX,EAAqB,OACvC,UAAS,EAAK,gBAKI,EAAc,EAAsC,EAAiB,EAAyB,OAAO,UAAiC,MACzJ,GAAM,EAAW,KAAK,EAAM,YAC9B,gBAAkB,KAAO,IAA+B,MAClD,GAAM,EAAG,OACT,EAAK,EAAI,OACT,EAAM,EAAI,YACV,EAAa,EAAG,cAClB,MACM,GAAkB,EAAI,EAAK,EAAY,YAGzC,GACI,kBAIT,EAAa,cAGQ,EAAgC,OACrD,IAAI,SAAQ,CAAC,EAAS,IAAW,GAChC,iBAAiB,UAAW,GAAS,GAC5B,EAAM,OAAyB,YAIxC,iBAAiB,QAAS,GAAS,MAC7B,GAAQ,GAAI,IAAgB,KAC3B,mBAOU,EAAoB,OAEtC,IAAI,SAAQ,CAAC,EAAS,IAAW,GAChC,iBAAiB,WAAY,IAAM,SAKnC,iBAAiB,QAAS,GAAS,GAC5B,GAAI,mBA0BoD,EAAqC,EAAsD,OAE3J,IAAI,SAAiB,CAAC,EAAS,IAAW,GAC/B,QAAU,GAAS,GACtB,GAAI,IAAgB,OAKjB,UAAY,AAAC,GAAU,MAC3B,GAAU,EAAM,OAAyB,UAC3C,CAAC,EAAQ,GACD,gBAKN,GAAS,EAAa,EAAO,MAAU,EAAO,IAAK,GAEnD,EAAO,iBAAQ,KACf,EAAS,iBAAQ,OAEnB,IACQ,IAGF,IACC,SAAS,KAET,cAGhB,MAAM,GAAO,MACN,IAAI,IAAa,uBAAwB,uBAMjB,EAAoB,EAAiC,MACjF,GAAe,eACf,GAAiB,EAAQ,AAAC,MACpB,KAAK,GACN,CAAC,KAAM,EAAO,MAElB,UC/IiB,CAIxB,YAAY,EAAiC,EAA2B,MAC/D,QAAU,OACV,aAAe,KAGpB,aAAyB,OAClB,MAAK,aAAa,cAGzB,cAAkC,OAC3B,MAAK,aAAa,eAGzB,eAAuB,OAChB,MAAK,aAAa,aAG7B,YAAY,EAAkB,EAAuE,OAC7F,IAAS,EACF,KAAK,QAAQ,WAAW,EAAO,GAC/B,EACA,KAAK,QAAQ,WAAW,GACxB,EACA,KAAK,QAAQ,WAAW,KAAM,GAE9B,KAAK,QAAQ,aAI5B,SAAS,EAA6B,OAC3B,MAAK,QAAQ,SAAS,GAGjC,MAAM,EAAyC,OACpC,GAAa,KAAK,QAAQ,MAAM,IAG3C,IAAI,EAAwD,OACjD,GAAa,KAAK,QAAQ,IAAI,IAGzC,OAAO,EAAkE,OACjE,MAAK,QAAQ,SAAS,UACf,EAAa,KAAK,QAAQ,OAAO,IAEjC,EAAa,KAAK,QAAQ,IAAI,IAAM,KAAK,GAAS,IACjD,EAAO,IACH,GAAU,KAAK,QAAQ,cACvB,OAAO,IAAY,aACT,CAAC,IAER,EAAQ,OAAO,CAAC,EAAK,IAAQ,EAAI,GAAM,MAM9D,OAAU,EAAiB,EAAuB,EAAmC,OAC1E,MAAK,QAAQ,EAAO,EAAS,EAAc,QAGtD,cAAiB,EAAiB,EAAuB,EAAmC,OACjF,MAAK,QAAQ,EAAO,EAAS,EAAc,QAGtD,YAAY,EAAiB,EAA8B,OAChD,MAAK,aAAa,EAAO,EAAQ,QAG5C,mBAAmB,EAAiB,EAA8B,OACvD,MAAK,aAAa,EAAO,EAAQ,QAG5C,YAAY,EAAiB,EAA4C,OAC9D,MAAK,aAAa,EAAO,EAAW,QAG/C,mBAAmB,EAAiB,EAA4C,OACrE,MAAK,aAAa,EAAO,EAAW,aAGzC,WAAU,EAAkB,EAA8C,MACtE,GAAS,KAAK,YAAY,EAAO,GACjC,EAAe,eACf,GAAiB,EAAQ,AAAC,MACpB,KAAK,GACN,IAEJ,EAGX,YAAY,EAAyC,OAC1C,MAAK,MAAM,EAAO,IAAM,GAAM,QAGzC,WAAW,EAAyC,OACzC,MAAK,MAAM,EAAO,IAAM,GAAM,QAGzC,KAAK,EAAiB,EAAsD,OACjE,MAAK,MAAM,EAAO,EAAW,QAGxC,YAAY,EAAiB,EAAuD,OACzE,MAAK,MAAM,EAAO,EAAW,aAGlC,YAAW,EAAmD,MAC1D,GAAS,KAAK,QAAQ,cAAc,EAAO,WAC7C,eACE,GAAc,EAAQ,CAAC,EAAG,OACnB,EACF,KAEJ,OAIL,eAAc,EAAiB,EAA0F,MACrH,GAAS,KAAK,QAAQ,WAAW,EAAO,aACxC,GAAiB,EAAQ,CAAC,EAAO,EAAK,IACjC,EAAC,KAAM,EAAS,EAAO,EAAK,WAIrC,aAAY,EAAiB,EAAwE,MACjG,GAAS,KAAK,QAAQ,cAAc,EAAO,aAC3C,GAAc,EAAQ,CAAC,EAAG,EAAK,IAC1B,EAAC,KAAM,EAAS,EAAK,WAQ9B,kBAAiB,EAAqB,EAAoB,EAAyE,MAC/H,GAAc,CAAC,EAAG,IAAM,EAAY,CAAC,KAAK,WAAW,IAAI,EAAG,GAAK,KAAK,WAAW,IAAI,EAAG,GACxF,EAAa,EAAK,QAAQ,KAAK,GAC/B,EAAW,EAAW,GACtB,EAAU,EAAW,EAAW,OAAS,GACzC,EAAY,EAAY,OAAS,OACjC,EAAS,KAAK,QAAQ,cAAc,KAAK,YAAY,MAAM,EAAU,GAAU,MACjF,GAAQ,OACN,GAAc,EAAQ,CAAC,EAAO,EAAK,IAAW,MACzC,EAAQ,EAAW,QAAU,EAAY,EAAW,GAAQ,GAAO,MAC7D,KAET,GAAO,MACP,EAAW,KAAW,EAAK,MACrB,GAAK,EAAO,aACX,EAAS,EAAK,MACZ,QAET,IAAQ,GAAS,EAAW,OACrB,GAEA,CACH,KAAM,GACN,OAAQ,EAAW,MAMnC,QAAW,EAAiB,EAAsC,EAAiB,EAAiD,IAC5H,GAAe,OACb,GAAS,KAAK,YAAY,EAAO,SAChC,GAAiB,EAAQ,AAAC,MACd,EAAQ,EAAc,GAC9B,IAIf,aAAa,EAAiB,EAAgB,EAA6C,OAChF,MAAK,aAAa,EAAO,AAAC,GACtB,EAAQ,SAAW,EAC3B,QAGD,cAAa,EAAiB,EAAuC,EAA6C,MAC9G,GAAS,KAAK,YAAY,EAAO,GACjC,EAAe,eACf,GAAiB,EAAQ,AAAC,MACpB,KAAK,GACN,CAAC,KAAM,EAAU,EAAS,MAE9B,OAIL,cAAa,EAAiB,EAA8B,EAA6C,MACrG,GAAS,KAAK,YAAY,EAAO,GACjC,EAAe,eACf,GAAiB,EAAQ,AAAC,GAAU,MAChC,GAAkB,EAAU,SAC9B,MACQ,KAAK,GAEV,CAAC,KAAM,CAAC,KAEZ,OAGL,cAAa,EAAiB,EAA6C,MACvE,GAAS,KAAK,YAAY,EAAO,aACjC,GAAiB,EAAQ,AAAC,GAErB,EAAC,KAAM,CADU,EAAU,WAKpC,OAAM,EAAiB,EAA8B,EAAuD,MACxG,GAAS,KAAK,YAAY,EAAO,MACnC,MACU,KAAM,GAAiB,EAAQ,AAAC,GAAU,MAC9C,GAAQ,EAAU,SACpB,OACS,GAEN,CAAC,KAAM,WAGP,ICzPnB,KAAM,IAAe,GAErB,YAAoB,EAAgB,EAAe,EAAmB,cAC5D,GAAY,iBAAQ,KACpB,EAAe,uBAAQ,cAAR,cAAqB,KAArB,cAAyB,aACtC,KAAK,GAAG,KAAgB,KAAa,KAAU,EAAO,IAAI,GAAK,KAAK,UAAU,IAAI,KAAK,kBAGhE,CAG/B,YAAY,EAA+B,MAClC,IAAM,KAGX,UAA6B,OACtB,MAAK,SAAS,WAGrB,WAA2B,OACvB,eAAiB,MAAK,IACf,KAAK,IAAI,YAEb,KAAK,IAGhB,SAAS,EAA6B,OAC3B,CAAC,CAAC,KAAK,IAAI,GAGtB,cAAc,EAAkB,EAA0E,IAClG,OAEK,MAAK,IAAI,mBAIE,GAAW,gBAAiB,CAAC,EAAO,GAAY,KAAK,KAC9D,KAAK,IAAI,cAAc,EAAO,SAJjB,GAAW,aAAc,CAAC,EAAO,GAAY,KAAK,KAC3D,KAAK,WAAW,EAAO,UAI9B,QACE,IAAI,IAAuB,gBAAiB,KAAK,IAAK,EAAK,CAAC,EAAO,KAIjF,WAAW,EAAkB,EAAmF,IACxG,YACgB,GAAW,aAAc,GAAI,KAAK,KAC3C,KAAK,IAAI,WAAW,EAAO,SAC9B,QACE,IAAI,IAAuB,aAAc,KAAK,IAAK,EAAK,CAAC,EAAO,KAI9E,IAAI,EAAS,EAAwD,IAC7D,YACgB,GAAW,MAAO,CAAC,EAAM,GAAM,KAAK,KAC7C,KAAK,SAAS,IAAI,EAAM,SAC3B,QACE,IAAI,IAAuB,MAAO,KAAK,IAAK,EAAK,CAAC,EAAM,KAItE,IAAI,EAAS,EAAwD,IAC7D,YACgB,GAAW,MAAO,CAAC,EAAM,GAAM,KAAK,KAC7C,KAAK,SAAS,IAAI,EAAM,SAC3B,QACE,IAAI,IAAuB,MAAO,KAAK,IAAK,EAAK,CAAC,EAAM,KAItE,IAAI,EAA2D,IACvD,YACgB,GAAW,MAAO,CAAC,GAAM,KAAK,KACvC,KAAK,IAAI,IAAI,SAChB,QACE,IAAI,IAAuB,MAAO,KAAK,IAAK,EAAK,CAAC,KAIhE,OAAO,EAAqE,IACpE,YACgB,GAAW,SAAU,CAAC,GAAM,KAAK,KAC1C,KAAK,IAAI,OAAO,SACnB,QACE,IAAI,IAAuB,SAAU,KAAK,IAAK,EAAK,CAAC,KAInE,OAAO,EAAuD,IACtD,YACgB,GAAW,SAAU,CAAC,GAAM,KAAK,KAC1C,KAAK,SAAS,OAAO,SACxB,QACE,IAAI,IAAuB,SAAU,KAAK,IAAK,EAAK,CAAC,KAInE,MAAM,EAA4C,IAC1C,OACO,MAAK,IAAI,MAAM,SAClB,QACE,IAAI,IAAuB,QAAS,KAAK,IAAK,EAAK,CAAC,KAIlE,MAAM,EAAwB,IACtB,OACO,MAAK,SAAS,MAAM,SACvB,QAEE,IAAI,IAAuB,QAAS,KAAK,IAAK,EAAK,CAAC,QAI9D,aAAuB,OAChB,OAAM,KAAK,KAAK,SAAS,6BAIV,GAAe,CACzC,YAAY,EAA0B,EAA2B,OACvD,GAAI,IAAsB,GAAW,MAG3C,YAAmC,OAC3B,MAAK,QAGjB,MAAM,EAAmC,OAC9B,IAAI,IAAe,GAAI,IAAsB,KAAK,UAAU,MAAM,IAAa,KAAK,cAG/F,IAAI,EAAU,EAAsB,MAW1B,GAAU,KAAK,UAAU,IAAI,QAC9B,iBAAiB,EAAS,EAAK,MAAO,OAAW,GAG1D,IAAI,EAAU,EAAsB,MAE1B,GAAU,KAAK,UAAU,IAAI,QAC9B,iBAAiB,EAAS,EAAK,MAAO,OAAW,QAGpD,QAAO,EAAU,EAAiC,IAChD,aACM,GAAa,KAAK,UAAU,IAAI,IAC/B,SACF,MACD,YAAe,aACX,IAAI,CAAC,EAAG,kBAAmB,GAAI,KAAK,SAAS,GAAQ,EAAG,GAAM,EAAI,MAAM,QACxE,0BACG,QAED,IAKlB,OAAO,EAA0C,EAAsB,MAE7D,GAAU,KAAK,UAAU,OAAO,QACjC,iBAAiB,EAAS,EAAK,SAAU,EAAe,QAGzD,iBAAiB,EAAqB,EAA2B,EAAuB,EAAyB,EAAsB,CACvI,KACI,gBAEK,GAAS,MAAM,GAAO,IAC3B,GACA,IACO,KAAK,SAAS,GACd,MACA,CAAC,SAEP,aAAa,cAAc,EAAK,EAAK,EAAe,KAIzD,SAAS,EAAyB,MAChC,GAAsB,GACtB,CAAC,WAAW,KAAK,aACnB,GACK,KAAK,KAAK,aAAa,EAAO,kBAE3B,KAAK,yBAA0B,YAEhC,KAAa,MAAK,UAAU,cAC/B,MACM,GAAQ,KAAK,UAAU,MAAM,KAC9B,KAAK,KAAK,aAAa,EAAO,EAAM,wBAEjC,KAAK,uBAAwB,SAGtC,GAGH,aAAa,EAAU,EAAyC,IAChE,MAAM,QAAQ,GAAU,IACpB,GAAa,WACN,KAAQ,MACX,MAAO,IAAU,WACT,EAAM,oBAKf,cAEA,GAAM,gBCnOC,EAAoB,OACnC,MAAK,UAAU,GAAY,gBAGhB,EAAoB,OAC/B,IAAY,KAAK,MAAM,IAGlC,YAAqB,EAAiB,IAC9B,MAAO,IAAU,UAAY,IAAU,MAAQ,CAAC,MAAM,QAAQ,GAAQ,IAElE,EAAM,iBACC,CAAC,MAAO,EAAM,YAAY,KAAM,MAAO,MAAM,KAAK,OAEzD,GAAS,YACF,KAAQ,GACX,EAAM,eAAe,OACd,GAAQ,GAAY,EAAM,WAGlC,cAEA,GAIf,YAAqB,EAAiB,IAC9B,MAAO,IAAU,UAAY,IAAU,MAAQ,CAAC,MAAM,QAAQ,GAAQ,IAClE,MAAO,GAAM,OAAU,gBACf,EAAM,WACL,kBAAoB,WAAU,KAAK,EAAM,WACzC,mBAAqB,YAAW,KAAK,EAAM,WAC3C,0BAA4B,mBAAkB,KAAK,EAAM,WACzD,mBAAqB,YAAW,KAAK,EAAM,WAC3C,oBAAsB,aAAY,KAAK,EAAM,WAC7C,mBAAqB,YAAW,KAAK,EAAM,WAC3C,oBAAsB,aAAY,KAAK,EAAM,WAC7C,qBAAuB,cAAa,KAAK,EAAM,WAC/C,qBAAuB,cAAa,KAAK,EAAM,WAC/C,sBAAwB,eAAc,KAAK,EAAM,WACjD,uBAAyB,gBAAe,KAAK,EAAM,qBAE7C,GAAM,SAGrB,GAAS,YACF,KAAQ,GACX,EAAM,eAAe,OACd,GAAQ,GAAY,EAAM,WAGlC,cAEA,WC3CW,CAItB,YAAY,EAAmC,EAA2B,MACjE,cAAgB,OAChB,cAAgB,KAGb,yBAAiC,OAClC,GAAG,KAAK,cAAc,6BAG3B,KAAI,EAA2B,MAC3B,GAAQ,KAAM,MAAK,cAAc,IAAI,MACvC,QACO,GAAM,MAIrB,wBAAwB,EAAa,EAAY,IAEzC,MACM,GAAQ,KAAK,uBAAyB,EACtC,EAAU,GAAU,QACrB,cAAc,QAAQ,EAAO,SAC7B,WACG,MAAM,kCAAmC,IAIzD,iCAAkC,MACzB,cAAc,cAAc,OAAW,CAAC,EAAqB,IAC1D,GAAI,WAAW,SACV,wBAAwB,EAAK,EAAM,OAErC,UAIT,wCAAuC,EAAiC,IACtE,GAAU,QACR,GAAW,KAAK,uBAChB,EAAS,EAAW,SAClB,GAAI,EAAG,EAAI,KAAK,cAAc,OAAQ,GAAK,EAAG,MAC5C,GAAQ,KAAK,cAAc,IAAI,MACjC,EAAM,WAAW,GAAS,MACpB,GAAQ,GAAM,KAAK,cAAc,QAAQ,IACzC,EAAM,EAAM,OAAO,EAAS,QAE5B,EAAU,KAAM,MAAK,cAAc,OAAO,KAAU,IACtD,IAAI,EAAK,CAAC,GACT,SACI,cAAc,IAAI,CAAC,MAAK,YACnB,WAIf,GAGX,IAAI,EAAa,EAAkB,CAC3B,EAAI,WAAW,SACV,wBAAwB,EAAK,QAEjC,cAAc,IAAI,CAAC,MAAK,UAGjC,IAAI,EAAa,EAAkB,CAC3B,EAAI,WAAW,SACV,wBAAwB,EAAK,QAEjC,cAAc,IAAI,CAAC,MAAK,UAGjC,OAAO,EAAmB,CAClB,EAAI,WAAW,SACV,cAAc,WAAW,KAAK,uBAAyB,QAE3D,cAAc,OAAO,YCxEJ,CAG1B,YAAY,EAAkC,MACrC,cAAgB,EAGzB,QAAiC,OACtB,MAAK,cAAc,YAG9B,IAAI,EAA4B,MACvB,cAAc,IAAI,GAG3B,IAAI,EAA6C,OACtC,MAAK,cAAc,IAAI,QAG5B,KAAI,EAAkC,MAClC,GAAa,KAAM,MAAK,cAAc,OAAO,SAC5C,KAAW,EAGtB,OAAO,EAAsB,MACpB,cAAc,OAAO,YC1BT,CAGrB,YAAY,EAAgC,MACnC,aAAe,EAGxB,QAAgC,OACrB,MAAK,aAAa,YAG7B,IAAI,EAA0B,MACrB,aAAa,IAAI,GAG1B,OAAO,EAAsB,MACpB,aAAa,OAAO,OC9BrB,GAAL,UAAK,EAAL,SACG,GAAN,qJADQ,mBAWW,CAInB,YAAY,EAA0B,MAC7B,cAAgB,EAGzB,OAAO,EAAgB,EAA6C,OAC5D,OAAK,eACD,CAAC,KAAK,cAAc,OAAO,EAAM,IAKrC,KAAK,OAAS,QAAa,CAAC,MAAM,QAAQ,IAAa,EAAK,SAAW,KAAK,MAQpF,SAAS,EAA+B,aAC/B,KAAO,EACL,MCpCf,aAAuB,UAEoB,CAApC,aApBP,WAqBqC,GAAI,IAAY,MAEjD,KAAY,EAEZ,IAAO,EAAG,EAA6B,OAC5B,GAAS,KAAK,MAGzB,UAAa,EAA4B,EAAG,EAA6B,OACjE,GACO,EAAK,KAAK,EAAG,GAEb,KAAK,IAAI,EAAG,GAI3B,YAAY,EAAG,EAAoB,WAC3B,SAAQ,GAAK,EAAE,EAAS,KAAK,QAAQ,KAAK,GAAM,IAC7C,KAAK,UAGV,SAA0C,KAI5C,QAAyB,OAClB,YAI8B,CAOzC,YAAY,EAAoB,MACvB,OAAS,EAGlB,KAAQ,EAAkB,EAA6B,OAC5C,GAAS,MAGpB,KAAgB,OACL,MAEX,KAAgB,OAAS,MAEzB,YAAY,EAAkB,EAA0C,WAChE,SAAQ,GAAK,EAAE,EAAS,QAAQ,KAAK,GAAM,IACxC,KAGX,aAAa,EAAkB,EAAuC,OAC3D,MAAK,cAGhB,aAAoB,EAEpB,aAAoB,KAEhB,QAAyB,OAClB,MAGP,WAAc,OACP,GAGX,MAAM,EAAmB,OACd,GAGX,OAAmB,OACR,MAGX,QAAe,EAEf,WAAuB,QAKd,IAAW,GAAI,ICjE5B,WAAmB,EAAgB,EAAoB,EAA4B,OACxE,GAAG,KAAU,GAAa,MAAe,GAAa,KAGjE,YAAmB,EAAqD,MAC9D,CAAC,EAAQ,EAAY,GAAc,EAAI,MAAM,WAC5C,CAAC,SAAQ,SAAU,GAAI,GAAS,GAAa,GAAa,GAAa,KAGlF,YAA0B,EAAgB,EAAyB,OACxD,GAAG,KAAU,IAGxB,YAA0B,EAAyD,MACzE,CAAC,EAAQ,GAAW,EAAW,MAAM,WACpC,CAAC,SAAQ,WAGpB,QAAY,CAQR,YAAY,EAAmB,EAAiB,EAAkB,EAAkB,EAAqB,GAAO,EAAqB,GAAO,MACnI,aAAe,OACf,MAAQ,OACR,OAAS,OACT,OAAS,OACT,WAAa,OACb,WAAa,EAGtB,cAAc,EAAyC,IAC/C,IAEI,KAAK,YACE,MAAK,aAAa,KAAKC,EAAU,EAAQ,KAAK,MAAM,WAAY,KAAK,MAAM,gBAIlF,KAAK,QAAU,CAAC,KAAK,aACd,MAAK,aAAa,MACrBA,EAAU,EAAQ,KAAK,OAAO,WAAY,KAAK,OAAO,YACtDA,EAAU,EAAQ,KAAK,OAAO,WAAY,EAAU,eACpD,KAAK,WACL,OAKJ,CAAC,KAAK,QAAU,KAAK,aACd,MAAK,aAAa,MACrBA,EAAU,EAAQ,KAAK,OAAO,WAAY,EAAU,eACpDA,EAAU,EAAQ,KAAK,OAAO,WAAY,KAAK,OAAO,YACtD,GACA,KAAK,eAIT,KAAK,QAAU,KAAK,aACb,MAAK,aAAa,MACrBA,EAAU,EAAQ,KAAK,OAAO,WAAY,KAAK,OAAO,YACtDA,EAAU,EAAQ,KAAK,OAAO,WAAY,KAAK,OAAO,YACtD,KAAK,WACL,KAAK,kBAGT,QACE,IAAI,IAAa,iCAAmC,KAAK,UAAU,MAAO,aAoB5D,CAG5B,YAAY,EAAiD,MACpD,eAAiB,EAO1B,UAAU,EAA2B,OAC1B,IAAIC,IAAM,KAAK,eAAe,YAAa,GAQtD,gBAAgB,EAAoB,EAAK,GAAc,OAC5C,IAAIA,IAAM,KAAK,eAAe,YAAa,OAAW,OAAW,EAAU,OAAW,GAQjG,gBAAgB,EAAoB,EAAK,GAAc,OAC5C,IAAIA,IAAM,KAAK,eAAe,YAAa,OAAW,EAAU,OAAW,GAUtF,WAAW,EAAiB,EAAiB,EAAU,GAAO,EAAU,GAAc,OAC3E,IAAIA,IAAM,KAAK,eAAe,YAAa,OAAW,EAAO,EAAO,EAAW,QASpF,YAAW,EAAgB,EAAoB,EAA+C,MAC1F,GAAW,EAAS,gBACjB,WAAa,EACf,KAAK,aAAa,EAAQ,EAAU,QASzC,aAAY,EAAgB,EAAoB,EAA+C,MAC3F,GAAW,EAAS,gBACjB,WAAa,EACf,KAAK,YAAY,EAAQ,EAAU,GAU9C,YAAY,EAAgB,EAAoB,EAA+C,MACrF,GAAW,KAAK,gBAAgB,EAAU,IAAM,cAAc,SAC7D,MAAK,eAAe,YAAY,EAAU,QAU/C,cAAa,EAAgB,EAAoB,EAA+C,MAC5F,GAAQ,KAAK,gBAAgB,EAAU,IAAM,cAAc,GAC3D,EAAS,KAAM,MAAK,eAAe,mBAAmB,EAAO,YAC5D,UACA,OAGL,oBAAmB,EAAgB,EAAoD,MACnF,GAAY,KAAK,eAAe,MAAM,aACtC,EAAO,EAAS,IAAI,GAAW,GAAiB,EAAQ,IACxD,EAAU,GAAI,iBACd,GAAU,iBAAiB,EAAM,GAAO,CAAC,EAAU,IAAO,MACtD,CAAC,WAAW,GAAiB,GAC7B,CAAC,YAAYC,GAAU,YACrB,IAAI,EAAS,GACd,KAEJ,OAiBL,2BAA0B,EAAgB,EAAiD,MACvF,GAAY,KAAK,eAAe,MAAM,aACtC,EAAO,EAAS,IAAI,GAAW,GAAiB,EAAQ,IACxD,EAAU,GAAI,OAAM,EAAK,WAC3B,eAG0D,QAClD,GAAI,EAAG,EAAI,EAAQ,OAAQ,EAAE,EAAG,IAChC,EAAQ,KAAO,iBAET,EAAQ,KAAO,SACd,GAAK,gBAKlB,GAAU,iBAAiB,EAAM,GAAO,CAAC,EAAK,IAAU,MAEpD,GAAS,EAAuB,QAAQ,YACtC,GAAS,IACD,IACT,CAAC,CAAC,IAEN,GAAiB,GAAiB,GAAe,QAU5D,UAAU,EAA2B,EAAiC,CACjE,SAAoC,IAAMF,EAAU,EAAM,OAAQ,EAAM,WAAY,EAAM,YAC1F,EAAoC,WAAa,GAAiB,EAAM,OAAQ,EAAM,MAAM,UACtF,KAAK,eAAe,OAAO,EAAoC,GAQ1E,OAAO,EAAiC,MAC/B,eAAe,IAAI,GAG5B,IAAI,EAAgB,EAA6D,OACtE,MAAK,eAAe,IAAIA,EAAU,EAAQ,EAAS,WAAY,EAAS,aAGnF,aAAa,EAAgB,EAA0D,OAC5E,MAAK,eAAe,MAAM,aAAa,IAAI,GAAiB,EAAQ,IAG/E,iBAAiB,EAAsB,MAC7B,GAASA,EAAU,EAAQ,EAAU,cAAe,EAAU,eAC9D,EAASA,EAAU,EAAQ,EAAU,cAAe,EAAU,eAC9D,EAAQ,KAAK,eAAe,YAAY,MAAM,EAAQ,QACvD,eAAe,OAAO,SC3StB,GAAc,KACd,EAAc,aCC3B,YAAmB,EAAgB,EAAuB,EAAiB,EAA+B,OAC/F,GAAG,KAAU,KAAiB,KAAW,IAUpD,YAAmB,EAA4B,MACrC,CAAC,EAAQ,EAAe,EAAS,GAAiB,EAAI,MAAM,WAC3D,CAAC,SAAQ,gBAAe,UAAS,yBAGT,CAG/B,YAAY,EAA+B,MAClC,OAAS,EAGlB,IAAI,EAAgB,EAAuB,EAAiB,EAA6B,MAChF,OAAO,IAAI,CAAC,IAAKA,GAAU,EAAQ,EAAe,EAAS,KAGpE,OAAO,EAAgB,EAAuB,EAAiB,EAA6B,MACnF,OAAO,OAAOA,GAAU,EAAQ,EAAe,EAAS,IAGjE,mBAAmB,EAAgB,EAAwB,MACjD,GAAQ,KAAK,OAAO,YAAY,MAClCA,GAAU,EAAQ,EAAU,EAAa,GACzCA,GAAU,EAAQ,EAAU,EAAa,GACzC,GACA,SAEC,OAAO,OAAO,GAGvB,iBAAiB,EAAgB,MACvB,GAAQ,KAAK,OAAO,YAAY,MAClCA,GAAU,EAAQ,EAAa,EAAa,GAC5CA,GAAU,EAAQ,EAAa,EAAa,GAC5C,GACA,SAEC,OAAO,OAAO,QAGjB,qBAAoB,EAAgB,EAAkB,EAA2C,MAG7F,GAAQ,KAAK,OAAO,YAAY,MAClCA,GAAU,EAAQ,EAAU,EAAS,GACrCA,GAAU,EAAQ,EAAU,EAAS,GACrC,GACA,UAGG,AADO,MAAM,MAAK,OAAO,UAAU,IAC7B,IAAI,GAAKE,GAAU,EAAE,WAGhC,iBAAgB,EAAgB,EAA4C,MAGxE,GAAQ,KAAK,OAAO,YAAY,MAClCF,GAAU,EAAQ,EAAU,EAAa,GACzCA,GAAU,EAAQ,EAAU,EAAa,GACzC,GACA,UAGG,AADO,MAAM,MAAK,OAAO,UAAU,IAC7B,IAAI,GAAKE,GAAU,EAAE,OCvE1C,YAAmB,EAAgB,EAAmB,EAAkB,OAC5D,GAAG,KAAU,KAAa,YASV,CAGxB,YAAY,EAAiC,MACpC,gBAAkB,EAG3B,IAAI,EAAgB,EAAc,EAAuD,MAC/E,GAAMF,GAAU,EAAQ,EAAM,SAC7B,MAAK,gBAAgB,IAAI,GAGpC,IAAI,EAAgB,EAAyB,MACnC,GAAMA,GAAU,EAAQ,EAAM,KAAM,EAAM,WAC1C,EAAQ,CAAC,SAAQ,QAAO,YACzB,gBAAgB,IAAI,GAG7B,iBAAiB,EAAsB,MAG7B,GAAQ,KAAK,gBAAgB,YAAY,MAAM,EAAQ,GAAG,KAAU,IAAe,GAAM,SAC1F,gBAAgB,OAAO,ICjCpC,YAAmB,EAAgB,EAAgB,OACxC,GAAG,KAAU,IAGxB,YAAmB,EAAiD,MAC1D,CAAC,EAAQ,GAAU,EAAI,MAAM,WAC5B,CAAC,SAAQ,kBAeS,CAGzB,YAAY,EAA6C,MAChD,kBAAoB,EAG7B,IAAI,EAAgB,EAAyD,OAClE,MAAK,kBAAkB,IAAIA,GAAU,EAAQ,IAGxD,IAAI,EAA0B,CAEzB,EAA8B,IAAMA,GAAU,EAAO,OAAQ,EAAO,aAChE,kBAAkB,IAAI,GAG/B,OAAO,EAAuC,MACpC,GAAQ,KAAK,kBAAkB,YAAY,WAAWA,GAAU,EAAQ,WACvE,MAAK,kBAAkB,YAAY,EAAO,GACtC,EAAO,SAAW,QAI3B,eAAc,EAAmC,MAC7C,GAAoB,GACpB,EAAQ,KAAK,kBAAkB,YAAY,WAAWA,GAAU,EAAQ,iBACxE,MAAK,kBAAkB,YAAY,EAAO,GAAO,MAC7C,GAAaE,GAAU,SAEzB,GAAW,SAAW,KACd,KAAK,EAAW,QACjB,IAEJ,KAEJ,EAGX,iBAAiB,EAAsB,MAG7B,GAAQ,KAAK,kBAAkB,YAAY,MAAM,EAAQ,GAAG,KAAU,IAAe,GAAM,SAC5F,kBAAkB,OAAO,ICpDtC,YAAmB,EAAgB,EAA4B,OACpD,GAAG,KAAU,GAAa,aAGF,CAG/B,YAAY,EAA6B,MAChC,OAAS,EAGlB,UAAU,EAA6B,IAC/B,OACO,MAAK,OAAO,YAAY,MAC3BF,GAAU,EAAQ,EAAU,eAC5BA,GAAU,EAAQ,EAAU,sBAE3B,QACC,IAAI,IAAa,sCAAsC,IAAU,IAI/E,IAAI,EAA0C,OACnC,MAAK,OAAO,UAAU,KAAK,UAAU,IAKhD,aAAa,EAAoD,OAQtD,MAAK,OAAO,YAAY,KAAK,UAAU,GAAS,GAC5C,MAAO,GAAS,QAAW,UAAY,MAAO,GAAS,WAAc,UAOpF,IAAI,EAA0B,CACzB,EAA2B,IAAMA,GAAU,EAAS,OAAQ,EAAS,SACjE,OAAO,IAAI,GAGpB,OAAO,EAA+B,MAC7B,OAAO,IAAI,GAGpB,IAAI,EAAgB,EAAwD,OACjE,MAAK,OAAO,IAAIA,GAAU,EAAQ,IAG7C,iBAAiB,EAAsB,MAC9B,OAAO,OAAO,KAAK,UAAU,KCxD1C,YAAmB,EAAgB,EAA4B,OACpD,GAAG,KAAU,GAAa,KAGrC,YAAmB,EAAqD,MAC9D,CAAC,EAAQ,GAAqB,EAAI,MAAM,KACxC,EAAa,GAAa,SACzB,CAAC,SAAQ,sBAGW,CAG3B,YAAY,EAAiC,MACpC,YAAc,OAGjB,kBAAiB,EAA6C,MAC1D,GAAQ,KAAK,YAAY,YAAY,MACvCA,GAAU,EAAQ,EAAU,eAC5BA,GAAU,EAAQ,EAAU,eAC5B,GACA,IAEE,EAAS,KAAM,MAAK,YAAY,WAAW,MAC7C,QACOE,IAAU,GAAkB,WAI3C,OAAO,EAAgB,EAAoB,MACjC,GAAW,KAAK,YAAY,YAAY,KAAKF,GAAU,EAAQ,SAChE,YAAY,OAAO,QAGtB,QAAO,EAAgB,EAAsC,MACzD,GAAW,KAAK,YAAY,YAAY,KAAKA,GAAU,EAAQ,UAE9D,CAAC,CADI,KAAM,MAAK,YAAY,OAAO,GAI9C,IAAI,EAAkC,GACrB,IAAMA,GAAU,EAAa,OAAQ,EAAa,iBAC1D,YAAY,IAAI,GAGzB,OAAO,EAAkC,MAChC,YAAY,IAAI,GAGzB,QAAkC,OACvB,MAAK,YAAY,YAG5B,iBAAiB,EAAsB,MAC7B,GAASA,GAAU,EAAQ,EAAU,eACrC,EAASA,GAAU,EAAQ,EAAU,eACrC,EAAQ,KAAK,YAAY,YAAY,MAAM,EAAQ,QACpD,YAAY,OAAO,YCrED,CAG3B,YAAY,EAA4B,MAC/B,OAAS,EAGlB,IAAI,EAAmD,OAC5C,MAAK,OAAO,IAAI,GAG3B,IAAI,EAAkC,MAC7B,OAAO,IAAI,GAGpB,OAAO,EAAsB,MACpB,OAAO,OAAO,ICV3B,YAAmB,EAAgB,EAA0B,OAClD,GAAG,KAAU,IAGxB,YAAmB,EAAmD,MAC5D,CAAC,EAAQ,GAAY,EAAI,MAAM,WAC9B,CAAC,SAAQ,oBAGa,CAG7B,YAAY,EAA8B,MACjC,OAAS,EAGlB,gBAAgB,EAA2C,MACjD,GAAQ,KAAK,OAAO,YAAY,WAAWA,GAAU,EAAQ,WAC5D,MAAK,OAAO,YAAY,EAAO,GAC3B,EAAO,SAAW,QAI3B,iBAAgB,EAAmC,MAC/C,GAAsB,GACtB,EAAQ,KAAK,OAAO,YAAY,WAAWA,GAAU,EAAQ,iBAC7D,MAAK,OAAO,YAAY,EAAO,GAAO,MAClC,GAAaE,GAAU,SAEzB,GAAW,SAAW,KACZ,KAAK,EAAW,UACnB,IAEJ,KAEJ,EAGX,IAAI,EAAgB,EAAuD,OAChE,MAAK,OAAO,IAAIF,GAAU,EAAQ,IAG7C,IAAI,EAAsC,GACvB,IAAMA,GAAU,EAAe,OAAQ,EAAe,eAChE,OAAO,IAAI,GAGpB,mBAAmB,EAA4D,OACpE,MAAK,OAAO,MAAM,mBAAmB,IAAI,GAGpD,OAAO,EAAgB,EAAwB,MACtC,OAAO,OAAOA,GAAU,EAAQ,IAGzC,iBAAiB,EAAsB,MAG7B,GAAQ,KAAK,OAAO,YAAY,MAAMA,GAAU,EAAQ,GAAcA,GAAU,EAAQ,GAAc,GAAM,SAC7G,OAAO,OAAO,ICvE3B,YAAmB,EAAmB,EAA2B,OACtD,GAAG,KAAa,IAG3B,YAAmB,EAAuD,MAChE,CAAC,EAAW,GAAa,EAAI,MAAM,WAClC,CAAC,YAAW,qBAYM,CAGzB,YAAY,EAA+B,MAClC,OAAS,OAGZ,eAAc,EAAsC,MAChD,GAAuB,GACvB,EAAQ,KAAK,OAAO,YAAY,WAAWA,GAAU,EAAW,iBAChE,MAAK,OAAO,YAAY,EAAO,GAAO,MAClC,GAAa,GAAU,SAEzB,GAAW,YAAc,KACd,KAAK,EAAW,WACpB,IAEJ,KAEJ,EAGX,OAAO,EAA0C,MACvC,GAAQ,KAAK,OAAO,YAAY,WAAWA,GAAU,EAAW,WAC/D,MAAK,OAAO,YAAY,EAAO,GAC3B,EAAQ,YAAc,GAIrC,IAAI,EAAmB,EAAoD,OAChE,MAAK,OAAO,IAAIA,GAAU,EAAW,IAGhD,IAAI,EAA2B,CAC1B,EAA4B,IAAMA,GAAU,EAAQ,UAAW,EAAQ,gBACnE,OAAO,IAAI,GAGpB,OAAO,EAAmB,EAAyB,MAC1C,OAAO,OAAOA,GAAU,EAAW,QCvDpC,IAAL,UAAK,EAAL,iBACW,GAAd,2BACW,GAAX,aAFQ,gBAKA,IAAL,UAAK,EAAL,mBACa,GAAhB,oEADQ,aAoBZ,YAAmB,EAAgB,EAAmB,EAA2B,OACtE,GAAG,KAAU,KAAa,YAGC,CAGlC,YAAY,EAA+C,MAClD,OAAS,OAGZ,KAAI,EAAgB,EAAmB,EAAqC,MACxE,GAAMA,GAAU,EAAQ,EAAW,GACnC,EAAa,KAAM,MAAK,OAAO,OAAO,SACrC,KAAQ,EAGnB,IAAI,EAAgB,EAAmB,EAAkE,OAC9F,MAAK,OAAO,IAAIA,GAAU,EAAQ,EAAW,IAGxD,IAAI,EAAyC,MACnC,GAAe,IACR,IAAMA,GAAU,EAAQ,OAAQ,EAAQ,UAAW,EAAQ,gBACnE,OAAO,IAAI,GAGpB,iBAAiB,EAAgB,MACvB,GAAQ,KAAK,OAAO,YAAY,MAClCA,GAAU,EAAQ,EAAa,GAC/BA,GAAU,EAAQ,EAAa,SAE9B,OAAO,OAAO,GAEvB,0BAA4C,OACjC,MAAK,OAAO,MAAM,YAAY,MAAM,KAAK,OAAO,YAAY,KAAK,IAG5E,4BAA4B,EAAqD,OACtE,MAAK,OAAO,MAAM,YAAY,YAAY,KAAK,OAAO,YAAY,KAAK,GAA2B,QAGvG,gBAAe,EAAgB,EAAmB,EAAkC,MAChF,GAAQ,KAAM,MAAK,OAAO,IAAIA,GAAU,EAAQ,EAAW,IAC7D,MACM,OAAS,OACV,OAAO,IAAI,SAIlB,uBAAwC,MACpC,GAAc,KAAK,OAAO,YAAY,KAAK,MAC7C,GAAQ,cACN,MAAK,OAAO,MAAM,YAAY,cAAc,EAAa,CAAC,EAA+B,EAAkB,OACzG,OAAS,IACT,OAAO,MACF,EACF,KAEJ,WChFwB,CAGnC,YAAY,EAA+B,MAClC,OAAS,EAGlB,OAAO,EAAsB,MACpB,OAAO,OAAO,GAGvB,IAAI,EAAsD,OAC/C,MAAK,OAAO,IAAI,GAG3B,IAAI,EAAgC,MAC3B,OAAO,IAAI,ICpBxB,YAAmB,EAAgB,EAAmB,EAAuC,OAClF,GAAG,KAAU,KAAa,YAUI,CAGrC,YAAY,EAAiC,MACpC,OAAS,EAGlB,IAAI,EAAgB,EAAmB,EAAmE,OAC/F,MAAK,OAAO,IAAI,GAAU,EAAQ,EAAW,IAGxD,IAAI,EAAgB,EAAmB,EAAsB,EAA0C,CAClG,EAAiC,IAAM,GAAU,EAAQ,EAAW,QAChE,OAAO,IAAI,GAGpB,iBAAiB,EAAsB,MAC7B,GAAQ,KAAK,OAAO,YAAY,MAClC,GAAU,EAAQ,EAAa,GAC/B,GAAU,EAAQ,EAAa,SAE9B,OAAO,OAAO,gBCjCQ,EAAe,EAAsB,OAC7D,GAAG,KAAS,YAuBK,CAGxB,YAAY,EAA8B,MACjC,OAAS,EAGlB,QAA+B,OACpB,MAAK,OAAO,iBAGjB,sBAAqB,EAAc,EAAqC,MACpE,GAAM,GAAmB,EAAO,GAChC,EAAuB,eACvB,MAAK,OAAO,MAAM,kBAAkB,aAAa,EAAK,GACpD,EAAM,eAAiB,EAChB,MAEH,KAAK,GACN,KAEJ,EAGX,IAAI,EAA4B,CAC3B,EAA6B,aAAe,GAAmB,EAAU,MAAO,EAAU,WACtF,OAAO,IAAI,GAGpB,OAAO,EAA4B,MAC1B,OAAO,IAAI,GAGpB,OAAO,EAAkB,MAChB,OAAO,OAAO,QAGjB,mBAAkB,EAAmC,MACjD,GAAQ,KAAK,OAAO,YAAY,MAClC,GAAmB,EAAO,GAC1B,GAAmB,EAAO,SAGxB,AADQ,MAAK,OAAO,MAAM,kBACpB,cAAc,EAAO,CAAC,EAAG,EAAI,OACjC,SACG,cChEW,CAG1B,YAAY,EAAgC,MACnC,OAAS,OAGZ,KAAI,EAAqD,OACpD,MAAM,MAAK,OAAO,IAAI,GAGjC,IAAI,EAA+B,MAC1B,OAAO,IAAI,ICOxB,QAAqB,CACjB,YACoB,EACA,EACA,EACA,EAClB,uEAGmB,CAOrB,YAAY,EAAqB,EAAiC,EAAkB,MAC3E,KAAO,OACP,mBAAqB,OACrB,QAAU,QACV,SAAW,OACX,aAAe,MAGpB,aAAyB,OAClB,MAAK,SAAS,cAGrB,cAAkC,OAC3B,MAAK,SAAS,eAGrB,eAAuB,OAChB,MAAK,SAAS,gBAGrB,SAAkB,OACX,MAAK,SAAS,OAGzB,UAAU,EAA8B,IAChC,CAAC,KAAK,mBAAmB,SAAS,QAE5B,IAAI,IAAa,kCAAkC,WAAc,KAAK,mBAAmB,KAAK,4BAEjG,IAAI,IAAM,KAAK,KAAK,YAAY,GAAO,MAGlD,OAAU,EAAkB,EAA0C,IAC9D,CAAC,KAAK,QAAQ,GAAO,MACf,GAAW,KAAK,UAAU,QAC3B,QAAQ,GAAQ,EAAS,SAE3B,MAAK,QAAQ,MAGpB,UAAwB,OACjB,MAAK,OAAO,EAAW,QAAS,GAAY,GAAI,IAAa,EAAU,KAAK,SAAS,kBAG5F,cAAgC,OACzB,MAAK,OAAO,EAAW,YAAa,GAAY,GAAI,IAAiB,OAG5E,sBAAwC,OACjC,MAAK,OAAO,EAAW,oBAAqB,GAAY,GAAI,IAAiB,OAGpF,UAAuB,OAChB,MAAK,OAAO,EAAW,QAAS,GAAY,GAAI,IAAY,OAGnE,oBAA2C,OACpC,MAAK,OAAO,EAAW,kBAAmB,GAAY,GAAI,IAAsB,OAGvF,iBAAqC,OAC9B,MAAK,OAAO,EAAW,eAAgB,GAAY,GAAI,IAAmB,OAGjF,oBAA2C,OACpC,MAAK,OAAO,EAAW,kBAAmB,GAAY,GAAI,IAAsB,OAGvF,YAA4B,OACrB,MAAK,OAAO,EAAW,UAAW,GAAY,GAAI,IAAe,OAGxE,cAA+B,OACxB,MAAK,OAAO,EAAW,YAAa,GAAY,GAAI,IAAgB,OAG3E,gBAAmC,OAC5B,MAAK,OAAO,EAAW,cAAe,GAAY,GAAI,IAAkB,OAG/E,iBAAoC,OAC7B,MAAK,OAAO,EAAW,eAAgB,GAAY,GAAI,IAAkB,OAGhF,mBAAwC,OACjC,MAAK,OAAO,EAAW,iBAAkB,GAAY,GAAI,IAAoB,OAGpF,cAA+B,OACxB,MAAK,OAAO,EAAW,YAAa,GAAY,GAAI,IAAgB,OAG3E,uBAAiD,OAC1C,MAAK,OAAO,EAAW,qBAAsB,GAAY,GAAI,IAAyB,OAG7F,wBAAmD,OAC5C,MAAK,OAAO,EAAW,sBAAuB,GAAY,GAAI,IAA0B,OAG/F,0BAAuD,OAChD,MAAK,OAAO,EAAW,wBAAyB,GAAY,GAAI,IAA4B,OAGnG,aAA6B,OACtB,MAAK,OAAO,EAAW,WAAY,GAAY,GAAI,IAAe,OAGzE,cAAgC,OACzB,MAAK,OAAO,EAAW,YAAa,GAAY,GAAI,IAAiB,SAG1E,UAAS,EAA+B,IACtC,MACM,IAAa,KAAK,YACnB,QACD,MAAK,aAAa,aACb,gBAAgB,GACf,KAAK,aAAa,GAAG,OAEzB,GAId,SAAS,EAAc,OACf,aAAiB,KACb,EAAM,UAAY,cAAgB,KAAK,aAAa,OAC7C,KAAK,aAAa,GAAG,MAG7B,EAGX,MAAM,EAAsB,IAEpB,MACK,KAAK,yBAEL,IAAI,mBAAoB,IAE7B,KAAK,aAAa,aACb,gBAAgB,GAI7B,cAAc,EAAqB,EAA+B,EAAuB,EAA4B,CAE7G,GAAM,UAAY,cAAgB,KAAK,aAAa,SAAW,SAC1D,aAAa,KAAK,GAAI,IAAe,EAAO,EAAS,EAAe,IAIzE,gBAAgB,EAAkC,MAChD,GAAW,GAAkB,CAE1B,KACc,IAAI,oBAAqB,KAAK,6BAEtC,KAAQ,MAAK,eACL,KAAK,CAAC,EAAG,EAAK,cAAe,GAAI,EAAK,MAAO,GAAQ,CAC5D,EAAK,WACA,YAAY,EAAK,WAErB,MAAM,EAAK,UAItB,EAAQ,GAAG,KAAK,aAAa,2CAC/B,IACW,KAAK,EAAO,QAElB,OAAO,IAAI,EAAO,IC/MnC,KAAM,IAAmC,gCAEpB,CAUjB,YAAY,EAA0B,EAAwB,EAAkC,EAAoC,EAA2B,EAAiB,MACvK,IAAM,OACN,WAAa,OACb,YAAc,OACd,2BAA6B,OAC7B,WAAa,OACb,aAAe,OACf,OAAS,EAGlB,oBAAoB,EAAgC,MAC1C,GAAM,EAAW,UAAU,GAAQ,CAAC,GAAY,SAAS,OAC3D,IAAQ,QACF,IAAI,IAAa,0CAA0C,EAAW,WAI9E,SAAQ,EAAgD,MACrD,oBAAoB,MACrB,MACM,GAAM,KAAK,IAAI,YAAY,EAAY,kBAGzC,MAAK,iCACC,GAAa,EAAI,YAAY,EAAW,IAAI,IAAI,KAEnD,GAAI,IAAY,EAAK,EAAY,YACpC,QACE,IAAI,IAAa,iBAAkB,SAI3C,cAAa,EAAgD,MAC1D,oBAAoB,MACrB,MACM,GAAM,KAAK,IAAI,YAAY,EAAY,mBAGzC,MAAK,iCACC,GAAa,EAAI,YAAY,EAAW,IAAI,IAAI,KAEnD,GAAI,IAAY,EAAK,EAAY,YACpC,QACE,IAAI,IAAa,sBAAuB,IAItD,OAAc,MACL,IAAI,WAGT,eAAuB,OAChB,MAAK,IAAI,wBCjEY,EAAkC,MAC5D,GAAM,EAAG,YAAY,GAAa,YAClC,EAAO,eACP,SAAQ,IAAI,GAAY,IAAI,KAAM,IAAQ,MACtC,GAAiB,EAAK,GAAQ,GAC9B,EAAQ,EAAI,YAAY,QACxB,GAAmB,EAAM,aAAc,AAAC,MAClC,KAAK,GACN,OAGR,oBAGyB,EAAiB,EAA6B,MACxE,GAAM,EAAG,YAAY,GAAa,sBAC7B,KAAQ,IAAa,MACtB,GAAQ,EAAI,YAAY,YACnB,KAAS,GAAK,KACf,IAAI,QAGZ,IAAa,GCzBvB,KAAM,IAA2B,EAC3B,GAA2B,EAE1B,YAA2B,EAAU,EAAQ,EAAQ,CACxD,GAAK,GAQD,GAAI,CAAC,EAAS,QAAQ,SAAS,GAC3B,SAAS,QAAQ,KAAK,GACf,MATX,UAAW,CACP,OAAQ,EACR,QAAS,CAAC,GACV,qBAAsB,IAEnB,EAUf,YAAoC,EAAe,OAC/C,KAAM,GAAW,EAAc,UAE/B,MAAO,CACH,OAFW,EAAc,QAGzB,WACA,WAAY,EAAc,KAAK,WAAW,KAC1C,cAAe,EAAc,KAAK,cAAc,KAChD,WAAY,EAAc,WAC1B,YAAa,KAAc,WAAd,cAAwB,qBAItC,QAAoB,CACvB,YAAY,CAAC,UAAS,eAAc,UAAS,YAAW,eAAc,CAClE,KAAK,SAAW,EAChB,KAAK,cAAgB,EACrB,KAAK,wBAA0B,KAC/B,KAAK,SAAW,EAChB,KAAK,WAAa,EAClB,KAAK,aAAe,OAGlB,oBAAmB,EAAS,EAAK,EAAK,CACxC,KAAM,CAAC,kBAAkB,EAQzB,EAAI,IAAI,UAAW,EAAQ,QAC3B,KAAM,SAAQ,IAAI,EAAQ,IAAI,KAAM,IAAU,CAC1C,KAAM,GAAO,KAAM,GAAe,IAAI,GACtC,AAAI,GACA,GAAI,IAAI,CAAC,EAAG,WAAY,GAAI,IAC5B,EAAK,qBAAuB,GAC5B,EAAe,IAAI,OAK/B,mBAAmB,EAAM,EAAe,EAAK,CACzC,MAAO,SAAQ,IAAI,MAAM,KAAK,EAAc,UAAU,IAAI,KAAM,IACrD,KAAK,mBAAmB,EAAc,UAI/C,WAAU,EAAM,EAAK,CACvB,GAAI,EAAK,mBAAqB,CAAC,EAAK,YAChC,OAEJ,KAAM,GAAa,KAAM,GAAK,eAAe,GAC7C,GAAI,CACA,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CACzC,KAAK,SAAS,WAAW,YACzB,KAAK,SAAS,WAAW,iBAE7B,GAAI,GACJ,GAAI,CACA,EAAoB,EAAK,uBAAuB,GAAM,GACtD,KAAM,GAAU,MAAM,KAAK,EAAW,QAAQ,UAC9C,EAAI,IAAI,UAAW,EAAQ,QAC3B,KAAM,MAAK,oBAAoB,EAAS,SACnC,EAAP,CACE,QAAI,QACE,EAEV,KAAM,GAAI,WACV,EAAK,8BAA8B,WAEnC,EAAW,gBAIb,qBAAoB,EAAS,EAAK,CACpC,KAAM,SAAQ,IAAI,EAAQ,IAAI,KAAM,IAAU,CAC1C,AAAI,EAAO,aAAe,QACtB,KAAM,MAAK,aAAa,EAAQ,WAKtC,cAAa,EAAQ,EAAK,CAC5B,KAAM,CAAC,kBAAkB,EACnB,EAAW,KAAM,GAAe,IAAI,EAAO,QAC3C,EAAkB,GAAkB,EAAU,EAAO,OAAQ,EAAO,QAC1E,AAAI,GACA,EAAe,IAAI,QAIrB,6BAA4B,EAAQ,EAAQ,EAAK,CACnD,KAAM,CAAC,iBAAgB,oBAAoB,EACrC,EAAW,KAAM,GAAe,IAAI,GAC1C,AAAI,GACA,GAAS,QAAU,EAAS,QAAQ,OAAO,GAAM,IAAO,GAExD,AAAI,EAAS,QAAQ,SAAW,EAC5B,GAAe,OAAO,GACtB,EAAiB,iBAAiB,IAElC,EAAe,IAAI,SAKzB,oBAAmB,EAAc,EAAK,CAGxC,GAAI,EAAa,UACb,KAAM,MAAK,aAAa,EAAa,OAAQ,WAGxC,EAAa,QAAS,CAC3B,KAAM,CAAC,UAAU,EAEjB,GAAI,EAAa,SAAW,KAAK,WAAY,CACzC,KAAM,GAAU,KAAM,GAAI,YAAY,cAAc,GACpD,KAAM,SAAQ,IAAI,EAAQ,IAAI,GACnB,KAAK,4BAA4B,EAAQ,EAAQ,SAG5D,MAAM,MAAK,4BAA4B,EAAQ,EAAa,OAAQ,SAK1E,YAAW,EAAS,EAAO,EAAK,CAIlC,KAAM,GAAoB,KAAM,GAAM,UAAU,CAC5C,QAAW,IACX,YAAe,EAAQ,OAAO,CAAC,EAAe,IAC1C,GAAc,GAAU,GACjB,GACR,IACH,MAAS,KAAK,iBACf,CAAC,QAAM,WAEJ,EAAsB,EAAI,KAAK,SAAU,GAAO,KAAK,0BAA0B,EAAkB,YAAgB,IACjH,EAAM,KAAM,MAAK,SAAS,aAAa,CACzC,KAAK,SAAS,WAAW,eACzB,KAAK,SAAS,WAAW,mBAE7B,GAAI,GACJ,GAAI,CAKA,EAAmB,AAJc,MAAM,SAAQ,IAAI,EAAoB,IAAI,MAAO,CAAC,SAAQ,kBAAkB,CACzG,KAAM,GAAmB,EAAa,IAAI,IAC1C,MAAO,MAAM,MAAK,8BAA8B,EAAQ,EAAkB,OAElC,OAAO,CAAC,EAAK,IAAY,EAAI,OAAO,GAAU,IAC1F,EAAI,IAAI,UAAW,EAAiB,cAC/B,EAAP,CACE,QAAI,QACE,EAEV,YAAM,GAAI,WACH,OAGL,+BAA8B,EAAQ,EAAkB,EAAK,CAC/D,KAAM,GAAiB,KAAM,GAAI,iBAAiB,gBAAgB,GAIlE,SAAW,KAAY,GACnB,AAAI,EAAiB,MAAM,GAAM,EAAG,WAAa,IAC7C,EAAI,iBAAiB,OAAO,EAAQ,GAK5C,KAAM,GAAsB,GACtB,EAA0B,GAEhC,EAAmB,KAAM,SAAQ,IAAI,EAAiB,IAAI,KAAM,IAAkB,CAC9E,GAAI,EAAe,SAAS,EAAe,UAAW,CAClD,KAAM,GAAiB,KAAM,GAAI,iBAAiB,IAAI,EAAe,OAAQ,EAAe,UAC5F,AAAI,EAAe,aAAe,EAAe,YAC7C,EAAoB,KAAK,GAGjC,EAAoB,KAAK,GACzB,EAAwB,KAAK,MAGjC,SAAW,KAAkB,GACzB,EAAI,iBAAiB,IAAI,GAG7B,KAAM,GAAW,KAAM,GAAI,eAAe,IAAI,GAC9C,SAAS,qBAAuB,GAChC,EAAI,eAAe,IAAI,GAEhB,EAMX,0BAA0B,EAA4B,EAAW,CAC7D,KAAM,GAAiB,GAAI,KAoC3B,MAnCqB,QAAO,QAAQ,GAA4B,IAAI,CAAC,CAAC,EAAQ,KAAkB,CAgC5F,KAAM,GAAe,AA/BG,OAAO,QAAQ,GAAc,OAAO,CAAC,CAAC,EAAU,KAAgB,SACpF,KAAM,GAAiB,EAAW,UAKlC,GAHI,AADiB,EAAW,UACX,GAGjB,IAAmB,EACnB,MAAO,GAEX,KAAM,GAAa,KAAW,OAAX,cAAkB,WAAW,KAC1C,EAAgB,KAAW,OAAX,cAAkB,cAAc,KACtD,GAAI,MAAO,IAAe,UAAY,MAAO,IAAkB,SAC3D,MAAO,GAEX,GAAI,EAAe,IAAI,GACnB,SAAU,IAAI,CACV,EAAG,8CACH,KAAM,GACP,EAAU,MAAM,MACZ,GAEX,EAAe,IAAI,GACnB,KAAM,GAAU,KAAK,mBAAmB,EAAY,GACpD,MAAK,IACD,EAAU,IAAI,CACV,EAAG,uCACH,KAAM,GACP,EAAU,MAAM,MAEhB,IAE0B,IAAI,CAAC,EAAG,KAAgB,GAC7D,MAAO,CAAC,SAAQ,kBAKxB,mBAAmB,EAAe,EAAW,OACzC,KAAM,GAAW,EAAc,UACzB,EAAS,EAAc,QACvB,EAAa,oBAAe,OAAf,cAAsB,GAAG,MAAuB,KACnE,MAAO,IAAuB,KAAK,SAAU,EAAQ,EAAU,EAAY,EAAe,QASxF,uBAAsB,EAAQ,EAAO,EAAK,CAC5C,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,CACpC,KAAK,SAAS,WAAW,YACzB,KAAK,SAAS,WAAW,iBAQvB,EAAU,KAAM,GAAI,YAAY,cAAc,GAEpD,MAAO,MAAM,MAAK,mBAAmB,EAAQ,EAAS,EAAK,EAAO,QAGhE,uBAAsB,EAAQ,EAAS,EAAO,EAAK,CACrD,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,CACpC,KAAK,SAAS,WAAW,iBAE7B,MAAO,MAAM,MAAK,mBAAmB,EAAQ,EAAS,EAAK,EAAO,QAUhE,oBAAmB,EAAQ,EAAS,EAAiB,EAAO,EAAK,CAEnE,KAAM,GAAa,AADS,MAAM,SAAQ,IAAI,EAAQ,IAAI,GAAU,EAAgB,eAAe,IAAI,MAChE,OAAO,GAGnC,GAAY,EAAS,QAAQ,SAAS,IAE3C,EAAqB,EAAW,OAAO,GAAK,EAAE,uBAAyB,IACvE,EAAqB,EAAW,OAAO,GAAK,EAAE,uBAAyB,IAC7E,EAAI,IAAI,WAAY,EAAmB,QACvC,EAAI,IAAI,WAAY,EAAmB,QACvC,GAAI,GACJ,AAAI,EAAmB,QAInB,GAAiB,KAAM,MAAK,WAAW,EAAmB,IAAI,GAAK,EAAE,QAAS,EAAO,IAGzF,KAAM,GAAY,KAAM,MAAK,SAAS,QAAQ,CAC1C,KAAK,SAAS,WAAW,mBAK7B,GAAI,GAAmB,AAHA,MAAM,SAAQ,IAAI,EAAmB,IAAI,GACrD,EAAU,iBAAiB,gBAAgB,EAAS,WAEzB,OAAO,CAAC,EAAK,IAAmB,EAAI,OAAO,GAAiB,IAClG,MAAI,IAAkB,EAAe,QACjC,GAAmB,EAAiB,OAAO,IAG/B,EAAiB,OAAO,GAE7B,CADa,GAAO,SAAW,KAAK,YAAc,EAAO,WAAa,KAAK,oBAMpF,0BAAyB,EAAe,EAAK,CAC/C,MAAO,MAAM,GAAI,iBAAiB,mBAAmB,SCtVhD,IAA0B,CACnC,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IAOJ,YAAkC,EAA+B,OAKpB,CACrC,aAAc,EAAG,QACb,aAAyB,MAAQ,IAAI,OAAM,cAC3C,cAAkC,MAAQ,IAAI,OAAM,WACxD,eAAgB,IAQxB,YAA6B,EAAuB,GAC7C,kBAAkB,UAAW,CAAC,QAAS,UAEvC,kBAAkB,cAAe,CAAC,QAAS,aAI3C,kBAAkB,oBAAqB,CAAC,QAAS,QAE7B,EAAG,kBAAkB,iBAAkB,CAAC,QAAS,QAEzD,YAAY,YAAa,aAAc,CAAC,OAAQ,OAE5D,kBAAkB,YAAa,CAAC,QAAS,UACzC,kBAAkB,gBAAiB,CAAC,QAAS,QAGpD,kBAAiC,EAAiB,EAAoC,MAE5E,GAAc,GAAI,IAAgB,EAAG,kBAAkB,cAAe,CAAC,QAAS,SAEhF,EAAY,EAAI,YAAY,kBAC5B,GAA8B,EAAU,aAAc,GAAS,IAC7D,EAAM,MAAM,OAASG,EAAmB,GAC9B,OAAO,EAAM,UACjB,GAAS,EAAW,gBAAgB,EAAM,OAAQ,EAAM,OAC1D,KACY,IAAI,EAAO,mBAGxB,KAIf,kBAA8B,EAAiB,EAAqB,EAA0C,MACpG,GAAU,EAAI,YAAY,cAC5B,MACM,GAAoB,EACpB,EAAQ,KAAM,GAAa,EAAQ,IAAI,OACzC,EAAO,GACC,OAAO,QACT,CAAC,YAAW,eAAc,kBAAkB,EAAM,MAElD,EAAQ,GAAI,IAAa,EAAgB,KACzC,IAAI,OAAQ,CAAC,MAAO,EAAW,SAAU,MACzC,IAAI,iBAAkB,UAE3B,KACD,gBACI,MAAM,4BAA6B,EAAI,QAIvD,YAA0B,EAAuB,GAC1C,kBAAkB,iBAAkB,CAAC,QAAS,WACxB,EAAG,kBAAkB,mBAAoB,CAAC,QAAS,QAC3D,YAAY,kBAAmB,gBAAiB,CAAC,OAAQ,OACvE,kBAAkB,cAAe,CAAC,QAAS,UAC3C,kBAAkB,uBAAwB,CAAC,QAAS,UACpD,kBAAkB,wBAAyB,CAAC,QAAS,aACrD,kBAAkB,0BAA2B,CAAC,QAAS,QACvC,EAAG,kBAAkB,aAAc,CAAC,QAAS,OACrD,YAAY,iBAAkB,eAAgB,CAAC,OAAQ,KAItE,kBAAqC,EAAiB,EAAoC,YAEhF,GAAc,EAAI,YAAY,eAC9B,EAAY,EAAI,YAAY,aAC5B,EAAmB,QACnB,GAAmB,EAAY,aAAc,MACrC,KAAK,GACR,aAEA,KAAW,GAAW,MACvB,GAAkB,KAAM,GAAa,EAAU,IAAI,GAAG,EAAQ,8BAChE,MACQ,WAAa,oBAAiB,QAAjB,cAAwB,cACtC,GAAQ,cACH,IAAI,KAM5B,YAAgC,EAAuB,GAChD,kBAAkB,cAAe,CAAC,QAAS,SAIlD,YAA2B,EAAuB,GAC3C,kBAAkB,UAAW,CAAC,QAAS,WAI9C,YAAwC,EAAuB,GACxD,kBAAkB,sBAAuB,CAAC,QAAS,mBAI1D,kBAA0C,EAAiB,EAAoC,IACvF,MACM,GAAa,EAAI,YAAY,gBACxB,YAAY,uBACjB,GAAmB,EAAW,aAAc,CAAC,EAAI,EAAK,IAAQ,MAC1D,CAAC,gBAAgB,QAChB,GAAG,kBACJ,CAAC,EAAM,GAAS,EAAa,MAAM,cACtC,aAAe,GAAmB,EAAO,KACxC,OAAO,GACJ,MAEA,YAAY,iBAAkB,eAAgB,CAAC,OAAQ,WAC7D,KACD,gBACI,MAAM,+BAAgC,EAAI,QAK1D,YAAsC,EAAwB,GACvD,kBAAkB,oBAAqB,CAAC,QAAS,QAIxD,kBAA+C,EAAiB,EAAqB,EAA2B,EAAe,MACrH,GAAmB,EAAI,YAAY,eACnC,EAA2B,QAC3B,GAA2B,EAAiB,aAAc,GACxD,GAAY,qBACG,KAAK,EAAY,QAE7B,SAEL,GAA6B,EAAI,YAAY,yBAC7C,EAAsC,EAAI,YAAY,kBACtD,EAAkB,EAAI,YAAY,wBAC7B,KAAU,GAAgB,IAC7B,GAAe,QACb,GAA0B,GAC1B,EAAc,YAAY,MAAM,EAAQ,GAAG,KAAU,IAAe,GAAM,SAC1E,GAAI,KAAK,CAAC,EAAG,OAAQ,GAAI,GAAS,KAAM,IAAO,YAC3C,GAA0B,EAAgB,WAAW,GAAc,GACjE,GAAO,aAAe,UACR,KAAK,EAAO,QAEvB,MAEP,IAAI,gBAAiB,EAAc,iBAC5B,KAAU,GAAe,MAC1B,GAAW,KAAM,GAAa,EAAoB,IAAI,IACtD,EAAoB,oBAAU,UAAV,cAAmB,OACvC,EAAkB,GAAkB,EAAU,EAAQ,GACxD,MACI,IAAI,CAAC,EAAG,YAAa,GAAI,EACzB,YAAa,EAAmB,WAAY,EAAgB,QAAQ,WACpD,IAAI,KACT,MAGnB,IAAI,eAAgB,GACpB,KAG2B,OAAO,MAOlD,kBAAmC,EAAiB,EAAqB,MAC/D,GAAU,EAAI,YAAY,WAC1B,EAAU,KAAM,GAAa,EAAQ,IAAI,YAC3C,KACQ,IAAI,CAAC,IAAK,GAAG,WAAkC,MAAO,EAAQ,QAI9E,kBAAyD,EAAiB,EAAqB,EAA2B,EAAe,MAC/H,GAAU,EAAI,YAAY,WAC1B,EAAe,GAAI,IAAa,GAAI,IAAM,EAAS,GAAyB,IAAM,KAK3E,uCAIP,GAAW,KAAM,GAAa,uCAAuC,KACvE,IAAI,WAAY,GAGxB,kBAA8B,EAAiB,EAAqB,UACrD,KAAa,GAAG,iBAAkB,MACnC,GAAQ,EAAI,YAAY,UACtB,OACC,2BACA,4BACA,kBACA,0BAEA,UAAW,MACN,GAAc,EAAM,aAAc,CAAC,EAAO,EAAK,IAC3C,GAAe,WAAW,MACrB,SAEJ,kBAIN,GACC,iBAQtB,kBAA4C,EAAiB,EAAqB,EAA2B,EAA8B,CAC1G,EAAI,YAAY,wBACxB,YAAY,WAAY,SAAU,CAAC,OAAQ,KAKpE,kBAAmC,EAAiB,EAAqB,EAA2B,EAA8B,MACxH,GAAuB,EAAI,YAAY,2BACzC,GAAmB,EACnB,EAAsB,OACpB,GAAwC,EAAqB,aAAc,CAAC,EAAO,EAAK,KACtF,EAAM,WACA,OAAS,GAAa,cAKtB,OAAS,GAAU,gBAClB,OAAO,MACM,MAEG,EAEpB,MAEP,IAAI,sBAAuB,KAC3B,IAAI,mBAAoB,qBCjSmB,EAA0C,MACnF,GAAS,2CACX,MACM,GAAK,KAAM,IAAa,EAAQ,GAAM,GACrC,kBAAkB,OAAQ,CAAC,QAAS,SACxC,EAAG,GACA,EAAU,EAAG,YAAY,CAAC,QAAS,iBACnC,GAAa,EAAQ,YAAY,QAAQ,IAAI,iBAE7C,IAAI,SAAQ,GAAK,WAAW,EAAG,SAC/B,GAAW,EAAG,YAAY,CAAC,QAAS,kBACpC,SAAQ,YACL,YAAY,QAAQ,IAAI,CAAC,IAAK,UAAW,MAAO,aACnD,IAAa,KAChB,cACE,MACD,EAAI,OAAS,iCACN,SAGR,GChBX,KAAM,IAAc,AAAC,GAAsB,oBAAoB,IACzD,GAA4B,SAAS,EAAmB,EAAwB,EAA2B,EAAe,MACtH,GAAS,CAAC,EAAI,EAAK,EAAY,IAAY,GAAa,EAAI,EAAK,EAAY,EAAS,EAAc,SACnG,IAAa,GAAY,GAAY,EAAQ,GAAO,OAAQ,IAOvE,mBAA2D,cAEjD,GAAO,QACT,uBAAM,YAAN,cAAiB,UAAjB,cAA0B,cACnB,MAAM,GAAK,UAAU,QAAQ,aAC7B,iBAAM,SAAS,wBAClB,aACM,GAAK,SAAS,uBACb,eAEA,cAGJ,WAIa,CAMxB,YAAY,EAA4C,EAAyB,OAAO,UAAW,EAAe,OAAO,YAAa,EAA4B,OAAO,aAAc,MAC9K,sBAAwB,OACxB,YAAc,OACd,aAAe,OACf,cAAgB,OAGnB,QAAO,EAAmB,EAAiC,YACvD,SAAK,wBAAL,cAA4B,+BAA+B,SACvC,KAAK,GAAa,CAEnC,WACO,KAAK,mEAIf,GAA4B,KAAM,IAA6B,KAAK,aACpE,EAAK,KAAM,IAA0B,EAAW,KAAK,YAAa,KAAK,cAAe,SACrF,IAAI,IAAQ,EAAI,KAAK,YAAa,KAAK,aAAc,EAA2B,KAAK,cAAe,EAAI,QAGnH,OAAO,EAAyC,MACtC,GAAe,GAAY,GAC3B,EAAM,KAAK,YAAY,eAAe,SACrC,GAAa,QAGlB,QAAO,EAAmB,EAAgC,MACtD,GAAK,KAAM,IAA0B,EAAW,KAAK,YAAa,KAAK,cAAe,SACrF,MAAM,IAAc,QAGzB,QAAO,EAAmB,EAAc,EAA8B,MAClE,GAAK,KAAM,IAA0B,EAAW,KAAK,YAAa,KAAK,cAAe,SACrF,MAAM,IAAc,EAAI,IAIvC,kBAA4B,EAAiB,EAAqB,EAA2B,EAAiB,EAA2B,EAA8B,MAC7J,GAAW,GAAc,QACxB,GAAI,KACP,CAAE,EAAG,oBAAqB,aAAY,WACtC,KAAO,IAAQ,QACF,GAAI,EAAU,EAAI,EAAS,EAAE,EAAG,MAC/B,GAAgB,GAAO,QACvB,GAAI,KAAK,IAAI,EAAI,IAAK,AAAC,GAAQ,EAAc,EAAI,EAAK,EAAc,OCjFnF,QAAqB,CACxB,YAAY,CAAC,SAAQ,YAAW,sBAAqB,CACjD,KAAK,QAAU,EACf,KAAK,WAAa,EAClB,KAAK,oBAAsB,OAIzB,eAAc,EAAa,EAAK,EAAK,CACvC,KAAM,CAAC,kBAAkB,EACzB,GAAI,EAAgB,CAChB,KAAM,GAAW,GAAY,EAAY,OACzC,AAAI,GAAY,EAAS,UAErB,EAAI,kBAAkB,IAAI,KAAK,QAAS,EAAS,SAAU,EAAS,SAAU,EAAY,IAE9F,KAAM,GAAS,KAAM,GAAI,eAAe,aAAa,KAAK,QAAS,GACnE,GAAI,EAAQ,CACR,KAAM,GAAwB,KAAM,MAAK,eAAe,EAAa,EAAQ,EAAK,GAClF,GAAI,EACA,MAAO,GAAsB,IAAI,GAC7B,GAAI,eAAe,OAAO,GACnB,GAAI,GAAW,EAAG,KAAK,wBAK9C,MAAO,WASL,kBAAiB,EAAc,EAAW,EAAK,EAAK,CACtD,KAAM,GAAc,GAAI,GAAW,EAAc,KAAK,qBAChD,EAAS,KAAM,MAAK,cAAc,EAAa,EAAK,GAG1D,GAAI,EAAU,YAAc,CAAC,GAAW,EAAa,OAAQ,CACzD,KAAM,GAAY,KAAM,GAAI,kBAAkB,gBAAgB,KAAK,QAAS,EAAY,IACxF,GAAI,EAAU,OACV,SAAW,KAAK,GAAW,CACvB,KAAM,GAAuB,KAAM,GAAI,eAAe,aAAa,KAAK,QAAS,EAAE,eACnF,GAAI,EAAsB,CACtB,KAAM,GAAgB,GAAI,GAAW,EAAsB,KAAK,qBAChE,KAAM,MAAK,eAAe,EAAe,EAAc,EAAK,KAM5E,MAAO,QAQL,gBAAe,EAAa,EAAoB,EAAK,EAAK,CAC5D,GAAI,EAAY,YAAc,EAC1B,MAAO,GAAI,KAAK,SAAU,KAAM,IAAO,CACnC,KAAM,GAAgB,EAAmB,MACnC,EAAW,GAAY,GAE7B,GADiB,KAAK,gBAAgB,EAAY,MAAO,EAAoB,EAAK,GACpE,CACV,KAAM,GAAU,CAAC,GACjB,GAAI,EAAU,CACV,KAAM,GAA6B,KAAM,MAAK,qBAAqB,EAAe,EAAU,EAAK,GACjG,AAAI,GACA,EAAQ,KAAK,GAGrB,MAAO,GAEX,MAAO,QAER,CACH,KAAM,GAAW,GAAY,EAAY,OACzC,GAAI,GAAY,CAAC,GAAW,EAAmB,QAEvC,AADY,EAAS,WACT,IACO,EAAI,KAAK,QAAS,GAC1B,KAAK,qBAAqB,EAAY,MAAO,EAAoB,IAGxE,MAAO,CAAC,GAKxB,MAAO,MAGX,gBAAgB,EAAgB,EAAsB,EAAK,EAAK,CAC5D,KAAM,GAAgB,EAAqB,MAC3C,EAAI,IAAI,cAAe,EAAe,UACtC,EAAI,IAAI,KAAM,EAAc,UAE5B,KAAM,GAAW,GAAY,GAC7B,MAAI,IAAY,EAAS,UACrB,EAAI,kBAAkB,OAAO,KAAK,QAAS,EAAS,SAAU,EAAS,SAAU,EAAc,UAGnG,EAAI,kBAAkB,mBAAmB,KAAK,QAAS,EAAc,UAErE,GAAY,EAAgB,GAC5B,MAAO,GAAqB,YAErB,GAGX,qBAAqB,EAAiB,EAA6B,CAE/D,KAAM,GAAW,GAAY,GAC7B,GAAI,CAAC,EACD,MAAO,GAGX,GAAI,CAAC,eAAe,EACpB,AAAK,GACD,GAAmB,YAAc,EAAc,IAEnD,GAAI,GAAa,EAAY,EAAS,KACtC,AAAK,GACD,GAAY,EAAS,KAAO,EAAa,CACrC,MAAO,EACP,GAAI,GACJ,eAAgB,OAAO,mBAG/B,KAAM,GAAW,EAAgB,SAAW,KAAK,WAEjD,SAAW,GAAK,EAAW,IAAM,EACjC,EAAW,OAAS,EACpB,EAAW,eAAiB,KAAK,IAC7B,EAAW,eACX,EAAgB,kBAGb,QAGL,sBAAqB,EAAuB,EAAkB,EAAK,EAAK,CAC1E,MAAI,GAAiB,WAAa,GACvB,EAAI,KAAK,0BAA2B,GAAO,KAAK,uBACnD,EAAiB,SACjB,EAAiB,IACjB,EAAK,IAGN,UAGL,wBAAuB,EAAU,EAAK,EAAK,EAAK,CAClD,KAAM,GAAS,KAAM,GAAI,eAAe,aAAa,KAAK,QAAS,GACnE,GAAI,CAAC,GAAU,CAAC,EAAO,YACnB,MAAO,MAEX,EAAI,IAAI,KAAM,GACd,KAAM,GAAY,KAAM,GAAI,kBAAkB,oBAAoB,KAAK,QAAS,EAAU,IAC1F,SAAI,IAAI,YAAa,EAAU,QAC/B,MAAO,GAAO,YAAY,GACtB,GAAc,EAAO,cACrB,MAAO,GAAO,YAElB,KAAM,SAAQ,IAAI,EAAU,IAAI,KAAM,IAAY,CAC9C,KAAM,GAAa,KAAM,GAAI,eAAe,aAAa,KAAK,QAAS,EAAS,eAChF,AAAK,GACD,EAAI,IAAI,CAAC,EAAG,qBAAsB,GAAI,EAAS,gBAE/C,GAAY,EAAW,OAAO,MAAQ,GACtC,KAAK,qBAAqB,EAAW,MAAO,EAAQ,MAGrD,GAIf,YAAuB,EAAK,CACxB,SAAW,KAAO,GACd,GAAI,EAAI,eAAe,GACnB,MAAO,GAGf,MAAO,WCjMY,CACnB,YAA4B,EAAoB,qBAG5C,aAAsB,OACf,CAAC,KAAK,UAGjB,aAAsB,OACX,MAAK,UAAY,IAAM,IAGlC,SAAqB,OACV,MAAK,UAAY,GAAU,SAAW,GAAU,kBAGhD,UAAqB,OACrB,cAGA,WAAsB,OACtB,KAIf,KAAM,IAAW,GAAI,IAAU,IACzB,GAAY,GAAI,IAAU,ICrBzB,eAAoC,GAAU,CACjD,YAAY,EAAU,EAAiB,EAAoB,CACvD,MAAM,GACN,KAAK,UAAY,EAEjB,KAAK,iBAAmB,QAGrB,OAAM,EAAU,EAAoB,CACvC,MAAO,IAAI,GAAsB,EAAU,GAAM,SAG9C,KAAI,EAAU,EAAoB,CACrC,MAAO,IAAI,GAAsB,EAAU,GAAO,MAGlD,UAAU,CACV,MAAO,MAAK,oBAGZ,WAAW,CACX,MAAO,CAAC,KAAK,WAGb,WAAW,CACX,MAAO,MAAK,aAGZ,aAAa,CACb,MAAO,MAAK,UAAU,MAGtB,aAAa,CACb,MAAI,MAAK,QACE,EAAU,cAEV,EAAU,iBAIrB,QAAQ,CACR,MAAO,CAAC,CAAC,KAAK,OAAS,CAAC,KAAK,eAG7B,QAAQ,CACR,MAAI,MAAK,QACE,KAAK,SAAS,cAEd,KAAK,SAAS,aAIzB,OAAM,EAAO,CACb,AAAI,KAAK,QACL,KAAK,SAAS,cAAgB,EAE9B,KAAK,SAAS,UAAY,KAI9B,cAAc,CACd,MAAI,MAAK,QACE,KAAK,SAAS,aAEd,KAAK,SAAS,cAIzB,aAAY,EAAS,CAErB,AAAI,KAAK,QACL,KAAK,SAAS,aAAe,EAE7B,KAAK,SAAS,WAAa,KAM/B,mBAAmB,CACnB,MAAI,MAAK,QACE,KAAK,SAAS,WAEd,KAAK,SAAS,UAIzB,kBAAiB,EAAI,CACrB,AAAI,KAAK,QACL,KAAK,SAAS,WAAa,EAE3B,KAAK,SAAS,OAAS,KAI3B,oBAAoB,CACpB,MAAO,IAAkB,KAAK,qBAG9B,YAAY,CACZ,MAAI,MAAK,QACE,GAAU,SAEV,GAAU,QAIzB,oBAAoB,EAAU,CAC1B,MAAO,IAAI,GAAsB,EAAU,KAAK,iBAAkB,KAAK,qBAG3E,qBAAqB,EAAW,CAC5B,MAAO,IAAI,GAAsB,EAAW,CAAC,KAAK,iBAAkB,KAAK,qBAG7E,kBAAmB,EACnB,qBAAsB,GChH1B,YAA2B,EAAQ,CAC/B,KAAM,GAAW,GAAI,KACrB,MAAO,GAAO,OAAO,GACb,EAAS,IAAI,EAAE,UACR,GAEP,GAAS,IAAI,EAAE,UACR,KAKZ,QAAiB,CACpB,YAAY,CAAC,SAAQ,qBAAoB,eAAc,kBAAiB,CACpE,KAAK,QAAU,EACf,KAAK,cAAgB,EACrB,KAAK,gBAAkB,EACvB,KAAK,oBAAsB,EAC3B,KAAK,aAAe,UAGlB,MAAK,EAAK,EAAK,CACjB,KAAM,GAAe,KAAM,GAAI,kBAAkB,aAAa,KAAK,SACnE,GAAI,EAAc,CACd,KAAM,CAAC,GAAa,KAAM,GAAI,eAAe,WAAW,KAAK,QAAS,EAAa,GAAI,GAIjF,EAAa,EAAY,EAAU,WAAa,EAAS,eAAe,WAC9E,KAAK,aAAe,GAAI,GAAS,EAAa,GAAI,GAItD,AAAI,KAAK,cACL,EAAI,IAAI,WAAY,KAAK,aAAa,iBAIxC,qBAAoB,EAAK,EAAe,CAC1C,KAAM,GAAe,KAAM,GAAI,kBAAkB,aAAa,KAAK,SACnE,GAAK,EAgBD,MAAO,GAhBQ,CACf,AAAK,GACD,GAAgB,MAEpB,KAAM,GAAW,CACb,OAAQ,KAAK,QACb,GAAI,EAAS,eAAe,WAC5B,WAAY,KACZ,OAAQ,KACR,cAAe,EACf,UAAW,MAEf,SAAI,kBAAkB,IAAI,GAC1B,KAAK,oBAAoB,IAAI,GACtB,QAMT,sBAAqB,EAAe,EAAe,EAAe,EAAK,CACzE,KAAM,GAAc,KAAM,GAAI,kBAAkB,IAAI,KAAK,QAAS,GAClE,GAAI,CAAC,EACD,KAAM,IAAI,OAAM,oCAAoC,KAExD,EAAY,OAAS,EACrB,EAAI,kBAAkB,OAAO,GAC7B,KAAM,GAAc,CAChB,OAAQ,KAAK,QACb,GAAI,EACJ,WAAY,EACZ,OAAQ,KACR,cAAe,EACf,UAAW,MAEf,SAAI,kBAAkB,IAAI,GAC1B,KAAK,oBAAoB,OAAO,EAAe,GACxC,CAAC,cAAa,oBAWnB,qBAAoB,EAAY,EAAS,EAAU,EAAK,EAAK,CAC/D,GAAK,GASE,GAAI,EAAS,QAAS,CAEzB,KAAM,GAAgB,EAAW,WACjC,EAAa,EAAW,kBACxB,KAAM,CAAC,cAAa,eAAe,KAAM,MAAK,qBAAqB,EAAe,EAAW,WAAY,EAAS,WAAY,GAC9H,EAAQ,KAAK,EAAsB,IAAI,EAAa,KAAK,sBACzD,EAAQ,KAAK,EAAsB,MAAM,EAAa,KAAK,sBAC3D,EAAI,IAAI,CAAC,EAAG,gBAAiB,QAAS,GAAM,GAAI,EAAW,kBAhB9C,CAKb,GAAI,GAAe,KAAM,MAAK,oBAAoB,EAAK,EAAS,YAChE,EAAa,GAAI,GAAS,EAAa,GAAI,EAAS,eAAe,YACnE,EAAQ,KAAK,EAAsB,MAAM,EAAc,KAAK,sBAC5D,EAAI,IAAI,CAAC,EAAG,gBAAiB,MAAO,GAAM,GAAI,EAAW,aAU7D,MAAO,QAGL,mBAAkB,EAAa,EAAK,EAAK,CAC3C,GAAI,GAAuB,EAC3B,SAAW,KAAS,GAEhB,AAAI,EAAM,OAASA,GACf,GAAI,UAAU,IAAI,KAAK,QAAS,GAChC,GAAwB,GAGhC,EAAI,IAAI,cAAe,QAGrB,gBAAe,EAAgB,EAAU,EAAY,EAAY,EAAK,EAAK,CAC7E,KAAM,GAAU,GACV,EAAiB,GACvB,GAAI,iBAAgB,OAAQ,CAExB,EAAa,KAAM,MAAK,oBAAoB,EAAY,EAAS,EAAU,EAAK,GAChF,EAAI,IAAI,iBAAkB,EAAe,QACzC,GAAI,GAA0B,EAC9B,SAAU,KAAS,GAAgB,CAE/B,EAAa,EAAW,UACxB,KAAM,GAAe,GAAiB,EAAY,KAAK,QAAS,GAChE,GAAI,GAAS,KAAM,GAAW,oBAAoB,EAAM,OAAQ,EAAO,GAMvE,GALI,GACA,GAAa,YAAc,EAAO,YAClC,EAAa,UAAY,EAAO,WAGhC,CADgB,KAAM,GAAI,eAAe,UAAU,EAAc,GAEjE,SAEJ,KAAM,GAAQ,GAAI,GAAW,EAAc,KAAK,qBAChD,EAAQ,KAAK,GACb,KAAM,GAA+B,KAAM,MAAK,gBAAgB,cAAc,EAAO,EAAK,GAC1F,AAAI,GACA,EAAe,KAAK,GAAG,GAMvB,MAAO,GAAM,WAAc,UAAY,EAAM,OAASA,GACtD,IAA2B,EAC3B,EAAI,UAAU,IAAI,KAAK,QAAS,IAGxC,EAAI,IAAI,0BAA2B,GAEvC,MAAO,CAAC,aAAY,UAAS,uBAG3B,sBAAqB,EAAU,EAAK,EAAK,CAC3C,GAAI,KAAK,aAAc,CACnB,KAAM,CAAC,cAAc,KAAK,aACpB,CAAC,GAAa,KAAM,GAAI,eAAe,WAAW,KAAK,QAAS,EAAY,GAClF,GAAI,EAAW,CACX,KAAM,GAAc,EAAU,MAAM,SAC9B,CAAC,UAAU,EACX,EAAQ,EAAO,UAAU,GAAS,EAAM,WAAa,GAC3D,GAAI,IAAU,GACV,SAAI,IAAI,mBAAoB,GACrB,OAAO,OAAO,GAAI,EAAU,CAC/B,QAAS,GACT,OAAQ,EAAO,MAAM,EAAQ,MAK7C,MAAK,GAAS,QAIP,EAHH,GAAI,IAAI,gCAAiC,IAClC,OAAO,OAAO,GAAI,EAAU,CAAC,QAAS,WAe/C,WAAU,EAAc,EAAU,EAAmB,EAAK,EAAK,CACjE,GAAI,CAAC,YAAY,EAGjB,EAAI,IAAI,WAAY,GAChB,GACA,GAAW,KAAM,MAAK,qBAAqB,EAAU,EAAK,IAE9D,GAAI,GACJ,AAAI,MAAM,QAAQ,iBAAU,SACxB,GAAiB,GAAkB,EAAS,SAEhD,KAAM,CAAC,SAAS,EAChB,GAAI,GACJ,AAAI,MAAM,QAAQ,iBAAO,SACrB,GAAc,EAAM,QAExB,KAAM,GAAa,KAAK,cAAc,kBAAkB,EAAa,EAAgB,GACrF,AAAI,GACA,KAAM,MAAK,kBAAkB,EAAa,EAAK,GAEnD,KAAM,CAAC,aAAY,UAAS,kBACxB,KAAM,MAAK,eAAe,EAAgB,EAAU,EAAY,KAAK,aAAc,EAAK,GACtF,EAAgB,KAAM,GAAW,MAAM,GAC7C,MAAO,CAAC,UAAS,iBAAgB,WAAY,EAAY,iBAG7D,UAAU,EAAY,CAClB,KAAK,aAAe,KAGpB,iBAAiB,CACjB,MAAO,MAAK,sBCxOS,CAKzB,YAAY,EAAe,MAClB,MAAQ,OACR,SAAW,MAGhB,OAAO,OAAS,MAAK,SAAS,OAExB,KAAK,EAA8B,OAClC,MAAK,qBAAqB,KAAK,SAAS,UAAU,IAGnD,qBAAqB,EAAa,IACpC,IAAQ,GAAI,MACN,GAAQ,KAAK,SAAS,SAExB,GAAM,SACD,SAAS,OAAO,EAAK,QACrB,SAAS,QAAQ,IAEnB,GAIL,KAAK,EAAU,EAA+B,IAChD,GAAgB,EAAc,KAAK,SAAS,UAAU,GAAe,QACpE,SAAS,QAAQ,GAClB,IAAkB,GACd,KAAK,SAAS,OAAS,KAAK,UACZ,KAAK,SAAS,OAAS,MAI1B,EAEjB,IAAkB,UACb,aAAa,KAAK,SAAS,SAC3B,SAAS,OAAO,EAAe,IAIlC,aAAa,EAAU,mBAGD,GAAgB,CAGhD,YAAY,EAAO,EAAiB,OAC1B,QACD,OAAS,EAGlB,IAAI,EAAuB,OAChB,MAAK,KAAK,GAAK,KAAK,OAAO,KAAO,GAG7C,IAAI,EAAU,MACJ,GAAM,KAAK,OAAO,QACnB,KAAK,EAAO,GAAK,KAAK,OAAO,KAAO,ICjE1C,QAAmB,CACtB,YAAY,EAAQ,CAChB,KAAK,QAAU,EACf,KAAK,OAAS,GAAI,IAAS,EAAG,GAAU,EAAO,QAGnD,kBAAkB,EAAa,EAAgB,EAAmB,CAC9D,MAAO,IAAI,IAAW,KAAM,EAAa,EAAgB,QAGvD,cAAa,EAAQ,EAAK,CAC5B,GAAI,GAAiB,KAAK,OAAO,IAAI,EAAO,QAC5C,GAAI,CAAC,EAAgB,CACjB,KAAM,GAAa,KAAM,GAAI,YAAY,IAAI,KAAK,QAAS,EAAO,QAClE,AAAI,GACA,GAAiB,GAAI,GAAW,IAIxC,GAAI,CAAC,GAAkB,CAAC,EAAe,OAAO,GAC1C,SAAI,YAAY,IAAI,EAAO,aAC3B,KAAK,OAAO,IAAI,GACT,GAAI,IAAa,EAAQ,iBAAgB,iBAIlD,cAAa,EAAQ,EAAK,CAC5B,GAAI,GAAS,KAAK,OAAO,IAAI,GAC7B,GAAI,CAAC,EAAQ,CACT,KAAM,GAAa,KAAM,GAAI,YAAY,IAAI,KAAK,QAAS,GAC3D,AAAI,GACA,GAAS,GAAI,GAAW,GACxB,KAAK,OAAO,IAAI,IAGxB,MAAO,IAIf,QAAiB,CACb,YAAY,EAAc,EAAa,EAAgB,EAAmB,CACtE,KAAK,cAAgB,EACrB,KAAK,gBAAkB,EACvB,KAAK,mBAAqB,EAC1B,KAAK,iBAAmB,KACpB,GACA,MAAK,iBAAmB,KAAK,sBAAsB,OAIvD,UAAU,CACV,MAAO,MAAK,cAAc,QAG9B,sBAAsB,EAAa,CAC/B,GAAI,GACJ,SAAW,KAAS,GAChB,GAAI,EAAM,OAASA,EAAmB,CAClC,KAAM,GAAS,EAAW,gBAAgB,KAAK,QAAS,GACxD,AAAI,GACK,IACD,GAAU,GAAI,MAElB,EAAQ,IAAI,EAAO,OAAQ,IAIvC,MAAO,GAGX,yBAAyB,EAAgB,CACrC,GAAI,GAEJ,OAAS,GAAI,EAAe,OAAS,EAAG,GAAK,EAAG,IAAK,CACjD,KAAM,GAAI,EAAe,GACnB,EAAS,EAAE,UACjB,GAAI,EAAE,OAASA,GAAqB,CAAC,kBAAS,IAAI,IAAS,CACvD,KAAM,GAAS,EAAW,gBAAgB,KAAK,QAAS,GACxD,AAAI,GACK,IACD,GAAU,GAAI,MAElB,EAAQ,IAAI,EAAO,OAAQ,KAIvC,MAAO,QAGL,qBAAoB,EAAQ,EAAO,EAAK,OAC1C,GAAI,GAQJ,MAPI,MAAK,iBACL,GAAS,KAAK,oCAAoC,EAAQ,GACtD,IAIR,GAAS,QAAK,mBAAL,cAAuB,IAAI,GAChC,GACO,EAEJ,KAAM,MAAK,cAAc,aAAa,EAAQ,QAGnD,OAAM,EAAK,CACb,KAAM,GAAgB,GAAI,KAC1B,GAAI,GAIJ,GAHI,KAAK,iBACL,GAAqB,KAAK,yBAAyB,KAAK,kBAExD,KAAK,kBACL,SAAW,KAAU,MAAK,iBAAiB,SACvC,GAAI,CAAC,kBAAoB,IAAI,EAAO,SAAS,CACzC,KAAM,GAAe,KAAM,MAAK,cAAc,aAAa,EAAQ,GACnE,AAAI,GAQI,CAD2B,CAAC,KAAK,oBAAsB,CAAC,EAAa,oBAErE,GAAa,mBAAqB,EAAO,YAE7C,EAAc,IAAI,EAAa,OAAQ,KAKvD,GAAI,EACA,SAAW,KAAU,GAAmB,SAAU,CAC9C,KAAM,GAAe,KAAM,MAAK,cAAc,aAAa,EAAQ,GACnE,AAAI,GACA,EAAc,IAAI,EAAa,OAAQ,GAInD,MAAO,GAKX,oCAAoC,EAAQ,EAAO,CAC/C,GAAI,GAAa,GACjB,OAAS,GAAI,KAAK,gBAAgB,OAAS,EAAG,GAAK,EAAG,IAElD,GAAI,AADM,KAAK,gBAAgB,GACzB,WAAa,EAAM,SAAU,CAC/B,EAAa,EACb,MAGR,OAAS,GAAI,EAAa,EAAG,GAAK,EAAG,IAAK,CACtC,KAAM,GAAI,KAAK,gBAAgB,GAC/B,GAAI,EAAE,OAASA,GAAqB,EAAE,YAAc,EAAQ,CACxD,KAAM,GAAS,EAAW,gBAAgB,KAAK,QAAS,GACxD,GAAI,EACA,MAAO,MC3JpB,QAAgB,CACnB,YAAY,CAAC,SAAQ,UAAS,qBAAoB,kBAAiB,CAC/D,KAAK,QAAU,EACf,KAAK,SAAW,EAChB,KAAK,oBAAsB,EAC3B,KAAK,gBAAkB,OAGrB,wBAAuB,EAAe,EAAQ,EAAK,EAAK,CAC1D,KAAM,GAAW,EAAO,IAAI,GAAK,EAAE,UAC7B,EAAsB,KAAM,GAAI,eAAe,mBAAmB,KAAK,QAAS,GACtF,EAAI,IAAI,iBAAkB,EAAoB,MAC9C,KAAM,GAAuB,EAAO,OAAO,GAAK,CAAC,EAAoB,IAAI,EAAE,WAC3E,EAAI,IAAI,uBAAwB,EAAqB,QACrD,GAAI,GACJ,GAAI,EAAc,kBAAmB,CACjC,EAAI,IAAI,mBAAoB,EAAc,kBAC1C,SAAW,KAAY,GAAoB,SACvC,GAAI,EAAS,aAAe,EAAc,iBAAkB,CACxD,EAAI,IAAI,sBAAuB,IAC/B,KAAM,GAAoB,KAAM,GAAI,kBAAkB,IAAI,KAAK,QAAS,EAAc,kBACtF,EAAyB,EAAc,qBAAqB,GAC5D,OAIZ,MAAO,CAAC,uBAAsB,+BAG5B,2BAA0B,EAAe,EAAK,CAChD,KAAM,CAAC,aAAY,aAAa,EAC1B,EAAQ,KAAM,MAAK,uBAAuB,EAAY,EAAW,GACvE,MAAI,GACO,GAAI,GAAS,EAAM,WAAY,EAAM,YAGrC,EAAS,mBAAmB,EAAc,iBAInD,wBAAuB,EAAY,EAAW,EAAK,CACrD,GAAI,EAAU,WAAY,CACtB,KAAM,CAAC,GAAc,KAAM,GAAI,eAAe,YAAY,KAAK,QAAS,EAAY,GACpF,MAAO,OACJ,CACH,KAAM,CAAC,GAAa,KAAM,GAAI,eAAe,WAAW,KAAK,QAAS,EAAY,GAClF,MAAO,SAIT,cAAa,EAAQ,EAAU,EAAW,EAAO,EAAK,EAAK,CAC7D,KAAM,GAAU,GACV,EAAiB,GAGvB,GAAI,GAAM,EACV,OAAS,GAAI,EAAG,EAAI,EAAO,OAAQ,EAAE,EAAG,CACpC,KAAM,GAAQ,EAAO,GACrB,EAAM,EAAI,oBAAoB,GAC9B,KAAM,GAAoB,GAAiB,EAAK,KAAK,QAAS,GACxD,EAAS,KAAK,YAAY,EAAM,OAAQ,EAAO,EAAQ,EAAG,GAChE,AAAI,GACA,GAAkB,YAAc,EAAO,YACvC,EAAkB,UAAY,EAAO,WAGzC,KAAM,GAA+B,KAAM,MAAK,gBAAgB,iBAAiB,EAAmB,EAAW,EAAK,GAIpH,GAHI,GACA,EAAe,KAAK,GAAG,GAEvB,KAAM,GAAI,eAAe,UAAU,EAAmB,GAAM,CAC5D,KAAM,GAAa,GAAI,GAAW,EAAmB,KAAK,qBAC1D,GAAkB,EAAS,EAAY,IAG/C,MAAO,CAAC,UAAS,kBAGrB,YAAY,EAAQ,EAAO,EAAQ,EAAO,EAAW,CACjD,WAAmB,EAAO,CACtB,MAAO,GAAM,OAASA,GAAqB,EAAM,YAAc,EAGnE,KAAM,GAAM,EAAU,WAAa,EAAI,GACvC,OAAS,GAAI,EAAQ,EAAK,GAAK,GAAK,EAAI,EAAO,OAAQ,GAAK,EAAK,CAC7D,KAAM,GAAQ,EAAO,GACrB,GAAI,EAAU,GACV,MAAO,GAAW,gBAAgB,KAAK,QAAS,GAOxD,OAAS,GAAI,EAAO,GAAK,GAAK,EAAI,EAAO,OAAQ,GAAK,EAAK,CACvD,KAAM,GAAQ,EAAO,GACrB,GAAI,EAAU,GACV,MAAO,GAAW,yBAAyB,KAAK,QAAS,GAKjE,KAAM,GAAmB,iBAAO,KAAK,GACrC,GAAI,EACA,MAAO,GAAW,gBAAgB,KAAK,QAAS,QAIlD,kBAAiB,EAAe,EAAwB,EAAK,EAAS,EAAK,EAAK,CAClF,KAAM,CAAC,aAAa,EACd,EAAmB,GACzB,UAAkB,EAAS,EAAe,GAE1C,AAAI,EAGA,GAAI,IAAI,gBAAiB,EAAuB,YAChD,EAAuB,MAAQ,KAC/B,EAAc,MAAQ,KAEtB,EAAI,kBAAkB,OAAO,EAAuB,UACpD,GAAkB,EAAS,EAAwB,GAInD,EAAiB,KAAK,EAAc,UACpC,EAAiB,KAAK,EAAuB,WAE7C,EAAc,MAAQ,EAE1B,EAAI,kBAAkB,OAAO,EAAc,UAEpC,OAGL,mBAAkB,EAAe,EAAU,EAAK,EAAK,CACvD,KAAM,CAAC,aAAY,aAAa,EAE1B,CAAC,QAAO,QAAO,SAAS,EAC9B,GAAI,CAAC,OAAO,EAEZ,GAAI,CAAC,MAAM,QAAQ,GACf,KAAM,IAAI,OAAM,6BAEpB,GAAI,MAAO,IAAQ,SACf,KAAM,IAAI,OAAM,iCAIpB,KAAM,GAAW,KAAM,GAAI,kBAAkB,IAAI,KAAK,QAAS,GAC/D,GAAI,CAAC,EACD,KAAM,IAAI,OAAM,qBAAqB,KAIzC,GAFA,EAAgB,EAAc,oBAAoB,GAE9C,EAAc,QAAU,EACxB,KAAM,IAAI,OAAM,kDAIpB,GAAI,EAAM,SAAW,EACjB,SAAc,YAAc,GAC5B,KAAM,GAAI,kBAAkB,OAAO,EAAc,UAC1C,CAAC,QAAS,CAAC,GAAgB,eAAgB,GAAI,UAAW,IAIrE,GAAI,GAAU,KAAM,MAAK,0BAA0B,EAAe,GAClE,EAAI,IAAI,UAAW,EAAQ,YAE3B,KAAM,CACF,uBACA,0BACA,KAAM,MAAK,uBAAuB,EAAe,EAAO,EAAK,GAE3D,CAAC,UAAS,kBAAkB,KAAM,MAAK,aAAa,EAAsB,EAAS,EAAW,EAAO,EAAK,GAC1G,EAAY,KAAM,MAAK,iBAAiB,EAAe,EAAwB,EAAK,EAAS,EAAK,GAExG,MAAO,CAAC,UAAS,iBAAgB,8BClKW,GAAwD,CACxG,WAAY,QACA,KAAK,MAAK,YACZ,QAAQ,MAKlB,QAAQ,EAAe,EAAgB,QAC3B,KAAK,MAAK,YACZ,MAAM,EAAO,EAAO,MAI9B,WAAW,EAAe,EAAU,EAAoB,QAC5C,KAAK,MAAK,YACZ,SAAS,EAAO,EAAO,EAAQ,MAIzC,WAAW,EAAe,EAAgB,QAC9B,KAAK,MAAK,YACZ,SAAS,EAAO,EAAO,MAMjC,SAAS,EAAiB,EAAe,EAAgB,QAC7C,KAAK,MAAK,YACZ,OAAO,EAAS,EAAO,EAAO,OCnD5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAQ+B,EAAY,EAAU,EAA0C,IACvF,GAAM,EACN,EAAO,EAAM,YAEV,EAAM,GAAM,IACX,GAAO,EAAM,IAAU,EACvB,EAAY,EAAW,EAAO,EAAM,IAEpC,EAAY,IACN,EAAM,EACL,EAAY,IACZ,IAED,EAAO,QAGd,GCtBJ,gBAAgC,GAAe,CAClD,WAAY,CACR,OAAQ,KAAK,MAAK,UACd,EAAE,UAKV,QAAQ,EAAK,EAAO,CAChB,OAAQ,KAAK,MAAK,UACd,EAAE,MAAM,EAAK,GAIrB,WAAW,EAAK,KAAU,EAAQ,CAC9B,OAAQ,KAAK,MAAK,UACd,EAAE,SAAS,EAAK,EAAO,GAAG,GAIlC,WAAW,EAAK,EAAO,CACnB,OAAQ,KAAK,MAAK,UACd,EAAE,SAAS,EAAK,IAIvB,OAAO,WAAY,CAChB,KAAM,IAAI,OAAM,oBAGhB,OAAO,CACP,KAAM,IAAI,OAAM,iBAIpB,IAAI,EAAK,CACL,KAAM,IAAI,OAAM,kBCpCjB,gBAA4B,GAAkB,CACjD,YAAY,EAAe,CACvB,QACA,KAAK,QAAU,GAAI,KAAI,GAG3B,OAAO,EAAK,EAAQ,CAChB,KAAM,GAAQ,KAAK,QAAQ,IAAI,GAC/B,MAAI,KAAU,OAGV,MAAK,QAAQ,IAAI,EAAK,GACtB,KAAK,WAAW,EAAK,EAAO,GACrB,IAEJ,GAGX,IAAI,EAAK,EAAO,CACZ,MAAK,MAAK,QAAQ,IAAI,GAKf,GAJH,MAAK,QAAQ,IAAI,EAAK,GACtB,KAAK,QAAQ,EAAK,GACX,IAKf,OAAO,EAAK,CACR,KAAM,GAAQ,KAAK,QAAQ,IAAI,GAC/B,MAAI,KAAU,OACV,MAAK,QAAQ,OAAO,GACpB,KAAK,WAAW,EAAK,GACd,IAEA,GAIf,IAAI,EAAK,EAAO,CACZ,MAAI,MAAK,QAAQ,IAAI,GAEjB,MAAK,QAAQ,IAAI,EAAK,GACf,KAAK,OAAO,IAGZ,KAAK,IAAI,EAAK,GAI7B,OAAQ,CACJ,KAAK,QAAQ,QACb,KAAK,YAGT,IAAI,EAAK,CACL,MAAO,MAAK,QAAQ,IAAI,MAGxB,OAAO,CACP,MAAO,MAAK,QAAQ,MAGvB,OAAO,WAAY,CAChB,MAAO,MAAK,QAAQ,UAGxB,QAAS,CACL,MAAO,MAAK,QAAQ,SAGxB,MAAO,CACH,MAAO,MAAK,QAAQ,QC1CrB,gBAA4B,GAAmB,CAClD,YAAY,EAAW,EAAY,CAC/B,QACA,KAAK,WAAa,EAClB,KAAK,YAAc,CAAC,EAAG,IAAM,EAAW,EAAE,MAAO,EAAE,OACnD,KAAK,aAAe,KACpB,KAAK,iBAAmB,KAG5B,MAAM,EAAK,EAAO,CACd,KAAM,GAAO,CAAC,MAAK,SACb,EAAM,GAAY,KAAK,aAAc,EAAM,KAAK,aACtD,KAAK,aAAa,OAAO,EAAK,EAAG,GACjC,KAAK,QAAQ,EAAK,GAGtB,SAAS,EAAK,EAAO,CACjB,KAAM,GAAO,CAAC,MAAK,SACb,EAAM,GAAY,KAAK,aAAc,EAAM,KAAK,aAEtD,KAAK,aAAa,OAAO,EAAK,GAC9B,KAAK,WAAW,EAAK,GAGzB,SAAS,EAAK,EAAO,EAAQ,CAEzB,GAAI,CAAC,KAAK,aACN,OAGJ,KAAM,GAAS,KAAK,aAAa,UAAU,GAAK,EAAE,MAAQ,GAG1D,KAAK,aAAa,OAAO,EAAQ,GACjC,KAAM,GAAO,CAAC,MAAK,SACb,EAAS,GAAY,KAAK,aAAc,EAAM,KAAK,aACzD,KAAK,aAAa,OAAO,EAAQ,EAAG,GAChC,IAAW,GACX,KAAK,SAAS,EAAQ,EAAQ,GAElC,KAAK,WAAW,EAAQ,EAAO,GAGnC,SAAU,CACN,KAAK,aAAe,GACpB,KAAK,YAGT,kBAAmB,CACf,KAAK,iBAAmB,KAAK,WAAW,UAAU,MAClD,KAAK,aAAe,GAAI,OAAM,KAAK,WAAW,MAC9C,GAAI,GAAI,EACR,OAAS,CAAC,EAAK,IAAU,MAAK,WAC1B,KAAK,aAAa,GAAK,CAAC,MAAK,SAC7B,EAAE,EAEN,KAAK,aAAa,KAAK,KAAK,aAC5B,MAAM,mBAGV,mBAAoB,CAChB,MAAM,oBACN,KAAK,aAAe,KACpB,KAAK,iBAAmB,KAAK,mBAGjC,IAAI,EAAO,CACP,MAAO,MAAK,aAAa,GAAO,SAGhC,SAAS,CACT,MAAO,MAAK,WAAW,MAG1B,OAAO,WAAY,CAChB,KAAM,GAAK,KAAK,aAAa,SAC7B,MAAO,CACH,MAAO,CACH,KAAM,GAAI,EAAG,OACb,MAAI,GAAE,OACF,GAAE,MAAQ,EAAE,MAAM,OAEf,KC/GhB,gBAA0B,GAAkB,CAC/C,YAAY,EAAQ,EAAQ,CACxB,QACA,KAAK,QAAU,EACf,KAAK,QAAU,EAEf,KAAK,UAAY,KACjB,KAAK,cAAgB,KAGzB,UAAU,EAAQ,CACd,KAAK,QAAU,EACX,KAAK,eACL,KAAK,iBAOb,eAAe,EAAS,GAAO,CAC3B,GAAI,KAAK,QAAS,CACd,KAAM,GAAc,KAAK,UACzB,KAAK,UAAY,KAAK,WAAa,GAAI,KACvC,SAAW,CAAC,EAAK,IAAU,MAAK,QAAS,CACrC,KAAM,GAAa,KAAK,QAAQ,EAAO,GAEvC,GADA,KAAK,UAAU,IAAI,EAAK,GACpB,CAAC,EAAQ,CACT,KAAM,GAAc,EAAc,EAAY,IAAI,GAAO,GACzD,KAAK,eAAe,EAAa,EAAY,EAAK,SAGvD,CAEH,GAAI,KAAK,WAAa,CAAC,EAEnB,SAAW,CAAC,EAAK,IAAU,MAAK,QAC5B,AAAK,KAAK,UAAU,IAAI,IACpB,KAAK,QAAQ,EAAK,GAI9B,KAAK,UAAY,MAIzB,MAAM,EAAK,EAAO,CACd,GAAI,KAAK,QAAS,CACd,KAAM,GAAW,KAAK,QAAQ,EAAO,GAErC,GADA,KAAK,UAAU,IAAI,EAAK,GACpB,CAAC,EACD,OAGR,KAAK,QAAQ,EAAK,GAGtB,SAAS,EAAK,EAAO,CACjB,KAAM,GAAc,CAAC,KAAK,SAAW,KAAK,UAAU,IAAI,GACxD,KAAK,UAAU,OAAO,GAClB,GACA,KAAK,WAAW,EAAK,GAI7B,SAAS,EAAK,EAAO,EAAQ,CAEzB,GAAI,EAAC,KAAK,UAGV,GAAI,KAAK,QAAS,CACd,KAAM,GAAc,KAAK,UAAU,IAAI,GACjC,EAAa,KAAK,QAAQ,EAAO,GACvC,KAAK,UAAU,IAAI,EAAK,GACxB,KAAK,eAAe,EAAa,EAAY,EAAK,EAAO,OAEzD,MAAK,WAAW,EAAK,EAAO,GAIpC,eAAe,EAAa,EAAY,EAAK,EAAO,EAAS,KAAM,CAC/D,AAAI,GAAe,CAAC,EAChB,KAAK,WAAW,EAAK,GAClB,AAAI,CAAC,GAAe,EACvB,KAAK,QAAQ,EAAK,GACX,GAAe,GACtB,KAAK,WAAW,EAAK,EAAO,GAIpC,kBAAmB,CACf,KAAK,cAAgB,KAAK,QAAQ,UAAU,MAC5C,KAAK,eAAe,IACpB,MAAM,mBAGV,mBAAoB,CAChB,MAAM,oBACN,KAAK,UAAY,KACjB,KAAK,cAAgB,KAAK,gBAG9B,SAAU,CACN,KAAK,iBACL,KAAK,aAGR,OAAO,WAAY,CAChB,MAAO,IAAI,IAAe,KAAK,QAAS,KAAK,cAG7C,OAAO,CACP,GAAI,GAAQ,EACZ,YAAK,UAAU,QAAQ,GAAY,CAC/B,AAAI,GACA,IAAS,KAGV,EAGX,IAAI,EAAK,CACL,KAAM,GAAQ,KAAK,QAAQ,IAAI,GAC/B,GAAI,GAAS,KAAK,QAAQ,EAAO,GAC7B,MAAO,IAKnB,QAAqB,CACjB,YAAY,EAAK,EAAW,CACxB,KAAK,UAAY,EACjB,KAAK,gBAAkB,EAAI,OAAO,YAGtC,MAAO,CAEH,OAAa,CACT,KAAM,GAAe,KAAK,gBAAgB,OAC1C,GAAI,EAAa,KACb,MAAO,GAEX,KAAM,GAAM,EAAa,MAAM,GAC/B,GAAI,KAAK,UAAU,IAAI,GACnB,MAAO,KC7IhB,gBAAwB,GAAkB,CAC7C,YAAY,EAAQ,EAAQ,EAAS,CACjC,QACA,KAAK,QAAU,EACf,KAAK,QAAU,EACf,KAAK,SAAW,EAChB,KAAK,cAAgB,GAAI,KAG7B,uBAAuB,EAAK,EAAQ,CAChC,KAAM,GAAQ,KAAK,cAAc,IAAI,GACrC,AAAI,GACA,KAAK,WAAW,EAAK,EAAO,GAIpC,MAAM,EAAK,EAAO,CACd,KAAM,GAAwB,KAAK,uBAAuB,KAAK,KAAM,GAC/D,EAAc,KAAK,QAAQ,EAAO,GACxC,KAAK,cAAc,IAAI,EAAK,GAC5B,KAAK,QAAQ,EAAK,GAGtB,SAAS,EAAiB,CACtB,KAAM,GAAc,KAAK,cAAc,IAAI,GAC3C,AAAI,KAAK,cAAc,OAAO,IAC1B,KAAK,WAAW,EAAK,GAI7B,SAAS,EAAK,EAAO,EAAQ,OAEzB,GAAI,CAAC,KAAK,cACN,OAEJ,KAAM,GAAc,KAAK,cAAc,IAAI,GAC3C,AAAI,IAAgB,QAChB,SAAK,WAAL,kBAAgB,EAAa,EAAQ,GAErC,KAAK,WAAW,EAAK,EAAa,IAI1C,kBAAmB,CACf,KAAK,cAAgB,KAAK,QAAQ,UAAU,MAC5C,OAAS,CAAC,EAAK,IAAU,MAAK,QAAS,CACnC,KAAM,GAAwB,KAAK,uBAAuB,KAAK,KAAM,GAC/D,EAAc,KAAK,QAAQ,EAAO,GACxC,KAAK,cAAc,IAAI,EAAK,GAEhC,MAAM,mBAGV,mBAAoB,CAChB,MAAM,oBACN,KAAK,cAAgB,KAAK,gBAC1B,KAAK,cAAc,QAGvB,SAAU,CACN,KAAK,cAAc,QACnB,KAAK,aAGR,OAAO,WAAY,CAChB,MAAO,MAAK,cAAc,aAG1B,OAAO,CACP,MAAO,MAAK,cAAc,KAG9B,IAAI,EAAK,CACL,MAAO,MAAK,cAAc,IAAI,IC5E/B,gBAAwB,GAAkB,CAC7C,YAAY,EAAS,CACjB,QACA,KAAK,SAAW,EAChB,KAAK,eAAiB,KAG1B,MAAM,EAAQ,EAAK,EAAO,CACtB,GAAI,CAAC,KAAK,uBAAuB,EAAQ,GAAM,CAC3C,KAAM,GAAiB,KAAK,6BAA6B,EAAQ,GACjE,AAAI,IAAmB,QAGnB,KAAK,WAAW,EAAK,GAEzB,KAAK,QAAQ,EAAK,IAI1B,SAAS,EAAQ,EAAK,EAAO,CACzB,GAAI,CAAC,KAAK,uBAAuB,EAAQ,GAAM,CAC3C,KAAK,WAAW,EAAK,GACrB,KAAM,GAAgB,KAAK,6BAA6B,EAAQ,GAChE,AAAI,IAAkB,QAGlB,KAAK,QAAQ,EAAK,IAK9B,SAAS,EAAQ,EAAK,EAAO,EAAQ,CAEjC,AAAI,CAAC,KAAK,gBAGL,KAAK,uBAAuB,EAAQ,IACrC,KAAK,WAAW,EAAK,EAAO,GAIpC,SAAU,CACN,KAAK,YAGT,kBAAmB,CACf,KAAK,eAAiB,KAAK,SAAS,IAAI,GAAU,GAAI,IAA0B,EAAQ,MAAM,aAC9F,MAAM,mBAGV,uBAAuB,EAAQ,EAAK,CAKhC,KAAM,GAAQ,KAAK,SAAS,QAAQ,GACpC,OAAS,GAAI,EAAG,EAAI,EAAO,GAAK,EAC5B,GAAI,KAAK,SAAS,GAAG,IAAI,KAAS,OAC9B,MAAO,GAGf,MAAO,GAIX,6BAA6B,EAAQ,EAAK,CAKtC,KAAM,GAAQ,KAAK,SAAS,QAAQ,GACpC,OAAS,GAAI,EAAQ,EAAG,EAAI,KAAK,SAAS,OAAQ,GAAK,EAAG,CAEtD,KAAM,GAAgB,AADP,KAAK,SAAS,GACA,IAAI,GACjC,GAAI,IAAkB,OAClB,MAAO,IAMnB,mBAAoB,CAChB,MAAM,oBACN,SAAW,KAAK,MAAK,eACjB,EAAE,WAIT,OAAO,WAAY,CAChB,MAAO,IAAI,IAAe,KAAK,aAG/B,OAAO,CACP,MAAO,MAAK,SAAS,OAAO,CAAC,EAAK,IAAM,EAAM,EAAE,KAAM,GAG1D,IAAI,EAAK,CACL,SAAW,KAAK,MAAK,SAAU,CAC3B,KAAM,GAAQ,EAAE,IAAI,GACpB,GAAI,EACA,MAAO,GAGf,MAAO,OAIf,QAAqB,CACjB,YAAY,EAAS,CACjB,KAAK,SAAW,EAChB,KAAK,aAAe,GACpB,KAAK,iBAAmB,KACxB,KAAK,iBAAmB,GAAI,KAGhC,MAAO,CACH,GAAI,GACJ,KAAO,CAAC,GAAQ,CACZ,GAAI,CAAC,KAAK,iBAAkB,CAExB,GADA,KAAK,cAAgB,EACjB,KAAK,SAAS,QAAU,KAAK,aAC7B,MAAO,CAAC,KAAM,IAElB,KAAK,iBAAmB,KAAK,SAAS,KAAK,cAAc,OAAO,YAEpE,KAAM,GAAe,KAAK,iBAAiB,OAC3C,GAAI,EAAa,KAAM,CACnB,KAAK,iBAAmB,KACxB,aACG,CACH,KAAM,GAAM,EAAa,MAAM,GAC/B,AAAK,KAAK,iBAAiB,IAAI,IAC3B,MAAK,iBAAiB,IAAI,GAC1B,EAAS,IAIrB,MAAO,IAIf,QAAgC,CAC5B,YAAY,EAAQ,EAAW,CAC3B,KAAK,QAAU,EACf,KAAK,WAAa,EAClB,KAAK,cAAgB,KAGzB,WAAY,CACR,YAAK,cAAgB,KAAK,QAAQ,UAAU,MACrC,KAGX,SAAU,CACN,KAAK,cAAgB,KAAK,gBAG9B,MAAM,EAAK,EAAO,CACd,KAAK,WAAW,MAAM,KAAK,QAAS,EAAK,GAG7C,SAAS,EAAK,EAAO,CACjB,KAAK,WAAW,SAAS,KAAK,QAAS,EAAK,GAGhD,SAAS,EAAK,EAAO,EAAQ,CACzB,KAAK,WAAW,SAAS,KAAK,QAAS,EAAK,EAAO,GAGvD,SAAU,CACN,KAAK,WAAW,QAAQ,KAAK,0BC1KG,GAAsB,CAG1D,YAAY,EAAqB,GAAI,cAE5B,OAAS,EAGlB,OAAO,EAAe,MACb,OAAO,KAAK,QACZ,QAAQ,KAAK,OAAO,OAAS,EAAG,GAGzC,OAAO,EAAmB,MAChB,CAAC,GAAQ,KAAK,OAAO,OAAO,EAAK,QAClC,WAAW,EAAK,GAGzB,WAAW,EAAa,EAAkB,QAC9B,KAAQ,QACP,OAAO,EAAK,MACV,EAIf,OAAO,EAAa,EAAe,MAC1B,OAAO,OAAO,EAAK,EAAG,QACtB,QAAQ,EAAK,GAGtB,KAAK,EAAiB,EAAqB,IACnC,EAAU,KAAK,OAAO,QAAU,EAAQ,KAAK,OAAO,OAAQ,MACtD,CAAC,GAAQ,KAAK,OAAO,OAAO,EAAS,QACtC,OAAO,OAAO,EAAO,EAAG,QACxB,SAAS,EAAS,EAAO,IAItC,OAAO,EAAa,EAAS,EAAc,KAAY,CAC/C,EAAM,KAAK,OAAO,cACb,OAAO,GAAO,OACd,WAAW,EAAK,EAAM,OAI/B,QAAuB,OAChB,MAAK,OAGhB,GAAG,EAA4B,IACvB,KAAK,QAAU,GAAO,GAAK,EAAM,KAAK,OAAO,aACtC,MAAK,OAAO,MAIvB,SAAiB,OACV,MAAK,OAAO,QAGtB,OAAO,WAAY,OACT,MAAK,OAAO,sBC3Da,EAAkC,EAAY,EAAmC,EAAoC,MACnJ,GAAQ,EAAM,UAAU,MAC1B,IAAU,GAAI,MACR,GAAQ,EAAM,GAEd,EAAS,EAAQ,SACnB,KAAW,MACA,WAAW,EAAO,EAAO,GAGjC,SAEJ,mBCXyB,GAAsB,CAItD,YAAY,EAA2C,qBAFjC,QAIb,YAAc,EAGvB,gBAAgB,EAAkB,MACzB,cAAc,GAGvB,cAAc,EAAkB,QAQpB,KAAQ,QACP,IAAI,GAIjB,cAAc,EAAkC,EAA6C,OAClF,IAAqB,EAAW,KAAK,OAAQ,KAAM,GAG9D,aAAa,EAAS,EAAwC,EAAoB,KAAY,MACpF,GAAM,KAAK,QAAQ,MACrB,IAAQ,GAAI,MACN,GAAe,KAAK,OAAO,GAC3B,EAAU,EAAQ,EAAc,QACjC,OAAO,GAAO,OACd,WAAW,EAAK,EAAS,IAItC,OAAO,EAAS,EAAoB,KAAY,MACtC,GAAM,KAAK,QAAQ,GACrB,IAAQ,UACH,OAAO,GAAO,OACd,WAAW,EAAK,EAAM,IAInC,QAAQ,EAAiB,MACf,GAAM,GAAY,KAAK,OAAQ,EAAM,KAAK,mBAC5C,GAAM,KAAK,OAAO,QAAU,KAAK,YAAY,KAAK,OAAO,GAAM,KAAU,EAClE,EAEA,GAIf,SAAS,EAAwB,IACzB,GAAM,GAAY,KAAK,OAAQ,EAAM,KAAK,kBACxC,EAAM,KAAK,OAAO,QAAU,KAAK,YAAY,KAAK,OAAO,GAAM,IAAS,MACnE,QAEJ,MAAK,IAAI,GAGpB,IAAI,EAAS,EAAoB,KAAY,MACnC,GAAM,GAAY,KAAK,OAAQ,EAAM,KAAK,aAC5C,GAAO,KAAK,OAAO,QAAU,KAAK,YAAY,KAAK,OAAO,GAAM,KAAU,QACrE,OAAO,OAAO,EAAK,EAAG,QACtB,QAAQ,EAAK,UAEb,OAAO,GAAO,OACd,WAAW,EAAK,EAAM,IAInC,IAAI,EAA4B,OACrB,MAAK,OAAO,GAGvB,OAAO,EAAmB,MAChB,GAAO,KAAK,OAAO,QACpB,OAAO,OAAO,EAAK,QACnB,WAAW,EAAK,MAGrB,QAAa,OACN,MAAK,UAGZ,SAAiB,OACV,MAAK,OAAO,QAGtB,OAAO,WAAY,OACT,IAAI,IAAS,OAK5B,QAAkB,CAId,YAAY,EAA6B,MAChC,aAAe,OACf,SAAW,KAGpB,MAAO,IACC,KAAK,aAAc,IACf,KAAK,cACA,SAAW,KAAK,aAAa,SAAS,KAAK,eAE3C,SAAW,KAAK,aAAa,IAAI,GAEtC,KAAK,eACE,CAAC,MAAO,KAAK,eAGf,aAAe,QAGxB,CAAC,KAAK,mBACC,CAAC,KAAM,qBCzHqB,GAAsB,CAQjE,YAAY,EAAmC,EAAqB,EAAwB,EAAqC,iCAN7E,wBAIxB,UAInB,YAAc,OACd,QAAU,OACV,SAAW,OACX,gBAAkB,EAG3B,cAAc,EAAkC,EAAoC,OACzE,IAAqB,EAAW,KAAK,cAAgB,KAAM,MAGlE,SAAS,OACF,MAAK,cAAe,QAG9B,OAAO,WAAY,OACT,MAAK,cAAe,sBAIL,EAA6B,EAAe,EAAsB,GACvF,cAAe,OAAO,EAAO,EAAG,KAChC,QAAQ,EAAO,eAGS,EAA6B,EAAe,EAAU,EAAmB,MAChG,GAAc,EAAK,cAAe,GACpC,EAAK,YACA,SAAS,EAAa,EAAQ,KAElC,WAAW,EAAO,EAAa,eAGP,EAA6B,EAAqB,MACzE,GAAc,EAAK,cAAe,KACnC,cAAe,OAAO,EAAO,GAC9B,EAAK,mBACA,gBAAgB,KAEpB,WAAW,EAAO,eAGI,EAA6B,EAAiB,EAAqB,MACxF,GAAc,EAAK,cAAe,KACnC,cAAe,OAAO,EAAS,KAC/B,cAAe,OAAO,EAAO,EAAG,KAChC,SAAS,EAAS,EAAO,eAGF,EAAmC,GAC1D,cAAgB,KAChB,4BC/DiC,GAA2D,CAA9F,aApBP,sCAqBkD,oBACjB,GAE7B,kBAAyB,MAChB,mBAAqB,KAAK,YAAY,UAAU,WAChD,YAAc,QACd,cAAgB,MACjB,GAAM,WACC,KAAQ,MAAK,iBACf,YAAY,KAAK,GAAI,IAAS,EAAK,OACjC,OAEN,cAGH,SAAwB,IACtB,MAAK,gBAGJ,UAAY,MACb,MACO,KAAK,YAAa,aAEf,AADQ,MAAK,YAAa,QACnB,IAAI,mBAGhB,UAAY,KAIzB,SAAgB,CACR,KAAK,mBACA,YAAY,KAAK,GAAI,UACrB,UAIb,MAAM,EAAe,EAAgB,CAC7B,KAAK,mBACA,YAAY,KAAK,GAAI,IAAS,EAAO,SACrC,UAIb,SAAS,EAAe,EAAU,EAAmB,CAC7C,KAAK,mBACA,YAAY,KAAK,GAAI,IAAY,EAAO,EAAO,SAC/C,UAIb,SAAS,EAAqB,CACtB,KAAK,mBACA,YAAY,KAAK,GAAI,IAAY,SACjC,UAIb,OAAO,EAAiB,EAAqB,CACrC,KAAK,mBACA,YAAY,KAAK,GAAI,IAAU,EAAS,SACxC,UAIb,mBAA0B,MACjB,0BACA,YAAc,UACd,cAAgB,MAM7B,QAAkB,CACd,YAAmB,EAAsB,EAAU,gCAE7C,KAAO,EAA2C,MAC9C,GAAc,KAAM,GAAK,QAAQ,KAAK,UACrC,EAAM,KAAK,MAAO,IAIjC,QAAqB,CACjB,YAAmB,EAAsB,EAAiB,EAAa,8CAEjE,KAAO,EAA2C,IAC1C,EAAM,KAAK,MAAO,KAAK,MAAO,KAAK,SAIrD,QAAqB,CACjB,YAAmB,EAAe,mBAE5B,KAAO,EAA2C,IAC1C,EAAM,KAAK,QAI7B,QAAmB,CACf,YAAmB,EAAwB,EAAe,kCAEpD,KAAO,EAA2C,IAC5C,EAAM,KAAK,QAAS,KAAK,QAIzC,QAAoB,MACV,KAAO,EAA2C,IAC3C,oBChHkB,GAAkD,CAIjF,eAAe,EAAsC,kCAFE,UAI9C,aAAe,EAGxB,iBAAiB,EAA2C,MAClD,GAAU,KAAK,aAAa,QAAQ,MACtC,GAAS,SACJ,GAAI,EAAG,EAAI,EAAS,EAAE,KACjB,KAAK,aAAa,GAAG,aAE5B,GAGX,kBAAyB,MAChB,oBAAsB,KAAK,aAAa,IAAI,GAAc,EAAW,UAAU,OAGxF,mBAA0B,UACX,KAAqB,MAAK,wBAKzC,SAAgB,MAIP,eACD,GAAM,WACA,KAAQ,WACT,QAAQ,EAAK,MACX,EAIf,MAAM,EAAe,EAAU,EAAyC,MAC/D,QAAQ,KAAK,iBAAiB,GAAc,EAAO,GAG5D,SAAS,EAAe,EAAU,EAAa,EAAyC,CAGhF,CAAC,KAAK,0BAGL,WAAW,KAAK,iBAAiB,GAAc,EAAO,EAAO,GAGtE,SAAS,EAAe,EAAU,EAAyC,MAClE,WAAW,KAAK,iBAAiB,GAAc,EAAO,GAG/D,OAAO,EAAiB,EAAe,EAAU,EAAyC,MAChF,GAAS,KAAK,iBAAiB,QAChC,SAAS,EAAS,EAAS,EAAS,EAAO,MAGhD,SAAiB,IACb,GAAM,SACD,GAAI,EAAG,EAAI,KAAK,aAAa,OAAQ,EAAE,KACrC,KAAK,aAAa,GAAG,aAEzB,IAGV,OAAO,WAAY,IACZ,GAAgB,EAChB,EAAK,KAAK,aAAa,GAAG,OAAO,kBAC9B,CACH,KAAM,IAAM,IACJ,GAAS,EAAG,YACT,EAAO,MAAM,OACC,EACb,GAAiB,KAAK,aAAa,aAC5B,KAEN,KAAK,aAAa,GAAe,OAAO,cACpC,EAAG,aAET,MCvEvB,OAAO,OAAO,GAAkB,UAAW,CACvC,WAAW,EAAY,CACnB,MAAO,IAAI,IAAc,KAAM,IAGnC,UAAU,EAAQ,EAAS,CACvB,MAAO,IAAI,IAAU,KAAM,EAAQ,IAGvC,aAAa,EAAQ,CACjB,MAAO,IAAI,IAAY,KAAM,IAGjC,QAAQ,EAAW,CACf,MAAO,IAAI,IAAU,CAAC,MAAM,OAAO,OCvB3C,YAAsB,EAAyB,CACvC,MAAO,IAAU,iBAGX,UAId,YAAsB,EAA4B,OACvC,WAAiB,IAAU,YAAc,MAAO,GAAM,SAAY,oBAGpD,CAAlB,aAlCP,mBAmCgD,GAE5C,MAAM,EAAoC,IAClC,CAAC,GAAa,QACR,IAAI,OAAM,0BAEhB,MAAK,oBACG,KAAK,wDACA,GACN,SAEN,aAAc,KAAK,GACjB,GAGX,QAAQ,EAA8B,IAC9B,KAAK,0BACG,KAAK,gDACN,UAEL,GAAM,KAAK,aAAc,QAAQ,SACnC,IAAO,QACF,aAAc,OAAO,EAAK,GAE5B,KAGX,SAAgB,IACR,KAAK,aAAc,UACR,KAAK,MAAK,gBACJ,QAEZ,aAAe,SAIxB,aAAsB,OACf,MAAK,eAAiB,KAGjC,eAAe,EAAyB,IAChC,AAAuB,GAAU,MAAQ,KAAK,iBACvC,WAEL,GAAM,KAAK,aAAc,QAAQ,MACnC,IAAQ,GAAI,MACN,CAAC,GAAc,KAAK,aAAc,OAAO,EAAK,MACvC,gBAEL,KAAK,qCAAsC,SAEhD,OCjEf,QAAoB,CAChB,YAAY,EAAI,EAAK,CACjB,KAAK,eAAiB,KACtB,KAAK,SAAW,EAAG,KAAM,GAG7B,UAAW,CACP,MAAO,MAAK,SAGhB,SAAU,CACN,AAAI,KAAK,gBACL,MAAK,eAAe,UACpB,KAAK,eAAiB,OASlC,kBAA6C,EAAQ,EAAU,EAAW,EAAQ,EAAoB,EAAK,CACvG,GAAI,GAAU,GACd,KAAM,GAAgB,EAAI,eACpB,EAAgB,EAAI,kBAE1B,KAAO,EAAQ,OAAS,GAAU,GAAU,CACxC,GAAI,GACJ,AAAI,EAAU,UAEV,EAAuB,KAAM,GAAc,YAAY,EAAQ,EAAU,GAEzE,EAAuB,KAAM,GAAc,aAAa,EAAQ,EAAU,GAE9E,GAAI,GAAe,EAAqB,IAAI,GAAK,GAAI,GAAW,EAAG,IAInE,GAHA,EAAU,GAAkB,EAAS,EAAc,GAG/C,EAAQ,OAAS,EAAQ,CACzB,KAAM,GAAW,KAAM,GAAc,IAAI,EAAQ,EAAS,YAM1D,GAAI,GAAgB,GAAI,GAAsB,EAAU,EAAU,WAAY,GAI9E,GAFA,GAAkB,EAAS,EAAe,GAEtC,CAAC,EAAc,OAAS,EAAc,kBAAmB,CACzD,KAAM,GAAe,KAAM,GAAc,IAAI,EAAQ,EAAc,kBACnE,EAAmB,IAAI,GACvB,KAAM,GAAoB,GAAI,GAAsB,EAAc,EAAU,UAAW,GACvF,GAAkB,EAAS,EAAmB,GAC9C,EAAW,EAAkB,iBAE7B,GAAW,MAIvB,MAAO,GAGJ,QAAqB,CACxB,YAAY,CAAC,SAAQ,UAAS,sBAAqB,CAC/C,KAAK,QAAU,EACf,KAAK,SAAW,EAChB,KAAK,oBAAsB,EAC3B,KAAK,gBAAkB,KAG3B,iBAAiB,EAAgB,CAC7B,KAAK,gBAAkB,KAGvB,gBAAgB,CAChB,KAAM,GAAS,CACX,KAAK,SAAS,WAAW,eACzB,KAAK,SAAS,WAAW,mBAE7B,MAAI,MAAK,iBACL,EAAO,KAAK,KAAK,SAAS,WAAW,sBAElC,EAGX,SAAS,EAAU,EAAW,EAAQ,EAAK,CACvC,MAAO,IAAI,IAAc,MAAO,EAAG,IAAQ,CACvC,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,KAAK,eAC7C,MAAO,MAAM,MAAK,UAAU,EAAU,EAAW,EAAQ,EAAG,EAAK,IAClE,GAGP,YAAY,EAAQ,EAAc,KAAM,EAAK,CACzC,MAAO,IAAI,IAAc,MAAO,EAAG,IAAQ,CACvC,KAAM,GAAM,GAAe,KAAM,MAAK,SAAS,QAAQ,KAAK,eACtD,EAAe,KAAM,GAAI,kBAAkB,aAAa,KAAK,SACnE,GAAI,GAEJ,GAAI,CAAC,EACD,EAAU,OACP,CACH,KAAK,oBAAoB,IAAI,GAC7B,KAAM,GAAoB,EAAsB,IAAI,EAAc,KAAK,qBACjE,EAAW,EAAkB,aACnC,EAAU,KAAM,MAAK,UAAU,EAAU,GAAU,SAAU,EAAQ,EAAG,EAAK,GAC7E,EAAQ,QAAQ,GAEpB,MAAO,IACR,QAGD,UAAS,EAAI,EAAK,CACpB,GAAI,GAAS,CAAC,KAAK,SAAS,WAAW,gBACvC,AAAI,KAAK,iBACL,EAAO,KAAK,KAAK,SAAS,WAAW,sBAEzC,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,GAClC,EAAe,KAAM,GAAI,eAAe,aAAa,KAAK,QAAS,GACzE,GAAI,EAAc,CACd,KAAM,GAAQ,GAAI,GAAW,EAAc,KAAK,qBAChD,MAAI,MAAK,iBAEL,KAAM,AADU,MAAK,gBAAgB,CAAC,GAAQ,EAAK,GACrC,WAEX,QAIT,WAAU,EAAU,EAAW,EAAQ,EAAG,EAAK,EAAK,CACtD,KAAM,GAAU,KAAM,IAA8B,KAAK,QAAS,EAAU,EAAW,EAAQ,KAAK,oBAAqB,GACzH,GAAI,KAAK,gBAAiB,CACtB,EAAE,eAAiB,KAAK,gBAAgB,EAAS,EAAK,GACtD,GAAI,CACA,KAAM,GAAE,eAAe,mBAEvB,EAAE,eAAiB,MAG3B,MAAO,IC5IR,gBAAqC,EAAW,IAC/C,aAAa,CACb,KAAM,IAAI,OAAM,4DAGhB,aAAa,CACb,KAAM,IAAI,OAAM,4DAGhB,iBAAiB,CACjB,MAAO,MAKP,cAAc,CACd,MAAO,MAGP,aAAa,CACb,MAAO,OAAM,aCzBd,QAAW,CACd,YAAY,EAAQ,CAChB,KAAK,QAAU,KAGf,KAAK,CACL,MAAO,MAAK,SCOb,QAAe,CAClB,YAAY,CAAC,SAAQ,UAAS,gBAAe,qBAAoB,gBAAe,QAAO,wBAAuB,SAAQ,CAClH,KAAK,QAAU,EACf,KAAK,SAAW,EAChB,KAAK,eAAiB,EACtB,KAAK,oBAAsB,EAC3B,KAAK,aAAe,GAAI,IACxB,KAAK,eAAiB,EACtB,KAAK,OAAS,EAEd,KAAK,eAAiB,GAAI,IAAY,CAAC,EAAG,IAAM,EAAE,QAAQ,IAC1D,KAAK,WAAa,KAClB,KAAK,gBAAkB,GAAI,IAAe,CACtC,OAAQ,KAAK,QACb,QAAS,KAAK,SACd,mBAAoB,KAAK,sBAE7B,KAAK,eAAiB,KACtB,KAAK,YAAc,KAEnB,KAAK,6BAA+B,GAAI,KAExC,KAAK,gBAAkB,KACvB,KAAK,OAAS,EACd,KAAK,sBAAsB,GAG/B,sBAAsB,EAAY,CAC9B,AAAI,GACA,MAAK,aAAe,EAAW,MAC/B,KAAK,aAAa,MAAM,EAAW,UAAU,GAAe,KAAK,aAAe,UAKlF,MAAK,EAAM,EAAY,EAAK,CAC9B,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,KAAK,gBAAgB,cAAc,OACvE,KAAK,SAAS,WAAW,YACzB,KAAK,SAAS,WAAW,YAEvB,EAAa,KAAM,GAAI,YAAY,IAAI,KAAK,QAAS,EAAK,IAChE,AAAI,EACA,KAAK,WAAa,GAAI,GAAW,GAKjC,KAAK,WAAa,EAAW,WAAW,KAAK,QAAS,EAAK,GAAI,GASnE,KAAM,GAAgB,KAAK,aAAa,MAAM,KAAK,gBAAgB,YAAY,GAAI,EAAK,IACxF,GAAI,CACA,KAAM,GAAU,KAAM,GAAc,WACpC,KAAK,+BAA+B,GACpC,KAAK,cAAc,WAEnB,KAAK,aAAa,eAAe,IAKzC,cAAc,EAAiB,CAC3B,KAAK,eAAe,cAAc,GAClC,AAAI,KAAK,eACL,KAAK,cAAgB,GAAI,IAAgB,KAAK,eAC1C,GAAM,KAAK,wBAAwB,GACnC,CAAC,EAAK,IAAW,CAEb,EAAI,aAAa,IAErB,GAAO,KAAK,iCAAiC,EAAK,GAAU,EAAO,oBAAoB,KAG3F,KAAK,cAAgB,GAAI,IAE7B,KAAK,YAAc,GAAI,IAAW,KAAK,eAAgB,KAAK,oBAG1D,yBAAwB,EAAI,CAK9B,GAAI,GACJ,AAAI,EAAG,YAAc,GACjB,GAAiB,KAAM,MAAK,gBAAgB,EAAG,aAAc,EAAG,iBAEpE,KAAM,GAAM,GAAI,IAAkB,CAC9B,aAAc,EAAI,OAAQ,KAAK,WAC/B,MAAO,KAAK,OAAQ,mBAExB,YAAK,+BAA+B,CAAC,IACrC,KAAK,iCAAiC,EAAK,GAAU,EAAO,iBAAiB,IACtE,EAGX,iCAAiC,EAAK,EAAS,SAE3C,KAAM,GAAgB,GAAK,CACvB,KAAM,GAAS,EAAQ,GACvB,MAAO,IAAkB,IAI7B,GAFA,KAAK,wBAAwB,EAAI,aAAa,aAAc,EAAI,eAAgB,GAE5E,EAAI,eAAgB,CAEpB,KAAM,GAAe,KAAI,eAAe,eAAnB,cAAiC,aACtD,KAAK,wBAAwB,EAAc,EAAI,eAAe,eAAgB,GAC9E,KAAI,eAAe,oBAAnB,QAAsC,QAAQ,GAAK,KAAK,oBAAoB,EAAG,kBAIvF,wBAAwB,EAAO,EAAS,EAAe,CACnD,GAAI,GAAQ,GAEZ,AAAI,GACA,GAAQ,KAAK,cAAc,cACvB,GAAK,EAAE,KAAO,EACd,IAIJ,CAAC,GAAS,GACV,KAAK,eAAe,cAChB,GAAK,EAAE,KAAO,EACd,QAKN,uBAAsB,EAAU,EAAK,CACvC,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CACzC,KAAK,SAAS,WAAW,eACzB,KAAK,SAAS,WAAW,oBAEvB,EAAY,KAAM,GAAI,kBAAkB,oBAAoB,KAAK,QAAS,EAAU,IAC1F,SAAW,KAAY,GAAW,CAC9B,KAAM,GAAa,KAAM,GAAI,eAAe,aAAa,KAAK,QAAS,EAAS,eAChF,GAAI,GAAc,EAAW,MAAM,SAAW,KAAK,WAAW,QAAU,GAAY,EAAW,OAAO,MAAQ,EAAK,CAC/G,KAAM,GAAa,GAAI,GAAW,EAAY,KAAK,qBACnD,YAAK,qCAAqC,CAAC,IACpC,GAGf,MAAO,MAIX,gBAAgB,EAAQ,CACpB,KAAK,WAAa,EAGtB,qCAAqC,EAAS,OAW1C,GAAI,EAAC,SAAK,gBAAL,cAAoB,kBAIzB,SAAW,KAAO,MAAK,cAAe,CAElC,GAAI,EAAI,eAAgB,CACpB,KAAM,GAAiB,EAAQ,KAAK,GAAK,EAAE,KAAO,EAAI,gBAEtD,WAAgB,iBAAiB,GAErC,GAAI,EAAI,eAAgB,CACpB,KAAM,GAAU,EAAI,eAAe,eAC7B,EAAiB,EAAQ,KAAK,GAAK,EAAE,KAAO,GAClD,WAAgB,iBAAiB,WAMtC,eAAc,EAAe,EAAO,OAEvC,WAAc,oBAAd,QAAiC,QAAQ,GAAS,EAAM,gBAAgB,IACxE,EAAM,WAAW,GACV,EAIX,eAAe,EAAS,OACpB,KAAK,qCAAqC,GAC1C,SAAW,KAAS,GAChB,GAAI,CACA,KAAK,eAAe,aAAa,EAAO,GAAS,eACjD,KAAM,GAAW,KAAK,6BAA6B,IAAI,EAAM,IAC7D,AAAI,GACA,IAAS,cAAc,EAAU,GACjC,KAAK,6BAA6B,IAAI,EAAM,GAAI,IAGpD,KAAM,oBAAN,QAAyB,QAAQ,GAAK,KAAK,oBAAoB,EAAG,uBAC7D,EAAP,CACE,GAAI,EAAI,OAAS,eAOb,SAGA,KAAM,IAOtB,WAAW,EAAY,CACnB,KAAK,qCAAqC,GAC1C,KAAK,oCAAoC,GACzC,KAAK,0BAA0B,GAC/B,KAAK,+BAA+B,GACpC,KAAK,eAAe,cAAc,GAStC,oCAAoC,EAAS,OAMzC,SAAW,KAAS,GAAS,CACzB,KAAM,GAAe,KAAK,6BAA6B,IAAI,EAAM,gBACjE,AAAI,kBAAc,iBAAkB,kBAAc,iBAAiB,KAE/D,MAAa,oBAAb,QAAgC,QAAQ,GAAK,KAAK,oBAAoB,EAAG,mBASrF,0BAA0B,EAAS,CAC/B,SAAW,KAAS,GAAS,CACzB,KAAM,GAAe,KAAK,6BAA6B,IAAI,EAAM,IACjE,AAAI,GACA,GAAa,kBAAkB,QAAQ,GAAK,CACxC,EAAE,gBAAgB,GAClB,KAAK,oBAAoB,EAAG,kBAEhC,KAAK,6BAA6B,OAAO,EAAM,MAK3D,oBAAoB,EAAO,EAAO,CAC9B,KAAM,GAAQ,EAAM,UAAY,EAAM,GAAK,KACrC,EAAU,EAAM,UAAY,KAAO,EAAM,GAC/C,KAAK,wBAAwB,EAAO,EAAS,IAAM,QAWjD,gCAA+B,EAAS,CAC1C,SAAW,KAAS,GAAS,CACzB,GAAI,CAAC,EAAM,eACP,SAEJ,KAAM,GAAK,EAAM,eAGjB,GAAI,GAAe,EAAQ,KAAK,GAAK,EAAE,KAAO,GAC9C,AAAK,GACD,GAAe,KAAK,qBAAqB,IAE7C,AAAI,EACA,EAAM,gBAAgB,GAQtB,KAAK,+BAA+B,SAK1C,gCAA+B,EAAO,CACxC,KAAM,GAAK,EAAM,eACjB,GAAI,GAAe,KAAM,MAAK,qBAAqB,GACnD,AAAK,GACD,GAAe,KAAM,MAAK,wBAAwB,IAElD,GAGA,MAAK,6BAA6B,IAAI,EAAI,GAC1C,EAAM,gBAAgB,GAGtB,KAAK,oBAAoB,EAAO,iBASxC,qBAAqB,EAAS,OAC1B,MAAO,QAAK,aAAa,KAAlB,OAA8B,KAAK,6BAA6B,IAAI,QAGzE,sBAAqB,EAAS,CAEhC,MADc,MAAM,MAAK,gBAAgB,SAAS,QAIhD,yBAAwB,EAAS,CACnC,KAAM,GAAW,KAAM,MAAK,OAAO,QAAQ,KAAK,QAAS,EAAS,GAAG,WAC/D,EAAS,EAAS,MAAM,OACxB,EAAS,EAAS,MAAM,KAAK,GAAK,EAAE,OAASA,GAAqB,EAAE,UAAY,GAChF,EAAQ,CACV,MAAO,EAAS,MAChB,YAAa,EAAO,QAAQ,YAC5B,UAAW,EAAO,QAAQ,YAExB,EAAa,GAAI,IAAuB,EAAO,KAAK,qBAC1D,MAAI,MAAK,iBAEL,KAAM,AADU,MAAK,gBAAgB,CAAC,IACxB,WAEX,OAUL,WAAU,EAAQ,CACpB,GAAI,KAAK,aAAa,WAClB,MAAO,GAEX,KAAM,GAAkB,KAAK,eAAe,MAAM,KAAK,GAAK,CAAC,CAAC,EAAE,WAChE,GAAI,CAAC,EACD,MAAO,GAEX,KAAM,GAAgB,KAAK,aAAa,MAAM,KAAK,gBAAgB,SAC/D,EAAgB,aAChB,GAAU,SACV,IAEJ,GAAI,CACA,KAAM,GAAU,KAAM,GAAc,WACpC,YAAK,WAAW,GACT,EAAQ,OAAS,UAExB,KAAK,aAAa,eAAe,SAInC,iBAAgB,EAAO,EAAS,OAClC,GAAI,GAEA,SAAW,KAAK,MAAK,cACjB,GAAI,EAAE,KAAO,EACT,MAAO,GAInB,MAAI,GACO,QAAK,aAAa,KAAlB,OAA8B,KAAM,MAAK,qBAAqB,GAElE,KAGX,aAAa,EAAS,CAClB,OAAS,GAAI,EAAG,EAAI,KAAK,eAAe,OAAQ,GAAK,EAAG,CACpD,KAAM,GAAQ,KAAK,eAAe,IAAI,GACtC,GAAI,EAAM,KAAO,EACb,MAAO,GAGf,MAAO,SAIP,UAAU,CACV,MAAO,MAAK,eAOZ,gBAAgB,CAChB,MAAO,MAAK,eAAe,MAI/B,SAAU,CACN,AAAI,KAAK,gBACL,MAAK,aAAa,UAClB,KAAK,iBACL,KAAK,eAAiB,MAK9B,iBAAiB,EAAgB,CAC7B,KAAK,gBAAkB,EACvB,KAAK,gBAAgB,iBAAiB,MAGtC,cAAc,CACd,MAAO,MAAK,gBAGZ,KAAK,CACL,MAAO,MAAK,YC1cpB,kBAA2B,CAAC,SAAQ,WAAU,CAK1C,MAAO,AADa,MAAM,AAHd,MAAM,GAAQ,QAAQ,CAC9B,EAAQ,WAAW,eAEO,YAAY,OAAO,IAC9B,IAAI,GAAK,GAAI,GAAW,IAG/C,kBAA4B,CAAC,UAAS,YAAW,SAAQ,QAAO,UAAS,wBAAuB,EAAK,CAGjG,KAAM,GAA2B,GAAI,KACrC,EAAqB,GAErB,KAAM,GAAiB,KAAM,GAAM,QAAQ,EAAQ,CAAC,GAAI,GAAY,CAAC,QAAM,WAErE,EAAM,KAAM,GAAQ,aAAa,CACnC,EAAQ,WAAW,YACnB,EAAQ,WAAW,cAGvB,GAAI,GACA,EAEJ,GAAI,CACA,EAAiB,EAAQ,uBAAuB,GAAM,GACtD,KAAM,CAAC,eAAe,EAChB,EAAe,EAAe,MACpC,GAAI,CAAC,MAAM,QAAQ,GACf,KAAM,IAAI,OAAM,aAEpB,EAAI,IAAI,UAAW,EAAa,QAChC,EAAU,KAAM,SAAQ,IAAI,EAAa,IAAI,KAAM,IAAe,CAC9D,KAAM,GAAS,iBAAa,UAC5B,GAAI,CAAC,EACD,KAAM,IAAI,OAAM,aAIpB,KAAM,GAAgB,EAAyB,IAAI,GACnD,GAAI,EACA,MAAO,GACJ,CACH,KAAM,GAAS,EAAW,gBAAgB,EAAQ,GAClD,MAAI,IACA,EAAY,IAAI,EAAO,aAEpB,YAGV,EAAP,CAEE,QAAI,QACE,UAIN,EAAqB,MAEzB,YAAM,GAAI,WACV,EAAQ,aAAa,GACd,EAGJ,kBAAkC,EAAS,EAAQ,CACtD,KAAM,CAAC,WAAW,EAClB,MAAK,GAAQ,KAAK,kBAIP,GAAY,GAFZ,EAAO,UAAU,EAAQ,IAAK,eAAgB,GAAO,GAAa,EAAS,IAMnF,kBAAiC,EAAS,EAAQ,CACrD,KAAM,GAAS,KAAM,IAAW,GAC1B,CAAC,WAAW,EAClB,MAAI,CAAC,EAAQ,KAAK,mBAAqB,CAAC,EAE7B,EAAO,UAAU,EAAQ,IAAK,cAAe,GAAO,GAAY,EAAS,IAE7E,EAGX,kBAA0B,CAAC,SAAQ,SAAQ,WAAU,CAEjD,KAAM,GAAS,KAAM,AADT,MAAM,GAAQ,QAAQ,CAAC,EAAQ,WAAW,eAC7B,YAAY,IAAI,EAAQ,GACjD,MAAO,GAAQ,GAAI,GAAW,GAAU,KAG5C,kBAA2B,CAAC,SAAQ,SAAQ,QAAO,WAAU,EAAK,CAC9D,GAAI,GACJ,GAAI,CACA,EAAa,KAAM,GAAM,MAAM,EAAQ,gBAAiB,EAAQ,CAAE,QAAO,iBAEtE,EAAP,CACI,GAAI,EAAM,OAAS,mBAAqB,EAAM,UAAY,cACtD,MAAO,MAEX,KAAM,GAEV,KAAM,GAAS,GAAI,GAAW,CAC1B,SACA,SACA,WAAY,EAAW,WACvB,UAAW,EAAW,WACtB,YAAa,EAAW,cAEtB,EAAM,KAAM,GAAQ,aAAa,CAAC,EAAQ,WAAW,cAC3D,GAAI,CACA,EAAI,YAAY,IAAI,EAAO,mBAEzB,EAAN,CACI,QAAI,QACE,EAEV,YAAM,GAAI,WACH,UCxHgB,CAIvB,YAAY,EAA0B,sBAFJ,OAGzB,cAAgB,EAGzB,QAAe,MACN,iBAAmB,EAG5B,SAAgB,MACP,iBAAmB,EACpB,KAAK,kBAAoB,QACpB,iBCZV,gBAAyB,GAAc,CAC1C,YAAY,CAAC,UAAS,iBAAgB,CAClC,MAAM,GACN,KAAK,SAAW,GAAI,IACpB,SAAW,KAAU,GACjB,KAAK,SAAS,IAAI,EAAO,OAAQ,GAIzC,UAAU,EAAe,CACrB,SAAW,CAAC,EAAQ,IAAiB,GAAc,UAC/C,KAAK,SAAS,IAAI,EAAQ,EAAa,WAI3C,UAAU,CACV,MAAO,MAAK,UCjBb,YAA2B,EAAe,EAAa,EAAK,CAC/D,KAAM,GAAiB,EAAY,UAAY,EAAY,YAAc,EACzE,GAAI,EAAc,QAAU,EACxB,GAAI,EAAc,OAAS,EAAG,CAC1B,KAAM,GAAa,EAAc,EAAc,OAAS,GAExD,MAAO,AADc,GAAc,MAAM,EAAG,EAAc,OAAS,GAC/C,IAAI,GAAK,EAAE,MAAM,KAAK,MAAQ,QAAU,EAAW,SACpE,CACH,KAAM,GAAc,EAAc,GAClC,MAAI,GACO,EAAY,KAEnB,GAAI,IAAI,CAAC,EAAG,kCAAmC,OAAQ,EAAc,OAAQ,YAAa,CAAC,CAAC,EAAa,sBAAuB,iBAAa,aACtI,uBAGZ,OAAI,GAAc,OAAS,EACvB,EAAc,IAAI,GAAK,EAAE,MAAM,KAAK,MAAQ,QAAQ,WAGpD,KAIR,QAAa,CAChB,YAAY,EAAQ,CAChB,KAAK,QAAU,EACf,KAAK,SAAW,GAAI,UASlB,kBAAiB,EAAW,EAAe,EAAK,CAClD,KAAM,GAAqB,GAAI,KACzB,EAAiB,GAEvB,SAAW,KAAkB,MAAK,SAAS,OACvC,AAAI,EAAU,QAAQ,KAAoB,IACtC,EAAe,KAAK,GAI5B,SAAW,CAAC,EAAQ,IAAiB,GAAc,UAC/C,AAAI,MAAK,SAAS,IAAI,IAAW,EAAU,QAAQ,KAAY,KAC3D,EAAmB,IAAI,EAAQ,EAAa,QAIpD,SAAW,KAAU,GACjB,GAAI,CAAC,KAAK,SAAS,IAAI,IAAW,CAAC,EAAmB,IAAI,GAAS,CAC/D,KAAM,GAAa,KAAM,GAAI,YAAY,IAAI,KAAK,QAAS,GAC3D,GAAI,EAAY,CACZ,KAAM,GAAS,GAAI,GAAW,GAC9B,EAAmB,IAAI,EAAO,OAAQ,IAIlD,MAAO,CAAC,mBAAoB,EAAmB,SAAU,kBAG7D,aAAa,CAAC,qBAAoB,kBAAiB,EAAa,EAAK,CACjE,SAAW,KAAU,GACjB,KAAK,SAAS,OAAO,GAEzB,SAAW,KAAU,GACjB,KAAK,SAAS,IAAI,EAAO,OAAQ,GAErC,KAAM,GAAgB,MAAM,KAAK,KAAK,SAAS,UAAU,KAAK,CAAC,EAAG,IAAM,EAAE,KAAK,cAAc,EAAE,OAC/F,KAAK,UAAY,GAAkB,EAAe,EAAa,MAG/D,WAAW,CACX,MAAO,MAAK,aAGZ,gBAAgB,CAChB,GAAI,KAAK,SAAS,OAAS,EACvB,SAAW,KAAU,MAAK,SAAS,SAC/B,MAAO,GAAO,UAGtB,MAAO,SAWP,oBAAoB,CACpB,GAAI,KAAK,SAAS,OAAS,EACvB,SAAW,KAAU,MAAK,SAAS,OAC/B,MAAO,GAGf,MAAO,OCtGR,QAAuB,CAC1B,YAAY,EAAa,CACrB,KAAK,KAAO,GAAI,KAChB,KAAK,aAAe,EAGxB,QAAQ,EAAS,EAAa,KAAM,CAChC,GAAI,GAAa,KAAK,KAAK,IAAI,GAC/B,MAAK,IACD,GAAa,GAAI,IAAc,KAAM,EAAY,GACjD,KAAK,KAAK,IAAI,EAAS,IAEpB,EAGX,aAAa,EAAc,CACvB,OAAS,GAAI,EAAG,EAAI,EAAa,OAAQ,GAAK,EAAG,CAC7C,KAAM,GAAQ,EAAa,GACrB,EAAa,KAAK,KAAK,IAAI,EAAM,IACvC,WAAY,OAAO,IAI3B,QAAQ,EAAI,CACR,KAAK,KAAK,OAAO,GACb,KAAK,KAAK,OAAS,GACnB,KAAK,gBAKjB,gBAA4B,GAAoB,CAC5C,YAAY,EAAU,EAAO,EAAI,CAC7B,QACA,KAAK,UAAY,EACjB,KAAK,OAAS,EACd,KAAK,IAAM,EAIX,QAAQ,UAAU,KAAK,IAAM,CACzB,AAAK,KAAK,kBACN,MAAK,UAAU,QAAQ,KAAK,KAC5B,KAAK,UAAY,QAK7B,UAAU,EAAS,CACf,GAAI,CAAC,KAAK,UACN,KAAM,IAAI,OAAM,4EAEpB,MAAO,OAAM,UAAU,GAG3B,mBAAoB,CAChB,KAAK,UAAU,QAAQ,KAAK,KAC5B,KAAK,UAAY,KACjB,MAAM,oBAGV,OAAO,EAAO,CAIV,KAAK,OAAS,EACd,KAAK,KAAK,KAAK,QAGnB,KAAM,CACF,MAAO,MAAK,oBCzEU,EAA6B,OAChD,IAAWC,GAAmB,KCAlC,KAAM,IAAa,sBAEnB,QAAkB,CACrB,YAAY,CAAC,kBAAiB,cAAa,YAAW,cAAa,CAC/D,KAAK,SAAW,EAChB,KAAK,aAAe,EACpB,KAAK,WAAa,EAClB,KAAK,YAAc,EAGvB,oBAAoB,EAAQ,CACxB,MAAI,KAAW,KAAK,YAAc,KAAK,cAAgB,OAC5C,GAEA,KAAK,UAIpB,YAAY,EAAW,CACnB,MAAO,MAAK,UAAY,KAAK,mBAAmB,MAGhD,YAAY,CACZ,MAAO,MAAK,UAAY,KAAK,gBAAgB,aAG7C,WAAW,CACX,MAAI,MAAK,cAAgB,OACd,OAAO,iBAEX,KAAK,aAAa,KAAK,YAGlC,aAAa,EAAQ,aACjB,GAAI,KAAK,SAAU,CACf,GAAI,GAAY,WAAK,SAAS,UAAd,cAAuB,QAAvB,cAA+B,GAI/C,GAHI,MAAO,IAAc,UACrB,GAAY,QAAK,SAAS,UAAd,cAAuB,eAEnC,MAAO,IAAc,SACrB,MAAO,WAEJ,KAAK,cACR,IAAW,SAAK,aAAa,UAAlB,cAA2B,SACtC,MAAO,KAGf,MAAO,GAIX,gBAAgB,EAAQ,OACpB,KAAM,GAAQ,QAAK,WAAL,cAAe,QAAQ,GACrC,MAAI,OAAO,IAAU,SACV,EAEA,GAIf,mBAAmB,EAAW,WAC1B,KAAM,GAAQ,WAAK,WAAL,cAAe,QAAQ,SAAvB,cAAgC,GAC9C,GAAI,MAAO,IAAU,SACjB,MAAO,GACJ,CACH,KAAM,GAAQ,QAAK,WAAL,cAAe,QAAQ,eACrC,MAAI,OAAO,IAAU,SACV,EAEA,ICnDvB,KAAMC,IAAuB,mBAEtB,gBAAuB,GAAa,CACvC,YAAY,CAAC,SAAQ,UAAS,QAAO,kBAAiB,uBAAsB,OAAM,uBAAsB,eAAc,YAAW,CAC7H,QACA,KAAK,QAAU,EACf,KAAK,SAAW,EAChB,KAAK,OAAS,EACd,KAAK,iBAAmB,EACxB,KAAK,SAAW,GAAI,IAAY,GAChC,KAAK,oBAAsB,GAAI,IAAmB,IAClD,KAAK,sBAAwB,EAC7B,KAAK,UAAY,KACjB,KAAK,MAAQ,EACb,KAAK,0BAA4B,KACjC,KAAK,YAAc,KACnB,KAAK,sBAAwB,EAC7B,KAAK,gBAAkB,KACvB,KAAK,cAAgB,EACrB,KAAK,UAAY,EACjB,KAAK,gBAAkB,KACvB,KAAK,aAAe,KACpB,KAAK,mBAAqB,KAC1B,KAAK,iBAAmB,UAGtB,oBAAmB,EAAU,EAAK,CACpC,KAAM,GAAe,GACrB,YAAM,SAAQ,IAAI,EAAS,IAAI,KAAM,IAAW,CAC5C,KAAM,GAAe,KAAM,GAAI,eAAe,aAAa,KAAK,QAAS,GACzE,AAAI,GACA,EAAa,KAAK,GAAI,GAAW,EAAc,KAAK,yBAGrD,EAGX,mCAAmC,EAAmB,EAAU,CAC5D,GAAI,GAAuB,KAAK,gBAAgB,qCAAqC,KAAK,UAAU,cAAe,GAEnH,KAAM,GAAc,EAAkB,OAAO,CAAC,EAAK,IAAO,GAAI,IAAI,EAAE,IAAY,GAAO,GAAI,MAC3F,SAAuB,EAAqB,OAAO,GAAK,CAAC,EAAY,IAAI,EAAE,KACpE,OAUL,eAAc,EAAS,EAAU,EAAK,OACxC,GAAI,CAAC,KAAK,gBACN,OAEJ,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,CACpC,KAAK,SAAS,WAAW,eACzB,KAAK,SAAS,WAAW,uBAE7B,GAAI,GAAe,KAAM,MAAK,mBAAmB,EAAU,GAC3D,GAAI,KAAK,UAAW,CAChB,KAAM,GAAuB,KAAK,mCAAmC,EAAc,CAAC,IACpF,EAAe,EAAa,OAAO,GAEvC,GAAI,EAAa,OAAQ,CAGrB,KAAM,AAFiB,MAAK,gBAAgB,GAAiB,MAAO,EAAc,EAAK,GAElE,WAErB,QAAK,YAAL,QAAgB,eAAe,GAK/B,KAAM,GAAU,KAAK,SAAS,KAAK,qBAAqB,EAAc,GAAO,IAC7E,AAAI,KAAM,MAAK,SAAS,kBAAkB,EAAS,KAAK,WACpD,KAAK,eAKjB,eAAe,EAAgB,CAC3B,MAAI,IAAkB,CAAC,KAAK,gBACxB,MAAK,gBAAkB,EACnB,KAAK,WACL,KAAK,UAAU,iBAAiB,KAAK,gBAAgB,KAAK,KAAM,GAAiB,WAE9E,IAEJ,GAOX,gBAAgB,EAAQ,EAAS,EAAmB,EAAM,KAAM,CAsC5D,MArCgB,IAAI,IAAkB,MAAO,EAAG,IAAQ,CAIpD,GAHK,GACD,GAAoB,KAAM,MAAK,SAAS,QAAQ,CAAC,KAAK,SAAS,WAAW,wBAE1E,EAAE,UAAW,OACjB,KAAM,GAAS,EAAQ,OAAO,GACnB,EAAM,YAAcA,IAC5B,IAAI,GAAS,EAAM,OAEtB,GADA,EAAE,YAAc,KAAM,MAAK,gBAAgB,kBAAkB,EAAQ,KAAM,EAAQ,GAC/E,EAAE,UAAW,OACjB,KAAM,GAAU,KAAM,GAAE,YAAY,UAEpC,GADA,EAAE,YAAc,KACZ,EAAE,UAAW,OACjB,KAAM,GAAS,CAAC,KAAK,SAAS,WAAW,yBACnC,EAAiB,KAAK,gBAC5B,AAAI,GAEA,EAAO,KAAK,KAAK,SAAS,WAAW,kBAEzC,KAAM,GAAW,KAAM,MAAK,SAAS,aAAa,GAClD,GAAI,GACJ,GAAI,CACA,EAAa,KAAM,GAAQ,MAAM,EAAU,GACvC,GACA,KAAM,GAAW,cAAc,SAE9B,EAAP,CACE,QAAS,QACH,EAEV,KAAM,GAAS,WAEf,EAAW,eAAe,GACtB,KAAK,iBACL,KAAK,gBAAgB,aAAa,IAEvC,GAAc,SAKf,6BAA4B,EAAS,EAAgB,EAAK,CAO5D,GAAI,GAAe,AANG,MAAM,SAAQ,IAAI,EAAQ,IAAI,KAAM,IAAO,CAC7D,KAAM,GAAgB,KAAM,GAAe,yBAAyB,EAAK,GACzE,GAAI,EACA,MAAO,MAAK,mBAAmB,EAAe,OAGrB,OAAO,CAAC,EAAY,IAAY,EAAU,EAAW,OAAO,GAAW,EAAY,IAKpH,GAAI,KAAK,UAAW,CAGhB,KAAM,GAA6B,AAFN,KAAK,mCAAmC,EAAc,GAE3B,IAAI,GAAK,EAAE,SAEnE,EAAe,EAAa,OAAO,GAEvC,MAAO,QAIL,MAAK,EAAS,EAAK,EAAK,CAC1B,EAAI,IAAI,KAAM,KAAK,IACnB,GAAI,CAKA,GAHI,GACA,KAAK,SAAS,KAAK,GAEnB,KAAK,SAAS,KAAK,WAAY,CAC/B,KAAM,GAAiB,KAAK,sBAAsB,KAAM,KAAK,SAAS,KAAK,YAC3E,KAAK,eAAe,GAGxB,GAAI,KAAK,SAAS,KAAK,YAAa,CAChC,KAAK,QAAU,GAAI,IAAO,KAAK,SAC/B,KAAM,GAAU,KAAM,MAAK,QAAQ,iBAAiB,KAAK,SAAS,KAAK,OAAQ,GAAI,GACnF,KAAK,QAAQ,aAAa,EAAS,KAAK,SAAS,KAAM,UAEtD,EAAP,CACE,KAAM,IAAI,IAAa,uBAAuB,KAAK,UAAW,SAIhE,eAAc,EAAQ,CACxB,AAAK,KAAK,kBACN,MAAK,iBAAmB,GAAI,MAEhC,KAAM,GAAY,KAAK,iBAAiB,IAAI,GAC5C,GAAI,EAEA,MAAO,GAGX,KAAM,GAAS,KAAM,IAAkB,CACnC,QAAS,KAAK,SACd,OAAQ,KAAK,QACb,SACA,QAAS,KAAK,SACd,MAAO,KAAK,QACb,KAAK,UAAU,QAClB,GAAI,CAAC,EACD,MAAO,MAEX,KAAM,GAAmB,GAAI,IAAwB,EAAQ,IAAM,KAAK,iBAAiB,OAAO,IAChG,YAAK,iBAAiB,IAAI,EAAQ,GAC3B,OAKL,gBAAe,EAAM,KAAM,CAC7B,GAAI,KAAK,YAEL,YAAK,YAAY,SACV,KAAK,YACT,CACH,KAAM,GAAU,KAAM,IAAmB,CACrC,QAAS,KAAK,SACd,OAAQ,KAAK,QACb,MAAO,KAAK,OACZ,QAAS,KAAK,SACd,UAAW,KAAK,gBAEhB,qBAAsB,GAAO,KAAK,0BAA4B,EAC9D,OACD,KAAK,UAAU,QAClB,YAAK,YAAc,GAAI,IAAW,CAC9B,UACA,cAAe,IAAM,CAAE,KAAK,YAAc,QAEvC,KAAK,aAKpB,QAAQ,EAAe,EAAQ,EAAM,KAAM,CAEvC,MAAO,MAAK,UAAU,OAAO,UAAU,EAAK,UAAW,KAAM,IAAO,CAIhE,GAHA,EAAI,IAAI,KAAM,KAAK,IACnB,EAAI,IAAI,WAAY,EAAc,YAClC,EAAI,IAAI,MAAO,EAAc,UAAU,eACnC,EAAc,YAAa,CAC3B,EAAI,IAAI,cAAe,IACvB,OAEJ,KAAM,GAAW,KAAM,MAAK,OAAO,SAAS,KAAK,QAAS,CACtD,KAAM,EAAc,MACpB,IAAK,EAAc,UAAU,cAC7B,MAAO,EACP,OAAQ,CACJ,kBAAmB,GACnB,0BAA2B,KAEhC,CAAC,QAAM,WAEJ,EAAM,KAAM,MAAK,SAAS,aAAa,CACzC,KAAK,SAAS,WAAW,cACzB,KAAK,SAAS,WAAW,eACzB,KAAK,SAAS,WAAW,kBACzB,KAAK,SAAS,WAAW,oBAE7B,GAAI,GACA,EACJ,GAAI,CAEA,EAAsB,KAAM,MAAK,cAAc,EAAS,MAAO,EAAK,GAEpE,KAAM,GAAiB,GAAI,IAAe,CACtC,OAAQ,KAAK,QACb,mBAAoB,KAAK,oBACzB,UAAW,KAAK,MAAM,KAQ1B,EAAY,KAAM,AANA,IAAI,IAAU,CAC5B,OAAQ,KAAK,QACb,QAAS,KAAK,SACd,mBAAoB,KAAK,oBACzB,mBAEwB,kBAAkB,EAAe,EAAU,EAAK,SACvE,EAAP,CACE,QAAI,QACE,EAEV,KAAM,GAAI,WACN,KAAK,iBAEL,KAAM,AADiB,MAAK,gBAAgB,GAAiB,SAAU,EAAU,QAAS,KAAM,GAC3E,WAGzB,SAAW,KAAY,GAAU,UAC7B,KAAK,oBAAoB,IAAI,GAEjC,AAAI,GACA,KAAK,cAAc,GAEnB,KAAK,WAEL,MAAK,UAAU,eAAe,EAAU,gBACxC,KAAK,UAAU,WAAW,EAAU,iBAU1C,eAAc,EAAO,EAAK,EAAK,EACrC,eAAgB,KAGZ,OAAO,CACP,GAAI,KAAK,QACL,MAAO,MAAK,QAAQ,SAExB,KAAM,GAAc,KAAK,SAAS,KAClC,MAAI,GAAY,KACL,EAAY,KAEnB,EAAY,eACL,EAAY,eAEhB,QAIP,KAAK,CACL,MAAO,MAAK,WAGZ,YAAY,CACZ,MAAI,MAAK,SAAS,KAAK,UACZ,KAAK,SAAS,KAAK,UACnB,KAAK,QACL,KAAK,QAAQ,cAEjB,QASP,gBAAgB,CAChB,MAAO,MAAK,WAGZ,uBAAuB,CACvB,MAAO,MAAK,SAAS,KAAK,wBAG1B,gBAAgB,CAChB,KAAM,GAAO,KAAK,SAAS,KAAK,KAChC,MAAO,CAAC,CAAE,IAAQ,EAAK,qBAGvB,cAAc,CACd,MAAO,CAAC,CAAC,KAAK,SAAS,KAAK,cAG5B,WAAW,CACX,MAAO,MAAK,aAAe,UAG3B,SAAS,CACT,MAAO,MAAK,aAAe,WAG3B,iBAAiB,CACjB,MAAO,MAAK,SAAS,KAAK,kBAG1B,oBAAoB,CACpB,MAAO,MAAK,SAAS,KAAK,aAG1B,kBAAkB,CAClB,MAAO,MAAK,oBAGZ,aAAa,CACb,MAAO,MAAK,SAAS,KAAK,WAG9B,yBAAyB,EAAQ,CAC7B,GAAI,KAAK,SAAS,KAAK,WAAa,EAChC,MAAO,GACJ,CAIH,KAAM,CAAC,SAAQ,YAAW,eAAe,KAAK,SAAS,KACvD,GAAI,GAAU,EAAO,SAAS,IAAY,EAAY,IAAiB,EACnE,MAAO,GAGf,MAAO,QAGL,mBAAmB,CACrB,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,CAAC,KAAK,SAAS,WAAW,YAC5D,EAAmB,KAAM,GAAI,UAAU,IAAI,KAAK,QAAS,sBAAuB,IACtF,GAAI,EACA,MAAO,IAAI,IAAY,CACnB,gBAAiB,EAAiB,MAClC,UAAW,KAAK,MAAM,GACtB,WAAY,KAAK,aAGzB,KAAM,GAAc,KAAM,GAAI,UAAU,IAAI,KAAK,QAAS,gBAAiB,IAC3E,GAAI,EACA,MAAO,IAAI,IAAY,CACnB,YAAa,EAAY,MACzB,UAAW,KAAK,MAAM,GACtB,WAAY,KAAK,aAElB,CACH,KAAM,GAAa,KAAK,WACxB,MAAO,IAAI,IAAY,CAAC,UAAW,KAAK,MAAM,GAAI,qBASpD,qBAAqB,CACvB,AAAI,KAAK,oBAAsB,KAAM,MAAK,mBAC1C,GAAI,GAAa,KAAK,aACtB,GAAI,CAAC,EAAY,CACb,KAAK,mBAAqB,KAAK,mBAC/B,KAAM,GAAc,KAAM,MAAK,mBAC/B,EAAa,GAAI,IAAwB,EAAa,IAAM,CAAE,KAAK,aAAe,OAClF,KAAK,aAAe,EACpB,KAAK,mBAAqB,KAE9B,MAAO,GAGX,gBAAgB,EAAW,OACvB,QAAK,kBAAL,QAAsB,gBAAgB,GAElC,KAAK,WAAa,GAClB,KAAK,UAAU,OAAO,IAAI,kBAAmB,GAClC,KAAK,gBAAgB,iCAAiC,KAAK,UAAU,cAAe,OAKnG,kBAAkB,CAClB,MAAO,CAAC,CAAC,KAAK,UAGlB,aAAc,CAEV,KAAK,KAAK,UAEV,KAAK,sBAAsB,MAI/B,aAAa,EAAM,KAAM,CACrB,MAAO,MAAK,UAAU,OAAO,UAAU,EAAK,gBAAiB,KAAM,IAAO,CAEtE,GADA,EAAI,IAAI,KAAM,KAAK,IACf,KAAK,UACL,KAAM,IAAI,OAAM,2CAEpB,KAAK,UAAY,GAAI,IAAS,CAC1B,OAAQ,KAAK,GACb,QAAS,KAAK,SACd,mBAAoB,KAAK,oBACzB,cAAe,KAAK,oBACpB,cAAe,IAAM,CACjB,KAAK,UAAY,KACb,KAAK,iBACL,KAAK,gBAAgB,wBAG7B,MAAO,KAAK,UAAU,MACtB,OAAQ,KAAK,UAAU,OACvB,sBAAuB,KAAM,MAAK,qBAClC,MAAO,KAAK,SAEhB,GAAI,CACA,AAAI,KAAK,iBACL,KAAK,UAAU,iBAAiB,KAAK,gBAAgB,KAAK,KAAM,GAAiB,WAErF,KAAM,MAAK,UAAU,KAAK,KAAK,MAAO,KAAK,WAAY,SAClD,EAAP,CAEE,WAAK,UAAU,UACT,EAEV,MAAO,MAAK,YAKpB,mBAAoB,CAAE,MAAO,MAE7B,aAAa,EAAS,CAClB,AAAK,KAAK,iBACN,MAAK,gBAAkB,GAAI,IAAiB,IAAM,CAC9C,KAAK,gBAAkB,QAG/B,GAAI,GAAQ,KACZ,AAAI,KAAK,WACL,GAAQ,KAAK,UAAU,aAAa,IAExC,KAAM,GAAa,KAAK,gBAAgB,QAAQ,EAAS,GACzD,MAAK,IAED,KAAK,eAAe,GAAS,KAAK,GAAS,CACvC,EAAW,OAAO,KACnB,MAAM,GAAO,CACZ,QAAQ,KAAK,wBAAwB,iBAAwB,KAG9D,OAGL,gBAAe,EAAS,CAG1B,MADc,MAAM,AADL,IAAI,IAAe,CAAE,OAAQ,KAAK,QAAS,QAAS,KAAK,SAAU,mBAAoB,KAAK,sBAChF,SAAS,GAIxC,SAAU,SACN,QAAK,kBAAL,QAAsB,UACtB,QAAK,YAAL,QAAgB,WAIxB,QAAwB,CACpB,YAAY,EAAW,EAAK,CACxB,KAAK,WAAa,GAClB,KAAK,YAAc,KACnB,KAAK,SAAW,EAAI,KAAK,iBAAkB,GAAO,EAAU,KAAM,IAGtE,UAAW,CACP,MAAO,MAAK,YAGZ,YAAY,CACZ,MAAO,MAAK,WAGhB,SAAU,CACN,KAAK,WAAa,GACd,KAAK,aACL,KAAK,YAAY,WC9jBtB,aAAqB,CAExB,KAAM,GAAM,AADF,KAAK,MAAM,KAAK,SAAW,OAAO,kBAC9B,SAAS,IACvB,MAAO,IAAM,IAAI,OAAO,GAAK,EAAI,QAAU,EAGxC,YAAiB,EAAO,CAC9B,MAAO,GAAM,WAAW,MAAQ,EAAM,SAAW,GCD3C,QAAgB,CACnB,YAAY,CAAC,SAAQ,UAAS,QAAO,iBAAgB,CACjD,EAAgB,GAAiB,GACjC,KAAK,QAAU,EACf,KAAK,SAAW,EAChB,KAAK,OAAS,EACd,KAAK,eAAiB,GAAI,IAAY,CAAC,EAAG,IAAM,EAAE,WAAa,EAAE,YACjE,KAAK,eAAe,gBAAgB,EAAc,IAAI,GAAQ,KAAK,oBAAoB,KACvF,KAAK,WAAa,GAClB,KAAK,SAAW,GAChB,KAAK,gBAAkB,KACvB,KAAK,mBAAqB,EAG9B,oBAAoB,EAAM,EAAc,KAAM,CAC1C,KAAM,GAAe,GAAI,IAAa,CAClC,OACA,OAAQ,IAAM,KAAK,aAAa,GAChC,WAAY,GAAU,KAAK,eAAe,OAAO,EAAc,GAC/D,gBAEJ,MAAO,GAGX,iBAAiB,EAAgB,CAC7B,KAAK,gBAAkB,EAG3B,UAAU,EAAK,CACX,KAAK,WAAa,GAClB,KAAK,iBAAmB,EAAI,YAAY,mBAAoB,KAAM,IAAO,CACrE,GAAI,CACA,SAAW,KAAgB,MAAK,eAC5B,KAAM,GAAI,KAAK,aAAc,KAAM,IAAO,CACtC,EAAI,IAAI,aAAc,EAAa,YACnC,GAAI,CACA,KAAK,mBAAqB,EAAa,WACvC,KAAM,MAAK,WAAW,EAAc,SAChC,EAAN,CACE,AAAI,YAAe,IACf,MAAK,SAAW,GAChB,EAAI,IAAI,UAAW,IACnB,EAAa,cAEb,GAAI,MAAM,GAMV,AALyB,EAAI,OAAS,mBAClC,GAAI,aAAe,KACnB,EAAI,aAAe,KACnB,EAAI,aAAe,KAGnB,GAAI,IAAI,SAAU,IAClB,KAAM,GAAa,SAEnB,EAAa,SAAS,YAI9B,KAAK,mBAAqB,aAKtC,KAAK,WAAa,GAClB,KAAK,iBAAmB,aAK9B,YAAW,EAAc,EAAK,CAKhC,GAJI,EAAa,aACb,MAAM,GAAI,KAAK,qBAAsB,GAAO,EAAa,kBAAkB,KAAK,OAAQ,IACxF,KAAM,MAAK,gBAAgB,IAE3B,EAAa,gBAAiB,CAC9B,EAAa,gBACb,KAAM,GAAoB,EAAa,qBACjC,CAAC,OAAM,WAAW,KAAM,GAAI,KAAK,UAAW,GAAO,KAAK,gBAAgB,QAC1E,EAAa,UAAW,EAAmB,KAAK,OAAQ,IAC5D,EAAa,aAAa,EAAM,GAChC,KAAM,MAAK,gBAAgB,GAE/B,GAAI,EAAa,aAAc,CAC3B,KAAM,GAAa,KAAK,KAAK,OAAQ,GAOrC,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CAAC,KAAK,SAAS,WAAW,gBACvE,GAAI,CACA,KAAM,MAAK,uBAAuB,EAAc,GAChD,KAAM,MAAK,mCACP,EAAa,MAAO,EAAa,SAAU,SAC1C,EAAP,CACE,QAAI,QACE,EAEV,KAAM,GAAI,iBAIZ,oCAAmC,EAAO,EAAU,EAAK,CAC3D,KAAM,GAA8B,KAAK,eAAe,MAAM,OAAO,GAC1D,EAAG,eAAiB,GAAS,EAAG,iBAAmB,GAE9D,SAAW,KAAa,GACpB,EAAU,kBAAkB,GAC5B,KAAM,MAAK,uBAAuB,EAAW,GAEjD,MAAO,QAGL,mBAAkB,EAAQ,EAAK,EAAW,CAC5C,KAAM,GAAU,GAChB,SAAW,KAAS,GAAQ,CACxB,KAAM,GAAQ,EAAM,UAAY,EAAM,SAAS,eAC/C,GAAI,GAMJ,GALA,AAAI,EACA,EAAM,KAAK,eAAe,MAAM,UAAU,GAAM,EAAG,QAAU,GAE7D,EAAM,KAAK,eAAe,MAAM,UAAU,GAAM,EAAG,WAAa,EAAM,UAEtE,IAAQ,GAAI,CACZ,KAAM,GAAe,KAAK,eAAe,IAAI,GACvC,EAAW,EAAM,SACvB,EAAU,IAAI,CAAC,EAAG,mBAAoB,WAAY,EAAa,WAAY,WAAU,UACrF,EAAI,cAAc,OAAO,EAAa,OAAQ,EAAa,YAC3D,EAAQ,KAAK,GACb,KAAM,MAAK,mCAAmC,EAAO,EAAU,IAGvE,MAAO,QAGL,cAAa,EAAc,CAE7B,GADe,KAAK,eAAe,MAAM,QAAQ,KAAkB,GACrD,CACV,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CAAC,KAAK,SAAS,WAAW,gBACvE,GAAI,CACA,EAAI,cAAc,OAAO,EAAa,OAAQ,EAAa,iBAC7D,CACE,EAAI,QAER,KAAM,GAAI,WAGV,KAAM,GAAM,KAAK,eAAe,MAAM,QAAQ,GAC9C,AAAI,IAAQ,IACR,KAAK,eAAe,OAAO,GAGnC,EAAa,UAGjB,aAAa,EAAe,CACxB,SAAW,KAAgB,GAAe,CACtC,KAAM,GAAM,KAAK,eAAe,MAAM,QAAQ,GAC9C,AAAI,IAAQ,IACR,KAAK,eAAe,OAAO,GAE/B,EAAa,WAIrB,cAAc,EAAW,CACrB,KAAK,SAAW,GACZ,KAAK,eAAe,QACpB,EAAU,KAAK,gBAAiB,GAAO,CACnC,EAAI,IAAI,KAAM,KAAK,SACnB,EAAI,IAAI,gBAAiB,KAAK,eAAe,QACxC,KAAK,YACN,KAAK,UAAU,GAEf,KAAK,kBACL,EAAI,YAAY,KAAK,yBAM/B,cAAa,EAAW,EAAS,EAAa,EAAK,CACrD,KAAM,GAAW,GAAuB,GACxC,GAAI,GAAe,KACnB,GAAI,EAAU,CACV,KAAM,GAAiB,GAAkB,GAKzC,GAJI,GAAQ,IACR,GAAe,EACf,GAAkB,EAAU,OAE5B,EAAS,WAAa,IAEM,KAAK,eAAe,MAAM,KAAK,GAAM,CAC7D,KAAM,GAAI,GAAuB,EAAG,SACpC,MAAO,GAAG,YAAc,GAAa,GAAK,EAAE,MAAQ,EAAS,KACxD,GAAG,eAAiB,GAAgB,EAAE,WAAa,EAAS,YAE5C,CACrB,EAAI,IAAI,qBAAsB,IAC9B,QAIZ,KAAM,MAAK,cAAc,EAAW,EAAS,EAAa,EAAc,KAAM,QAG5E,eAAc,EAAW,EAAS,EAAa,EAAc,EAAgB,EAAK,CACpF,KAAM,GAAe,KAAM,MAAK,qBAAqB,EAAW,EAAS,EAAc,EAAgB,GACvG,KAAK,eAAe,IAAI,GACxB,EAAI,IAAI,aAAc,EAAa,YACnC,EAAI,IAAI,gBAAiB,KAAK,eAAe,QACzC,CAAC,KAAK,YAAc,CAAC,KAAK,UAC1B,KAAK,UAAU,GAEf,KAAK,kBACL,EAAI,YAAY,KAAK,uBAIvB,kBAAiB,EAAgB,EAAQ,EAAK,CAKhD,GAJ2B,KAAK,eAAe,MAAM,KAAK,GAC/C,EAAG,YAAc,GACnB,GAAG,eAAiB,GAAkB,EAAG,iBAAmB,IAE7C,CACpB,EAAI,IAAI,oBAAqB,IAC7B,OAEJ,GAAI,GACA,EACJ,GAAI,GAAQ,GAAiB,CACzB,EAAe,EACf,KAAM,GAAQ,EACR,EAAK,KAAK,eAAe,MAAM,KAAK,GAAM,EAAG,QAAU,GAC7D,GAAI,GAAM,CAAC,EAAG,UAAY,EAAG,SAAW,EAAW,QAAS,CAGxD,EAAI,IAAI,SAAU,GAClB,KAAM,GAAG,QACT,eACO,EACP,EAAiB,EAAG,aAOpB,YAED,CACH,EAAiB,EACjB,KAAM,GAAK,KAAK,eAAe,MAAM,KAAK,GAAM,EAAG,WAAa,GAChE,AAAI,GAGA,GAAe,EAAG,OAG1B,EAAI,IAAI,eAAgB,GACxB,EAAI,IAAI,iBAAkB,GAC1B,KAAM,MAAK,cAAc,EAAgB,CAAC,UAAS,KAAM,EAAc,EAAgB,MAGvF,gBAAgB,CAChB,MAAO,MAAK,oBAGV,iBAAgB,EAAc,CAChC,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CAAC,KAAK,SAAS,WAAW,gBACvE,GAAI,CACA,KAAK,uBAAuB,EAAc,SACrC,EAAP,CACE,QAAI,QACE,EAEV,KAAM,GAAI,gBAGR,wBAAuB,EAAc,EAAK,CAG5C,AAAI,KAAM,GAAI,cAAc,OAAO,EAAa,OAAQ,EAAa,aACjE,EAAI,cAAc,OAAO,EAAa,WAIxC,sBAAqB,EAAW,EAAS,EAAc,EAAgB,EAAa,CACtF,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CAAC,KAAK,SAAS,WAAW,gBACvE,GAAI,GACJ,GAAI,CACA,KAAM,GAAqB,EAAI,cACzB,EAAuB,KAAM,GAAmB,iBAAiB,KAAK,UAAY,EAKlF,EAAa,AADG,KAAK,IAAI,EAAsB,KAAK,oBACvB,EAC7B,EAAkB,IAAc,GAClC,IAAc,IACd,CAAC,CAAC,KAAK,gBACX,EAAe,KAAK,oBAAoB,CACpC,OAAQ,KAAK,QACb,aACA,YACA,UACA,eACA,iBACA,MAAO,KACP,kBACA,YAAa,CAAC,CAAC,GAChB,GACH,EAAmB,IAAI,EAAa,YAC/B,EAAP,CACE,QAAI,QACE,EAEV,YAAM,GAAI,WACH,EAGX,SAAU,CACN,SAAW,KAAM,MAAK,eAClB,EAAG,WCzUR,QAAuB,CAC1B,YAAY,CAAC,WAAU,OAAM,YAAW,CACpC,KAAK,UAAY,EAEjB,KAAK,iBAAmB,EACxB,KAAK,iBAAmB,KAAK,iBAC7B,KAAK,UAAY,EACjB,KAAK,QAAU,KACf,KAAK,gBAAkB,KACvB,KAAK,eAAiB,KACtB,KAAK,SAAW,GAChB,KAAK,OAAS,KACd,KAAK,WAAa,KAIlB,OAAO,CACP,MAAO,MAAK,iBAAiB,QAG7B,YAAY,CACZ,MAAO,MAAK,WAGhB,OAAQ,OACJ,QAAK,iBAAL,QAAqB,WAGrB,eAAe,CACf,MAAO,MAAK,sBAIV,UAAU,CACZ,GAAI,KAAK,gBACL,KAAM,IAAI,OAAM,qBAEpB,KAAM,CAAC,OAAM,QAAQ,KAAM,IAAkB,KAAK,UAAW,KAAK,kBAClE,KAAK,iBAAmB,EACxB,KAAK,gBAAkB,OAIrB,QAAO,EAAO,EAAkB,EAAK,CACvC,KAAK,eAAiB,EAAM,iBAAiB,KAAK,iBAAkB,KAAK,UAAW,CAChF,eAAgB,GAAa,CACzB,KAAK,WAAa,EAClB,KAEJ,QAEJ,KAAM,CAAC,eAAe,KAAM,MAAK,eAAe,WAChD,KAAK,QAAU,EAInB,eAAe,EAAS,EAAS,CAC7B,GAAI,CAAC,KAAK,QACN,KAAM,IAAI,OAAM,2BAEpB,GAAI,GAAS,EAAQ,OAAO,EAAG,EAAQ,YAAY,QACnD,GAAQ,GAAG,aAAmB,EAAS,KAAK,iBAAiB,MAC7D,GAAQ,GAAG,iBAAuB,EAAS,KAAK,iBAAiB,UACjE,AAAI,KAAK,gBACL,GAAQ,GAAG,QAAc,EAAS,OAAO,OAAO,KAAK,gBAAiB,CAClE,SAAU,KAAK,iBAAiB,SAChC,IAAK,KAAK,WAGd,GAAQ,GAAG,OAAa,EAAS,KAAK,SAI9C,SAAU,CACN,KAAK,iBAAiB,UACtB,KAAK,iBAAiB,WAI9B,YAAiB,EAAM,EAAS,EAAO,CACnC,KAAM,GAAQ,EAAK,MAAM,KACzB,GAAI,GAAM,EACV,OAAS,GAAI,EAAG,EAAK,EAAM,OAAS,EAAI,GAAK,EAAG,CAC5C,KAAM,GAAM,EAAM,GAClB,AAAK,EAAI,IACL,GAAI,GAAO,IAEf,EAAM,EAAI,GAEd,KAAM,GAAU,EAAM,EAAM,OAAS,GACrC,EAAI,GAAW,ECjFnB,KAAM,IAAuB,mBAEtB,gBAAmB,GAAS,CAC/B,YAAY,EAAS,CACjB,MAAM,GAEN,KAAM,CAAC,iBAAiB,EAClB,EAAiB,GAAI,IAAe,CACtC,OAAQ,KAAK,GACb,mBAAoB,KAAK,oBACzB,UAAW,KAAK,MAAM,KAE1B,KAAK,YAAc,GAAI,IAAW,CAC9B,OAAQ,KAAK,GACb,mBAAoB,KAAK,oBACzB,iBACA,aAAc,GAAI,IAAa,KAAK,MAExC,KAAK,WAAa,GAAI,IAAU,CAAC,OAAQ,KAAK,GAAI,QAAS,KAAK,SAAU,MAAO,KAAK,OAAQ,kBAGlG,eAAe,EAAgB,CAC3B,MAAI,OAAM,eAAe,GACrB,MAAK,WAAW,iBAAiB,KAAK,iBAC/B,IAEJ,QAGL,aAAY,EAAc,EAAY,EAAS,EAAK,EAAK,OAC3D,EAAI,IAAI,KAAM,KAAK,IACf,GACA,EAAI,IAAI,UAAW,EAAQ,QAE/B,GAAI,GAAiB,KAAK,SAAS,KAAK,kBAAkB,EAAc,EAAY,KAAK,MAAM,IAC3F,EAAiB,KAAK,gBAE1B,AAAI,CAAC,GAAkB,EAAe,YAClC,GAAI,IAAI,mBAAoB,IAC5B,EAAiB,KAAK,sBAAsB,KAAM,EAAe,aAGrE,GAAI,GACA,EACJ,GAAI,EAAgB,CAChB,GAAI,GAAkB,qBAAc,WAAd,cAAwB,SAAU,GAExD,AAAI,GAKA,GAAe,KAAM,MAAK,4BAA4B,EAAS,EAAgB,GAC3E,EAAa,QACb,GAAI,IAAI,QAAS,EAAa,QAC9B,EAAkB,EAAgB,OAAO,EAAa,IAAI,GAAS,EAAM,UAGjF,EAAkB,EAAgB,OAAO,GAC9B,kBAAO,QAAS,IAEvB,EAAgB,QAChB,GAAqB,KAAM,GAAe,kBACtC,EAAiB,EAAS,GAAiB,KAAM,IAI7D,MAAO,CACH,iBACA,iBACA,qBACA,eAAgB,KAChB,qBAIF,kBAAiB,EAAa,EAAW,CAC3C,AAAI,EAAY,oBACZ,KAAM,GAAU,KAAK,UAAW,KAAM,IAAO,CACzC,EAAI,IAAI,KAAM,KAAK,IACnB,EAAY,eAAiB,KAAM,GAAY,mBAAmB,UAClE,EAAY,mBAAqB,MAClC,EAAU,MAAM,aAKrB,WAAU,EAAc,EAAe,CAAC,iBAAgB,iBAAgB,iBAAgB,gBAAe,EAAK,EAAK,QACnH,EAAI,IAAI,KAAM,KAAK,IACnB,KAAM,GAAW,EAAe,UAAU,KAAK,SAAS,MACxD,AAAI,GAGA,GAAI,UAAU,iBAAiB,KAAK,IACpC,EAAI,YAAY,iBAAiB,KAAK,KAE1C,KAAM,CAAC,QAAS,EAAY,iBAAgB,aAAY,iBACpD,KAAM,GAAI,KAAK,aAAc,IAAO,KAAK,YAAY,UACjD,EAAc,EAAU,EAAe,kBAAmB,EAAK,IAAM,EAAI,MAAM,QACvF,GAAI,EAAgB,CAChB,KAAM,IAAa,KAAM,GAAI,KAAK,iBAAkB,IAAO,EAAe,MAAM,EAAK,KACrF,EAAI,IAAI,oBAAqB,GAAW,QAAQ,MAChD,EAAI,IAAI,mBAAoB,GAAW,OAAO,MAC1C,KAAK,iBACL,KAAM,IAAW,cAAc,GAEnC,GAAW,eAAe,GACtB,kBAAc,SACd,IAAW,eAAe,GAC1B,EAAe,KAAK,GAAG,IAG/B,EAAI,IAAI,aAAc,EAAW,QACjC,EAAI,IAAI,iBAAkB,EAAe,QACzC,GAAI,GAAuB,GAE3B,AAAI,GAAkB,KAAK,mBAAqB,kBAAe,OAC3D,GAAuB,KAAM,GAAe,mBAAmB,EAAe,EAAK,GACnF,EAAI,IAAI,uBAAwB,IAEpC,KAAM,GAAa,EAAW,OAAO,GAErC,EAAiB,EAAe,qBAC5B,EAAY,EAAe,CAAC,KAAK,gBAAiB,KAAK,MAAM,IAGjE,AAAI,EAAe,aAAe,OAC9B,EAAI,YAAY,OAAO,KAAK,IAG5B,EAAiB,KAAK,SAAS,UAAU,EAAgB,GAEzD,GACA,EAAI,IAAI,iBAAkB,EAAe,KAAK,KAAK,SAAS,OAIhE,GAAI,GAIJ,AAAI,kBAAgB,cAEX,MAAK,SACN,MAAK,QAAU,GAAI,IAAO,KAAK,UAEnC,EAAc,KAAM,MAAK,QAAQ,iBAAiB,EAAe,OAAQ,EAAe,IAE5F,GAAI,GACJ,AAAI,MAAM,QAAQ,MAAa,WAAb,eAAuB,SACrC,GAAuB,KAAM,MAAK,WAAW,kBAAkB,EAAa,SAAS,OAAQ,EAAK,IAEtG,KAAM,GAAmB,KAAK,qBAAqB,GACnD,MAAO,CACH,iBACA,iBACA,aACA,iBACA,aACA,uBACA,gBACA,cACA,mBACA,wBASR,UAAU,EAAS,EAAK,CACpB,KAAM,CACF,iBAAgB,aAAY,iBAAgB,aAC5C,uBAAsB,gBAAe,mBACrC,cAAa,kBACb,EAIJ,GAHA,EAAI,IAAI,KAAM,KAAK,IACnB,KAAK,YAAY,UAAU,GAC3B,KAAK,eAAe,GAChB,EAAc,KAAM,CACpB,GAAI,KAAK,0BACL,SAAW,CAAC,EAAQ,IAAiB,GAAc,UAC/C,KAAK,0BAA0B,IAAI,EAAQ,EAAa,QAShE,GANI,KAAK,aACL,KAAK,YAAY,UAAU,GAE3B,KAAK,kBACL,KAAK,uBAAuB,GAE5B,KAAK,WACL,SAAW,CAAC,EAAQ,IAAiB,GAAc,UAC/C,GAAI,IAAW,KAAK,MAAM,GAAI,CAC1B,KAAK,UAAU,gBAAgB,EAAa,QAC5C,QAKhB,GAAI,GAAa,GAQjB,GAPI,GACA,MAAK,SAAS,aAAa,GACtB,KAAK,SAAS,KAAK,aACpB,MAAK,QAAU,MAEnB,EAAa,IAEb,KAAK,SAAW,EAAa,CAC7B,KAAM,GAAU,KAAK,KACrB,KAAK,QAAQ,aAAa,EAAa,KAAK,SAAS,KAAM,GACvD,IAAY,KAAK,MACjB,GAAa,IAGrB,AAAI,GACA,KAAK,mBAAmB,GAExB,GACA,KAAK,cAEL,KAAK,WAEL,MAAK,UAAU,eAAe,GAC9B,KAAK,UAAU,WAAW,IAE1B,KAAK,iBACL,MAAK,gBAAgB,aAAa,GAClC,KAAK,gBAAgB,aAAa,IAElC,GACA,KAAK,WAAW,aAAa,GAIrC,uBAAuB,EAAe,CAClC,SAAW,CAAC,EAAQ,IAAiB,GAAe,CAChD,KAAM,GAAmB,KAAK,iBAAiB,IAAI,GACnD,AAAI,GACA,EAAiB,IAAI,EAAa,SAK9C,qBAAqB,EAAc,WAC/B,KAAM,GAAoB,GAAS,EAAM,YAAc,IAAM,EAAM,OAASC,GAE5E,MADwB,QAAa,WAAb,cAAuB,OAAO,KAAK,KAAnC,OAAyD,KAAa,QAAb,cAAoB,OAAO,KAAK,GAIrH,mBAAmB,EAAiB,CAChC,GAAI,KAAK,aAAc,CACnB,KAAM,GAAiB,GAAI,IAAY,CACnC,kBACA,UAAW,KAAK,MAAM,GACtB,WAAY,KAAK,aAErB,KAAK,aAAa,IAAI,IAI9B,wBAAwB,CAAC,wBAAuB,CAC5C,MAAO,QAQL,oBAAmB,EAAS,EAAK,CACnC,EAAI,IAAI,KAAM,KAAK,IACf,KAAK,iBACL,KAAM,MAAK,gBAAgB,0BAA0B,KAAK,OAAQ,KAAM,GAKhF,MAAM,EAAmB,EAAW,CAChC,GAAI,KAAK,gBAAiB,CACtB,KAAM,GAAgB,iBAAmB,IAAI,kBAC7C,AAAI,GAEA,EAAU,aAAa,kBAAmB,GACtC,GAAI,IAAI,KAAM,KAAK,IACZ,KAAK,gBAAgB,0BAA0B,KAAK,OAAQ,EAAe,KAK9F,KAAK,WAAW,cAAc,QAI5B,MAAK,EAAS,EAAK,EAAK,CAC1B,GAAI,CACA,KAAM,OAAM,KAAK,EAAS,EAAK,GAC/B,KAAM,MAAK,YAAY,KAAK,EAAK,SAC5B,EAAP,CACE,KAAM,IAAI,IAAa,uBAAuB,KAAK,UAAW,SAIhE,eAAc,EAAU,EAAK,EAAK,CAEpC,MAD6B,MAAM,MAAK,WAAW,kBAAkB,EAAU,EAAK,GAIxF,cAAc,EAAsB,CAChC,KAAK,WAAW,aAAa,GAIjC,UAAU,EAAW,EAAS,EAAa,EAAM,KAAM,CACnD,MAAO,MAAK,UAAU,OAAO,UAAU,EAAK,OAAQ,GAChD,GAAI,IAAI,KAAM,KAAK,IACZ,KAAK,WAAW,aAAa,EAAW,EAAS,EAAa,KAK7E,cAAc,EAAgB,EAAQ,EAAM,KAAM,CAC9C,MAAO,MAAK,UAAU,OAAO,UAAU,EAAK,SAAU,GAClD,GAAI,IAAI,KAAM,KAAK,IACZ,KAAK,WAAW,iBAAiB,EAAgB,EAAQ,UAKlE,0BAAyB,EAAM,KAAM,CACvC,GAAI,EAAC,KAAK,gBAGV,MAAO,MAAK,UAAU,OAAO,UAAU,EAAK,2BAA4B,GACpE,GAAI,IAAI,KAAM,KAAK,IACZ,KAAK,gBAAgB,yBAAyB,KAAK,OAAQ,QAItE,gBAAgB,OAChB,MAAO,SAAK,UAAL,cAAc,oBAAqB,KAAK,WAG/C,WAAW,CACX,MAAO,MAAK,SAAS,KAAK,YAG1B,oBAAoB,CACpB,MAAO,MAAK,SAAS,KAAK,qBAG1B,iBAAiB,CACjB,MAAO,MAAK,SAAS,KAAK,kBAG1B,oBAAoB,CACpB,MAAO,MAAK,SAAS,KAAK,uBAGxB,kBAAkB,OACpB,KAAM,GAAU,KAAK,YAAY,eACjC,GAAI,EAAS,CAIT,KAAM,GAAa,KAAM,AAHb,MAAM,MAAK,SAAS,QAAQ,CACpC,KAAK,SAAS,WAAW,kBAEA,eAAe,IAAI,KAAK,QAAS,GAC9D,MAAO,oBAAY,QAAZ,cAAmB,eAI5B,aAAY,EAAM,KAAM,CAC1B,GAAI,KAAK,UAAY,KAAK,kBACtB,MAAO,MAAM,MAAK,UAAU,OAAO,UAAU,EAAK,cAAe,KAAM,IAAO,CAC1E,EAAI,IAAI,KAAM,KAAK,IACnB,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CACzC,KAAK,SAAS,WAAW,cAE7B,GAAI,GACJ,GAAI,CACA,EAAO,KAAK,SAAS,iBAAiB,SACjC,EAAP,CACE,QAAI,QACE,EAEV,KAAM,GAAI,WACV,KAAK,SAAS,aAAa,GAC3B,KAAK,cAEL,GAAI,CACA,KAAM,GAAc,KAAM,MAAK,kBAC/B,AAAI,GACA,KAAM,MAAK,OAAO,QAAQ,KAAK,QAAS,SAAU,SAEjD,EAAP,CAEE,GAAI,EAAI,OAAS,kBACb,KAAM,MAO1B,MAAM,EAAM,KAAM,CACd,MAAO,MAAK,UAAU,OAAO,UAAU,EAAK,aAAc,KAAM,IAAO,CACnE,EAAI,IAAI,KAAM,KAAK,IACnB,KAAM,MAAK,OAAO,MAAM,KAAK,GAAI,CAAC,QAAM,aAKhD,mBAAoB,CAChB,MAAO,MAAK,WAAW,cAI3B,uBAAuB,EAAO,EAAK,CAC/B,MAAO,MAAK,SAAS,uBAAuB,EAAO,GAIvD,8BAA8B,EAAS,CACnC,KAAK,SAAS,aAAa,GAG/B,iBAAiB,EAAM,EAAU,CAC7B,MAAO,IAAI,IAAiB,CAAC,OAAM,WAAU,SAAU,KAAK,YAGhE,SAAU,CACN,MAAM,UACN,KAAK,WAAW,WCxbjB,gBAA2B,GAAS,CACvC,YAAY,EAAS,CACjB,MAAM,GAGN,KAAK,iBAAmB,EAAQ,gBAChC,KAAK,gBAAkB,EAAQ,eAC/B,KAAK,gBAAkB,EAKvB,KAAK,aAAe,KACpB,KAAK,UAAY,KAGrB,QAAS,CACL,KAAK,iBAAmB,EAG5B,SAAU,CACN,KAAK,iBAAmB,EACpB,KAAK,kBAAoB,GACzB,KAAK,wBAIP,gBAAe,EAAQ,EAAK,CAC9B,KAAM,GAAe,KAAM,GAAI,YAAY,IAAI,KAAK,GAAI,GACxD,MAAI,GACO,GAAI,GAAW,GAEf,EAAW,WAAW,KAAK,GAAI,EAAQ,aAIhD,MAAK,EAAqB,EAAK,EAAK,CACtC,KAAM,CAAC,UAAS,eAAe,EAC/B,YAAK,aAAe,EAChB,KAAK,cACL,MAAK,UAAY,KAAM,MAAK,eAAe,KAAK,aAAa,OAAQ,IAElE,MAAM,KAAK,EAAS,EAAK,QAI9B,WAAU,EAAmB,EAAc,EAAY,EAAK,EAAK,CAEnE,GADA,EAAI,IAAI,KAAM,KAAK,IACf,IAAe,QAAS,CACxB,KAAM,GAAiB,GAAgB,EAAc,KAAK,MAAM,IAChE,GAAI,GAAkB,EAAmB,CACrC,KAAM,GAAc,GAAkB,KAAK,aAC3C,GAAI,GACJ,AAAI,GACA,GAAW,KAAM,MAAK,eAAe,EAAe,OAAQ,IAEhE,KAAM,GAAc,GAAqB,KAAK,SAAS,KACvD,SAAI,oBAAoB,IAAI,CACxB,QAAS,EAAY,YACrB,gBAEG,CAAC,cAAa,WAAU,oBAEhC,AAAI,KAAe,QACtB,EAAI,oBAAoB,OAAO,KAAK,IAGxC,MAAO,GAQX,UAAU,CAAC,cAAa,cAAa,YAAW,EAAK,CACjD,EAAI,IAAI,KAAM,KAAK,IACf,GACA,KAAK,SAAS,aAAa,GAE3B,GACA,MAAK,aAAe,GAEpB,GACA,MAAK,UAAY,GAErB,KAAK,iBAGL,WAAW,OACX,MAAO,SAAK,eAAL,cAAmB,cAAe,WAGzC,WAAW,OACX,MAAO,SAAK,eAAL,cAAmB,cAAe,SAGzC,WAAW,CACX,MAAO,MAAK,aAGZ,aAAa,OACb,MAAO,QAAK,eAAL,cAAmB,OAG9B,YAAa,CACT,MAAO,GAGX,OAAO,EAAM,KAAM,CACf,MAAO,MAAK,UAAU,OAAO,UAAU,EAAK,cAAe,KAAM,IAAO,CACpE,EAAI,IAAI,KAAM,KAAK,IACnB,KAAM,MAAK,OAAO,OAAO,KAAK,GAAI,CAAC,QAAM,WACzC,KAAM,GAAa,KAAK,SAAS,WAC3B,EAAM,KAAM,MAAK,SAAS,aAAa,CACzC,EAAW,UACX,EAAW,oBACX,EAAW,YACX,EAAW,eACX,EAAW,kBACX,EAAW,kBACX,EAAW,cACX,EAAW,qBACX,EAAW,wBACX,EAAW,aAGf,EAAI,UAAU,iBAAiB,KAAK,IACpC,EAAI,oBAAoB,OAAO,KAAK,IACpC,EAAI,YAAY,iBAAiB,KAAK,IACtC,EAAI,eAAe,iBAAiB,KAAK,IACzC,EAAI,kBAAkB,iBAAiB,KAAK,IAC5C,EAAI,kBAAkB,iBAAiB,KAAK,IAC5C,EAAI,cAAc,iBAAiB,KAAK,IACxC,EAAI,qBAAqB,iBAAiB,KAAK,IAC/C,EAAI,wBAAwB,iBAAiB,KAAK,IAClD,KAAM,GAAI,WAAW,kBAAkB,KAAK,IAE5C,KAAM,GAAI,WAEV,KAAK,gBAAkB,EACvB,KAAK,mBAEL,KAAK,gBAAgB,KAAK,MAIlC,KAAK,EAAM,KAAM,CACb,MAAO,MAAK,UAAU,OAAO,UAAU,EAAK,uBAAwB,KAAM,IAAO,CAC7E,KAAM,MAAK,OAAO,KAAK,KAAK,GAAI,CAAC,QAAM,cAKnD,YAAyB,EAAc,EAAW,SAC9C,KAAM,GAAY,GAAkB,EAAc,CAAC,EAAW,IACtD,GAAM,OAASH,GAEX,EAAM,YAAc,GAAa,EAAM,SAAW,EAAM,WACxD,GAAY,GAGb,GACR,MACH,GAAI,EACA,MAAO,CAEH,WAAY,KAAU,UAAV,cAAmB,WAC/B,OAAQ,KAAU,UAAV,cAAmB,OAC3B,OAAQ,EAAU,0BC1KK,EAAmB,EAAsB,EAAmC,MACrG,GAAW,KAAM,SAAQ,IAAI,EAAQ,IAAI,KAAM,IAAU,MACrD,GAAW,KAAM,GAAM,QAAQ,EAAQ,CAAC,QAAM,iBAC7C,IAAI,IAAQ,EAAQ,EAAS,YAAuB,EAAS,wBAE/D,KAAK,CAAC,EAAG,IAAM,EAAE,KAAK,cAAc,EAAE,OACxC,UAU8B,CACrC,YACoB,EACA,EACA,EAClB,sDAEE,OAAO,OAAS,MAAK,aAAe,KAAK,gBAGF,CAC3C,YAA4B,EAAgB,kBACxC,cAAc,KACd,OAAO,OAAS,MAAK,UACrB,YAAY,GCiBpB,YAAkC,EAAyB,QAC/C,OACC,GAAS,kBACT,GAAS,cACH,OACN,GAAS,aACH,IAInB,YAAuB,EAAwB,QACnC,OACC,GAAS,oBACH,2BACN,GAAS,cACH,mBACN,GAAS,aACH,+BAImB,GAA8B,CAShE,YACoB,EACC,EACA,EACD,EACA,EAChB,EACF,sHAd4B,qBAKP,QAWd,YAAc,EAAQ,cAAgB,OAAY,GAAyB,EAAQ,MAAQ,EAAQ,YACpG,EAAQ,UACH,gBAAkB,EAAQ,SAC5B,MACG,GAAc,CAChB,UAAW,EACX,YAAc,MAAQ,UAAR,cAAiB,SAAU,GAEvC,KAA0B,SAAW,IAAI,IAAI,GAAU,GAAI,IAAc,SAC1E,gBAAkB,GAAkB,EAAgB,EAAa,SAKxE,QAAO,EAAsB,EAA8B,IACzD,IACI,MACA,KAAK,QAAQ,OAAQ,MACf,CAAC,UAAU,KAAK,QAChB,EAAa,GAAI,IAAiB,CAAC,SAAU,EAAO,KAAM,KAAM,EAAO,KAAM,SAAU,KAAK,gBAC5F,GAAW,OAAO,EAAO,IAAM,GAAI,KACpB,CACjB,KAAM,EAAO,QAEN,eAAe,MAAO,QAE/B,GAAmC,CACrC,UAAW,KAAK,QAAQ,OAAS,EAAS,cAC1C,OAAQ,GAAc,KAAK,QAAQ,MACnC,cAAe,IAEf,KAAK,QAAQ,SACC,KAAO,KAAK,QAAQ,MAElC,KAAK,QAAQ,UACC,MAAQ,KAAK,QAAQ,OAEnC,KAAK,QAAQ,YACC,OAAS,KAAK,QAAQ,SAEpC,KAAK,QAAQ,UACC,gBAAkB,KAAK,QAAQ,OAE7C,KAAK,QAAQ,uBAAyB,OACxB,iBAAmB,CAC7B,aAAc,KAGlB,KAAK,eACS,cAAc,KAAK,MAEjC,KACc,cAAc,KAAK,CAC7B,KAAM,gBACN,UAAW,GACX,QAAS,SAGX,GAAW,KAAM,GAAM,WAAW,EAAe,CAAC,QAAM,gBACzD,QAAU,EAAS,cACnB,QACA,OAAS,OAEb,kBASH,cAAa,EAAsB,EAA8B,IAC/D,IAEI,CAAC,KAAK,QAAQ,MAAQ,KAAK,QAAQ,QAAS,MACvC,SAAW,KAAM,IAAa,KAAK,QAAQ,QAAS,EAAO,QAC1D,GAAc,CAChB,UAAW,EACX,YAAa,KAAK,QAAQ,QAAQ,aAEjC,gBAAkB,GAAkB,KAAK,SAAU,EAAa,QAChE,sBAKT,WAAW,EAAiB,MAC3B,eAAe,KAAM,QACrB,KAAK,aAGV,gBAAwB,iBAAS,cAAK,QAAQ,UAAb,cAAuB,KAAvB,OAA6B,KAAK,UAAlC,OAA6C,KAAK,MACnF,YAAgC,eAAS,WAAK,WAAL,cAAgB,KAAhB,cAAoB,aAC7D,gBAAoC,eAAS,WAAK,QAAQ,SAAb,cAAqB,OAArB,cAA2B,OACxE,SAA6B,OAAS,MAAK,WAC3C,OAAO,OAAS,MAAK,mBACrB,iBAA0B,OAAS,MACnC,QAA2B,OAAS,MAAK,OAE7C,QAAS,CACA,KAAK,oBACD,eACA,aAAe,QACf,WAAW,mBAIpB,cAAc,OAAS,MAAK,aAGhC,SAAU,CACF,KAAK,QAAQ,aACR,QAAQ,OAAO,KAAK,eAI3B,gCAA+B,EAAY,EAAkB,EAAsB,EAA8B,IAC/G,CAAC,KAAK,QAAQ,SAAW,KAAK,QAAQ,OAAS,EAAS,0BAGtD,GAAS,KAAK,QAAQ,QAAQ,GAC9B,EAAc,gBACd,GAAI,KAAK,OAAS,EAAa,KAAM,IAAO,IAC1C,MACM,GAAM,KAAM,GAAQ,aAAa,CAAC,EAAQ,WAAW,iBACvD,MACA,GACW,KAAM,GAAI,YAAY,IAAI,GAChC,MACU,CAAC,KAAM,EAAa,QAAS,UAEtC,GAAM,EAAS,WACjB,GAAY,EAAI,GACf,MACG,GAAU,EAAY,MAGpB,KAAK,KAAK,WAChB,YAAY,IAAI,QACd,GAAI,iBACL,WACD,QACE,OAEJ,GAAM,eAAe,EAAK,GAAI,EAAa,EAAS,QAAS,CAAC,QAAM,iBACrE,KAED,MAAM,OCxOnB,gBAAqB,GAAa,CACrC,YAAY,CAAC,SAAQ,OAAM,QAAO,kBAAiB,uBAAsB,uBAAsB,YAAW,CACtG,QACA,KAAK,QAAU,EACf,KAAK,MAAQ,EACb,KAAK,OAAS,EACd,KAAK,sBAAwB,EAC7B,KAAK,sBAAwB,EAC7B,KAAK,iBAAmB,EACxB,KAAK,UAAY,EACjB,KAAK,YAAc,KACnB,KAAK,WAAa,GAClB,KAAK,WAAa,GAClB,KAAK,UAAY,GACjB,KAAK,UAAY,MAGjB,WAAW,CACX,MAAO,MAGP,KAAK,CACL,MAAO,MAAK,WAGZ,OAAO,CACP,MAAO,MAAK,YAAY,MAAQ,KAAK,YAAY,kBAGjD,kBAAkB,CAClB,MAAO,MAAK,YAAY,mBAGxB,YAAY,CACZ,MAAO,MAAK,YAAY,aAIxB,gBAAgB,CAChB,MAAO,MAAK,YAAY,eAAiB,KAAK,MAG9C,YAAY,CACZ,MAAO,MAAK,YAAY,aAGxB,cAAc,CACd,MAAO,MAAK,YAAY,eAGxB,UAAU,CACV,MAAO,MAAK,SAGhB,yBAAyB,EAAQ,CAC7B,MAAO,MAAK,iBAAmB,KAAK,SAAS,SAAW,KAGxD,WAAW,CACX,MAAO,MAAK,YAAY,WAAa,YAGrC,iBAAiB,CACjB,MAAO,MAAK,YAAY,oBAGtB,QAAO,EAAM,KAAM,CACrB,KAAM,MAAK,UAAU,OAAO,UAAU,EAAK,eAAgB,KAAM,IAAO,CACpE,KAAK,WAAa,GAClB,KAAK,YAAY,aACjB,KAAM,MAAK,OAAO,KAAK,KAAK,QAAS,CAAC,QAAM,kBAI9C,QAAO,EAAM,KAAM,CACrB,KAAM,MAAK,UAAU,OAAO,UAAU,EAAK,eAAgB,KAAM,IAAO,CACpE,KAAK,WAAa,GAClB,KAAK,YAAY,aACjB,KAAM,MAAK,OAAO,MAAM,KAAK,QAAS,CAAC,QAAM,gBAIjD,YAAY,CACZ,MAAO,MAAK,cAGZ,WAAW,CACX,MAAO,MAAK,aAGZ,YAAY,CACZ,MAAO,MAAK,cAGZ,WAAW,CACX,MAAO,MAAK,aAGZ,kBAAkB,CAClB,MAAO,MAAK,iBAGhB,YAAY,EAAQ,CAChB,KAAK,KAAK,UACV,KAAK,sBAAsB,KAAM,GAGrC,KAAK,EAAY,EAAK,CAClB,EAAI,IAAI,KAAM,KAAK,IACnB,KAAK,YAAc,EACnB,KAAK,SAAW,EAAW,QAAU,GAAI,GAAW,EAAW,SAAW,UAGxE,WAAU,EAAY,EAAc,EAAK,EAAK,OAChD,GAAI,IAAe,SAAU,CACzB,EAAI,IAAI,KAAM,KAAK,IACnB,EAAI,IAAI,MAAO,IACf,KAAM,GAAc,KAAa,eAAb,cAA8B,OAClD,GAAI,CAAC,MAAM,QAAQ,GACf,MAAO,MAEX,KAAM,GAAc,KAAK,mBAAmB,GAC5C,GAAI,GACJ,AAAI,CAAC,EAAY,MAAQ,CAAC,EAAY,gBAClC,GAAS,KAAM,MAAK,cAAc,EAAa,IAEnD,KAAM,GAAW,KAAK,aAAa,GACnC,GAAI,CAAC,EACD,MAAO,MAEX,KAAM,GAAU,KAAK,YAAY,EAAU,GACrC,EAAa,KAAK,YAAY,EAAa,EAAU,EAAS,EAAa,GACjF,SAAI,QAAQ,IAAI,GACT,CAAC,aAAY,eAEpB,UAAI,IAAI,KAAM,KAAK,IACnB,EAAI,IAAI,aAAc,GACtB,EAAI,QAAQ,OAAO,KAAK,IACjB,CAAC,QAAS,GAAM,cAI/B,UAAU,EAAS,EAAK,CACpB,EAAI,IAAI,KAAM,KAAK,IACf,GACA,CAAI,EAAQ,QACR,MAAK,WAAa,GAClB,KAAK,WAAa,GAClB,AAAI,EAAQ,aAAe,OACvB,KAAK,UAAY,GAEjB,KAAK,UAAY,GAErB,KAAK,KAAK,WAGV,MAAK,YAAc,EAAQ,WAC3B,KAAK,SAAW,EAAQ,UAKpC,YAAY,EAAa,EAAU,EAAS,EAAa,EAAQ,CAC7D,KAAM,GAAO,EAAS,EAAO,SAAW,EAAY,KAC9C,EAAY,EAAS,EAAO,cAAgB,EAAY,UACxD,EAAgB,kBAAQ,oBAAqB,KAAK,GACxD,MAAO,CACH,OAAQ,KAAK,GACb,YAAa,CAAC,CAAC,EAAY,WAC3B,gBAAiB,EAAY,gBAE7B,OACA,YACA,gBACA,eAAgB,EAAY,eAC5B,UAAW,KAAK,UAAU,MAAM,MAChC,SAAU,KAAK,aAAa,GAC5B,QAAS,iBAAS,aAI1B,mBAAmB,EAAa,CAC5B,MAAO,GAAY,OAAO,CAAC,EAAM,IAAU,GAAkB,EAAM,EAAO,KAAK,MAAM,IAAK,GAAI,IAAY,KAAM,KAAK,UAGnH,eAAc,EAAa,EAAK,CAClC,KAAM,GAAU,EAAY,OAAO,GAAK,EAAE,OAASA,GAC7C,EAAe,EAAQ,OAAO,GAAK,EAAE,YAAc,KAAK,MAAM,IAC9D,EAAgB,EAAa,OAAO,CAAC,EAAK,IAAM,CAClD,KAAM,GAAS,EAAW,gBAAgB,KAAK,GAAI,GACnD,SAAI,IAAI,EAAO,OAAQ,GAAI,IAAa,EAAQ,OACzC,GACR,GAAI,MACD,EAAe,EAAa,IAAI,GAAK,EAAE,WACvC,EAAS,GAAI,IAAO,KAAK,IACzB,EAAU,KAAM,GAAO,iBAAiB,EAAc,EAAe,MAGrE,EAAe,GAAI,IAAY,KAAM,KAAK,IAChD,SAAa,UAAY,EAAQ,OAAO,CAAC,EAAK,WAAM,SAAO,OAAE,UAAF,cAAW,cAAe,OAAS,EAAI,IAAI,GACtG,EAAa,YAAc,EAAQ,OAAO,CAAC,EAAK,WAAM,SAAO,OAAE,UAAF,cAAW,cAAe,SAAW,EAAI,IAAI,GAC1G,EAAO,aAAa,EAAS,EAAc,GACpC,EAGX,aAAa,EAAa,CACtB,MAAO,GAAY,KAAK,GAAK,EAAE,OAASA,GAAqB,EAAE,YAAc,KAAK,MAAM,IAG5F,YAAY,EAAU,EAAa,CAC/B,KAAM,GAAqB,EAAY,KAAK,GAAK,EAAE,OAASA,GAAqB,EAAE,YAAc,EAAS,QAC1G,GAAI,EACA,MAAO,GAAW,gBAAgB,KAAK,GAAI,GAInD,aAAa,EAAa,OACtB,KAAM,GAAQ,EAAY,KAAK,GAAK,EAAE,OAAS,qBAC/C,MAAI,GACO,KAAM,UAAN,cAAe,UAEnB,cC5MK,CAGhB,YAAY,EAAiC,MACpC,aAAe,QAGjB,YAAW,EAAc,EAAe,EAAiB,EAA2B,OAChF,IAAI,IAAO,CACd,KAAM,OACN,OAAQ,GACR,KAAM,OAAO,OAAO,GAAI,EAAM,CAAC,IAAK,EAAO,4BAC3C,UACA,OAAQ,EACR,iBAAkB,WAClB,oBAAqB,WACrB,KAAM,aAIP,sBAAqB,EAAyC,OAC1D,CAAC,WAAY,QAGlB,QAAO,EAAsB,EAA8B,IACzD,GACI,IAAI,WAAY,GAAI,KAAI,KAAK,aAAa,KAAK,UAAW,cAE1D,IAAI,WAAY,WAElB,GAAM,UAAU,KAAK,aAAc,CAAC,QAAM,gBAG9C,SAAQ,EAAsB,EAA8B,MACxD,GAAoB,OAAO,OAAO,GAAI,KAAK,aAAc,CAAC,KAAM,YAChE,GAAM,UAAU,EAAmB,CAAC,QAAM,WAGpD,WAAgC,OACrB,MAAK,aAGhB,OAAO,EAAiB,OAChB,MAAK,aAAa,SAAW,EAAO,aAAa,QAGjD,KAAK,aAAa,UAAY,EAAO,aAAa,QAC3C,GAEJ,KAAK,UAAU,KAAK,aAAa,QAAU,KAAK,UAAU,EAAO,aAAa,mBCvE/D,EAAY,EAAgC,OAC/D,IAA8B,EAAO,EACxC,IAAc,GACd,CAAC,EAAO,IAAU,EAAM,KAAK,gBAIO,EAAY,EAAmB,EAA6B,EAA4C,OACzI,GAAM,OAAO,CAAC,EAAK,IAAU,MAC1B,GAAM,EAAQ,MAChB,GAAa,EAAI,IAAI,SACpB,OACY,MACT,IAAI,EAAK,MAED,EAAY,GACrB,GACR,GAAI,kBAGgB,EAAa,EAA2D,OACxF,GAAO,OAAO,CAAC,EAAQ,IAAU,MAC9B,GAAc,EAAO,SACtB,GAAO,KAGD,IAAgB,IAFhB,GAAe,EAInB,GACR,IC1BA,QAA2B,CAC9B,YAAY,CAAC,WAAU,CACnB,KAAK,SAAW,EAChB,KAAK,eAAiB,KACtB,KAAK,kBAAoB,KAG7B,iBAAiB,CAAC,gBAAe,oBAAmB,CAChD,KAAK,eAAiB,EACtB,KAAK,kBAAoB,EAG7B,eAAe,EAAgB,OAC3B,MAAO,QAAK,iBAAL,cAAqB,qBAAqB,QAG/C,aAAY,EAAgB,EAAM,EAAK,EAAK,CAC9C,EAAI,IAAI,eAAgB,GAAQ,EAAgB,GAAK,EAAE,OACvD,KAAM,GAAkB,EAAe,OAAO,GAAK,EAAE,OAAS,oBAC9D,GAAI,CAAC,KAAK,eAAgB,CACtB,EAAI,IAAI,wCAAyC,EAAI,MAAM,MAC3D,OAGJ,KAAM,GAAY,EAAgB,OAAO,UAAK,YAAE,UAAF,cAAW,aAAc,KACvE,GAAI,EAAU,OAAQ,CAClB,KAAM,GAAoB,KAAM,MAAK,eAAe,WAAW,EAAW,EAAM,GAChF,EAAI,IAAI,iBAAkB,GAAQ,EAAkB,QAAS,UAAK,WAAE,QAAF,cAAS,QAC3E,SAAW,KAAO,GAAkB,OAChC,EAAI,MAAM,iBAAiB,MAAM,GAErC,KAAM,GAAc,KAAK,kBAAkB,2BAA2B,EAAkB,QAAS,GACjG,MAAO,IAAI,IAAgB,EAAmB,SAKhD,WAAU,EAAM,EAAK,CAEvB,SAAK,kBAAkB,MAAM,GAEtB,AADgB,MAAM,SAAQ,IAAI,EAAK,YAAY,IAAI,GAAO,KAAK,kBAAkB,aAAa,EAAK,MACxF,KAAK,GAAY,CAAC,CAAC,IAIjD,QAAsB,CAClB,YAAY,EAAmB,EAAa,CACxC,KAAK,kBAAoB,EACzB,KAAK,YAAc,EACnB,KAAK,cAAgB,GAAQ,EAAa,GAAK,EAAE,SChDzD,KAAM,IAAsB,EAA0B,aAChD,GAA8B,EAA0B,wBACxD,GAA+B,EAA0B,iBAE/D,kBAAqC,EAAS,EAAW,EAAuB,EAAgB,EAAS,CACrG,KAAM,GAAiB,EAAQ,OAAO,GAChC,EAAM,KAAM,GAAQ,aAAa,CACnC,EAAQ,WAAW,UAEvB,GAAI,CAGA,EAAI,QAAQ,IAAI,GAAqB,GACrC,EAAI,QAAQ,IAAI,GAA6B,GAC7C,EAAI,QAAQ,IAAI,GAA8B,SACzC,EAAP,CACE,QAAI,QACE,EAEV,KAAM,GAAI,WAGP,QAAc,aACJ,MAAK,CAAC,MAAK,YAAW,QAAO,SAAQ,WAAU,YAAW,OAAM,CACzE,KAAM,GAAiB,KAAM,GAAI,QAAQ,IAAI,IAC7C,GAAI,EAAgB,CAChB,KAAM,GAAU,GAAI,GAAI,QAClB,EAAwB,KAAM,GAAI,QAAQ,IAAI,IACpD,EAAQ,SAAS,EAAW,GAC5B,KAAM,GAAiB,KAAM,GAAI,QAAQ,IAAI,IAC7C,MAAO,IAAI,IAAQ,CAAC,YAAW,QAAO,UAAS,SAC3C,WAAU,wBAAuB,iBAAgB,MAAK,2BAIrD,uBAAsB,CAAC,MAAK,mBAAkB,YAAW,QAAO,SAAQ,YAAW,WAAU,CACtG,KAAM,GAAU,EAAiB,2BAC3B,EAAc,KAAK,MAAM,EAAQ,iBAGjC,EAAiB,AADI,OAAO,QAAQ,EAAY,YACZ,OACpC,EAAwB,GAC9B,YAAM,IAAsB,EAAS,EAAW,EAAuB,EAAgB,GAChF,GAAI,IAAQ,CACf,YAAW,QAAO,UAAS,SAC3B,SAAU,EAAiB,SAC3B,wBAAuB,iBAAgB,MAAK,0BAIvC,QAAO,CAAC,MAAK,YAAW,QAAO,SAAQ,WAAU,YAAW,WAAU,CAC/E,KAAM,GAAU,GAAI,GAAI,QACxB,AAAI,EACA,KAAM,GAAU,qBAAqB,EAAS,EAAQ,+BAEtD,GAAQ,SACR,EAAQ,uBAAuB,EAAQ,gCAE3C,KAAM,GAAwB,GACxB,EAAiB,EACvB,MAAI,IACA,KAAM,IAAsB,EAAS,EAAW,EAAuB,EAAgB,GAEpF,GAAI,IAAQ,CAAC,YAAW,QAAO,UAAS,SAC3C,WAAU,wBAAuB,iBAAgB,MAAK,cAG9D,YAAY,CAAC,YAAW,QAAO,UAAS,SAAQ,WAAU,wBAAuB,iBAAgB,MAAK,aAAY,CAC9G,KAAK,KAAO,EACZ,KAAK,WAAa,EAClB,KAAK,OAAS,EACd,KAAK,SAAW,EAChB,KAAK,QAAU,EACf,KAAK,UAAY,EACjB,KAAK,uBAAyB,EAC9B,KAAK,gBAAkB,EACvB,KAAK,WAAa,EAClB,KAAK,cAAgB,KAAK,MAAM,KAAK,SAAS,oBAG9C,eAAe,CACf,MAAO,MAAK,cAGhB,YAAY,EAAU,CAClB,KAAK,UAAY,OAGf,YAAW,EAAS,EAAoB,EAAK,OAC/C,KAAM,GAAc,KAAK,MAAM,KAAK,SAAS,iBAEvC,EAAqB,OAAO,QAAQ,EAAY,YACtD,GAAI,EAAmB,QAAU,CAAC,KAAK,uBAAwB,CAC3D,KAAM,GAAU,GAChB,GAAI,CAAC,KAAK,uBAAwB,CAC9B,EAAI,IAAI,WAAY,IACpB,KAAM,GAAe,KAAK,MAAM,KAAK,SAAS,iBAC9C,EAAQ,YAAc,KAAK,mBAAmB,GAElD,AAAI,EAAmB,QACnB,GAAI,IAAI,OAAQ,IAChB,EAAQ,cAAgB,KAAK,oBAAoB,IAErD,KAAM,GAAqB,EAAqB,KAAK,UAAY,OAC3D,EAAW,KAAM,MAAK,OAAO,WAAW,EAAoB,EAAS,CAAC,QAAM,WAClF,KAAK,gBAAkB,oBAAU,sBAAV,cAA+B,kBACtD,EAAI,IAAI,iBAAkB,KAAK,iBAK/B,KAAM,MAAK,sBAAsB,EAAS,GAAgB,CACtD,AAAI,EAAmB,QACnB,MAAK,SAAS,yBACd,WAAc,IAAI,GAAqB,KAAK,SAAS,OAAO,KAAK,aACjE,WAAc,IAAI,GAA8B,KAAK,kBAEpD,KAAK,wBACN,MAAK,uBAAyB,GAC9B,WAAc,IAAI,GAA6B,KAAK,iCAM9D,sBAAqB,EAAS,EAAK,CAcrC,KAAM,GAAU,KAAK,SAAS,8BAOxB,EAAW,KAAK,MAAM,EAAU,GAEtC,GAAI,KAAK,gBAAkB,EAAU,CACjC,KAAM,GAAc,KAAK,MAAM,KAAK,SAAS,iBAEvC,EAAsB,AADD,OAAO,QAAQ,EAAY,YACP,OAKzC,EAAc,EAAW,EAAsB,KAAK,gBAC1D,MAAI,GAAc,GACd,KAAM,GAAI,KAAK,gBAAiB,GAAO,CACnC,EAAI,IAAI,MAAO,GACf,EAAI,IAAI,SAAU,KAAK,iBACvB,EAAI,IAAI,cAAe,GACvB,EAAI,IAAI,MAAO,GACf,EAAI,IAAI,QAAS,GACjB,KAAK,SAAS,uBAAuB,GACrC,KAAK,sBAAsB,EAAS,GAAgB,CAChD,EAAa,IAAI,GAAqB,KAAK,SAAS,OAAO,KAAK,iBAKrE,GAEX,MAAO,GAGX,wBAAwB,EAAW,EAAM,CACrC,KAAM,GAAa,GAAI,MAAK,KAAK,QACjC,GAAI,CACA,SAAW,oBAAoB,KAAK,SAAU,EAAW,GAClD,QACF,EAAP,CACE,QAAW,OACL,QAIR,0BAAyB,EAAkB,EAAiB,CAC9D,KAAM,GAAa,GAAI,MAAK,KAAK,QACjC,GAAI,CACA,MAAI,MAAK,WACL,KAAM,MAAK,WAAW,yBAAyB,KAAK,SAAU,EAAY,EAAkB,GAE5F,EAAW,gBAAgB,KAAK,SAAU,EAAkB,GAEzD,QACF,EAAP,CACE,QAAW,OACL,GAId,sBAAsB,EAAS,EAAK,CAKhC,KAAK,SAAS,qBAAqB,GACnC,EAAI,QAAQ,IAAI,GAAqB,KAAK,SAAS,OAAO,KAAK,aAGnE,UAAU,EAAwB,EAAK,EAAK,CAExC,KAAM,GAAW,EAAuB,kBACxC,GAAI,OAAO,cAAc,IAAa,IAAa,KAAK,gBACpD,SAAI,QAAQ,IAAI,GAA8B,GAC9C,EAAI,IAAI,WAAY,GACb,EAIf,UAAU,EAAU,CAEhB,AAAI,OAAO,cAAc,IACrB,MAAK,gBAAkB,GAI/B,mBAAmB,EAAc,CAC7B,KAAM,GAAM,CACR,QAAS,KAAK,QACd,UAAW,KAAK,UAChB,WAAY,CAAC,GAAe,GAC5B,KAAM,IAEV,SAAW,CAAC,EAAW,IAAW,QAAO,QAAQ,GAC7C,EAAI,KAAK,GAAG,KAAa,KAAK,aAAe,EAEjD,YAAK,WAAW,GACT,EAGX,oBAAoB,EAAoB,CACpC,KAAM,GAAM,GACZ,SAAW,CAAC,EAAO,IAAW,GAAoB,CAC9C,KAAM,GAAS,CACX,IAAK,GAET,KAAK,WAAW,GAChB,EAAI,qBAAqB,KAAW,EAExC,MAAO,QAGL,uBAAsB,EAAS,EAAU,CAC3C,GAAI,EAAS,CACT,KAAM,GAAM,KAAM,GAAQ,aAAa,CACnC,EAAQ,WAAW,UAEvB,GAAI,CACA,KAAM,GAAS,EAAI,eACd,EAAP,CACE,QAAI,QACE,EAEV,KAAM,GAAI,eAEV,MAAM,GAAS,QAIvB,WAAW,EAAK,CACZ,KAAM,GAAO,EAAI,YAAc,GACzB,EAAW,EAAI,SAErB,MAAO,GAAI,WACX,MAAO,GAAI,SAEX,EAAK,KAAK,SAAW,EAAK,KAAK,UAAY,GAC3C,EAAK,KAAK,SAAS,WAAa,KAAK,WACjC,KAAK,SAAS,KAAKL,GAAY,UAAU,IAC7C,EAAI,WAAa,EACb,IAAa,QACb,GAAI,SAAW,GAIvB,cAAc,EAAK,CACf,MAAO,MAAK,SAAS,OAAO,GAGhC,SAAU,CACN,KAAK,SAAS,OACd,KAAK,SAAW,gBC3RI,CAIxB,YAAY,EAAY,EAAoC,MACnD,IAAM,OACN,gBAAkB,KAGvB,KAAa,OACN,MAAK,OAGZ,mBAAqD,aAC9C,QAAK,kBAAL,cAAsB,cAG7B,YAAoB,aACb,QAAK,kBAAL,cAAsB,eAG3B,cAAa,EAAU,EAAsC,IAC3D,KAAK,YAAc,oCAAqC,MAClD,GAAK,KAAK,mBACZ,EAAG,IAAK,MACF,GAAW,KAAM,IAAgB,EAAI,UAAW,EAAG,GAAI,SACtD,GAAG,MAAQ,UACX,EAAG,WAAY,MAChB,GAAU,EAAI,YAAY,sBAC3B,GAAQ,WAGN,EAAG,WAAW,YAAc,EAAQ,WAAW,WAClD,EAAG,WAAW,aAAe,EAAQ,WAAW,YAChD,EAAG,WAAW,OAAS,EAAQ,WAAW,KAJnC,UAOZ,YAIE,CAIb,YAAY,EAAgC,EAAuB,MAC1D,gBAAkB,OAClB,WAAa,EAGtB,gBAAgB,EAAkC,OACvC,IAAI,IAAI,EAAa,KAAK,eAGjC,cAA8B,OACvB,MAAK,mBAGZ,KAAa,OACN,MAAK,gBAAgB,MAG5B,YAAwB,OACjB,MAAK,cAGZ,YAAoB,OACb,MAAK,gBAAgB,WAIpC,kBAA+B,EAAmB,EAAe,EAAqC,MAC5F,CAAC,SAAQ,YAAY,EACrB,CAAC,OAAM,UAAU,EACjB,CAAC,SAAQ,MAAK,QAAQ,EAEtB,EAAK,EAAO,OAAO,GAGnB,EAAW,GAAI,YAAW,GAC1B,EAAW,mEAEX,EAAO,EAAK,OAAO,IACnB,EAAU,KAAM,GAAO,KAAK,EAAK,EAAU,EAAM,UAAW,KAC5D,EAAS,EAAQ,MAAM,EAAG,IAC1B,EAAU,EAAQ,MAAM,IACxB,EAAa,KAAM,GAAI,WAAW,CAAC,IAAK,EAAQ,KAAI,KAAM,EAAK,OAAO,KACtE,EAAM,KAAM,GAAK,QAAQ,EAAS,EAAY,iBAE7C,GAAO,OAAO,GCnGzB,KAAM,IAAqB,IACrB,GAAkB,sBAQgB,EAAgC,EAAoB,EAAkC,MACpH,CAAC,oBAAoB,KACvB,CAAC,OACK,IAAI,OAAM,2BAEhB,EAAiB,YAAc,gBACzB,IAAI,OAAM,qCAAqC,EAAiB,kBAEpE,CAAC,QAAQ,EAAS,SAClB,EAAU,KAAM,GAAS,OAAO,OAAO,OACzC,EAAK,OAAO,GACZ,EAAiB,YAAc,GAE/B,EAAK,OAAO,EAAiB,MAC7B,UACA,EAAiB,MAAQ,UACtB,IAAI,IAAI,EAAgB,GCxBnC,KAAM,IAA0B,CAAC,IAAM,eAQJ,EAAgC,EAAqB,EAAU,EAAyB,MACjH,GAAS,EAAS,SAAS,OAAO,OAAO,EAAY,QAAQ,KAAM,QAErE,GAAS,WACF,KAAK,MACF,KAEV,IAAW,OACL,IAAI,OAAM,2BAGX,GAAI,EAAG,EAAI,GAAwB,OAAQ,EAAE,KAC9C,EAAO,KAAO,GAAwB,QAChC,IAAI,OAAM,uBAKpB,EAAO,SACP,GAAwB,OAAS,EAAI,mBAAqB,OAEpD,IAAI,OAAM,yBAGd,GAAU,WAAW,KAAK,EAAO,MACnC,GAAwB,OACxB,GAAwB,OAAS,EAAI,2BAGlC,IAAI,IAAI,EAAgB,GC9BnC,KAAM,IAAW,GAAG,WACd,GAAoB,GAAG,uBAEjB,IAAL,UAAK,EAAL,mEAAK,aAKZ,kBAAyC,EAAuD,YACtF,GAAM,KAAM,GAAQ,QAAQ,CAC9B,EAAQ,WAAW,cAEjB,EAAkB,KAAM,GAAI,YAAY,IAAI,gCAC5C,EAAK,oBAAiB,UAAjB,cAA0B,OACjC,CAAC,cAGC,GAAiB,KAAM,GAAI,YAAY,IAAI,wBAAwB,QACrE,EAAC,QAGE,IAAI,IAAe,EAAI,EAAe,2BAGlB,EAAU,EAA0B,EAA+C,MACxG,GAAsC,KAAM,GAAI,QAAQ,IAAI,aAC9D,QAAQ,IAAI,GAAmB,KAC/B,QAAQ,IAAI,GAAU,CAAC,GAAI,EAAI,GAAI,UAAW,EAAI,YAC/C,oBAGmB,EAA4C,MAChE,GAAU,KAAM,GAAI,QAAQ,IAAI,OAClC,CAAC,cAGC,GAAiB,KAAM,GAAI,YAAY,IAAI,wBAAwB,EAAQ,SAC7E,QACO,IAAI,IAAI,GAAI,IAAe,EAAQ,GAAI,EAAe,SAAgC,EAAQ,6BAK7E,EAAiC,GACzD,QAAQ,OAAO,sBAGiB,EAAe,EAAoB,EAAkB,EAAoB,EAAwB,MAC/H,GAAiB,KAAM,IAA0B,MACnD,CAAC,OACK,IAAI,OAAM,qEAEb,MAAM,IAAgC,EAAM,EAAY,EAAgB,EAAU,qBAGvC,EAAe,EAAoB,EAAgC,EAAoB,EAAwB,IAC7J,MACA,IAAS,IACH,KAAM,IAAkB,EAAgB,EAAY,WACnD,IAAS,IACV,GAAmB,EAAgB,EAAY,EAAK,aAEpD,IAAI,OAAM,iBAAiB,WAE9B,qBAGsC,EAAU,EAAkB,EAA8C,MACjH,GAAiB,KAAM,IAA0B,MACnD,KAAM,kBAAgB,aAAa,EAAK,UACjC,GAAI,gBAAgB,GClFnC,KAAM,IAAsC,0CAIrC,kBAAmC,EAAO,EAAK,EAAU,EAAK,CACjE,GAAI,CACA,KAAM,GAAW,KAAM,GAAM,oBAAoB,CAAC,QAAM,WACxD,GAAI,EAAS,YAAY,YAAc,GACnC,MAAO,IAAI,IAA0B,EAAU,EAAK,SAEnD,EAAP,CACE,AAAI,EAAI,OAAS,mBACb,GAAI,MAAQ,GAEhB,QAID,kBAA+C,EAAS,EAAO,EAAK,EAAmB,EAAK,OAS/F,KAAM,GAAW,AARA,MAAM,GAAM,uBAAuB,CAChD,YAAa,CACT,UAAW,GACX,QAAS,EAAQ,cAAc,EAAI,UAAU,SAC7C,WAAY,MAAI,cAAJ,cAAiB,mBAAoB,IAErD,4BAA6B,IAC9B,YACuB,UAC1B,SAAQ,YAAY,GACpB,KAAM,GAAQ,WAAW,OAAW,GAAM,GACnC,EAGX,QAAgC,CAC5B,YAAY,EAAkB,EAAK,EAAU,CACzC,KAAK,kBAAoB,EACzB,KAAK,KAAO,EACZ,KAAK,UAAY,OAGf,SAAQ,EAAS,EAAY,CAC/B,KAAM,GAAiB,GAAI,IAAe,oBAAqB,KAAK,kBAAkB,YAAY,YAC5F,EAAM,KAAM,IAAgC,EAAS,EAAY,EAAgB,KAAK,UAAW,KAAK,MACtG,EAAU,GAAI,MAAK,KAAK,QAC9B,GAAI,CACA,KAAM,GAAiB,KAAK,kBAAkB,YAAY,QAC1D,SAAQ,SAAS,EAAI,UAAU,QAAS,GACjC,GAAI,IAAiB,KAAK,kBAAmB,EAAS,SACxD,EAAP,CAEE,GADA,EAAQ,OACJ,EAAI,UAAY,sBAChB,OAEA,KAAM,OAKd,WAAW,CACX,MAAO,MAAK,kBAAkB,WAItC,QAAuB,CACnB,YAAY,EAAkB,EAAS,EAAK,CACxC,KAAK,kBAAoB,EACzB,KAAK,SAAW,EAChB,KAAK,KAAO,OAGV,OAAM,EAAO,EAAK,CACpB,GAAI,CAEA,MAAO,AADU,MAAM,GAAM,sBAAsB,KAAK,SAAU,CAAC,QAAM,YACzD,aAClB,CACE,MAAO,IAKf,0BAA2B,CACvB,KAAM,GAAU,KAAK,SACrB,YAAK,SAAW,OACT,KAGP,WAAW,CACX,MAAO,MAAK,kBAAkB,aAG9B,MAAM,CACN,MAAO,MAAK,KAGhB,SAAU,OACN,QAAK,WAAL,QAAe,OACf,KAAK,SAAW,gBChGN,CAId,SAAmB,OACV,MAAK,SAMH,SALE,SAAW,GAAI,SAAQ,GAAW,MAC9B,SAAW,IAEb,SAKT,OAAsB,MAClB,CAAC,KAAK,gBACF,MAAK,cAIf,UAAmB,OACZ,CAAC,CAAC,KAAK,SAGlB,SAAgB,IACR,KAAK,SAAU,MACV,SAAW,YACV,GAAU,KAAK,cAChB,SAAW,YAKxB,UAAsC,OAC3B,MAAK,kBAIG,CAEnB,YAA4B,EAAe,cAG3C,SAAgB,UACD,KAAQ,MAAK,QACf,WC7CV,YAA4B,EAAY,EAAW,EAAW,EAAW,CAC5E,MAAO,CACH,QAAS,EAAW,OAAO,GAC3B,UAAW,EAAW,aACtB,YACA,SAAU,GAIX,QAAc,CACjB,YAAY,EAAM,EAAW,EAAK,EAAQ,GAAO,CAC7C,KAAK,KAAO,EACZ,KAAK,KAAO,EACZ,KAAK,WAAa,EAClB,KAAK,MAAQ,EACb,KAAK,WAAa,QAGf,QAAO,EAAW,EAAY,EAAK,EAAW,EAAW,CAC5D,KAAM,GAAO,GAAmB,EAAY,EAAW,EAAW,GAClE,MAAO,IAAIS,IAAQ,EAAM,EAAW,EAAK,OAGzC,KAAK,CACL,MAAO,MAAK,KAAK,UAGrB,MAAO,CACH,KAAM,GAAU,GAAI,MAAK,KAAK,QAC9B,SAAQ,SAAS,KAAK,WAAY,KAAK,KAAK,SACrC,EAGX,OAAO,EAAY,CACf,EAAW,OAGf,KAAK,EAAY,CACb,KAAK,KAAK,QAAU,EAAW,OAAO,KAAK,YAC3C,KAAK,WAAa,ICzBnB,QAAuB,CAC1B,YAAY,EAAO,EAAqB,EAAmB,CACvD,KAAK,MAAQ,EACb,KAAK,oBAAsB,EAC3B,KAAK,kBAAoB,EACzB,KAAK,QAAU,KACf,KAAK,aAAe,GAGxB,UAAU,EAAQ,CACd,KAAK,QAAU,EAGnB,sBAAuB,CACnB,KAAK,aAAe,MAGpB,aAAa,CACb,MAAI,MAAK,QACmB,KAAK,QAAQ,aAAe,KAAK,kBAGtD,MAGP,eAAe,CACf,MAAI,MAAK,QACE,CAAC,KAAK,WACN,MAAK,yBAOhB,wBAAwB,CAExB,MAAO,CAAC,KAAK,SAAW,CAAC,KAAK,cC7CtC,KAAM,IAA+B,EAErC,YAAyB,EAAS,CAC9B,MAAO,GAAQ,OAAS,EAG5B,YAAsB,EAAU,CAC5B,EAAS,KAAK,CAAC,EAAG,IACP,EAAE,KAAK,SAAW,EAAE,KAAK,UAIjC,QAAiB,CACpB,YAAY,CAAC,UAAS,YAAW,MAAK,YAAW,UAAS,MAAK,iBAAgB,CAC3E,KAAK,SAAW,EAChB,KAAK,WAAa,EAClB,KAAK,KAAO,EACZ,KAAK,WAAa,EAClB,KAAK,SAAW,EAChB,KAAK,KAAO,EACZ,KAAK,eAAiB,OAUpB,sBAAqB,EAAQ,OAC/B,KAAM,GAAa,GAAI,KACvB,SAAW,KAAS,GAAQ,CACxB,KAAM,GAAY,KAAM,UAAN,cAAgB,WAClC,AAAI,GACA,EAAW,IAAI,GAKvB,KAAM,GAAQ,KAAM,SAAQ,IAAI,MAAM,KAAK,GAAY,IAAI,GAChD,KAAK,eAAe,SAAS,KAExC,MAAO,IAAI,IAAU,QAoBnB,YAAW,EAAQ,EAAM,EAAK,CAChC,GAAI,CACA,KAAM,GAAqB,GAAQ,EAAQ,UAAS,WAAM,UAAN,cAAgB,aAC9D,EAAY,KAAK,OAEjB,EAAsB,KAAM,SAAQ,IAAI,MAAM,KAAK,EAAmB,WAAW,IAAI,CAAC,CAAC,EAAW,KAC7F,KAAK,wBAAwB,EAAW,EAAQ,EAAW,KAEhE,EAAU,EAAoB,OAAO,CAAC,EAAK,IAAM,EAAI,OAAO,EAAE,SAAU,IACxE,EAAS,EAAoB,OAAO,CAAC,EAAK,IAAM,EAAI,OAAO,EAAE,QAAS,IACtE,EAAuB,EAAoB,IAAI,GAAK,EAAE,qBAC5D,MAAO,IAAIC,IAAkB,EAAsB,EAAS,EAAQ,KAAK,SAAU,SAC9E,EAAP,CAIE,QAAK,UACC,QAIR,yBAAwB,EAAW,EAAQ,EAAW,EAAiB,CACzE,KAAM,GAAW,KAAM,MAAK,aAAa,EAAW,GAC9C,EAAsB,GAAI,IAAoB,EAAW,EAAU,KAAK,KAAM,GAC9E,EAAU,GACV,EAAS,GAEf,SAAW,KAAS,GAChB,GAAI,CACA,KAAM,GAAS,KAAK,qBAAqB,EAAqB,EAAO,GACrE,EAAQ,KAAK,SACR,EAAP,CACE,EAAO,KAAK,GAGpB,MAAO,CAAC,UAAS,SAAQ,uBAG7B,qBAAqB,EAAqB,EAAO,EAAW,CACxD,KAAM,GAAY,EAAoB,UAChC,EAAU,KAAK,4BAA4B,GACjD,GAAI,GACJ,GAAI,CACA,EAAY,EAAoB,QAAQ,SACnC,EAAP,CAEE,KAAM,IAAI,GAAgB,4BAA6B,EAAO,CAAC,YAAW,MAAO,EAAI,UAGzF,GAAI,MAAO,IAAc,UAAY,GAAgB,GAAU,CAC3D,GAAI,GACJ,GAAI,CACA,EAAe,KAAK,yBAAyB,EAAW,EAAS,SAC5D,EAAP,CACE,KAAM,IAAI,GAAgB,yCAAyC,EAAM,UAAW,EAAO,CAAC,YAAW,UAE3G,EAAoB,cAAc,EAAa,SAC/C,EAAY,EAAa,UAE7B,GAAI,MAAO,IAAc,SAAU,CAC/B,GAAI,GACJ,GAAI,CACA,EAAU,KAAK,MAAM,SAChB,EAAP,CACE,KAAM,IAAI,GAAgB,qBAAsB,EAAO,CAAC,YAAW,UAEvE,YAAK,iBAAiB,EAAS,GACxB,GAAI,IAAiB,EAAS,EAAW,EAAQ,KAAK,aAE7D,MAAM,IAAI,GAAgB,0BAA2B,EACjD,CAAC,gBAAiB,EAAoB,SAAS,IAAI,GAAK,EAAE,MAKtE,yBAAyB,EAAW,EAAS,EAAW,CACpD,GAAI,GAKJ,KAAM,GAAa,KAAK,SAAS,wBAAwB,EAAW,EAAQ,MAC5E,GAAI,CACA,EAAY,EAAW,QAAQ,EAAQ,KAAM,EAAQ,MACrD,KAAM,GAAUD,GAAQ,OAAO,EAAW,EAAY,KAAK,KAAM,KAAK,WAAY,GAClF,SAAQ,OAAO,GACR,CAAC,UAAS,mBACZ,EAAP,CACE,QAAW,OACL,GAId,4BAA4B,EAAO,OAC/B,KAAM,GAAa,KAAM,UAAN,cAAe,WAClC,GAAI,CAAC,EACD,KAAM,IAAI,GAAgB,yBAA0B,GAExD,KAAM,GAAU,iBAAa,KAAK,SAAS,aAAa,YACxD,GAAI,CAAC,EACD,KAAM,IAAI,GAAgB,iCAAkC,GAGhE,MAAO,QAGL,cAAa,EAAW,EAAK,CAG/B,KAAM,GAAW,AAFM,MAAM,GAAI,YAAY,OAAO,IAEpB,IAAI,GAAK,GAAIA,IAAQ,EAAG,KAAK,WAAY,KAAK,OAC9E,UAAa,GACN,EAGX,iBAAiB,EAAS,EAAO,WAC7B,GAAI,EAAQ,SAAW,EAAM,OACzB,KAAM,IAAI,GAAgB,wBAAyB,EAAO,CAAC,OAAQ,EAAM,OAAQ,YAAa,EAAQ,SAE1G,GAAI,EAAQ,YAAc,KAAK,WAC3B,KAAM,IAAI,GAAgB,oBAAqB,EAAO,CAAC,UAAW,EAAQ,YAE9E,GAAI,MAAQ,iBAAR,cAAwB,WAAY,KAAK,SAAS,aAAa,QAC/D,KAAM,IAAI,GAAgB,wBAAyB,EAAO,CAAC,IAAK,KAAQ,iBAAR,cAAwB,UAG5F,GAAI,CAAC,EAAQ,KACT,KAAM,IAAI,GAAgB,0BAA2B,EAAO,CAAC,YAEjE,GAAI,MAAO,MAAQ,OAAR,cAAc,UAAY,SACjC,KAAM,IAAI,GAAgB,oDAAqD,EAAO,CAAC,aAMnG,QAA0B,CACtB,YAAY,EAAW,EAAU,EAAK,EAAW,CAC7C,KAAK,UAAY,EACjB,KAAK,SAAW,EAChB,KAAK,KAAO,EACZ,KAAK,WAAa,EAGtB,cAAc,EAAS,CAEnB,KAAK,SAAS,QAAQ,GAG1B,QAAQ,EAAS,CACb,SAAW,KAAW,MAAK,SAAU,CACjC,KAAM,GAAY,KAAK,oBAAoB,EAAS,GACpD,GAAI,MAAO,IAAc,SAIrB,UAAa,KAAK,UACX,GAKnB,qBAAsB,CAClB,MAAO,MAAK,SAAS,OAAO,GAAW,EAAQ,eAG/C,iBAAiB,CACjB,MAAO,MAAK,SAAS,KAAK,GAAW,EAAQ,OAQjD,oBAAoB,EAAS,EAAS,CAClC,KAAM,GAAa,EAAQ,OAC3B,GAAI,CACA,GAAI,GAAgB,IAAY,CAAC,EAAW,gBAAgB,EAAQ,MAChE,OAEJ,GAAI,CACA,KAAM,GAAY,EAAW,QAAQ,EAAQ,KAAM,EAAQ,MAC3D,SAAQ,KAAK,GACb,EAAQ,SAAW,KAAK,WACjB,QACF,EAAP,CACE,GAAI,GAAgB,GAChB,KAAM,IAAI,OAAM,4DAA4D,EAAQ,OAAO,EAAI,WAGnG,gBAGJ,EAAQ,OAAO,KAS3B,QAAwB,CACpB,YAAY,EAAsB,EAAS,EAAQ,EAAS,EAAM,CAC9D,KAAK,sBAAwB,EAC7B,KAAK,SAAW,EAChB,KAAK,QAAU,EACf,KAAK,OAAS,EACd,KAAK,MAAQ,KAGb,iBAAiB,CACjB,MAAO,MAAK,sBAAsB,KAAK,GAAO,EAAI,gBAGtD,MAAM,EAAK,CACP,GAAI,CACA,SAAW,KAAuB,MAAK,sBAAuB,CAC1D,SAAW,KAAW,GAAoB,sBAEtC,GADA,EAAI,YAAY,IAAI,EAAQ,MACxB,EAAQ,MAAO,CACf,KAAM,GAAa,EAAQ,OAC3B,GAAI,CACA,KAAK,SAAS,sBAAsB,EAAY,WAEhD,EAAQ,OAAO,IAI3B,GAAI,EAAoB,SAAS,OAAS,GAA8B,CACpE,KAAM,CAAC,YAAW,YAAY,EAE9B,OAAS,GAAI,EAAS,OAAS,EAAG,GAAK,GAA+B,GAAK,EAAG,CAC1E,KAAM,GAAU,EAAS,GACzB,EAAI,YAAY,OAAO,EAAW,EAAQ,eAKtD,KAAK,MAAM,YChTvB,YAA4B,EAAY,CACpC,MAAO,GAAW,OAAO,CAAC,EAAO,IACzB,CAAC,GAAS,EAAY,EACf,EAEA,EAEZ,MAGP,KAAM,IAAgB,oBAKhB,GAAiB,GAEhB,QAAiB,CACpB,YAAY,CAAC,UAAS,MAAK,UAAS,YAAW,UAAS,MAAK,YAAW,iBAAgB,CACpF,KAAK,SAAW,EAChB,KAAK,KAAO,EACZ,KAAK,SAAW,EAChB,KAAK,WAAa,EAClB,KAAK,SAAW,EAChB,KAAK,KAAO,EACZ,KAAK,WAAa,EAClB,KAAK,eAAiB,OAGpB,SAAQ,EAAM,EAAS,EAAS,EAAO,EAAK,CAC9C,GAAI,GAAW,GACf,OAAS,GAAI,EAAG,EAAI,EAAQ,OAAS,GAAK,GAAgB,CACtD,KAAM,GAAe,EAAQ,MAAM,EAAG,EAAI,IACpC,EAAgB,KAAM,MAAK,sBAAsB,EAAM,EAAS,EAAc,EAAO,GAC3F,EAAW,EAAS,OAAO,GAE/B,MAAO,QAGL,uBAAsB,EAAM,EAAS,EAAS,EAAO,EAAK,CAI5D,KAAM,GAAQ,KAAM,SAAQ,IAAI,EAAQ,IAAI,GACjC,KAAK,eAAe,SAAS,EAAO,iBAE/C,GAAI,CACA,KAAM,CACF,wBACA,6BACA,KAAM,MAAK,sBAAsB,GAE/B,EAAY,KAAK,OAEvB,GAAI,GAAoB,GACxB,GAAI,CACA,GAAI,EAAsB,OAAQ,CAC9B,KAAM,GAAuB,KAAM,GAAI,KAAK,kBAAmB,GAAO,KAAK,mBACvE,EAAuB,EAAO,EAAW,IAC7C,EAAoB,EAAkB,OAAO,GAEjD,KAAM,MAAK,cAAc,GACzB,EAAoB,EAAkB,OAAO,GAC7C,KAAM,GAAa,CAAC,EAAG,UAAW,QAAS,EAAkB,QACvD,EAAW,EAAI,KAAK,EAAY,IAAM,EAAkB,IAAI,GAAU,CACxE,KAAM,GAAmB,KAAK,kBAAkB,EAAM,EAAS,GAC/D,MAAO,IAAI,IAAiB,EAAkB,EAAO,WAEzD,YAAM,MAAK,eAAe,EAAmB,GACtC,UAEP,SAAW,KAAU,GACjB,EAAO,mBAIf,SAAW,KAAQ,GACf,EAAK,gBAKX,uBAAsB,EAAS,CACjC,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,CAAC,KAAK,SAAS,WAAW,cAC5D,EAAsB,KAAM,SAAQ,IAAI,EAAQ,IAAI,KAAM,IACrD,KAAM,GAAI,YAAY,cAAc,EAAO,iBAEhD,EAAwB,EAAQ,OAAO,CAAC,EAAG,IAAM,CACnD,KAAM,GAAa,EAAoB,GACvC,MAAO,CAAE,kBAAY,UAGnB,EAA4B,EAAQ,IAAI,CAAC,EAAQ,IAAM,CACzD,KAAM,GAAa,EAAoB,GACvC,GAAI,kBAAY,QAAS,EAAG,CACxB,KAAM,GAAY,GAAmB,GACrC,MAAO,IAAiB,cAAc,EAAQ,MAEnD,OAAO,GAAU,CAAC,CAAC,GAEtB,MAAO,CAAC,wBAAuB,6BAGnC,kBAAkB,EAAM,EAAS,EAAQ,CACrC,KAAM,CAAC,UAAS,UAAU,EACpB,EAAY,KAAK,UAAU,KAAK,gCAAgC,EAAM,EAAS,IAC/E,EAAU,EAAQ,QAAQ,GAQhC,MAPyB,CACrB,UAAW,GACX,WAAY,KAAK,SAAS,aAAa,WACvC,WAAY,EACP,EAAO,eAAgB,IAMpC,gCAAgC,EAAM,EAAS,EAAQ,CACnD,MAAO,CACH,KAAM,CACF,QAAW,KAAK,SAAS,aAAa,SAE1C,eAAgB,CACZ,QAAW,EAAO,YAEtB,UAAW,EAAO,OAClB,OAAQ,KAAK,WACb,UACA,aAIF,oBAAmB,EAAuB,EAAO,EAAW,EAAK,CACnE,KAAM,GAAuB,KAAM,GAAI,KAAK,QAAS,GAAO,KAAK,kBAAkB,EAAO,EAAuB,IACjH,GAAI,CACA,SAAW,KAAU,GAAsB,CACvC,KAAM,CAAC,SAAQ,cAAc,EAC7B,EAAO,QAAU,KAAM,MAAK,SAAS,yBAAyB,EAAO,cAAe,GAExF,KAAM,MAAK,eAAe,EAAsB,SAC3C,EAAP,CACE,SAAW,KAAU,GACjB,EAAO,UAEX,KAAM,GAEV,MAAO,QAGL,mBAAkB,EAAO,EAAkB,EAAK,CAElD,KAAM,GAAgB,GAAmB,EACrC,GAAU,EAAO,OACjB,IAAM,GAAI,KACV,CAAC,EAAW,IAAW,EAAU,IAAI,EAAO,SAAU,IAEpD,EAAc,MAAM,KAAK,EAAc,WAAW,OAAO,CAAC,EAAU,CAAC,EAAQ,KAC/E,GAAS,GAAU,MAAM,KAAK,EAAU,UAAU,OAAO,CAAC,EAAY,IAClE,GAAW,EAAO,UAAY,GACvB,GACR,IACI,GACR,IACG,EAAgB,KAAM,GAAM,UAAU,CACxC,QAAS,IACT,cAAe,GAChB,CAAC,QAAM,WACV,AAAI,OAAO,KAAK,EAAc,UAAU,QACpC,EAAI,IAAI,CAAC,EAAG,WAAY,QAAS,OAAO,KAAK,EAAc,WAAY,EAAI,MAAM,MAErF,KAAM,GAAa,iBAAgB,cACnC,MAAO,MAAK,2BAA2B,EAAY,EAAe,GAGtE,2BAA2B,EAAY,EAAe,EAAK,OACvD,KAAM,GAA4B,GAClC,SAAW,CAAC,EAAQ,IAAgB,QAAO,QAAQ,GAC/C,SAAW,CAAC,EAAU,IAAkB,QAAO,QAAQ,GAAc,CACjE,KAAM,CAAC,EAAe,GAAc,OAAO,QAAQ,GAAe,GAC5D,CAAC,GAAgB,EAAc,MAAM,KAC3C,GAAI,IAAiB,GAAe,CAChC,KAAM,GAAS,KAAc,IAAI,KAAlB,cAA2B,IAAI,GAC9C,GAAI,GACyB,GACrB,KAAK,SAAU,EAAQ,EAAU,EAAO,WAAY,EAAY,GAC9C,CAClB,KAAM,GAAS,GAAiB,QAAQ,EAAQ,EAAW,KAC3D,EAA0B,KAAK,KAMnD,MAAO,QAGL,eAAc,EAAmB,CACnC,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,CAAC,KAAK,SAAS,WAAW,cAIlE,GAAI,GAAS,GACb,GAAI,CACA,KAAM,SAAQ,IAAI,EAAkB,IAAI,KAAM,IAAoB,CAC9D,KAAM,GAAe,KAAM,GAAI,YAAY,IACvC,EAAiB,OAAO,cAAe,EAAiB,WAC5D,GAAI,GAAgB,CAAC,EAAQ,CACzB,KAAM,GAAa,GAAI,MAAK,KAAK,QACjC,EAAW,SAAS,KAAK,WAAY,EAAa,SAClD,EAAiB,QAAU,YAG9B,EAAP,CACE,EAAS,GAET,SAAW,KAAU,GACjB,EAAO,UAEX,KAAM,SAIR,gBAAe,EAAmB,EAAW,CAC/C,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CAAC,KAAK,SAAS,WAAW,cACvE,GAAI,CACA,SAAW,KAAU,GAAmB,CACpC,KAAM,GAAe,GACjB,EAAO,QAAS,EAAO,OAAO,cAAe,EAAW,KAAK,YACjE,EAAI,YAAY,IAAI,UAEnB,EAAP,CACE,QAAI,QACE,EAEV,KAAM,GAAI,YAQlB,QAAuB,CACnB,YAAY,EAAQ,EAAY,EAAW,CACvC,KAAK,OAAS,EACd,KAAK,WAAa,EAClB,KAAK,UAAY,EAEjB,KAAK,QAAU,WAGZ,SAAQ,EAAQ,EAAY,CAC/B,MAAO,IAAI,IAAiB,EAAQ,EAAY,YAG7C,eAAc,EAAQ,EAAW,CACpC,MAAO,IAAI,IAAiB,EAAQ,KAAM,GAG9C,SAAU,CACN,AAAI,KAAK,SACL,KAAK,QAAQ,QAKzB,QAAuB,CACnB,YAAY,EAAS,EAAQ,CACzB,KAAK,QAAU,EACf,KAAK,OAAS,GC/Qf,QAAwB,CAC3B,YAAY,EAAQ,EAAS,EAAQ,EAAe,CAChD,KAAK,QAAU,EACf,KAAK,SAAW,EAChB,KAAK,QAAU,EACf,KAAK,eAAiB,OAYpB,OAAM,EAAK,CACb,YAAM,SAAQ,IAAI,KAAK,eAAe,IAAI,KAAM,IAAe,CAC3D,GAAI,CACA,KAAK,oBAAoB,KAAK,QAAS,EAAa,SAC/C,EAAP,CACE,KAAK,QAAQ,IAAI,EAAY,QAAS,OAGvC,CACH,QAAS,KAAK,SACd,OAAQ,KAAK,cAQf,qBAAoB,EAAQ,EAAa,EAAK,CAChD,KAAM,CAAC,eAAc,YAAW,UAAS,aAAa,EAChD,EAAa,KAAM,GAAI,wBAAwB,IAAI,EAAQ,EAAW,GAE5E,GAAI,GAAc,EAAW,UAAY,EAAS,CAG9C,KAAM,GAAa,AADS,EAAW,UAAY,EACV,EAAU,EAAW,QAE9D,WAAK,SAAS,OAAO,GAEf,GAAI,GAAgB,wBAAyB,MAAO,CACtD,eACA,aACA,aAAc,EAAW,UAIjC,AAAK,GACD,EAAI,wBAAwB,IAAI,EAAQ,EAAW,EAAc,CAC7D,UACA,2BC1De,EAA4B,EAAsB,IACzE,WACW,CAAC,EAAK,IAAU,GAAI,YACvB,IAAI,EAAK,GCGlB,QAA4B,CAC/B,YAAY,EAAQ,EAAoB,EAAQ,CAC5C,KAAK,QAAU,EACf,KAAK,oBAAsB,EAC3B,KAAK,eAAiB,OAGpB,UAAU,CACZ,GAAI,CACA,KAAM,GAAS,KAAK,eACd,EAAU,GAAI,KACd,EAAgB,GACtB,YAAM,SAAQ,IAAI,KAAK,oBAAoB,IAAI,KAAM,IAAqB,CACtE,KAAM,GAAgB,KAAM,GAAkB,aAC9C,GAAS,EAAc,OAAQ,GAC/B,GAAS,EAAc,QAAS,GAChC,EAAc,KAAK,GAAG,EAAc,kBAEjC,GAAIC,IAAkB,KAAK,QAAS,EAAS,EAAQ,WAE5D,KAAK,WAIb,SAAU,CACN,SAAW,KAAM,MAAK,oBAClB,EAAG,mBC9BmB,CAK9B,YAAY,EAAmB,EAAsB,EAAsB,MAClE,UAAY,OACZ,aAAe,OACf,MAAQ,KAGb,UAAkB,OACX,MAAK,MAAM,YAGlB,YAAoB,OACb,MAAK,MAAM,0BCFK,CAO3B,YAAY,EAAc,EAAyB,EAAkC,EAAsB,MAClG,IAAM,OACN,OAAS,OACT,UAAY,OACZ,UAAY,OACZ,mBAAqB,EAAY,GAAK,YAGzC,aAAwC,MACpC,GAAwC,GACxC,EAAyC,GAAI,QAC/C,eAEE,MAAK,UAAU,OAAO,KAAK,IAAK,KAAM,IAAW,UACxC,KAAS,MAAK,UACjB,MACM,GAAa,EAAM,QAAQ,cAC7B,MAEA,KAAK,UAAW,MACV,GAAU,KAAK,UAAU,cAAc,EAAS,QACjD,mBAAoB,KAAK,KACX,KAAM,GAAQ,kBAEd,EAAQ,QAAQ,QAEjC,CAAC,aAAa,KAChB,MACA,GACU,KAAK,MAAM,SAChB,QACC,IAAI,GAAgB,qBAAsB,EAAO,CAAC,YAAW,WAEnE,EAAQ,UAAY,KAAK,IAAI,YACvB,IAAI,GAAgB,oBAAqB,EAC3C,CAAC,gBAAiB,EAAQ,QAAS,YAAa,KAAK,IAAI,WAEnD,KAAK,GAAI,IAAqB,KAAK,IAAI,UAAW,EAAkB,cAAe,SAC3F,GAAS,GAAI,IAAiB,EAAS,KAAK,IAAI,UAAW,KAAK,IAAI,qBAClE,IAAI,EAAM,SAAU,SACvB,MAED,EAAI,OAAS,oBAGZ,MACQ,GAAI,QAEV,IAAI,EAAM,SAAU,MAKhC,CAAC,UAAS,SAAQ,iBAG7B,SAAU,IACF,KAAK,4BACM,KAAK,MAAK,qBACf,SC/ElB,YAAsB,EAA0C,aACrD,KAAM,UAAN,cAAgB,WAG3B,YAAsB,EAA0C,aACrD,KAAM,UAAN,cAAgB,WAG3B,YAAuB,EAA0C,aACtD,KAAM,UAAN,cAAe,uBAGI,EAAsB,OACzC,OAAO,IAAa,IAAW,UAC/B,MAAO,IAAa,IAAW,UAC/B,MAAO,IAAc,IAAW,iBAGd,CAEzB,aAAc,MACL,OAAS,MAGd,YAAgC,OACzB,IAAa,KAAK,OAAO,OAGhC,YAAgC,OACzB,IAAa,KAAK,OAAO,iBAIH,EAAuD,OACjF,IAA2D,EAC9D,AAAC,GAAyB,GAAG,GAAa,MAAU,GAAa,KACjE,IAAM,GAAI,IACV,CAAC,EAAwB,IAAyB,EAAM,OAAO,KAAK,YChC9C,CAG1B,aAAa,EAAgB,EAAmB,EAAmB,OACxD,MAAK,SAAW,GAAU,KAAK,YAAc,GAAa,KAAK,YAAc,KAgBpF,WAAgC,OAAS,MAAK,aAE9C,UAAS,EAA4B,MAAO,UAAY,eAGnC,EAAqC,EAA0C,OAChG,GAAW,oBAAsB,EAAgB,oCAGf,GAAQ,CAGlD,4BAA4B,EAAmB,EAAoC,OACxE,MAAK,6BAA6B,EAAQ,OAAW,QAG1D,OAAM,EAAmB,EAAoC,IAE3D,MACA,KAAK,WAAa,aAKZ,MAAK,6BAA6B,EAAQ,CAAC,EAAS,IAAc,GACnD,EAAQ,OAAO,IACjC,GAEH,KAAK,WAAa,SACX,GAGN,MACgB,KAAM,GAAO,OAAO,KAAM,CAAC,EAAS,IAAc,EAAQ,OAAO,UAEhF,GAAe,CACjB,OAAQ,KAAK,OACb,UAAW,KAAK,UAChB,UAAW,KAAK,UAChB,QAAS,EACT,OAAQ,KAAK,aACb,OAAQ,KAAK,UACb,YAAa,CAAC,QAAW,KAAK,6BAE9B,qBAAqB,IAAI,GACtB,MAGP,WAAW,OAAS,MAAK,eAEf,8BAA6B,EAAmB,EAAyF,EAAoC,IACnL,KAAK,WAAa,aACX,MAAK,YAEZ,GAAc,EAAO,aAAa,KAAK,OAAQ,KAAK,UAAW,KAAK,cACpE,CAAC,EAAa,MACR,GAAa,KAAM,IAAe,KAAK,OAAQ,KAAK,UAAW,KAAK,UAAW,GAGjF,IACI,EAAW,aACG,EACP,EAAW,gBACb,UAAY,EAAW,cAIpC,EAAa,MACP,GAAM,OACN,GAAO,OAAO,KAAM,KAAM,IAAc,MACpC,GAAO,OAAO,EAAK,CAAC,EAAiB,IAAc,MAGhD,SAAW,GAAa,EAAY,KACrC,SAAW,CAAC,KAAK,SACjB,KAAK,UAAY,KACR,EAAY,iBAM5B,SAAW,SAEb,MAAK,YAGF,eAA6B,OAChC,IAAa,aAM5B,gBAAmC,GAAgB,CAG/C,YAAY,EAAoC,cAEvC,kBAAoB,KAGzB,SAAS,aAAS,QAAK,kBAAkB,MAAM,UAA7B,cAAuC,WACzD,YAAY,OAAS,MAAK,kBAAkB,uBAC5C,YAAY,aAAS,QAAK,kBAAkB,MAAM,UAA7B,cAAuC,cAC5D,oBAAoB,OAAS,MAAK,kBAAkB,qBACpD,mBAA2B,aAAS,QAAK,kBAAkB,MAAM,UAA7B,cAAuC,eAC3E,oBAA4B,OAAS,YAC3B,YAAuB,OAAS,IAAU,cAExD,SAAS,EAAS,GACN,OAAO,KAAK,mCAOS,GAAgB,CAGjD,YACqB,EACA,EACA,EACnB,wEAGO,SAAW,QAGX,YAAc,KAAK,gBAAgB,iBAGxC,SAAiB,OAAS,MAAK,WAC/B,YAAoB,OAAS,MAAK,aAAa,cAC/C,YAAoB,OAAS,MAAK,gBAAgB,gBAClD,oBAA4B,OAAS,MAAK,aAAa,WACvD,mBAA2B,OAAS,MAAK,eACzC,oBAA4B,OAAS,YAC3B,YAAuB,OAAS,IAAU,SAExD,SAAS,EAAkC,GAC/B,OAAO,KAAK,mBAI5B,gBAA4B,GAAgB,CACxC,YAAoB,EAAyB,EAA4B,EAAqB,gEAI1F,SAAS,OAAS,MAAK,WACvB,YAAY,OAAS,MAAK,YAAY,cACtC,YAAY,OAAS,MAAK,cAC1B,oBAAoB,aAAS,QAAK,YAAY,sBAAjB,cAA0C,WACvE,mBAA2B,OAAS,MAAK,YAAY,eACrD,oBAA4B,OAAS,oBAC3B,YAAuB,OAAS,IAAU,OAExD,SAAS,EAAS,GACN,eAAe,KAAK,qBAGlB,eAA6B,OAChC,IAAa,0BAIO,GAAQ,CAGvC,YAAY,EAAwC,cAE3C,SAAW,QACX,aAAe,KAGpB,SAAS,OAAS,MAAK,aAAa,UACpC,YAAY,OAAS,MAAK,aAAa,aACvC,YAAY,OAAS,MAAK,aAAa,aACvC,oBAAoB,OAAS,MAAK,aAAa,YAAa,WAC5D,WAAW,OAAS,MAAK,aAAa,YACtC,mBAA2B,OAAS,MAAK,aAAa,SAAW,MACjE,oBAA4B,OAAS,WAEzC,SAAS,EAAS,EAAW,GACjB,SAAS,EAAW,KAAK,qBAGjC,aAAa,OAIN,CAAC,CAAC,KAAK,8BAIe,EAAwD,YACnF,GAAa,KAAG,MAAM,UAAT,cAAmB,YAChC,EAAM,GAAI,IAAqB,MAEjC,MAAO,GAAI,QAAW,UACtB,MAAO,GAAI,WAAc,UACzB,MAAO,GAAI,WAAc,UACzB,MAAO,IAAe,eAEf,eAYe,EAAQ,EAAW,EAAuC,YAC9E,GAAa,EAAW,YACxB,EAAY,EAAW,WAEvB,EAAoB,KAAW,sBAAX,cAAoC,WAG1D,MAAO,IAAW,UAClB,MAAO,IAAc,UACrB,MAAO,IAAc,UACrB,MAAO,IAAe,UACtB,MAAO,IAAsB,eAEtB,IAAI,IAAc,EAAQ,EAAW,qBAIf,EAAgB,EAAmB,EAAmB,EAAsD,MACvI,GAAuB,KAAM,GAAI,qBAAqB,IAAI,EAAQ,EAAW,MAC/E,QACO,IAAI,IAAc,WC7PT,CAIpB,YAAY,EAAsB,EAAkC,MAC3D,UAAY,OACZ,UAAY,OAGf,uBAAsB,EAAQ,EAAW,EAAW,EAAU,EAAK,IACjE,GAAe,KAAM,GAAI,qBAAqB,IAAI,EAAQ,EAAW,MAErE,mBAAc,aAGd,EAAc,MACR,GAAiB,GAAI,KAAI,EAAa,mBACjC,KAAM,KACE,IAAI,KAEV,SAAW,MAAM,KAAK,UAEpB,CAAC,SAAQ,YAAW,YAAW,cAE9C,qBAAqB,IAAI,SAG3B,0BAAyB,EAAQ,EAAW,EAAW,EAAK,MACxD,GAAe,KAAM,GAAI,qBAAqB,IAAI,EAAQ,EAAW,MACvE,GAAgB,CAAC,EAAa,cACvB,GAAa,cAItB,YAAW,EAAQ,EAAW,EAAW,EAAK,MAC1C,GAAe,KAAM,GAAI,qBAAqB,IAAI,EAAQ,EAAW,SACpD,OAAO,kBAAc,UAAY,cActD,mBAAkB,EAAgB,EAAyB,EAAwC,EAAkB,MACjH,GAAS,GAAI,KACb,EAA+B,YAE1B,KAAS,GACZ,GAAc,KACF,KAAK,KAEV,IAAI,EAAM,SAAU,GAAI,GAAgB,uBAAwB,SAIzE,GAAkB,GAAqB,GAEvC,EAA0C,eAC1C,SAAQ,IAAI,MAAM,KAAK,EAAgB,UAAU,IAAI,KAAM,IAAS,MAChE,GAAM,KAAM,MAAK,WAAW,EAAQ,EAAM,UAAY,EAAM,UAAY,EAAS,MACnF,IACmB,KAAK,GAAI,IAAkB,EAAK,EAAM,OAAQ,KAAK,UAAW,KAAK,0BAE3E,KAAS,GAAM,SACf,IAAI,EAAM,SAAU,GAAI,GAAgB,oBAAqB,OAKzE,GAAIC,IAAsB,EAAQ,EAAoB,QAGnD,YAAW,EAAgB,EAAmB,EAAmB,EAAwC,EAAgD,IAC/J,EAAS,MACH,GAAM,EAAQ,KAAK,GAAK,EAAE,aAAa,EAAQ,EAAW,OAC5D,GAAO,KAAM,GAAI,4BAA4B,KAAK,UAAW,SACtD,QAIT,GAAY,KAAK,UAAU,aAAa,EAAQ,EAAW,MAC7D,QACO,QAEL,GAAa,KAAM,IAAe,EAAQ,EAAW,EAAW,MAClE,GAAc,EAAW,uBAClB,GAOf,aAAa,EAAsB,EAAoC,OAC5D,GAAI,MAAM,KAAK,UAAW,GAOrC,2BAA2B,EAAuC,EAAkC,cAC1F,GAA0B,YACrB,KAAM,GACT,MAAG,QAAH,cAAU,QAAS,cAAgB,MAAG,MAAM,UAAT,cAAkB,aAAc,KAGnE,KAAK,WAAY,GAAO,MAClB,GAAM,GAAqB,GAC7B,KACI,IAAI,SAAU,EAAI,UAClB,IAAI,KAAM,EAAI,aACb,KAAK,OAEN,SAAW,EAAI,MAAM,OACrB,IAAI,UAAW,MAExB,EAAI,MAAM,cAEV,GAGX,kBAAkB,EAAgB,EAAmB,EAAkD,OAC5F,IAAc,EAAQ,EAAW,GAG5C,SAAU,MACD,UAAU,2BCrIQ,GAA2B,CAOtD,YAAY,EAAU,EAAmB,EAAe,OAC9C,QACD,UAAY,OACZ,IAAM,EAGf,aAAa,EAAgB,EAAmB,EAAwC,MAC9E,GAAM,KAAK,mBAAmB,EAAQ,EAAW,MACnD,IAAQ,SACD,MAAK,qBAAqB,GAAM,SAIzC,QAAU,EAAc,EAA+F,MACnH,GAAQ,KAAM,MAAK,kBAAkB,MACvC,OACO,MAAM,GAAS,EAAM,QAAS,KAAK,wBAErC,iBAAiB,OAI1B,UAAU,OACH,MAAK,SAAS,KAAK,GAAM,EAAG,WAAa,GAGpD,SAAU,QACG,GAAI,EAAG,EAAI,KAAK,SAAS,OAAQ,GAAK,OACtC,SAAS,GAAG,eAGhB,SAAS,OAAO,EAAG,KAAK,SAAS,aAG5B,mBAAkB,EAAqC,IAC7D,WACS,KAAK,uBAAuB,MAAU,SACzC,MAAK,4BAEX,EAAM,KAAK,KAAM,MACX,GAAK,KAAK,qBAAqB,SAEjC,GAAG,SAAS,MACT,UAAY,EACR,MAGJ,SAAW,IACX,IAAM,IACL,SAAS,EAAG,QAAS,KAAK,WAE3B,OACJ,MAEG,GAAU,GAAI,MAAK,IAAI,sBACzB,SAAS,EAAS,KAAK,gBACrB,GAAK,GAAI,IAAa,EAAK,eAC5B,KAAK,GACH,GAIP,iBAAiB,EAAkB,GACpC,UAAY,EACX,EAAG,UAAY,GAAK,KAAK,8BACpB,8BAEA,8BAAgC,KAAK,uBAAyB,QAInE,wBAAwC,OACvC,MAAK,qCACD,8BAAgC,GAAI,SAAQ,GAAW,MACnD,uBAAyB,KAG/B,KAAK,8BAGR,uBAAuB,EAAc,IACrC,GAAM,KAAK,iBAAiB,SAC5B,KAAQ,KACJ,KAAK,KAAO,KAAK,QACX,KAAK,QAEL,KAAK,2BAA2B,GAClC,IAAQ,OACF,KAAK,2BAIhB,EAGH,mBAAmB,EAAgB,EAAmB,EAA2B,OAC9E,MAAK,SAAS,OAAO,CAAC,EAAS,EAAI,EAAG,IAAQ,MAC3C,GAAS,IAAY,GAAK,OAAY,EAAI,SAE5C,GAAG,SAAW,IAAQ,EAAG,iBAAiB,EAAQ,EAAW,IACzD,EAAC,GAAU,EAAG,SAAS,IAChB,EAGR,GACR,IAGC,iBAAiB,EAAsB,OACpC,MAAK,SAAS,UAAU,GACpB,EAAG,iBAAiB,EAAI,OAAQ,EAAI,UAAW,EAAI,YAAc,EAAG,SAAS,IAIpF,2BAA2B,EAAsB,OAC9C,MAAK,SAAS,OAAO,CAAC,EAAU,EAAI,EAAG,IAAQ,MAC5C,GAAQ,IAAa,GAAK,OAAY,EAAI,SAE5C,GAAG,WAAa,GAAK,EAAG,iBAAiB,EAAI,OAAQ,EAAI,UAAW,EAAI,YACpE,EAAC,GAAS,CAAC,EAAG,SAAS,IAChB,EAGR,GACR,IAGC,uBAAgC,QAC3B,GAAI,KAAK,SAAS,OAAS,EAAG,GAAK,EAAG,GAAK,KAE5C,AADO,KAAK,SAAS,GAClB,WAAa,QACT,SAGR,IAIf,QAAmB,CAKf,YAAY,EAAc,EAAkC,MACnD,IAAM,OACN,QAAU,OACV,SAAW,EAGpB,iBAAiB,EAAgB,EAAmB,EAA4B,OACrE,MAAK,IAAI,SAAW,GAAU,KAAK,IAAI,YAAc,GAAa,KAAK,IAAI,YAAc,EAIpG,SAAS,EAAqB,OACnB,IAAa,KAAK,QAAS,EAAM,SAG5C,SAAS,EAAc,OACZ,MAAK,IAAI,mBAAqB,EAAI,kBACrC,KAAK,IAAI,oBAAsB,EAAI,kBAG3C,SAAU,MACD,QAAQ,YACR,QAAU,UAOf,SAA8B,OACvB,MAAK,IAAI,eC5LX,IAAY,iDAkBK,CAC1B,YACY,EACA,EACV,2CAEK,cAAa,EAAoB,EAAwB,EAA4B,MAClF,GAAiB,EAAS,WAC1B,EAAa,GAAI,GAAI,aACrB,EAAa,GAAI,GAAI,gBACvB,MACM,GAAS,EAAW,sBAAsB,MAC5C,IAAW,OACL,IAAI,OAAM,yDAAyD,kBAAuB,OAEzF,kBAAkB,SACzB,WACO,OACL,QAEH,IAAI,IAAiB,EAAY,GAG5C,eAAe,EAA0C,MAC/C,GAAc,KAAK,WAAY,QACjC,EAAY,UACZ,EAAY,IACZ,EAAY,kBAET,MAAK,MAAM,GAGtB,eAAe,EAAc,EAAiC,MACpD,GAA8B,CAChC,UAAW,EACX,WAAY,EAAI,UAChB,oBAAqB,CAAC,QAAS,EAAI,mBACnC,gCAAiC,GACjC,YAAa,SAEV,MAAK,WAAY,QAAQ,KAAK,UAAU,IAGnD,SAAU,iBACD,qBAAY,YACZ,WAAa,eACb,qBAAY,YACZ,WAAa,QCpD1B,KAAM,IAAmB,YAEF,CAQnB,YACqB,EACA,EACA,EACA,EACA,EACA,EACA,EAAmB,IACtC,uIAfoC,GAAI,GAAyE,sBAEhG,qBACI,4BACO,MAa1B,aAAsB,OAAS,MAAK,YACpC,QAA2B,OAAS,MAAK,UACzC,UAAkB,OAAS,MAAK,WAAW,WAC3C,cAAuB,OAAS,MAAK,gBACrC,qBAA8B,OAAS,MAAK,yBAE1C,YAAW,EAAgB,EAAmB,EAAqD,MAC/F,GAAkB,KAAM,MAAK,MAAM,yBAAyB,KAAK,WAAW,QAAS,EAAQ,EAAW,CAAC,QAAM,cACjH,CAAC,EAAgB,yBAGf,GAAiB,KAAK,OAAO,eAAe,EAAgB,iBAC9D,kBAAgB,aAAc,QACvB,IAAc,EAAQ,EAAW,GACjC,kBAAgB,cACnB,IAAI,oBAAqB,EAAe,WAIpD,iBAAiB,EAAmC,OACzC,GAAI,qBAAqB,uBAGpC,MAAM,EAAqB,CAClB,KAAK,oBAAoB,SACtB,aAAa,mBAAoB,KAAM,IAAO,IAC1C,KAAK,aAAc,GACf,IAAI,cAAe,KAAK,0BAG3B,SAAW,QACX,OAAS,YACT,oBAAsB,QACrB,GAAY,KAAK,mBAAmB,QACrC,oBAAoB,IAAI,MACzB,MACM,GAAU,YACX,oBAAsB,SACtB,QACA,SAAW,GACZ,EAAI,OAAS,sBAA0B,UAAY,6BAA+B,EAAI,UAAY,kBAC9F,IAAI,gBAAiB,SACpB,aAAe,IAGhB,GAAI,OAAS,cAAiB,EAAI,OAAS,gBAAkB,EAAI,UAAY,qBACxE,OAAS,KAGlB,MAAM,QAET,oBAAoB,IAAI,UAKjC,mBAAmB,EAA4D,OAC5E,IAAI,IAAmB,MAAO,EAAc,IAAgB,IAC3D,GAAQ,EACR,EAAiB,SACR,MACH,GAAS,KAAK,SAAS,SAAW,KAAK,SACvC,EAAU,KAAK,SAAS,MAAM,cAAc,KACrC,QACP,GAAQ,eACR,GAAM,KAAM,MAAK,QAAQ,QAAQ,CAAC,EAAW,yBACtC,KAEL,EAAiB,KAAM,GAAI,qBAAqB,6BAC5C,GAAI,IAAS,EAAO,SAC1B,SAA2B,GAAI,qBAAqB,4BAA4B,KACjF,IAAI,GAAS,GAAI,IAAc,OAChC,EAAkB,SAAW,EAAG,GAC5B,IAAI,QAAS,eAGf,GAAU,KAAM,MAAK,oBAAoB,GACzC,EAAgB,KAAK,MAAM,uBAAuB,KAAK,WAAW,QAAS,EAAS,CAAC,UAC9E,QACP,GAAc,gBACd,MAAK,mBAAmB,EAAmB,MAC/B,EAAkB,SACxB,GAAI,IAAS,EAAO,YAK9B,qBAAoB,EAAgD,MACxE,GAA4B,CAAE,MAAO,IACrC,EAAe,EAAQ,eAClB,KAAO,GAAU,IACpB,GAAc,EAAa,EAAI,QAC9B,MACY,EAAa,EAAI,QAAU,CAAE,SAAU,OAE5C,SAAS,EAAI,WAAa,KAAM,MAAK,cAAc,SAE5D,QAGG,oBAAmB,EAAqB,EAA8B,MAC1E,GAAM,KAAM,MAAK,QAAQ,aAAa,CACxC,EAAW,yBAEF,MACT,MACM,SAAQ,IAAI,EAAS,IAAI,GACpB,EAAI,qBAAqB,eAAe,EAAI,OAAQ,EAAI,UAAW,EAAI,mBAE7E,WACD,QACE,OAEJ,GAAI,gBAGA,eAAc,EAAwC,OACzD,MAAM,MAAK,UAAU,OAAO,EAAS,GAAW,MAC7C,GAAoB,EAAQ,oBAC5B,EAAa,EAAQ,eAAe,SACnC,CACH,oBAAqB,EACrB,gBAAiB,EACjB,YAAa,GACb,aAAc,KAAK,OAAO,eAAe,EAAS,MAK9D,SAAU,MACD,OAAO,sBAGH,mBAAkB,EAAoB,EAAU,EAA8B,EAAsB,EAAsB,EAAkB,EAAkD,MACjM,GAAmB,KAAM,GAAc,WAAW,qBAAsB,MAC1E,EAAkB,MACZ,GAAa,GAAI,YAAW,EAAS,SAAS,OAAO,OAAO,IAC5D,EAAa,KAAM,GAAM,kBAAkB,cAC7C,EAAW,YAAcC,GAAsB,MACzC,GAASC,GAA4B,aAAa,EAAW,UAAW,EAAY,SACnF,IAAI,IAAU,EAAY,EAAQ,EAAO,EAAW,EAAS,aAE9D,IAAI,OAAM,6BAA6B,EAAW,uBAMlD,CAClB,YACoB,EACA,EAClB,+BC7LC,QAAiB,CACpB,YAAY,CAAC,YAAW,MAAK,UAAS,YAAW,UAAS,MAAK,eAAc,CACzE,KAAK,WAAa,EAClB,KAAK,KAAO,EACZ,KAAK,SAAW,EAChB,KAAK,WAAa,EAClB,KAAK,SAAW,EAChB,KAAK,KAAO,EACZ,KAAK,aAAe,EAGxB,uBAAuB,EAAQ,EAAK,CAChC,EAAI,sBAAsB,OAAO,QAG/B,sBAAqB,EAAQ,EAAK,CACpC,GAAI,GAAe,KAAM,GAAI,sBAAsB,IAAI,GACvD,GAAI,EAAc,CACd,KAAM,GAAU,GAAI,MAAK,KAAK,qBAC9B,GAAI,CACA,SAAQ,SAAS,KAAK,WAAY,EAAa,SACxC,KAAK,sBAAsB,EAAS,WAE3C,EAAQ,SAKpB,sBAAsB,EAAa,EAAM,EAAQ,CAC7C,MAAO,CACH,UAAW,EAAY,UACvB,OACA,SACA,QAAS,EAAY,QACrB,WAAY,KAAK,SAAS,aAAa,WACvC,WAAY,EAAY,iBAI1B,uBAAsB,EAAQ,EAAkB,CAClD,GAAI,GAAU,GAAI,MAAK,KAAK,qBAC5B,GAAI,CACA,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CACzC,KAAK,SAAS,WAAW,qBACzB,KAAK,SAAS,WAAW,wBAE7B,GAAI,GACJ,GAAI,CACA,GAAI,GAAe,KAAM,GAAI,sBAAsB,IAAI,GACvD,EAAiB,KAAM,MAAK,qBAAqB,EAAS,EAAc,EAAQ,EAAkB,GAC9F,GACA,KAAK,cAAc,KAAK,OAAQ,EAAS,EAAQ,SAEhD,EAAP,CACE,QAAI,QACE,EAEV,YAAM,GAAI,WACH,UAEP,EAAQ,aAIV,sBAAqB,EAAS,EAAc,EAAQ,EAAkB,EAAK,CAI7E,GAHI,GACA,EAAQ,SAAS,KAAK,WAAY,EAAa,SAE/C,CAAC,GAAgB,KAAK,eAAe,EAAS,EAAa,UAAW,GAAmB,CAEzF,AAAI,GACA,GAAQ,OACR,EAAU,GAAI,MAAK,KAAK,sBAE5B,EAAQ,SACR,KAAM,GAAiB,KAAK,sBAAsB,EAAS,GAE3D,YAAM,AADU,IAAI,IAAgB,EAAQ,EAAS,KAAK,SAAS,cACrD,MAAM,KAAK,WAAY,GAC9B,GAIf,cAAc,EAAW,EAAS,EAAQ,EAAK,CAC3C,EAAI,sBAAsB,IAAI,CAC1B,SACA,QAAS,EAAQ,OAAO,KAAK,YAC7B,mBAYF,SAAQ,EAAQ,EAAM,EAAS,EAAkB,CACnD,GAAI,GAAU,GAAI,MAAK,KAAK,qBAC5B,GAAI,CACA,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CACzC,KAAK,SAAS,WAAW,qBACzB,KAAK,SAAS,WAAW,wBAE7B,GAAI,GACA,EACJ,GAAI,CACA,GAAI,GAAe,KAAM,GAAI,sBAAsB,IAAI,GACvD,EAAiB,KAAM,MAAK,qBAAqB,EAAS,EAAc,EAAQ,EAAkB,GAClG,EAAmB,KAAK,gBAAgB,EAAQ,EAAS,EAAM,GAE/D,KAAM,GAAY,EAAiB,KAAK,OAAS,EAAa,UAC9D,KAAK,cAAc,EAAW,EAAS,EAAQ,SAE1C,EAAP,CACE,QAAI,QACE,EAEV,YAAM,GAAI,WACH,GAAI,IAAiB,EAAkB,WAE9C,AAAI,GACA,EAAQ,QAKpB,eAAe,EAAS,EAAW,EAAkB,CACjD,GAAI,GAAmB,OACvB,AAAI,OAAO,cAAc,iBAAkB,qBACvC,GAAmB,iBAAkB,oBAEzC,GAAI,GAAqB,IAQzB,GAPI,OAAO,cAAc,iBAAkB,uBACvC,GAAqB,iBAAkB,sBAGvC,KAAK,OAAU,EAAY,GAG3B,EAAQ,iBAAmB,EAC3B,MAAO,GAIf,gBAAgB,EAAQ,EAAS,EAAM,EAAS,CAC5C,KAAM,GAAY,KAAK,UAAU,CAC7B,QAAS,EACT,OACA,YAEE,EAAa,EAAQ,QAAQ,GAUnC,MARyB,CACrB,UAAW,EACX,WAAY,KAAK,SAAS,aAAa,WACvC,aACA,WAAY,EAAQ,aACpB,UAAW,KAAK,cAMxB,sBAAsB,EAAS,EAAQ,CACnC,MAAO,CACH,QAAS,EACT,WAAY,EAAQ,aACpB,YAAa,EAAQ,cACrB,UAAW,EAGX,YAAa,EAAQ,kBAajC,QAAuB,CACnB,YAAY,EAAS,EAAgB,CACjC,KAAK,QAAU,EACf,KAAK,eAAiB,GC1L9B,KAAM,IAAiB,mBAIjB,GAAwB,GAAK,IAG5B,QAAqB,CACxB,YAAY,CAAC,OAAM,gBAAe,gBAAe,mBAAkB,mBAAkB,mBAAkB,UAAS,YAAW,6BAA4B,SAAQ,CAC3J,KAAK,MAAQ,EACb,KAAK,eAAiB,EACtB,KAAK,eAAiB,EACtB,KAAK,kBAAoB,EACzB,KAAK,kBAAoB,EAEzB,KAAK,kBAAoB,EAEzB,KAAK,mBAAqB,GAAI,KAC9B,KAAK,SAAW,EAChB,KAAK,WAAa,EAClB,KAAK,4BAA8B,EACnC,KAAK,OAAS,EACd,KAAK,yBAA2B,GAChC,KAAK,qBAAuB,KAC5B,KAAK,iBAAmB,KACxB,KAAK,UAAY,GAGrB,gBAAgB,EAAW,CACvB,AAAI,KAAK,YAAc,CAAC,CAAC,GAGzB,MAAK,WAAa,QAGhB,kCAAiC,EAAS,EAAK,CACjD,KAAM,GAAS,EAAQ,OAAO,GAAK,EAAE,aAAe,CAAC,EAAE,aAAe,EAAE,OAAO,IAAI,GAAK,EAAE,OACpF,EAAkB,GAAqB,GACvC,EAAS,MAAM,KAAK,EAAgB,UACpC,EAAM,KAAM,MAAK,SAAS,QAAQ,CAAC,KAAK,SAAS,WAAW,uBAC5D,EAAc,KAAM,SAAQ,IAAI,EAAO,IAAI,KAAM,IAC5C,KAAK,kBAAkB,WAAW,KAAK,MAAM,GAAI,EAAM,UAAW,EAAM,UAAW,KAExF,EAAkB,EAAO,OAAO,CAAC,EAAG,IAAM,CAAC,EAAY,IAC7D,GAAI,EAAgB,OAEhB,OAAS,GAAI,EAAgB,OAAS,EAAG,GAAK,EAAG,IAAK,CAClD,KAAM,GAAU,EAAgB,GAChC,KAAM,GAAI,KAAK,UAAW,GAAO,KAAK,iCAAiC,EAAQ,UAAW,EAAQ,UAAW,KAKzH,sBAAuB,CACnB,KAAK,mBAAqB,GAAI,UAG5B,oBAAmB,EAAe,EAAK,EAAK,CAC9C,GAAI,GAAc,GAClB,KAAM,GAAqB,MAAM,KAAK,EAAc,UAEpD,MAAI,GAAmB,KAAK,GAAK,EAAE,UAC/B,GAAI,IAAI,CACJ,EAAG,yBACH,UAAW,EAAmB,OAAO,GAAK,EAAE,SAAS,IAAI,GAAK,EAAE,UAEpE,KAAK,kBAAkB,uBAAuB,KAAK,MAAM,GAAI,IAE7D,EAAmB,KAAK,GAAK,EAAE,YAC/B,GAAc,KAAM,MAAK,uCAAuC,EAAoB,EAAK,IAE7F,KAAM,MAAK,eAAe,mBAAmB,KAAK,MAAO,EAAe,GACjE,OAGL,mBAAkB,EAAQ,EAAS,EAAQ,EAAK,WAClD,KAAM,GAAS,GAAI,KACb,EAAc,GACpB,SAAW,KAAS,GAChB,AAAI,EAAM,kBAAoB,MAAM,WAAN,cAAgB,mBAG1C,OAAM,UAAN,cAAe,aAAc,GAC7B,EAAO,IAAI,EAAM,SAAU,GAAI,OAAM,0BAA4B,MAAM,UAAN,cAAe,aAEpF,EAAY,KAAK,IAErB,KAAM,GAAc,KAAM,MAAK,kBAAkB,kBAC7C,KAAK,MAAM,GAAI,EAAa,EAAS,GACzC,MAAO,IAAI,IAAsB,EAAa,EAAQ,EAAQ,KAAM,QAGlE,2BAA0B,EAAQ,EAAS,EAAQ,EAAQ,EAAK,EAAK,CACvE,KAAM,GAAuB,EAAO,OAAO,GAAS,CAChD,KAAM,GAAQ,EAAO,IAAI,EAAM,UAC/B,MAAO,kBAAO,QAAS,sBAE3B,GAAI,CAAC,EAAqB,OACtB,OAGJ,KAAM,GAAyB,GAAqB,GASpD,AARI,IAAW,GAAiB,MAC5B,KAAM,SAAQ,IAAI,MAAM,KAAK,EAAuB,UAAU,IAAI,KAAM,IAAS,CAC7E,KAAM,GAAW,EAAM,OAAO,IAAI,GAAK,EAAE,UACzC,MAAO,MAAK,kBAAkB,sBAC1B,KAAK,MAAM,GAAI,EAAM,UAAW,EAAM,UAAW,EAAU,MAInE,EAAC,KAAK,YAIV,EAAI,aAAa,mBAAoB,KAAM,IAAO,CAM9C,GAHA,EAAI,IAAI,SAAU,GAClB,EAAI,IAAI,SAAU,EAAqB,QACvC,EAAI,IAAI,WAAY,EAAuB,MACvC,IAAW,GAAiB,KAAM,CAElC,GADA,KAAM,MAAK,OAAO,cAAc,KAAO,UACnC,KAAK,UACL,OAGJ,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,CAAC,KAAK,SAAS,WAAW,uBAClE,KAAM,SAAQ,IAAI,MAAM,KAAK,GAAwB,IAAI,MAAO,CAAC,EAAK,KAAW,CAC7E,AAAI,KAAM,MAAK,kBAAkB,WAAW,KAAK,MAAM,GAAI,EAAM,UAAW,EAAM,UAAW,IACzF,EAAuB,OAAO,MAI1C,KAAM,SAAQ,IAAI,MAAM,KAAK,EAAuB,UAAU,IAAI,GACvD,EAAI,KAAK,UAAW,GAAO,KAAK,iCAAiC,EAAM,UAAW,EAAM,UAAW,aAKhH,yBAAwB,EAAQ,EAAK,CACvC,GAAI,GAAS,KAAK,mBAAmB,IAAI,EAAO,qBAChD,AAAK,GACD,GAAS,KAAM,MAAK,eAAe,yBAAyB,EAAO,oBAAqB,GACxF,KAAK,mBAAmB,IAAI,EAAO,oBAAqB,IAE5D,AAAI,EACA,EAAO,UAAU,GACT,KAAK,MAAM,mBACnB,EAAO,4BAIT,kCAAiC,EAAW,EAAW,EAAK,CAE9D,GAAI,CAAC,KAAK,WAAY,CAClB,EAAI,IAAI,UAAW,IACnB,KAAK,8BACL,OAEJ,EAAI,IAAI,KAAM,GACd,EAAI,IAAI,YAAa,GACrB,GAAI,CACA,KAAM,GAAU,KAAM,MAAK,WAAW,WAAW,KAAK,MAAM,GAAI,EAAW,GAC3E,GAAI,EAAS,CACT,GAAI,EAAQ,YAAc,EAAW,CACjC,EAAI,IAAI,mBAAoB,EAAQ,WACpC,EAAI,SAAW,EAAI,MAAM,KACzB,OAEJ,GAAI,GAAe,GACf,EACJ,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CAAC,KAAK,SAAS,WAAW,uBACvE,GAAI,CACA,EAAe,KAAM,MAAK,kBAAkB,aAAa,EAAS,GAClE,EAAI,IAAI,WAAY,GAChB,GACA,GAAgB,EAAQ,gBAEvB,EAAP,CACE,QAAI,QACE,EAEV,KAAM,GAAI,WACN,GACA,KAAM,GAAI,KAAK,kBAAmB,GAAO,KAAK,MAAM,cAAc,EAAS,GAAiB,GAAI,WAGnG,EAAP,CACE,AAAM,EAAI,OAAS,mBAAqB,EAAI,UAAY,cAGpD,GAAI,MAAQ,EACZ,EAAI,SAAW,EAAI,MAAM,OAHzB,EAAI,IAAI,YAAa,KAajC,yBAAyB,EAAS,EAAK,CACnC,MAAO,MAAK,kBAAkB,yBAAyB,KAAK,MAAM,GAAI,EAAQ,UAAW,EAAQ,UAAW,QAI1G,0BAAyB,EAAO,EAAK,OACvC,GAAI,WAAK,uBAAL,cAA2B,WAAY,IAG3C,MAAK,qBAAuB,KAAK,OAAO,gBACxC,GAAI,CACA,KAAK,iBAAoB,UAAY,OACjC,KAAM,GAAiB,KAAM,MAAK,kBAAkB,sBAAsB,KAAK,MAAM,GAAI,KAAK,mBAC9F,AAAI,GACA,SAAK,aAAL,QAAiB,MAAM,GACvB,KAAM,GAAI,KAAK,YAAa,GAAO,KAAK,iBAAiB,EAAgB,EAAO,SAGxF,KAAM,MAAK,yBAEX,KAAK,iBAAmB,YAI1B,SAAQ,EAAM,EAAS,EAAO,EAAK,OAGrC,AAAI,KAAK,kBACL,GAAI,IAAI,yBAA0B,IAClC,KAAM,MAAK,kBAEf,KAAM,GAAe,KAAM,GAAI,KAAK,iBAAkB,IAAM,KAAK,kBAAkB,QAAQ,KAAK,MAAM,GAAI,EAAM,EAAS,KAAK,oBAC9H,MAAI,GAAa,gBACb,SAAK,aAAL,QAAiB,MAAM,GACvB,KAAM,GAAI,KAAK,YAAa,GAAO,KAAK,iBAAiB,EAAa,eAAgB,EAAO,KAE1F,CACH,KAAM,GACN,QAAS,EAAa,SAI9B,iBAAiB,EAAe,CAC5B,SAAW,KAAK,GAAc,SAC1B,GAAI,EAAE,UACF,MAAO,GAGf,MAAO,QAGL,kBAAiB,EAAgB,EAAO,EAAK,CAC/C,GAAI,GAAa,KAAM,MAAK,SAAS,aAAa,CAAC,KAAK,SAAS,WAAW,aACxE,EACJ,GAAI,CACA,EAAY,KAAK,4BAA4B,EAAgB,KAAM,SAC9D,EAAP,CACE,QAAW,QACL,EAKV,KAAM,MAAK,8BAA8B,EAAW,EAAO,QAGzD,wCAAuC,EAAoB,EAAK,EAAK,CACvE,KAAM,GAAU,EAAmB,OAAO,GAAK,EAAE,WAAW,IAAI,GAAK,EAAE,QACjE,EAAiB,KAAM,MAAK,kBAAkB,qBAChD,KAAK,MAAM,GAAI,GACnB,MAAI,GACA,GAAI,IAAI,CACJ,EAAG,4BAA6B,UAChC,GAAI,EAAe,WACnB,YAAa,EAAe,cAEhC,KAAK,4BAA4B,EAAgB,EAAS,GACnD,IAEJ,QAGL,2BAA0B,EAAO,EAAY,EAAK,CAEpD,GAAI,MAAK,yBAGT,MAAK,yBAA2B,GAChC,GAAI,CACA,AAAK,GAED,GAAa,KAAM,AADP,MAAM,MAAK,SAAS,QAAQ,CAAC,KAAK,SAAS,WAAW,cAC3C,WAAW,qBAAqB,iBAAkB,KAAK,MAAM,KAExF,SAAW,KAAa,GAEpB,AAAI,EAAU,OAAS,kBAGvB,KAAM,GAAI,KAAK,YAAa,GAAO,KAAK,8BAA8B,EAAW,EAAO,YAG5F,KAAK,yBAA2B,KAIxC,4BAA4B,EAAgB,EAAS,EAAK,CAEtD,KAAM,GAAY,CACd,GAFO,KAAK,MAAM,KAAK,SAAW,OAAO,kBAAkB,WAG3D,KAAM,iBACN,MAAO,KAAK,MAAM,GAClB,UACA,kBAEJ,SAAI,WAAW,IAAI,GACZ,OAGL,+BAA8B,EAAW,EAAO,EAAK,CACvD,EAAI,IAAI,KAAM,EAAU,IAExB,KAAM,MAAK,eAAe,UAAU,KAAK,MAAO,GAChD,GAAI,GACJ,GAAI,EAAU,UAAY,KAAM,CAC5B,EAAU,KAAM,MAAK,eAAe,sBAAsB,KAAK,MAAM,GAAI,EAAO,GAChF,KAAM,GAAU,MAAM,KAAK,EAAQ,OAAO,CAAC,EAAK,IAAW,EAAI,IAAI,EAAO,QAAS,GAAI,OACvF,EAAU,QAAU,EACpB,KAAM,MAAK,uBAAuB,GAAc,EAAW,OAAO,QAElE,GAAU,KAAM,MAAK,eAAe,sBAAsB,KAAK,MAAM,GAAI,EAAU,QAAS,EAAO,GAGvG,KAAM,GAAW,KAAM,GAAI,KAAK,cAAe,GAAO,KAAK,eAAe,QACtE,aAAc,EAAU,eAAgB,EAAS,EAAO,IACtD,EAAiB,EAAQ,OAAO,GAAK,CAAC,EAAS,KAAK,GAAK,EAAE,SAAW,IAC5E,KAAM,GAAI,KAAK,OAAQ,GAAO,KAAK,uBAAuB,GAAgB,EAAU,EAAO,IACvF,EAAe,QACf,KAAM,GAAI,KAAK,iBAAkB,KAAM,IAAO,CAC1C,EAAI,IAAI,UAAW,EAAe,IAAI,GAAK,EAAE,WAC7C,KAAM,GAAgB,EAAU,QAAQ,OAAO,GAAU,EAAe,KAAK,GAAK,EAAE,SAAW,IAC/F,EAAI,IAAI,gBAAiB,GACzB,EAAU,QAAU,EAGpB,KAAM,MAAK,uBAAuB,GAAc,EAAW,OAAO,IAElE,KAAM,GAAkB,KAAK,kBAAkB,sBAAsB,EAAU,eAAgB,WAAY,kBAC3G,KAAM,MAAK,4BAA4B,+BAAgC,EAAiB,EAAgB,EAAO,KAGvH,KAAM,MAAK,uBAAuB,GAAc,EAAW,OAAO,EAAU,UAG1E,wBAAuB,EAAU,CACnC,KAAM,GAAW,KAAM,MAAK,SAAS,aAAa,CAAC,KAAK,SAAS,WAAW,aAC5E,GAAI,CACA,EAAS,EAAS,kBACb,EAAP,CACE,QAAS,QACH,EAEV,KAAM,GAAS,gBAGb,6BAA4B,EAAM,EAAS,EAAS,EAAO,EAAK,CAClE,KAAM,GAAgB,GAAQ,EAAS,GAAU,EAAO,QAClD,EAAU,CACZ,SAAU,MAAM,KAAK,EAAc,WAAW,OAAO,CAAC,EAAS,CAAC,EAAQ,KACpE,GAAQ,GAAU,EAAQ,OAAO,CAAC,EAAW,IACzC,GAAU,EAAO,UAAY,EACtB,GACR,IACI,GACR,KAED,EAAQ,KACd,KAAM,GAAM,aAAa,EAAM,EAAS,EAAO,CAAC,QAAM,gBAGpD,wBAAuB,EAAM,EAAU,EAAO,EAAK,CACrD,EAAI,IAAI,WAAY,EAAS,QAC7B,KAAM,GAAiB,GAAQ,EAAU,GAAW,EAAQ,OAAO,QAC7D,EAAU,CACZ,SAAU,MAAM,KAAK,EAAe,WAAW,OAAO,CAAC,EAAS,CAAC,EAAQ,KACrE,GAAQ,GAAU,EAAS,OAAO,CAAC,EAAW,IAC1C,GAAU,EAAQ,OAAO,UAAY,EAAQ,QACtC,GACR,IACI,GACR,KAED,EAAQ,KACd,KAAM,GAAM,aAAa,EAAM,EAAS,EAAO,CAAC,QAAM,WAG1D,qCAAqC,EAAS,EAAM,CAChD,MAAO,GAAQ,OAAO,GAAS,SAC3B,GAAI,EAAM,aAAe,CAAC,EAAM,YAAa,CACzC,KAAM,CAAC,SAAS,EAChB,GAAI,EAAO,CACP,KAAM,GAAY,KAAM,UAAN,cAAgB,WAC5B,EAAY,KAAM,UAAN,cAAgB,WAClC,MAAO,GAAK,KAAK,GAAO,IAAc,EAAI,WAAa,IAAc,EAAI,YAGjF,MAAO,KAIf,SAAU,CACN,KAAK,UAAY,IAQzB,QAA4B,CACxB,YAAY,EAA6B,EAAa,EAAQ,EAAgB,EAAQ,CAClF,KAAK,6BAA+B,EACpC,KAAK,aAAe,EACpB,KAAK,QAAU,EACf,KAAK,gBAAkB,EACvB,KAAK,QAAU,OAGb,UAAU,CACZ,MAAO,IAAI,IACP,KAAM,MAAK,6BAA6B,UACxC,KAAK,aACL,KAAK,QACL,KAAK,gBACL,KAAK,SAGb,SAAU,CACN,KAAK,6BAA6B,WAI1C,QAAwB,CACpB,YAAY,EAAyB,EAAa,EAAQ,EAAgB,EAAQ,CAC9E,KAAK,yBAA2B,EAChC,KAAK,aAAe,EACpB,KAAK,QAAU,EACf,KAAK,gBAAkB,EACvB,KAAK,QAAU,OAGb,OAAM,EAAK,EAAK,CAClB,KAAM,CAAC,UAAS,UAAU,KAAM,MAAK,yBAAyB,MAAM,GACpE,UAAS,KAAK,aAAc,GAC5B,KAAM,MAAK,gBAAgB,0BAA0B,KAAK,QAAS,EAAS,EAAQ,KAAK,QAAS,EAAK,GAChG,GAAI,IAAsB,EAAS,EAAQ,KAAK,kBAI/D,QAA4B,CACxB,YAAY,EAAS,EAAQ,EAAgB,CACzC,KAAK,QAAU,EACf,KAAK,OAAS,EACd,KAAK,gBAAkB,EAG3B,eAAe,EAAS,CACpB,SAAW,KAAS,GAAS,CACzB,KAAM,GAAS,KAAK,QAAQ,IAAI,EAAM,IACtC,GAAI,EACA,EAAM,oBAAoB,OACvB,CACH,KAAM,GAAQ,KAAK,OAAO,IAAI,EAAM,IACpC,AAAI,GACA,EAAM,mBAAmB,KAMzC,cAAc,EAAK,CACf,MAAO,SAAQ,IAAI,MAAM,KAAK,KAAK,QAAQ,UAAU,IAAI,GAC9C,KAAK,gBAAgB,wBAAwB,EAAQ,cCvehD,CAAjB,aAlBP,WAmB0C,GAAI,UAEpC,UAAS,EAAuB,IAC9B,GAAO,KAAK,KAAK,IAAI,SACrB,QACM,GAAK,UAEJ,GAAI,MACN,eACA,KAAK,IAAI,EAAK,MAGlB,WAAY,KAAK,IAAM,SAEhB,UAAU,KAAK,IAAM,CACpB,EAAM,cACF,KAAK,OAAO,OAItB,WCdY,CAIvB,YAAY,CAAC,MAAK,YAA2C,MACpD,KAAO,OACP,UAAY,OAGf,YAAW,EAAc,EAA+C,cACpE,GAAc,KAAM,GAAI,YAAY,IAAI,MAC1C,CAAC,cAGC,GAAgB,uBAAa,UAAb,cAAsB,YAAtB,cAAkC,KAAK,KAAK,OAC9D,CAAC,OACK,IAAI,OAAM,UAAU,EAAY,iCAAiC,KAAK,KAAK,SAGjF,KAAK,KAAK,YAAc,0CACjB,MAAM,MAAK,kBAAkB,EAAY,KAAM,QAEhD,IAAI,OAAM,iCAAiC,KAAK,KAAK,OAAO,KAAK,KAAK,kBAI9E,mBAAkB,EAAc,EAA+C,MAC3E,CAAC,SAAQ,QAAQ,KAAK,UAAU,SAEhC,EAAU,KAAM,MAAK,UAAU,OAAO,OAAO,KAC/C,KAAK,KAAK,UACV,GAAI,YAAW,GAAG,OAClB,EAAK,OAAO,GACZ,UACA,KAEE,EAAS,EAAQ,MAAM,EAAG,IAC1B,EAAU,EAAQ,MAAM,IACxB,EAAkB,EAAO,OAAO,EAAc,eAMhD,CAJe,KAAM,MAAK,UAAU,OAAO,KAAK,OAChD,EAAS,EAAO,OAAO,EAAc,KACrC,EAAiB,gBAGX,IAAI,OAAM,gBAGd,GAAiB,KAAM,MAAK,UAAU,OAAO,IAAI,WAAW,CAC9D,IAAK,EACL,GAAI,EAAO,OAAO,EAAc,IAChC,KAAM,UAGH,GAAK,OAAO,IC9B3B,KAAM,IAAa,cACb,GAAa,SAEZ,QAAc,CAEjB,YAAY,CAAC,UAAS,QAAO,cAAa,MAAK,YAAW,WAAU,mBAAkB,CAClF,KAAK,UAAY,EACjB,KAAK,SAAW,EAChB,KAAK,OAAS,EACd,KAAK,iBAAmB,EACxB,KAAK,UAAY,KACjB,KAAK,aAAe,EACpB,KAAK,OAAS,GAAI,IAClB,KAAK,oBAAsB,CAAC,EAAM,IAAW,KAAK,OAAO,OAAO,EAAK,GAAI,GACzE,KAAK,qBAAuB,GAAI,KAChC,KAAK,SAAW,GAAI,IACpB,KAAK,sBAAwB,CAAC,EAAQ,IAAW,KAAK,SAAS,OAAO,EAAO,GAAI,GACjF,KAAK,iCAAmC,CAAC,EAAK,IAAW,CACrD,AAAI,EAAI,YACJ,KAAK,mBAAmB,OAAO,EAAI,IAEnC,KAAK,mBAAmB,OAAO,EAAI,GAAI,IAG/C,KAAK,mBAAqB,GAAI,IAC9B,KAAK,MAAQ,GAAI,IAAK,EAAY,QAClC,KAAK,sBAAwB,GAAI,IAAqB,CAAC,YACvD,KAAK,KAAO,EACZ,KAAK,SAAW,KAChB,KAAK,aAAe,KACpB,KAAK,eAAiB,KACtB,KAAK,eAAiB,KACtB,KAAK,WAAa,KAClB,KAAK,kBAAoB,KACzB,KAAK,kBAAoB,KACzB,KAAK,cAAgB,IAAM,KAAK,UAChC,KAAK,WAAa,EAClB,KAAK,WAAa,GAAI,GAAgB,QACtC,KAAK,oBAAsB,GAAI,KAE3B,GACA,MAAK,SAAW,GAAI,GAAI,QACxB,KAAK,eAAiB,GAAI,IAAc,CACpC,UACA,aAAc,KAAK,cACnB,QAAS,KAAK,SACd,UAAW,EAAY,OACvB,YAAa,EAAY,YAGjC,KAAK,sBAAwB,KAAK,sBAAsB,KAAK,MAC7D,KAAK,oBAAsB,KAAK,oBAAoB,KAAK,MACzD,KAAK,eAAiB,GAAI,GAAgB,OAG1C,iBAAiB,OACjB,MAAO,QAAK,eAAL,cAAmB,aAAa,WAGvC,sBAAsB,CACtB,MAAO,MAAK,wBAGZ,WAAW,CACX,MAAO,MAAK,aAAa,YAGzB,SAAS,CACT,MAAO,MAAK,aAAa,OAI7B,kBAAmB,CAGf,KAAM,GAAgB,GAAI,IACpB,EAAgB,GAAIC,IAAc,CACpC,QAAS,KAAK,aACd,UAAW,GACX,IAAK,KAAK,KACV,QAAS,KAAK,SACd,IAAK,KAAK,UAAU,MAAM,IAC1B,UAAW,KAAK,MAAM,GACtB,kBAEJ,KAAK,eAAiB,GAAIC,IAAc,CACpC,QAAS,KAAK,aACd,UAAW,GACX,IAAK,KAAK,KACV,QAAS,KAAK,SACd,IAAK,KAAK,UAAU,MAAM,IAC1B,UAAW,KAAK,MAAM,GACtB,QAAS,KAAK,SACd,kBAEJ,KAAK,WAAa,GAAIC,IAAgB,KAAK,KAAM,GAAY,IAC7D,KAAK,kBAAoB,GAAIC,IAAiB,CAC1C,QAAS,KAAK,aACd,UAAW,GACX,IAAK,KAAK,KACV,QAAS,KAAK,SACd,UAAW,KAAK,WAChB,IAAK,KAAK,UAAU,MAAM,IAC1B,YAAa,KAAK,aAAa,WAEnC,KAAK,kBAAoB,GAAIC,IAAiB,KAAK,WAAY,KAAK,YACpE,KAAK,sBAAsB,iBAAiB,CAAC,gBAAe,iBAAkB,KAAK,oBAGvF,sBAAsB,EAAM,EAAkB,OAS1C,GAAI,CAAC,KAAK,eACN,KAAM,IAAI,OAAM,mEAGpB,MAAI,GAAiB,YAAc,EACxB,KAEJ,GAAI,IAAe,CACtB,OACA,cAAe,KAAK,eACpB,cAAe,KAAK,eACpB,iBAAkB,KAAK,kBACvB,iBAAkB,KAAK,kBACvB,QAAS,KAAK,SACd,UAAW,QAAK,aAAL,cAAiB,MAC5B,mBACA,2BAA4B,IAAM,CAC9B,AAAK,KAAK,WAAW,OACjB,KAAK,eAAe,IAAI,KAGhC,MAAO,KAAK,UAAU,QAY9B,oBAAoB,EAAM,EAAY,EAAM,OAAW,CACnD,MAAO,MAAK,UAAU,OAAO,UAAU,EAAK,wBAAyB,KAAM,IAAO,CAC9E,GAAI,CAAC,KAAK,KACN,KAAM,IAAI,OAAM,gBAEpB,AAAI,KAAK,WAAW,OAChB,MAAK,WAAW,MAAM,UACtB,KAAK,WAAW,IAAI,OAExB,KAAM,GAAM,KAAMC,IAAsB,EAAM,EAAY,KAAK,SAAU,KAAK,UAAW,KAAK,MAExF,EAAU,KAAM,MAAK,SAAS,QAAQ,CACxC,KAAK,SAAS,WAAW,cAE7B,GAAI,KAAM,MAAK,iBAAiB,EAAK,EAAS,GAG1C,YAAM,MAAK,cAAc,EAAK,GAC9B,KAAK,WAAW,MAAM,MAAM,GACrB,EAEP,KAAM,IAAI,OAAM,uDAKtB,eAAc,EAAK,EAAK,CAI1B,KAAM,GAAY,KAAK,WAAW,MAClC,GAAI,CAAC,EACD,OAEJ,KAAM,GAAgB,EAAU,QAC1B,EAAW,KAAM,MAAK,SAAS,aAAa,CAC9C,KAAK,SAAS,WAAW,QACzB,KAAK,SAAS,WAAW,uBAE7B,GAAI,CACA,KAAM,GAAwB,KAAMC,IAAa,EAAK,EAAe,GAGrE,GAFA,EAAI,IAAI,wBAAyB,GACjC,EAAI,IAAI,gBAAiB,GACrB,CAAC,CAAC,GAAyB,IAA0B,EAAe,CACpE,KAAM,GAAe,KAAM,GAAU,iBAAiB,GACtD,EAAI,IAAI,wBAAyB,UAEhC,EAAP,CACE,QAAS,QACH,EAEV,KAAM,GAAS,gBAGb,uBAAuB,CACzB,KAAM,GAAW,KAAM,MAAK,SAAS,aAAa,CAC9C,KAAK,SAAS,WAAW,UAE7B,GAAI,CACAC,GAAc,SACT,EAAP,CACE,QAAS,QACH,EAGV,GADA,KAAM,GAAS,WACX,KAAK,WAAW,MAAO,CACvB,SAAW,KAAQ,MAAK,OAAO,SAC3B,AAAI,EAAK,aACL,EAAK,gBAAgB,QAG7B,KAAK,WAAW,MAAM,UACtB,KAAK,WAAW,IAAI,OAI5B,iBAAiB,EAAS,EAAK,EAAK,CAChC,MAAO,GAAI,KAAK,oBAAqB,KAAM,IAAO,CAC9C,GAAI,CACA,KAAM,GAAgB,GAAI,IAAc,CAAC,IAAK,EAAS,SAAU,KAAK,YAChE,EAAY,KAAM,IAAU,kBAC9B,KAAK,UACL,KAAK,KACL,EACA,KAAK,OACL,KAAK,WACL,KAAK,SACL,GAEJ,GAAI,EAAW,CACX,SAAW,KAAQ,MAAK,OAAO,SAC3B,AAAI,EAAK,aACL,EAAK,gBAAgB,GAG7B,YAAK,WAAW,IAAI,GACb,UAEN,EAAP,CACE,EAAI,MAAM,GAEd,MAAO,QASX,YAAY,CACZ,MAAO,MAAK,cAGZ,cAAc,CACd,MAAO,CAAC,CAAC,KAAK,kBAIZ,gBAAe,EAAK,CACtB,AAAI,KAAK,MACA,MAAK,cACN,MAAK,aAAe,KAAM,MAAK,kBAAkB,KAAK,aAAa,SAAU,KAAK,UAClF,EAAI,IAAI,OAAQ,KAAK,aAAa,cAClC,KAAK,oBAET,KAAM,MAAK,aAAa,qBAAqB,KAAK,SAAU,GAC5D,KAAM,GAAI,KAAK,aAAc,GAAO,KAAK,aAAa,WAAW,KAAK,SAAU,GAAO,UAKzF,mBAAkB,EAAkB,EAAK,CAE3C,MADA,GAAI,IAAI,WAAY,EAAiB,UACjC,AAAC,KAAK,KAIN,EAAiB,WAAa,KAAK,SACnC,GAAI,IAAI,eAAgB,IACjB,IAEP,KAAK,aACL,GAAI,IAAI,wBAAyB,IAC1B,IAEN,KAAM,GAAiB,MAAM,KAAK,OAAQ,GAI/C,MAAK,aAAe,KAAMC,IAAY,sBAAsB,CACxD,mBACA,MAAO,KAAK,OACZ,IAAK,KAAK,KACV,UAAW,GACX,OAAQ,KAAK,aAAa,OAC1B,UAAW,KAAK,WAChB,SAAU,KAAK,SACf,QAAS,KAAK,WAElB,EAAI,IAAI,OAAQ,KAAK,aAAa,cAClC,KAAK,mBACE,IAfH,GAAI,IAAI,kBAAmB,IACpB,IAbP,GAAI,IAAI,SAAU,IACX,IA6Bf,kBAAkB,EAAU,EAAU,OAAW,CAE7C,MAAOA,IAAY,OAAO,CACtB,MAAO,KAAK,OACZ,IAAK,KAAK,KACV,UAAW,GACX,OAAQ,KAAK,aAAa,OAC1B,UAAW,KAAK,WAChB,WACA,YAIR,sBAAsB,EAAK,EAAM,KAAM,CACnC,MAAO,MAAK,UAAU,OAAO,UAAU,EAAK,wBAAyB,KAAM,IAAO,CAC9E,KAAM,GAAqB,KAAM,MAAK,kBAAkB,kBACxD,GAAI,CACA,KAAM,GAAW,KAAM,IACnB,EAAoB,KAAK,OAAQ,EAAK,oBAAqB,GAC/D,SAAI,IAAI,WAAY,GACb,UAEP,EAAmB,kBAMzB,MAAK,EAAK,CACZ,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,CACpC,KAAK,SAAS,WAAW,QACzB,KAAK,SAAS,WAAW,YACzB,KAAK,SAAS,WAAW,QACzB,KAAK,SAAS,WAAW,YACzB,KAAK,SAAS,WAAW,eACzB,KAAK,SAAS,WAAW,kBACzB,KAAK,SAAS,WAAW,gBAG7B,KAAK,UAAY,KAAM,GAAI,QAAQ,IAAI,QAEnC,KAAK,MACL,MAAK,aAAe,KAAMA,IAAY,KAAK,CACvC,MAAO,KAAK,OACZ,IAAK,KAAK,KACV,UAAW,GACX,OAAQ,KAAK,aAAa,OAC1B,SAAU,KAAK,aAAa,SAC5B,UAAW,KAAK,WAChB,QAEA,KAAK,cACL,GAAI,IAAI,OAAQ,KAAK,aAAa,cAClC,KAAK,qBAGb,KAAM,GAAwB,KAAM,MAAK,wBAAwB,GAE3D,EAAU,KAAM,GAAI,QAAQ,SAC5B,EAAoB,QAAQ,IAAI,EAAQ,IAAI,KAAM,IAAc,CAClE,KAAM,GAAS,KAAK,aAAa,EAAW,QAC5C,EAAI,KAAK,SAAU,GAAO,EAAO,KAAK,EAAY,IAClD,KAAK,SAAS,IAAI,EAAO,GAAI,MAG3B,EAAQ,KAAM,GAAI,YAAY,SAC9B,EAAkB,QAAQ,IAAI,EAAM,IAAI,KAAM,IAAW,CAC3D,KAAM,GAAO,KAAK,iBAAiB,EAAQ,OAAQ,EAAsB,IAAI,EAAQ,SACrF,KAAM,GAAI,KAAK,OAAQ,GAAO,EAAK,KAAK,EAAS,EAAK,IACtD,KAAK,OAAO,IAAI,EAAK,GAAI,MAG7B,KAAM,SAAQ,IAAI,CAAC,EAAmB,IACtC,SAAW,CAAC,EAAQ,IAAW,MAAK,QAAS,CACzC,KAAM,GAAO,KAAK,MAAM,IAAI,GAC5B,AAAI,GACA,EAAK,UAAU,IAK3B,SAAU,aACN,QAAK,aAAL,QAAiB,UACjB,KAAK,WAAa,OAClB,QAAK,WAAW,QAAhB,QAAuB,UACvB,KAAK,WAAW,IAAI,QACpB,QAAK,oBAAL,QAAwB,UACxB,KAAK,kBAAoB,OACzB,QAAK,eAAL,QAAmB,UACnB,KAAK,aAAe,OACpB,SAAW,KAAQ,MAAK,OAAO,SAC3B,EAAK,UAET,KAAK,OAAS,YASZ,OAAM,EAAqB,EAAkB,EAAK,OACpD,GAAI,EAAqB,CAErB,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CACzC,KAAK,SAAS,WAAW,UAE7B,EAAI,QAAQ,IAAI,iBAAkB,GAElC,KAAM,GAAI,WAGd,GAAI,CAAC,KAAK,WAAW,MAAO,CACxB,AAAI,GACA,KAAM,GAAI,KAAK,iCAAkC,KAAM,IAAO,CAC1D,KAAM,GAAU,KAAMC,IAAqC,EAAiB,IAAK,KAAK,SAAU,KAAK,WACrG,AAAI,GACA,GAAI,IAAI,UAAW,IACnB,KAAM,MAAK,cAAc,MAIrC,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,CACpC,KAAK,SAAS,WAAW,QACzB,KAAK,SAAS,WAAW,cAGvB,EAAU,KAAMC,IAAY,GAClC,AAAI,GAEI,KAAM,MAAK,iBAAiB,EAAS,EAAK,IAC1C,SAAK,WAAW,QAAhB,QAAuB,MAAM,IAGhC,KAAK,WAAW,OAGjB,KAAK,WAAW,IAAI,MAO5B,KAAM,GAAa,KAAM,AAHV,MAAM,MAAK,SAAS,aAAa,CAC5C,KAAK,SAAS,WAAW,cAEG,WAAW,SACrC,EAAoB,GAAQ,EAAY,GAAK,EAAE,OAErD,SAAW,KAAQ,MAAK,OAAO,SAAU,CACrC,GAAI,GACJ,KAAM,GAAiB,EAAkB,IAAI,EAAK,IAClD,AAAI,GACA,GAAuB,GAAQ,EAAgB,GAAK,EAAE,OAE1D,EAAK,MAAM,EAAsB,SAInC,yBAAwB,EAAK,CAE/B,MAAO,AADe,MAAM,GAAI,cAAc,UACzB,OAAO,CAAC,EAAQ,IAAO,CACxC,KAAM,GAAQ,EAAO,IAAI,EAAG,QAC5B,MAAI,GACA,EAAM,KAAK,GAEX,EAAO,IAAI,EAAG,OAAQ,CAAC,IAEpB,GACR,GAAI,SAGP,QAAQ,CACR,MAAO,MAAK,OAGhB,2BAA2B,EAAQ,CAC/B,SAAW,EAAE,IAAS,MAAK,OACvB,GAAI,EAAK,yBAAyB,GAC9B,MAAO,GAGf,SAAW,EAAE,IAAW,MAAK,SACzB,GAAI,EAAO,yBAAyB,GAChC,MAAO,GAMnB,iBAAiB,EAAQ,EAAe,CACpC,MAAO,IAAI,IAAK,CACZ,SACA,aAAc,KAAK,cACnB,QAAS,KAAK,SACd,qBAAsB,KAAK,oBAC3B,MAAO,KAAK,OACZ,gBAAiB,KAAK,iBACtB,gBACA,KAAM,KAAK,MACX,qBAAsB,KAAK,sBAC3B,SAAU,KAAK,YAKvB,oBAAoB,EAAQ,CACxB,KAAM,GAAO,GAAI,IAAa,CAC1B,SACA,aAAc,KAAK,cACnB,QAAS,KAAK,SACd,qBAAsB,IAAM,GAC5B,gBAAiB,IAAM,KAAK,qBAAqB,OAAO,GACxD,eAAgB,KAAK,oBACrB,MAAO,KAAK,OACZ,gBAAiB,KAAK,iBACtB,KAAM,KAAK,MACX,qBAAsB,KAAK,sBAC3B,SAAU,KAAK,YAEnB,YAAK,qBAAqB,IAAI,EAAQ,GAC/B,KAGP,UAAU,CACV,MAAO,MAAK,SAIhB,aAAa,EAAQ,CACjB,MAAO,IAAI,IAAO,CACd,SACA,MAAO,KAAK,OACZ,qBAAsB,KAAK,sBAC3B,gBAAiB,KAAK,iBACtB,KAAM,KAAK,MACX,SAAU,KAAK,eAInB,oBAAoB,CACpB,MAAO,MAAK,mBAGhB,WAAW,EAAS,CAChB,GAAI,GACJ,YAAK,UAAU,OAAO,YAAY,cAAe,KAAM,IAAO,CAC1D,KAAM,GAAK,SAAS,KAAK,MAAM,KAAK,UAAU,SAAW,OAAO,oBAChE,EAAmB,GAAI,IACnB,EAAI,EAAS,KAAK,iCAClB,KAAK,iBAAkB,KAAK,UAAW,GAC3C,KAAK,mBAAmB,IAAI,EAAI,GAChC,KAAM,GAAW,CAAC,EAAiB,OAAO,KAAK,OAAQ,IAEvD,AAAI,AADiB,EAAQ,eAAiB,IAE1C,EAAS,KAAK,EAAiB,aAAa,KAAK,OAAQ,IAE7D,KAAM,SAAQ,IAAI,GAGd,EAAiB,QACb,MAAK,MAAM,IAAI,EAAiB,SAChC,KAAK,4BAA4B,EAAiB,OAAQ,GAE9D,KAAM,GAAiB,+BAA+B,KAAK,MAAO,KAAK,SAAU,KAAK,OAAQ,MAG/F,OAGL,gBAAe,EAAc,OAC/B,KAAM,GAAiB,KAAa,YAAb,cAAwB,OAC/C,GAAI,MAAM,QAAQ,IAAmB,EAAe,OAChD,MAAO,MAAM,MAAK,sBAAsB,eAAe,QAIzD,aAAY,EAAc,EAAM,EAAK,EAAK,OAC5C,KAAM,GAAiB,KAAa,YAAb,cAAwB,OAC/C,GAAI,MAAM,QAAQ,IAAmB,EAAe,OAChD,MAAO,MAAM,GAAI,KAAK,aAAc,GAAO,KAAK,sBAAsB,YAAY,EAAgB,EAAM,EAAK,SAK/G,WAAU,EAAc,EAAc,EAAa,EAAK,EAAK,CAC/D,KAAM,GAAU,CACZ,SAAU,KACV,mBAAoB,MAElB,EAAY,EAAa,WAC/B,GAAI,IAAc,KAAK,UAAW,CAC9B,KAAM,GAAW,CAAC,MAAO,EAAW,SAAU,GAE9C,EAAI,QAAQ,IAAI,OAAQ,GACxB,EAAQ,SAAW,EAGvB,KAAM,GAAyB,EAAa,2BAC5C,AAAI,KAAK,cAAgB,GACrB,GAAQ,mBAAqB,KAAK,aAAa,UAAU,EAAwB,EAAK,IAG1F,KAAM,GAAc,EAAa,aACjC,AAAI,KAAK,gBAAkB,MAAM,QAAQ,iBAAa,UAAY,EAAY,QAAQ,QAClF,KAAM,GAAI,KAAK,cAAe,GAAO,KAAK,eAAe,mBAAmB,EAAY,QAAS,EAAK,IAGtG,GACA,GAAQ,eAAiB,KAAM,GAAI,KAAK,aAAc,GAAO,KAAK,sBAAsB,UAAU,EAAa,EAAK,KAIxH,KAAM,GAAc,EAAa,aACjC,GAAI,MAAM,QAAQ,iBAAa,QAC3B,SAAW,KAAS,GAAY,OAC5B,AAAI,MAAO,GAAM,MAAS,UACtB,EAAI,YAAY,IAAI,GAIhC,MAAO,GAIX,UAAU,CAAC,WAAU,sBAAqB,CACtC,AAAI,GAEA,MAAK,UAAY,GAEjB,KAAK,cACL,KAAK,aAAa,UAAU,QAK9B,oBAAmB,EAAS,EAAe,EAAK,OAKlD,AAAK,GAEG,AADsB,KAAM,MAAK,aAAa,qBAAqB,KAAK,SAAU,IAElF,KAAM,GAAI,KAAK,aAAc,GAAO,KAAK,aAAa,WAAW,KAAK,SAAU,GAAO,IAG3F,EAAQ,gBACR,SAAK,WAAW,QAAhB,QAAuB,MAAM,IAIrC,4BAA4B,EAAQ,EAAK,CACrC,SAAW,EAAE,IAAqB,MAAK,mBACnC,GAAI,EAAiB,SAAW,EAAQ,CACpC,KAAM,GAAmB,KAAK,oBAAoB,IAAI,EAAiB,IACvE,AAAI,GACA,GAAI,IAAI,gCACJ,IAAI,UAAW,EAAiB,IAChC,IAAI,SAAU,EAAiB,QACnC,EAAiB,IAAI,EAAiB,MAAQ,EAAW,WAE7D,EAAiB,UACjB,KAAK,mBAAmB,OAAO,EAAiB,IAChD,QAKZ,oCAAoC,EAAc,EAAY,EAAoB,EAAK,SAEnF,SAAW,KAAM,GACb,AAAI,EAAG,UACH,MAAK,OAAO,IAAI,EAAG,GAAI,EAAG,MAC1B,KAAK,4BAA4B,EAAG,GAAI,IACjC,EAAG,cACV,KAAK,OAAO,OAAO,EAAG,IAG9B,SAAW,KAAM,GACb,AAAI,EAAG,UACH,KAAK,SAAS,IAAI,EAAG,GAAI,EAAG,QACrB,EAAG,cACV,KAAK,SAAS,OAAO,EAAG,IAMhC,GAAI,KAAK,oBAAoB,OAAS,EAAG,CACrC,SAAW,KAAO,GACd,AAAI,EAAI,WACJ,SAAK,oBAAoB,IAAI,EAAI,MAAjC,QAAsC,IAAI,EAAW,WAG7D,SAAW,KAAM,GACb,AAAI,EAAG,WACH,SAAK,oBAAoB,IAAI,EAAG,MAAhC,QAAqC,IAAI,EAAW,SAG5D,SAAW,KAAM,GAAc,CAC3B,KAAM,GAAmB,KAAK,oBAAoB,IAAI,EAAG,IACzD,GAAI,EAAkB,CAClB,KAAM,GAAc,EAAiB,MAAQ,EAAW,QACxD,GAAI,EAAG,UACH,EAAiB,IAAI,WACd,EAAG,aAAc,CACxB,KAAM,GAAiB,EAAc,EAAW,QAChD,EAAiB,IAAI,OAOzC,oBAAoB,EAAQ,CACxB,KAAM,GAAmB,KAAK,oBAAoB,IAAI,GACtD,AAAI,GACA,EAAiB,IAAK,GAAiB,MAAQ,EAAW,UAAY,EAAW,aAKrF,YAAY,OACZ,MAAO,QAAK,YAAL,cAAgB,SAIvB,eAAe,OACf,MAAO,QAAK,YAAL,cAAgB,YAGvB,OAAO,CACP,MAAO,MAAK,SAGZ,kBAAkB,CAClB,MAAO,MAAK,iBAGhB,wBAAwB,EAAQ,CAC5B,MAAI,GACO,KAAK,cAEL,KAAK,oBAId,cAAc,CAChB,MAAO,MAAK,UAAU,OAAO,IAAI,aAAc,KAAM,IAAO,CACxD,KAAM,GAAiB,GAAO,qBAAqB,KAAK,aAAa,IAC/D,EAAS,KAAM,MAAK,UAAU,oBAAoB,WAAW,GAAQ,GAC3E,GAAI,CAAC,EACD,SAAI,IAAI,YAAa,IACd,GAEX,KAAM,GAAO,OAAO,KAAK,OAAQ,GAGjC,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CAAC,KAAK,SAAS,WAAW,UACvE,SAAI,QAAQ,IAAI,GAAY,EAAO,aACnC,KAAM,GAAI,WACH,UAKT,eAAe,CACjB,MAAO,MAAK,UAAU,OAAO,IAAI,cAAe,KAAM,IAAO,CACzD,KAAM,MAAK,UAAU,oBAAoB,cAEzC,KAAM,GAAa,KAAM,AADT,MAAM,MAAK,SAAS,QAAQ,CAAC,KAAK,SAAS,WAAW,WACrC,QAAQ,IAAI,IAC7C,GAAI,CAAC,EAED,MAAO,GAGX,KAAM,AADS,IAAI,IAAO,GACb,QAAQ,KAAK,OAAQ,GAClC,KAAM,GAAM,KAAM,MAAK,SAAS,aAAa,CAAC,KAAK,SAAS,WAAW,UACvE,SAAI,QAAQ,OAAO,IACnB,KAAM,GAAI,WACH,UAIT,8BAA8B,CAChC,MAAK,MAAM,MAAK,UAAU,oBAAoB,gBAKvC,CAAC,CADW,KAAM,AADT,MAAM,MAAK,SAAS,QAAQ,CAAC,KAAK,SAAS,WAAW,WACrC,QAAQ,IAAI,IAHlC,QAOT,iCAAiC,CAEnC,KAAM,GAAa,KAAM,AADT,MAAM,MAAK,SAAS,QAAQ,CAAC,KAAK,SAAS,WAAW,WACrC,QAAQ,IAAI,IAC7C,GAAI,CAAC,EACD,MAAO,GAEX,KAAM,GAAW,GAAI,IAAO,GACtB,EAAoB,KAAM,MAAK,OAAO,aAAa,WAEzD,MAAO,AADgB,mBAAmB,UAAW,IAAI,IAAI,GAAQ,GAAI,IAAO,IAC3D,KAAK,GAAK,EAAE,OAAO,SAGtC,eAAc,EAAQ,CAExB,GADuB,CAAC,CAAC,KAAK,mBAAmB,IAAI,GAEjD,MAAO,GAAW,aAGtB,GADiB,CAAC,CAAC,KAAK,OAAO,IAAI,GAE/B,MAAO,GAAW,OACf,CACH,KAAM,GAAY,CAAC,CAAC,KAAK,SAAS,IAAI,GAEhC,EAAa,KAAM,AADb,MAAM,MAAK,SAAS,QAAQ,CAAC,KAAK,SAAS,WAAW,uBACrC,oBAAoB,IAAI,GACrD,MAAI,IAAa,EACN,EAAW,QAAU,EAAW,SAChC,EACA,EAAW,QACX,EACA,EAAW,SAEX,EAAW,WAKxB,mBAAkB,EAAQ,CAC5B,GAAI,GAAa,KAAK,oBAAoB,IAAI,GAC9C,GAAI,CAAC,EAAY,CACb,KAAM,GAAS,KAAM,MAAK,cAAc,GACxC,EAAa,GAAI,IAAwB,EAAQ,IAAM,CACnD,KAAK,oBAAoB,OAAO,KAGpC,KAAK,oBAAoB,IAAI,EAAQ,GAEzC,MAAO,GAUX,+BAA+B,EAAQ,CACnC,GAAI,GAAe,KAAK,qBAAqB,IAAI,GACjD,MAAI,GACA,EAAa,SAEb,EAAe,KAAK,oBAAoB,GAErC,EAGX,iBAAiB,EAAQ,EAAM,KAAM,CACjC,MAAO,MAAK,UAAU,OAAO,UAAU,EAAK,mBAAoB,KAAM,IAAO,CACzE,EAAI,IAAI,KAAM,GACd,KAAM,GAAqB,KAAK,qBAAqB,IAAI,GACzD,GAAI,EACA,SAAmB,SACZ,EAEX,KAAM,GAAM,KAAM,MAAK,SAAS,QAAQ,CACpC,KAAK,SAAS,WAAW,oBACzB,KAAK,SAAS,WAAW,cAEvB,EAAU,KAAM,GAAI,oBAAoB,IAAI,GAClD,GAAI,EAAS,CACT,KAAM,GAAO,KAAK,oBAAoB,GACtC,YAAM,GAAK,KAAK,EAAS,EAAK,GACvB,KAKnB,SAAS,EAAe,EAAM,KAAM,CAChC,MAAO,MAAK,UAAU,OAAO,UAAU,EAAK,WAAY,KAAM,IAEnD,AADM,MAAM,MAAK,OAAO,cAAc,EAAe,CAAC,QAAM,YACvD,kBCh6BiC,CAKrD,YAAY,CAAC,WAAU,WAAU,cAAuE,MAC/F,UAAY,OACZ,UAAY,OACZ,WAAa,OAGhB,OAAM,EAAsB,EAAoB,EAA6C,OACxF,MAAM,GAAM,cAAc,KAAK,UAAW,KAAK,UAAW,EAAY,CAAC,QAAM,oBCXtC,CAIlD,YAAY,CAAE,aAAY,cAAyD,MAC1E,WAAa,OACb,YAAc,OAGjB,OAAM,EAAsB,EAAoB,EAA6C,OACxF,MAAM,GAAM,WAAW,KAAK,YAAa,KAAa,EAAY,CAAC,QAAM,oBCf7D,CAGvB,YAAY,EAAoB,MACvB,YAAc,KAGnB,aAAqB,OAAS,MAAK,YAEvC,qBAAqB,EAA2B,OACrC,GAAG,KAAK,gEAAgE,aCR3C,CAKxC,YAAY,EAAiB,EAA6B,MACjD,SAAW,OACX,QAAU,EAenB,aAAa,EAA8B,MAClC,WAAa,KAGlB,YAAmC,OAC5B,MAAK,4BC1BW,GAAsB,CACjD,4BAAiD,OACtC,CACH,QAAS,KAAK,SACd,KAAM,KAAK,SAIf,OAAe,OACR,iCCTgB,GAAsB,CACjD,4BAAiD,OACtC,CACH,QAAS,KAAK,SACd,KAAM,KAAK,SAKf,OAAe,OACR,mBAGP,gBAAgB,aACT,QAAK,UAAL,cAAc,SAAS,kBAG9B,iBAAiB,aACV,QAAK,UAAL,cAAc,SAAS,0BCNZ,CAMtB,YAAY,EAAsB,EAAgC,EAA6B,MACtF,OAAS,OACT,gBAAkB,OAClB,cAAgB,aAA0B,EAAM,QAGnD,QAAwC,MACpC,GAAW,KAAM,MAAK,OAAO,SAC/B,KAAK,gBAAgB,SACrB,KAAK,gBAAgB,SACrB,KAAK,gBAAgB,yBACrB,OACA,KAAK,gBAAgB,cAAc,iBAChC,MAAK,wBAAwB,QAQlC,aAAY,EAA0E,MAClF,GAAO,EAAM,6BACb,CAAE,WAAU,WAAU,2BAA0B,gBAAiB,KAAK,gBACtE,EAAU,KAAK,OAAO,SAAS,EAAU,EAAU,EAA0B,EAAM,GACnF,EAAW,KAAM,GAAQ,WACzB,EAAS,KAAM,GAAQ,eACvB,EAA6C,SAAK,GAAL,CAAe,iBAC3D,MAAK,0BAA0B,EAAsB,GAGxD,wBAAwB,EAAqE,MAC3F,CAAE,UAAS,UAAW,EACtB,EAAO,KAAK,cAAc,EAAS,UACrC,CAAC,OACK,IAAI,OAAM,4CAEhB,GACA,WACO,KAAS,GAAK,OAAQ,MACvB,GAAoB,KAAK,yBAAyB,EAAO,EAAS,GACnE,KAIU,aAAa,KACZ,MAJC,IACD,SAMb,QAGG,2BAA0B,EAAgC,EAAqC,cACjG,EAAS,YACR,UACI,aAAe,aAEnB,QACG,KAAS,YAAT,cAAoB,SAAS,EAAa,YACnC,GAAa,eAGd,IAAI,OAAM,uCAKxB,yBAAyB,EAAc,EAAiB,EAA6B,QACjF,OACC,sBACM,IAAI,IAAU,EAAS,iBAAS,QACtC,sBACM,IAAI,IAAU,EAAS,iBAAS,iBAEjC,IAAI,OAAM,kBAAkB,SAI1C,cAAuD,OAChD,MAAK,cClFb,KAAM,GAAa,GACtB,aACA,QACA,cACA,eACA,eACA,UACA,eACA,YACA,YACA,QACA,SAGS,GAAe,GACxB,aACA,cACA,WAGG,QAAa,CAChB,YAAY,EAAU,CAClB,KAAK,UAAY,EACjB,KAAK,6BAA+B,GACpC,KAAK,QAAU,GAAI,GAAgB,EAAW,YAC9C,KAAK,OAAS,KACd,KAAK,cAAgB,KACrB,KAAK,aAAe,KACpB,KAAK,SAAW,KAChB,KAAK,MAAQ,KACb,KAAK,WAAa,KAClB,KAAK,SAAW,KAChB,KAAK,kBAAoB,KACzB,KAAK,YAAc,EAAS,UAC5B,KAAK,eAAiB,EAAS,gBAC/B,KAAK,cAAgB,OAGzB,oBAAqB,CACjB,MAAQ,MAAK,MAAM,KAAK,UAAU,SAAW,OAAO,kBAAmB,cAGvE,YAAY,CACZ,MAAO,MAAK,gBAGV,0BAAyB,EAAW,CACtC,AAAI,KAAK,QAAQ,QAAU,EAAW,YAGtC,MAAK,QAAQ,IAAI,EAAW,SAC5B,KAAM,MAAK,UAAU,OAAO,IAAI,eAAgB,KAAM,IAAO,CACzD,EAAI,IAAI,KAAM,GACd,GAAI,CACA,KAAM,GAAc,KAAM,MAAK,UAAU,mBAAmB,IAAI,GAChE,GAAI,CAAC,EACD,KAAM,IAAI,OAAM,uBAAyB,GAE7C,KAAM,MAAK,iBAAiB,EAAa,KAAM,GAC/C,EAAI,IAAI,SAAU,KAAK,QAAQ,aAC1B,EAAP,CACE,EAAI,MAAM,GACV,KAAK,OAAS,EACd,KAAK,QAAQ,IAAI,EAAW,WAKxC,mBAAmB,EAAS,EAAY,CAKpC,KAAM,GAAQ,EAAQ,MAChB,EAAS,CAAC,cAChB,SAAW,KAAQ,GACf,AAAI,EAAK,OAAS,mBACd,EAAO,SAAW,CAAC,EAAU,IAAa,GAAI,IAAoB,CAAC,aAAY,WAAU,aAExF,AAAI,EAAK,OAAS,eAAiB,EAAM,KAAK,GAAQ,EAAK,OAAS,iBACrE,EAAO,IAAM,GAAI,IAAe,GAE3B,EAAK,OAAS,iBACnB,GAAO,MAAQ,GAAc,GAAI,IAAiB,CAAC,aAAY,gBAGvE,MAAO,GAGX,WAAW,EAAY,CACnB,MAAO,IAAI,IAAmB,KAAM,IAAgB,CAChD,EAAa,KAAM,IAAiB,EAAY,CAAC,EAAK,IAC3C,EAAa,KAAK,UAAU,QAAQ,EAAK,KAEpD,KAAM,GAAQ,GAAI,IAAc,CAAC,aAAY,QAAS,KAAK,UAAU,UAC/D,EAAW,KAAM,GAAa,EAAM,iBAAiB,WAC3D,MAAO,MAAK,mBAAmB,EAAU,UAI3C,mBAAkB,EAAY,EAAU,EAAU,EAA0B,CAC9E,KAAM,GAAU,KAAK,UAAU,QACzB,EAAQ,GAAI,IAAc,CAAC,aAAY,YAM7C,MALqB,IAAI,IAAa,EAAO,CACzC,WACA,WACA,kCAKF,gBAAe,EAAa,CAAC,uBAAuB,GAAI,CAC1D,KAAM,GAAgB,KAAK,QAAQ,MACnC,AAAI,IAAkB,EAAW,aAC7B,IAAkB,EAAW,YAC7B,IAAkB,EAAW,OAGjC,MAAK,eACL,KAAM,MAAK,UAAU,OAAO,IAAI,QAAS,KAAM,IAAO,CAClD,KAAK,QAAQ,IAAI,EAAW,OAC5B,KAAM,GAAQ,KAAK,UAAU,MAC7B,GAAI,GACJ,GAAI,CACA,KAAM,GAAU,KAAK,UAAU,QACzB,EAAQ,GAAI,IAAc,CAAC,WAAY,EAAY,WAAY,YAC/D,EAAY,KAAM,GAAY,MAAM,EAAO,WAAY,GACvD,EAAY,KAAK,qBACvB,EAAc,CACV,GAAI,EACJ,SAAU,EAAU,UACpB,OAAQ,EAAU,QAClB,WAAY,EAAY,WACxB,WAAY,EAAY,WACxB,YAAa,EAAU,aACvB,SAAU,EAAM,OAEpB,EAAI,IAAI,KAAM,SACT,EAAP,CACE,KAAK,OAAS,EACd,AAAI,EAAI,OAAS,kBACb,CAAI,EAAI,UAAY,cAChB,KAAK,cAAgB,GAAa,YAElC,KAAK,cAAgB,GAAa,QAEtC,EAAI,IAAI,eAAgB,KAAK,eAC7B,KAAK,QAAQ,IAAI,EAAW,cACzB,AAAI,EAAI,OAAS,kBACpB,MAAK,cAAgB,GAAa,WAClC,KAAK,QAAQ,IAAI,EAAW,cAE5B,KAAK,QAAQ,IAAI,EAAW,OAEhC,OAEJ,GAAI,GACJ,AAAI,GACA,GAAmB,KAAM,MAAK,0BAA0B,EAAa,GACjE,GACA,GAAY,SAAW,EAAiB,WAGhD,KAAM,MAAK,UAAU,mBAAmB,IAAI,GAI5C,GAAI,CACA,KAAM,MAAK,iBAAiB,EAAa,EAAkB,GAC3D,EAAI,IAAI,SAAU,KAAK,QAAQ,aAC1B,EAAP,CACE,EAAI,MAAM,GAEV,WAAkB,UAClB,KAAK,OAAS,EACd,KAAK,QAAQ,IAAI,EAAW,gBAKlC,kBAAiB,EAAa,EAAkB,EAAK,CACvD,EAAI,IAAI,aAAc,KAAK,UAAU,SACrC,KAAM,GAAQ,KAAK,UAAU,MAC7B,KAAK,6BAA+B,GACpC,KAAK,QAAQ,IAAI,EAAW,SAC5B,KAAK,aAAe,GAAI,IAAY,CAChC,aAAc,KAAK,UAAU,aAC7B,WAAY,GAAI,IAAsB,EAAM,eAC5C,cAAe,EAAM,gBAEzB,KAAM,GAAQ,GAAI,IAAc,CAC5B,WAAY,EAAY,WACxB,YAAa,EAAY,YACzB,QAAS,KAAK,UAAU,QACxB,YAAa,KAAK,eAEtB,KAAK,WAAa,EAAY,GAC9B,KAAK,SAAW,KAAM,MAAK,UAAU,eAAe,OAAO,EAAY,GAAI,GAE3E,KAAM,GAAsB,CACxB,GAAI,EAAY,GAChB,SAAU,EAAY,SACtB,OAAQ,EAAY,OACpB,WAAY,EAAY,YAEtB,EAAM,KAAM,MAAK,YACvB,GAAI,GAAY,KAChB,AAAI,KAAK,gBACL,GAAY,KAAM,MAAK,gBAE3B,KAAK,kBAAoB,GAAI,IAAiB,CAAC,QAAO,UACtD,KAAK,kBAAkB,QACvB,KAAM,GAAkB,GAAI,IAAgB,CACxC,WAAY,EAAY,WACxB,SAAU,KAAK,YAoCnB,GAlCA,KAAK,SAAW,GAAI,IAAQ,CACxB,QAAS,KAAK,SACd,YAAa,EACb,MAAO,KAAK,kBAAkB,MAC9B,MACA,YACA,kBACA,SAAU,KAAK,YAEnB,KAAM,MAAK,SAAS,KAAK,GACzB,AAAI,EACA,MAAM,GAAI,KAAK,oBAAqB,GAAO,KAAK,SAAS,kBAAkB,EAAkB,IAC7F,KAAM,MAAK,SAAS,sBAAsB,EAAiB,IAAK,IACxD,KAAK,SAAS,aACtB,MAAK,QAAQ,IAAI,EAAW,cAC5B,KAAM,GAAI,KAAK,iBAAkB,GAAO,KAAK,SAAS,eAAe,KAGzE,KAAK,MAAQ,GAAI,IAAK,CAAC,MAAO,KAAK,kBAAkB,MAAO,QAAS,KAAK,SAAU,QAAS,KAAK,SAAU,OAAQ,KAAK,UAAU,SAEnI,KAAK,uBAAyB,KAAK,aAAa,iBAAiB,UAAU,GAAS,CAChF,AAAI,IAAU,GAAiB,QAC3B,KAAK,UAAU,OAAO,YAAY,YAAa,KAAM,IAAO,CAExD,KAAK,kBAAkB,QACvB,KAAK,MAAM,QACX,KAAK,6BAA+B,GACpC,KAAM,GAAI,EACV,EAAmB,OACnB,KAAM,GAAI,KAAK,gBAAiB,GAAO,KAAK,SAAS,MAAM,KAAK,aAAa,qBAAsB,EAAG,QAIlH,KAAM,GAAI,KAAK,kBAAmB,IAAM,KAAK,qBACzC,MAAK,aAGT,MAAK,QAAQ,IAAI,EAAW,OAMxB,CAAC,KAAK,8BAA8B,CACpC,KAAM,GAAuB,KAAM,GAAM,SAAS,CAAC,QAAS,IAAO,QAAM,WACzE,GAAI,KAAK,YACL,OAEJ,KAAM,GAAI,EACV,EAAmB,OAEnB,KAAM,GAAI,KAAK,gBAAiB,GAAO,KAAK,SAAS,MAAM,EAAsB,EAAG,UAItF,oBAAoB,CACtB,KAAK,MAAM,QACX,KAAK,QAAQ,IAAI,EAAW,WAE5B,KAAK,wBAA0B,KAAK,MAAM,OAAO,QAAQ,GAAK,OAC1D,MAAI,KAAM,EAAW,QAIV,SAAK,MAAM,QAAX,cAAkB,QAAS,kBAE/B,IAAM,EAAW,UAE5B,GAAI,CAEA,GADA,KAAM,MAAK,wBAAwB,QAC/B,KAAK,MAAM,OAAO,QAAU,EAAW,SAAW,KAAK,MAAM,MAC7D,KAAM,MAAK,MAAM,YAEhB,EAAP,CAEE,GAAI,EAAI,OAAS,aACb,OAEJ,KAAM,WAEN,KAAK,wBAA0B,MAIvC,0BAA0B,EAAa,EAAK,CACxC,MAAO,GAAI,KAAK,iBAAkB,KAAM,IAAO,OAC3C,KAAK,QAAQ,IAAI,EAAW,cAC5B,KAAM,GAAQ,GAAI,IAAc,CAC5B,WAAY,EAAY,WACxB,YAAa,EAAY,YACzB,QAAS,KAAK,UAAU,UAEtB,EAAM,KAAM,MAAK,YACvB,GAAI,GACJ,GAAI,CACA,EAA4B,KAAM,IAAoB,EAAO,EAAK,KAAK,UAAW,SAC7E,EAAP,CACE,GAAI,EAAI,OAAS,kBACb,EAAI,IAAI,gBAAiB,QAEzB,MAAM,GAGd,GAAI,EAA2B,CAC3B,GAAI,GACJ,KAAM,GAAqB,GAAI,SAAQ,GAAK,EAAqB,GACjE,KAAK,cAAgB,GAAI,IAAa,EAA2B,GACjE,KAAK,QAAQ,IAAI,EAAW,cAC5B,KAAM,GACN,KAAM,GAAmB,QAAK,gBAAL,cAAoB,kBAC7C,YAAK,cAAgB,KACd,QAKf,eAAe,CACf,MAAO,MAAK,iBAGZ,aAAa,CACb,MAAO,MAAK,WAGZ,YAAY,CACZ,MAAO,MAAK,UAGZ,eAAe,CACf,MAAO,MAAK,iBAIZ,OAAO,CACP,MAAO,MAAK,SAIZ,UAAU,CACV,MAAO,MAAK,YAGZ,cAAc,CACd,MAAO,MAAK,gBAGZ,cAAc,CACd,MAAO,CAAC,KAAK,aAGjB,YAAY,EAAW,CACnB,MAAO,MAAK,UAAU,OAAO,IAAI,SAAU,KAAM,IAAO,CACpD,KAAK,WAAa,EAClB,EAAI,IAAI,KAAM,KAAK,YACnB,KAAM,GAAc,KAAM,MAAK,UAAU,mBAAmB,IAAI,KAAK,YACrE,GAAI,CAAC,EACD,KAAM,IAAI,OAAM,iCAAiC,KAAK,cAE1D,GAAI,CAMA,KAAM,AALQ,IAAI,IAAc,CAC5B,WAAY,EAAY,WACxB,YAAa,EAAY,YACzB,QAAS,KAAK,UAAU,UAEhB,OAAO,CAAC,QAAM,gBAC5B,EACF,KAAM,MAAK,cAAc,KAIjC,SAAU,CACN,AAAI,KAAK,wBACL,MAAK,yBACL,KAAK,uBAAyB,MAElC,KAAK,aAAe,KAChB,KAAK,mBACL,MAAK,kBAAkB,OACvB,KAAK,kBAAoB,MAEzB,KAAK,OACL,MAAK,MAAM,OACX,KAAK,MAAQ,MAEb,KAAK,UACL,MAAK,SAAS,UACd,KAAK,SAAW,MAEhB,KAAK,yBACL,MAAK,wBAAwB,UAC7B,KAAK,wBAA0B,MAE/B,KAAK,UACL,MAAK,SAAS,QACd,KAAK,SAAW,WAIlB,eAAc,EAAK,CACrB,AAAI,KAAK,YAIL,MAAK,UAGL,KAAM,SAAQ,IAAI,CACd,EAAI,KAAK,iBAAkB,IAAM,KAAK,UAAU,eAAe,OAAO,KAAK,aAC3E,EAAI,KAAK,qBAAsB,IAAM,KAAK,UAAU,mBAAmB,OAAO,KAAK,eAEvF,KAAK,WAAa,MAI1B,cAAe,CACX,KAAK,QAAQ,IAAI,EAAW,YAC5B,KAAK,OAAS,KACd,KAAK,cAAgB,MAI7B,QAAmB,CACf,YAAY,EAA2B,EAAa,CAChD,KAAK,2BAA6B,EAClC,KAAK,kBAAoB,OACzB,KAAK,aAAe,KAGpB,4BAA4B,CAC5B,MAAO,MAAK,2BAGhB,OAAO,EAAkB,CACrB,KAAK,kBAAoB,EACzB,KAAK,gBC7cN,eAAwB,GAAa,CACxC,YAAY,EAAU,GAAI,CACtB,QACA,KAAK,YAAc,KACnB,KAAK,YAAc,GACnB,KAAK,SAAW,EAGpB,aAAa,EAAiB,CAC1B,KAAM,CAAC,aAAY,aAAY,YAAY,KAAK,SAChD,MAAO,QAAO,OAAO,CAAC,aAAY,aAAY,YAAW,GAI7D,UAAU,EAAM,CACZ,MAAO,MAAK,SAAS,GAGzB,MAAM,EAAY,CACd,MAAK,MAAK,aACN,MAAK,YAAc,GAAI,KAEpB,KAAK,YAAY,MAAM,GAGlC,QAAQ,EAAY,CAChB,MAAI,MAAK,YACE,KAAK,YAAY,QAAQ,GAE7B,KAGX,SAAU,CACN,AAAI,KAAK,aACL,KAAK,YAAY,UAErB,KAAK,YAAc,MAGnB,aAAa,CACb,MAAO,MAAK,YAGhB,eAAe,EAAY,CACvB,MAAI,MAAK,YACE,KAAK,YAAY,eAAe,GAEpC,KAQX,KAAK,KAAU,EAAM,CAEjB,GAAI,GAAS,GACb,OAAS,GAAI,EAAG,EAAI,EAAM,OAAQ,EAAE,EAChC,EAAS,EAAS,EAAM,GACpB,EAAI,EAAK,QACT,GAAS,EAAS,EAAK,IAG/B,MAAO,GAGX,cAAc,EAAS,CACnB,KAAK,SAAW,OAAO,OAAO,KAAK,SAAU,GAGjD,WAAW,EAAc,CACrB,AAAI,KAAK,SAAS,WACd,KAAK,SAAS,WAAW,GAEzB,KAAK,KAAK,SAAU,MAIxB,WAAW,CACX,MAAO,MAAK,SAAS,YAGrB,QAAQ,CACR,MAAO,MAAK,SAAS,SAAS,SAG9B,SAAS,CACT,MAAO,MAAK,SAAS,UAOrB,aAAa,CACb,MAAO,MAAK,SAAS,cAGrB,aAAa,CACb,MAAO,MAAK,SAAS,YC3GtB,WAAwB,EAAM,CACjC,GAAI,GAAY,EAAK,OAAO,GAC5B,MAAI,KAAc,KAAO,IAAc,KAAO,IAAc,MACxD,GAAY,EAAK,OAAO,IAErB,EAAU,cAUrB,YAAkB,EAAK,CACnB,GAAI,GAAO,EACP,EACA,EACJ,GAAI,EAAI,SAAW,EACf,MAAO,GAEX,IAAK,EAAI,EAAG,EAAI,EAAI,OAAQ,IACxB,EAAM,EAAI,WAAW,GACrB,EAAS,IAAQ,GAAK,EAAQ,EAC9B,GAAQ,EAEZ,MAAO,MAAK,IAAI,GAGb,WAAkC,EAAI,CACzC,MAAQ,IAAS,GAAM,EAAK,EAGzB,YAA0B,EAAW,EAAS,EAAU,EAAiB,CAC5E,GAAI,EAAW,CACX,KAAM,GAAY,EAAU,EAAS,iBACrC,MAAO,GAAgB,gBAAgB,EAAW,EAAW,EAAW,QAE5E,MAAO,MCnCX,KAAM,IAAa,CAAC,mBAAoB,SAAU,QAE3C,gBAAgC,EAAU,CAC7C,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,QAAU,GACf,KAAK,QAAU,MAGf,SAAS,CACT,MAAO,MAAK,WAGZ,QAAO,EAAO,CACd,AAAI,IAAU,KAAK,SACf,MAAK,QAAU,EACf,KAAK,WAAW,WAIxB,OAAQ,CACJ,AAAI,KAAK,SACL,MAAK,QAAU,GACf,KAAK,WAAW,WAIxB,MAAO,CACH,AAAK,KAAK,SACN,MAAK,QAAU,GACf,KAAK,WAAW,cAIpB,SAAS,CACT,MAAO,MAAK,QAGhB,QAAQ,EAAO,CACX,MAAI,GAAM,OAAS,KAAK,KACb,GAAW,QAAQ,KAAK,MAAQ,GAAW,QAAQ,EAAM,MAE7D,KAIP,eAAe,CACf,MAAO,GAAe,KAAK,SAG3B,oBAAoB,CACpB,MAAO,GAAyB,KAAK,cAAc,eAGvD,UAAU,EAAM,CACZ,MAAO,IAAiB,KAAK,cAAc,UAAW,EAAM,KAAK,SAAU,KAAK,cAAc,oBAG9F,cAAc,CACd,MAAO,MAAK,MC5Db,gBAAgC,GAAkB,CACrD,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,QAAQ,EACf,KAAK,MAAQ,EACb,KAAK,KAAO,KAAK,WAAW,kBAAkB,KAAK,MAAM,OAGzD,OAAO,CACP,MAAO,UAGP,MAAM,CACN,MAAO,MAAK,KAMhB,QAAQ,EAAO,CACX,KAAM,GAAmB,MAAM,QAAQ,GACvC,GAAI,IAAqB,EACrB,MAAO,GAOX,KAAM,GAAS,KAAK,MACd,EAAY,EAAM,MAExB,GAAI,EAAO,gBAAkB,EAAU,cACnC,MAAI,GAAO,cACA,EAEJ,GAEX,KAAM,GAAc,EAAO,qBACrB,EAAiB,EAAU,qBAC3B,EAAmB,OAAO,cAAc,GACxC,EAAsB,OAAO,cAAc,GAEjD,GAAI,IAAqB,EACrB,MAAK,GAGE,EAFI,GAIf,KAAM,GAAW,EAAiB,EAClC,GAAI,IAAa,GAAK,CAAC,GAAuB,CAAC,EAAkB,CAE7D,KAAM,GAAU,KAAK,KAAK,cAAc,EAAM,MAC9C,MAAI,KAAY,EACL,KAAK,MAAM,GAAG,cAAc,EAAM,MAAM,IAE5C,EAEX,MAAO,MAGP,WAAW,CACX,MAAO,MAAK,MAAM,YAGlB,OAAO,CACP,MAAO,MAAK,MAAM,MAAQ,KAAK,oBAG/B,aAAa,CACb,MAAO,MAAK,MAAM,qBAGlB,gBAAgB,CAChB,MAAO,MAAK,MAAM,iBAAmB,KAGrC,gBAAgB,CAChB,MAAO,MAAK,OCjFb,YAA0B,EAAG,EAAG,CACnC,MAAI,KAAM,EACC,EAEA,EAAI,EAAI,GAAK,ECDrB,gBAAkC,GAAkB,CACvD,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,UAAU,EACjB,KAAK,QAAU,EACf,KAAK,KAAO,KAAK,WAAW,kBAAkB,KAAK,QAAQ,OAG3D,OAAO,CAAE,MAAO,MAAK,QAAQ,WAAa,KAAK,QAAQ,aACvD,OAAO,CAAE,MAAO,YAChB,MAAM,CAAE,MAAO,MAAK,QACpB,OAAO,CAAE,MAAO,MAAK,QAAQ,QAC7B,gBAAgB,CAAE,MAAO,MACzB,WAAW,CAAE,MAAO,MACpB,aAAa,CAAE,MAAO,MAAK,WAC3B,gBAAgB,CAAE,MAAO,MAAK,QAKlC,QAAQ,EAAO,CACX,KAAM,GAAmB,MAAM,QAAQ,GACvC,GAAI,IAAqB,EACrB,MAAO,GAEX,KAAM,GAAW,EAAM,QAAQ,UAAY,KAAK,QAAQ,UACxD,MAAI,KAAa,EACN,EAEJ,GAAiB,KAAK,QAAQ,GAAI,EAAM,QAAQ,KC5BxD,gBAA4C,GAAkB,CACjE,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,oBAAoB,EAC3B,KAAK,kBAAoB,EACzB,KAAK,KAAO,KAAK,WAAW,kBAAkB,KAAK,kBAAkB,OAGrE,OAAO,CAAE,MAAO,CAAC,KAAK,kBAAkB,SACxC,OAAO,CAAE,MAAO,sBAChB,gBAAgB,CAAE,MAAO,CAAC,KAAK,QAC/B,aAAa,CAAE,MAAO,CAAC,KAAK,MAAQ,KAAK,gBACzC,MAAM,CAAE,MAAO,MAAK,QACpB,OAAO,CAAE,MAAO,MAAK,kBAAkB,QACvC,gBAAgB,CAAE,MAAO,MAAK,kBAKlC,QAAQ,EAAO,CACX,KAAM,GAAY,MAAM,QAAQ,GAChC,GAAI,IAAc,EACd,MAAO,GAEX,KAAM,GAAU,GAAiB,KAAK,KAAM,EAAM,MAClD,MAAI,KAAY,EACL,GAAiB,KAAK,kBAAkB,GAAI,EAAM,kBAAkB,IAEpE,EAIf,UAAU,EAAM,OAEZ,MAAO,QAAK,kBAAkB,gBAAvB,OAAwC,MAAM,UAAU,ICtChE,QAAiB,CACpB,YAAY,EAAO,CACf,KAAK,OAAS,EAAM,MAAM,KAAK,IAAI,GAAK,EAAE,cAAc,QAG5D,QAAQ,EAAY,CAChB,KAAM,GAAO,EAAW,KAAK,cAC7B,MAAO,MAAK,OAAO,MAAM,GAAK,EAAK,SAAS,KCL7C,gBAAuB,GAAkB,CAC5C,YAAY,EAAQ,EAAO,CACvB,QACA,KAAK,QAAU,EACf,KAAK,OAAS,EACd,KAAK,cAAgB,KAGzB,UAAW,CACP,MAAO,CAAC,CAAC,KAAK,OAGlB,SAAS,EAAO,CACZ,KAAK,OAAS,EACV,GACA,KAAK,UAAU,KAAK,QAI5B,UAAU,EAAO,CACb,SAAW,CAAC,EAAK,IAAU,MAAK,QAC5B,EAAM,EAAK,GAInB,MAAM,EAAK,EAAO,CACd,AAAI,KAAK,QACL,KAAK,OAAO,EAAK,GAErB,KAAK,QAAQ,EAAK,GAGtB,SAAS,EAAK,EAAO,CACjB,KAAK,WAAW,EAAK,GAGzB,SAAS,EAAK,EAAO,EAAQ,CACzB,AAAI,KAAK,QACL,KAAK,OAAO,EAAK,EAAO,GAE5B,KAAK,WAAW,EAAK,EAAO,GAGhC,kBAAmB,CACf,KAAK,cAAgB,KAAK,QAAQ,UAAU,MACxC,KAAK,QACL,KAAK,UAAU,KAAK,QAExB,MAAM,mBAGV,mBAAoB,CAChB,MAAM,oBACN,KAAK,cAAgB,KAAK,gBAG9B,SAAU,CACN,AAAI,KAAK,QACL,KAAK,UAAU,KAAK,QAExB,KAAK,aAGR,OAAO,WAAY,CAChB,MAAO,MAAK,QAAQ,OAAO,eAG3B,OAAO,CACP,MAAO,MAAK,QAAQ,KAGxB,IAAI,EAAK,CACL,MAAO,MAAK,QAAQ,IAAI,ICxEzB,QAAiB,CACpB,YAAY,EAAa,CACrB,KAAK,aAAe,EACpB,KAAK,MAAQ,GAAI,IAAK,GAAI,GAC1B,KAAK,aAAe,GAAI,KACxB,KAAK,gBAAkB,GAAI,GAAgB,KAAK,UAGhD,iBAAiB,CACjB,MAAO,MAAK,mBAGZ,OAAO,CACP,MAAO,MAAK,MAGhB,KAAK,EAAM,EAAQ,OAAW,CAC1B,MAAO,MAAK,UAAU,KAAK,KAAK,KAAK,GAAI,GAAQ,EAAM,KAG3D,UAAU,EAAM,CAGZ,KAAM,GAAU,KAAK,MACrB,KAAK,MAAQ,EAEb,OAAS,GAAI,EAAQ,SAAS,OAAS,EAAG,GAAK,EAAG,GAAK,EAAG,CACtD,KAAM,GAAU,EAAQ,SAAS,GACjC,GAAI,CAAC,KAAK,MAAM,IAAI,EAAQ,MAAO,CAC/B,KAAM,GAAa,KAAK,aAAa,IAAI,EAAQ,MACjD,WAAY,iBAIpB,SAAW,KAAW,MAAK,MAAM,SAAU,CACvC,KAAM,GAAa,KAAK,aAAa,IAAI,EAAQ,MACjD,WAAY,gBAKhB,KAAK,gBAAgB,IAAI,KAAK,OAGlC,QAAQ,EAAM,CACV,GAAI,GAAa,KAAK,aAAa,IAAI,GACvC,MAAK,IACD,GAAa,GAAI,IAAkB,KAAM,GACzC,KAAK,aAAa,IAAI,EAAM,IAEzB,EAGX,SAAS,EAAU,CACf,GAAI,GACA,EACJ,IAAK,EAAI,EAAG,EAAI,EAAS,OAAQ,GAAK,EAAG,CACrC,GAAI,CAAC,KAAK,aAAa,EAAQ,EAAS,IACpC,MAAO,IAAI,IAAK,EAAS,MAAM,EAAG,GAAI,KAAK,cAE/C,EAAS,EAAS,GAEtB,MAAO,IAAI,IAAK,EAAU,KAAK,cAGnC,QAAQ,EAAM,EAAO,CACjB,MAAO,IAAI,GAAQ,EAAM,IAIjC,YAA2B,EAAG,EAAG,CAC7B,GAAI,IAAM,EACN,MAAO,GAGX,GAAI,MAAM,QAAQ,IAAM,MAAM,QAAQ,GAAI,CACtC,KAAM,GAAM,KAAK,IAAI,EAAE,OAAQ,EAAE,QACjC,OAAS,GAAI,EAAG,EAAI,EAAK,GAAK,EAC1B,GAAI,EAAE,KAAO,EAAE,GACX,MAAO,GAGf,MAAO,GAEX,MAAO,GAGJ,OAAc,CACjB,YAAY,EAAM,EAAO,CACrB,KAAK,KAAO,EACZ,KAAK,MAAQ,IAAU,OAAY,GAAO,GAIlD,QAAW,CACP,YAAY,EAAW,GAAI,EAAa,CACpC,KAAK,UAAY,EACjB,KAAK,aAAe,EAGxB,OAAQ,CACJ,MAAO,IAAI,IAAK,KAAK,UAAU,QAAS,KAAK,cAGjD,KAAK,EAAS,CACV,GAAI,GAAQ,KAAK,UAAU,OAAS,EACpC,EAAG,CACC,GAAI,KAAK,aAAa,KAAK,UAAU,GAAQ,GAAU,CAEnD,KAAM,GAAc,KAAK,UAAU,MAAM,EAAG,EAAQ,GACpD,SAAY,KAAK,GACV,GAAI,IAAK,EAAa,KAAK,cAEtC,GAAS,QACL,GAAS,IAEjB,MAAO,MAGX,MAAM,EAAM,CACR,KAAM,GAAQ,KAAK,UAAU,UAAU,GAAK,EAAE,OAAS,GACvD,MAAI,KAAU,GACH,GAAI,IAAK,KAAK,UAAU,MAAM,EAAG,EAAQ,GAAI,KAAK,cAEtD,GAAI,IAAK,GAAI,KAAK,cAG7B,IAAI,EAAM,CACN,MAAO,MAAK,UAAU,KAAK,GAAK,EAAE,OAAS,GAG/C,QAAQ,EAAS,CACb,KAAM,GAAQ,KAAK,UAAU,UAAU,GAAK,EAAE,OAAS,EAAQ,MAC/D,GAAI,IAAU,GAAI,CACd,KAAM,GAAS,KAAK,UAAU,EAAQ,GACtC,GAAI,KAAK,aAAa,EAAQ,GAAU,CACpC,KAAM,GAAQ,KAAK,UAAU,EAAQ,GACrC,GAAI,CAAC,GAAS,KAAK,aAAa,EAAS,GAAQ,CAC7C,KAAM,GAAc,KAAK,UAAU,QACnC,SAAY,GAAS,EACd,GAAI,IAAK,EAAa,KAAK,gBAI9C,MAAO,SAGP,WAAW,CACX,MAAO,MAAK,WAQpB,gBAAgC,GAAoB,CAChD,YAAY,EAAY,EAAM,CAC1B,cACA,KAAK,YAAc,EACnB,KAAK,MAAQ,EACb,KAAK,cAAgB,KAAW,KAAK,IAAI,KAApB,cAA2B,MAGpD,KAAM,CAEF,KAAM,GAAU,AADH,KAAK,YAAY,KACT,IAAI,KAAK,OAE9B,MADc,kBAAS,MAI3B,eAAgB,CACZ,KAAM,GAAW,KAAK,MACtB,AAAK,GAAkB,EAAU,KAAK,gBAClC,MAAK,cAAgB,EACrB,KAAK,KAAK,KCjLf,QAAgB,CACnB,YAAY,CAAC,UAAS,aAAY,eAAc,iBAAgB,CAC5D,KAAK,SAAW,EAChB,KAAK,YAAc,EACnB,KAAK,cAAgB,EACrB,KAAK,eAAiB,EACtB,KAAK,cAAgB,KACrB,KAAK,kBAAoB,KACzB,KAAK,eAAiB,GACtB,KAAK,kBAAoB,KAAK,oBAGlC,mBAAoB,OAEhB,KAAM,GAAY,GADF,KAAK,cAAc,KAAK,SAAS,cAAgB,IACvC,IAAI,aAAZ,cAAwB,MAC1C,MAAI,OAAO,IAAc,SACd,EAEJ,KAGX,QAAS,CACL,KAAK,cAAgB,KAAK,SAAS,UAAU,GAAO,KAAK,UAAU,IAGnE,KAAK,kBAAoB,KAAK,YAAY,eAAe,UAAU,GAAQ,KAAK,uBAAuB,IACvG,KAAK,UAAU,KAAK,SAAS,OAGjC,SAAU,CACN,KAAK,cAAgB,KAAK,gBAC1B,KAAK,kBAAoB,KAAK,oBAGlC,uBAAuB,EAAM,CACzB,KAAM,GAAM,KAAK,WAAW,GAC5B,AAAI,IAAQ,KAAK,SAAS,OACtB,CAAI,KAAK,eAEL,KAAK,SAAS,mBAAmB,GAEjC,KAAK,SAAS,gBAAgB,IAK1C,0BAA0B,EAAS,CAI/B,KAAK,eAAiB,GACtB,KAAK,YAAY,UAAU,GAC3B,KAAK,eAAiB,GAG1B,cAAc,EAAK,CACf,KAAM,GAAU,KAAK,SAAS,UAAU,GACxC,MAAO,MAAK,YAAY,SAAS,KAAK,cAAc,EAAS,KAAK,YAAY,KAAM,KAAK,oBAG7F,UAAU,EAAK,CACX,KAAM,GAAU,KAAK,cAAc,GACnC,KAAK,0BAA0B,GAGnC,QAAQ,EAAK,CACT,KAAK,SAAS,QAAQ,GAG1B,mBAAoB,CAChB,KAAM,GAAc,KAAK,cAAc,KAAK,SAAS,cAAgB,IACrE,MAAI,GAAY,SAAS,SAAW,EAChC,MAAK,0BAA0B,GACxB,IAEJ,GAGX,eAAe,EAAU,CACrB,GAAI,GAAO,KAAK,YAAY,KAC5B,SAAW,KAAW,GAElB,GADA,EAAO,EAAK,KAAK,GACb,CAAC,EACD,OAGR,MAAO,MAAK,WAAW,GAG3B,cAAc,EAAM,EAAO,CACvB,MAAO,MAAK,eAAe,CAAC,KAAK,YAAY,QAAQ,EAAM,KAG/D,gBAAgB,EAAM,CAClB,MAAO,MAAK,WAAW,KAAK,YAAY,KAAK,MAAM,IAGvD,WAAW,EAAM,CACb,MAAO,MAAK,SAAS,UAAU,KAAK,eAAe,IAGvD,kBAAkB,EAAQ,CAEtB,KAAM,GAAU,GAAG,KAAK,eAAe,KAAK,YAAY,KAAK,MAAM,yBAAyB,IAC5F,MAAO,MAAK,SAAS,UAAU,GAGnC,sBAAuB,CACnB,MAAO,QAAO,SAAS,OAG3B,cAAe,CAGX,KAAK,SAAS,mBAAmB,GAAG,OAAO,SAAS,UAAU,OAAO,SAAS,SC/G/E,aAA4B,CAC/B,MAAO,IAAI,IAAW,IAGnB,YAAsB,CAAC,UAAS,cAAa,CAChD,MAAO,IAAI,IAAU,CAAC,UAAS,aAAY,iBAAe,kBAG9D,YAAqB,EAAQ,EAAO,CAChC,KAAM,CAAC,QAAQ,EACf,OAAQ,iBAAQ,UACP,QAED,MAAO,KAAS,SAAY,IAAS,WAAa,IAAS,OAAS,IAAS,aAC5E,UACD,MAAO,KAAS,QAAU,IAAS,SAAW,IAAS,YAAc,IAAS,kBAC7E,QAED,MAAO,KAAS,QAAU,IAAS,sBAClC,OACD,MAAO,KAAS,YAAc,IAAS,kBACtC,cACD,MAAO,KAAS,WAAY,IAAS,WAAa,IAAS,iBAE3D,MAAO,IA4BnB,YAA8B,EAAO,EAAQ,EAAM,CAC/C,GAAI,EAAM,MAAM,SAAS,GAarB,MAAO,GAbuB,CAC9B,KAAM,GAAgB,EAAK,IAAI,mBACzB,EAAU,EAAK,IAAI,QACzB,GAAI,GAAQ,EACZ,AAAI,EACA,EAAQ,EAAc,MACf,GACP,GAAQ,EAAM,MAAM,QAAQ,EAAQ,QAExC,KAAM,GAAU,EAAM,MAAM,QAC5B,SAAQ,GAAS,EACV,GAAI,GAAQ,QAAS,IAMpC,YAA+B,EAAO,EAAS,EAAQ,GAAM,CACzD,EAAM,KAAK,GAAI,GAAQ,gBACvB,EAAM,KAAK,GAAI,GAAQ,EAAS,IAG7B,YAA0B,EAAY,EAAM,CAC/C,KAAM,GAAW,EAAW,KAAK,SAC3B,EAAI,EAAS,UAAU,GAAW,EAAQ,OAAS,eACzD,GAAI,GAAQ,EACZ,MAAI,KAAM,IACN,GAAQ,EAAK,MAAM,QACnB,EAAQ,EAAM,KAAK,EAAS,IAC5B,EAAQ,EAAM,KAAK,EAAS,EAAI,KAE7B,EAGJ,YAAsB,EAAS,EAAgB,EAAkB,CAEpE,KAAM,GAAQ,EAAQ,OAAO,GAAG,MAAM,KAChC,EAAW,EAAM,OAAO,YACxB,EAAW,GACjB,GAAI,GACJ,KAAO,CAAE,GAAO,EAAS,QAAQ,MAAM,CACnC,KAAM,GAAO,EAAK,MAClB,GAAI,IAAS,QAAS,CAClB,KAAM,GAAa,EAAS,OAAO,MACnC,GAAI,IAAe,OAAa,MAChC,KAAM,GAAU,EAAW,MAAM,KACjC,EAAS,KAAK,GAAI,GAAQ,EAAM,IAChC,KAAM,GAAgB,SAAS,EAAS,OAAO,OAAS,IAAK,IACvD,EAAS,EAAQ,GACvB,AAAI,EACA,EAAS,KAAK,GAAI,GAAQ,OAAQ,IAElC,EAAS,KAAK,GAAI,GAAQ,kBAAmB,YAE1C,IAAS,YAAa,CAC7B,KAAM,GAAS,EAAS,OAAO,MAC/B,GAAI,CAAC,EAAU,MACf,KAAM,GAAQ,EAAe,IAAI,SAOjC,GANI,GACA,EAAS,KAAK,GAAqB,EAAO,EAAQ,IAEtD,EAAS,KAAK,GAAI,GAAQ,OAAQ,IAEH,AADL,EAAM,UAAU,GAAQ,IAAS,cACP,EAAM,OAAS,EACvC,CAGxB,KAAM,GAAmB,EAAe,SAClC,EAAI,EAAiB,UAAU,GAAK,EAAE,OAAS,eACrD,AAAI,IAAM,IACN,EAAS,KAAK,GAAG,EAAiB,MAAM,aAGzC,IAAS,eAAgB,CAChC,GAAI,GAAiB,EAAe,IAAI,WACxC,AAAI,MAAO,kBAAgB,QAAU,UAAY,GAC7C,GAAiB,GAAI,GAAQ,UAAW,IAExC,GACA,EAAS,KAAK,WAEX,IAAS,WAAa,IAAS,UACtC,GAAsB,EAAU,WACzB,IAAS,SAAU,CAC1B,KAAM,GAAS,EAAS,OAAO,MAC/B,GAAI,CAAC,EAAU,MACf,GAAsB,EAAU,EAAM,WAC/B,EAAK,SAAS,cAAe,CAEpC,KAAM,GAAa,EAAK,MAAM,KAAK,MACnC,EAAS,KAAK,GAAI,GAAQ,MAAO,QAC9B,CAEH,KAAM,GAAQ,EAAS,OAAO,MAC9B,EAAS,KAAK,GAAI,GAAQ,EAAM,KAGxC,MAAO,GAGJ,YAAuB,EAAM,CAChC,GAAI,GAAU,GACV,EACJ,SAAW,KAAW,GAAK,SAAU,CACjC,OAAQ,EAAQ,UACP,QACD,GAAW,UAAU,EAAQ,MAAM,KAAK,OACxC,UACC,kBACD,GAAW,IAAI,EAAQ,QACvB,UACC,OACD,AAAI,kBAAa,QAAS,QAEtB,GAAW,IADG,EAAY,MAAM,QAAQ,EAAQ,SAGhD,GAAW,IAAI,EAAQ,QAAQ,EAAQ,QAE3C,UACC,kBACA,MAED,iBAEA,GAAW,IAAI,EAAQ,OACnB,EAAQ,OAAS,EAAQ,QAAU,IACnC,IAAW,IAAI,EAAQ,SAGnC,EAAc,EAElB,MAAO,GClLJ,gBAAiC,EAAU,CAC9C,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,WAAW,EAClB,KAAK,mBAAqB,KAAK,mBAAmB,EAAQ,kBAAmB,EAAQ,QAAS,EAAQ,OACtG,KAAK,yBAA2B,GAAI,IAAS,KAAK,oBAClD,KAAK,gBAAkB,KAAK,yBAAyB,WAAW,CAAC,EAAG,IAAM,EAAE,QAAQ,IACpF,KAAK,eAAiB,KACtB,KAAK,mBACL,KAAK,UAAY,KAAK,WAAW,cAAc,WAC/C,KAAK,aAAe,KAAK,WAAW,cAAc,YAClD,KAAK,eAAiB,KAAK,WAAW,cAAc,eAGxD,mBAAmB,EAAmB,EAAS,EAAO,CAkBlD,MAhBiB,GAAQ,KAAK,EAAmB,GAAO,UAAU,CAAC,EAAM,IAAe,OACpF,GAAI,GACJ,MAAI,GAAK,eACL,EAAK,GAAI,IAA8B,KAAK,aAAa,CAAC,iBAAkB,EAAM,gBAC/E,AAAI,EAAK,SACZ,EAAK,GAAI,IAAoB,KAAK,aAAa,CAAC,OAAQ,EAAM,gBAE9D,EAAK,GAAI,IAAkB,KAAK,aAAa,CAAC,KAAM,EAAM,gBAG1D,AADW,SAAK,WAAW,KAAK,IAAI,UAAzB,cAAkC,SAAU,EAAK,IAE5D,GAAG,OACH,KAAK,iBAAiB,IAEnB,IAKf,iBAAiB,EAAI,OAIjB,QAAK,iBAAL,QAAqB,QACrB,KAAK,eAAiB,KAGtB,WAAW,CACX,MAAO,MAAK,aAGZ,cAAc,CACd,MAAO,MAAK,gBAGZ,gBAAgB,CAAE,MAAO,MAAK,eAElC,kBAAmB,CACf,KAAM,GAAiB,KAAK,WAAW,QAAQ,QAC/C,KAAK,MAAM,EAAe,UAAU,GAAU,KAAK,MAAM,KAEzD,KAAM,GAAiB,KAAK,WAAW,QAAQ,SAC/C,KAAK,YAAc,CAAC,CAAC,EAAe,MACpC,KAAK,MAAM,EAAe,UAAU,GAAW,CAC3C,KAAM,GAAU,KAAK,YAAc,CAAC,CAAC,EACrC,KAAK,YAAc,CAAC,CAAC,EACjB,GACA,KAAK,WAAW,kBAK5B,MAAM,EAAQ,SACV,QAAK,iBAAL,QAAqB,QACrB,KAAK,eAAiB,KAClB,GACA,MAAK,eAAiB,KAAK,mBAAmB,IAAI,GAClD,QAAK,iBAAL,QAAqB,QAI7B,YAAa,CACT,KAAM,GAAO,KAAK,WAAW,KAAK,IAAI,QACtC,GAAI,GAAO,KAAK,WAAW,KAAK,MAAM,WACtC,AAAI,KAAK,YACD,GACA,GAAO,EAAK,KAAK,GACjB,EAAO,GAAiB,KAAK,WAAY,IAG7C,AAAI,EACA,GAAO,EAAK,KAAK,KAAK,WAAW,QAAQ,QAAS,CAAC,EAAK,SACxD,EAAO,EAAK,KAAK,GACjB,EAAO,GAAiB,KAAK,WAAY,IAEzC,GAAO,EAAK,KAAK,KAAK,WAAW,QAAQ,QAAS,KAClD,EAAO,EAAK,KAAK,KAAK,WAAW,QAAQ,kBAAmB,KAGpE,KAAK,WAAW,UAAU,MAG1B,iBAAiB,CACjB,MAAO,MAAK,gBAGhB,aAAc,CACV,KAAK,yBAAyB,SAAS,MACvC,KAAK,yBAAyB,UAAU,CAAC,EAAQ,IAAO,EAAG,OAAS,IAGxE,UAAU,EAAO,CAEb,GADA,EAAQ,EAAM,OACV,EAAM,SAAW,EACjB,YAAK,cACE,GACJ,CACH,KAAM,GAAiB,CAAC,KAAK,yBAAyB,WAChD,EAAS,GAAI,IAAW,GAC9B,YAAK,yBAAyB,SAAS,CAAC,EAAQ,IAAO,CACnD,EAAG,OAAS,CAAC,EAAO,QAAQ,KAEzB,IC/HZ,QAAmB,CACtB,YAAY,EAAQ,EAAQ,EAAS,EAAc,CAC/C,KAAK,QAAU,EACf,KAAK,QAAU,EACf,KAAK,SAAW,EAChB,KAAK,cAAgB,KAGrB,gBAAgB,CAChB,MAAO,MAAK,YAGZ,eAAe,CACf,MAAO,MAAK,WAGZ,eAAe,CACf,MAAO,MAAK,WAGZ,eAAe,CACf,MAAO,MAAK,oBAGT,SAAS,CACZ,MAAO,IAAI,IAAa,GAAM,GAAO,GAAO,YAGzC,QAAO,EAAW,CACrB,MAAO,IAAI,IAAa,GAAO,GAAM,GAAO,SAGzC,UAAU,CACb,MAAO,IAAI,IAAa,GAAO,GAAO,GAAO,YAG1C,SAAQ,EAAQ,CACnB,MAAO,IAAI,IAAa,GAAO,GAAO,GAAM,IC7B7C,gBAA8B,GAAmB,CACpD,YAAY,EAAS,EAAa,CAC9B,QACA,KAAK,SAAW,EAChB,KAAK,OAAS,KACd,KAAK,mBAAqB,KAC1B,KAAK,aAAe,EACpB,KAAK,sBAAwB,KAAK,sBAAsB,KAAK,MAGjE,sBAAsB,EAAM,EAAQ,CAChC,KAAM,GAAQ,EAAK,WACb,EAAU,KAAK,aAAa,GAClC,KAAK,WAAW,EAAS,EAAM,GAGnC,kBAAmB,CACf,KAAK,mBAAqB,KAAK,SAAS,UAAU,MAClD,KAAK,iBAGT,gBAAiB,CACb,KAAK,OAAS,GACd,GAAI,GAAc,KAClB,OAAS,KAAS,MAAK,SACnB,AAAI,EAAC,GAAe,CAAC,EAAY,gBAAgB,KAC7C,GAAc,KAAK,aAAa,GAC5B,GACA,KAAK,OAAO,KAAK,IAI7B,GAAI,GAAW,KACf,OAAS,KAAQ,MAAK,OAClB,AAAI,GACA,EAAS,kBAAkB,GAE/B,EAAK,sBAAsB,GAC3B,EAAW,EAEf,AAAI,GACA,EAAS,kBAAkB,MAI/B,SAAW,KAAQ,MAAK,OACpB,EAAK,cAAc,KAAK,uBAIhC,aAAa,EAAO,CAChB,MAAO,IAAY,KAAK,OAAQ,EAAO,CAAC,EAAO,IAEpC,CAAC,EAAK,aAAa,IAIlC,eAAe,EAAO,EAAK,CACvB,KAAM,GAAO,KAAK,cAAc,GAChC,GAAI,GAAQ,EAAK,aAAa,KAAW,EACrC,MAAO,GAIf,cAAc,EAAS,CACnB,MAAI,IAAW,GAAK,EAAU,KAAK,OAAO,OAC/B,KAAK,OAAO,GAEhB,KAGX,mBAAoB,CAChB,KAAK,mBAAqB,KAAK,qBAC/B,OAAQ,GAAI,EAAG,EAAI,KAAK,OAAO,OAAQ,GAAI,EACvC,KAAK,OAAO,GAAG,UAEnB,KAAK,OAAS,KAGlB,SAAU,CAEN,KAAK,qBACL,KAAK,YAGT,MAAM,EAAO,EAAO,CAChB,KAAM,GAAU,KAAK,aAAa,GAC5B,EAAW,KAAK,cAAc,EAAU,GAC9C,GAAI,GAAY,EAAS,gBAAgB,GAAQ,CAC7C,KAAK,WAAW,EAAU,EAAG,GAC7B,OAGJ,KAAM,GAAW,KAAK,cAAc,GACpC,GAAI,GAAY,EAAS,gBAAgB,GAAQ,CAC7C,KAAK,WAAW,EAAS,GACzB,OAGJ,KAAM,GAAU,KAAK,aAAa,GAClC,AAAI,GACI,IACA,GAAS,kBAAkB,GAE3B,EAAQ,sBAAsB,IAE9B,GACA,GAAQ,kBAAkB,GAC1B,EAAS,sBAAsB,IAEnC,KAAK,OAAO,OAAO,EAAS,EAAG,GAC/B,KAAK,QAAQ,EAAS,GAGtB,EAAQ,cAAc,KAAK,wBAMnC,SAAS,EAAO,EAAO,EAAQ,CAE3B,GAAI,CAAC,KAAK,OACN,OAEJ,KAAM,GAAU,KAAK,aAAa,GAC5B,EAAO,KAAK,eAAe,EAAO,GACxC,GAAI,EAAM,CACN,KAAM,GAAS,EAAK,YAAY,EAAO,EAAQ,KAAK,cACpD,GAAI,EAAO,cAAe,CACtB,KAAM,GAAU,KAAK,aAAa,GAClC,AAAI,EACA,MAAK,aAAa,EAAS,EAAM,EAAS,EAAO,cACjD,EAAQ,cAAc,KAAK,wBAE3B,KAAK,YAAY,EAAS,GAGlC,AAAI,EAAO,cACP,KAAK,YAAY,EAAS,GAE1B,EAAO,cACP,KAAK,WAAW,EAAS,EAAM,EAAO,eAgBlD,aAAa,EAAS,EAAc,EAAS,EAAc,CACvD,EAAa,UACb,KAAM,GAAW,KAAK,cAAc,EAAU,GACxC,EAAW,KAAK,cAAc,EAAU,GAC9C,KAAK,OAAO,GAAW,EACvB,WAAU,kBAAkB,GAC5B,EAAQ,sBAAsB,GAC9B,EAAQ,kBAAkB,GAC1B,WAAU,sBAAsB,GAChC,KAAK,WAAW,EAAS,EAAS,GAGtC,YAAY,EAAS,EAAM,CACvB,KAAM,GAAW,KAAK,cAAc,EAAU,GACxC,EAAW,KAAK,cAAc,EAAU,GAI9C,KAAK,OAAO,OAAO,EAAS,GAC5B,EAAK,UACL,KAAK,WAAW,EAAS,GACzB,WAAU,kBAAkB,GAC5B,WAAU,sBAAsB,GAIpC,SAAS,EAAO,EAAO,CACnB,KAAM,GAAU,KAAK,aAAa,GAC5B,EAAO,KAAK,eAAe,EAAO,GACxC,AAAI,GAEA,CADmB,EAAK,YAAY,GAEhC,KAAK,YAAY,EAAS,GAE1B,KAAK,WAAW,EAAS,IAKrC,QAAkC,GAMjC,OAAO,WAAY,CAChB,MAAO,MAAK,OAAO,YAGnB,SAAS,CACT,MAAO,MAAK,OAAO,OAGvB,UAAW,CACP,MAAO,MAAK,OAAO,GAGvB,aAAa,EAAY,CACrB,KAAM,GAAM,GAAY,KAAK,OAAQ,EAAY,CAAC,EAAY,IACnD,EAAW,QAAQ,IAExB,EAAY,KAAK,OAAO,GAC9B,MAAI,kBAAW,QAAQ,MAAgB,EAC5B,EAEJ,GAGX,cAAc,EAAO,EAAK,CACtB,MAAO,MAAK,OAAO,MAAM,EAAO,GAAK,OAAO,aCvN7C,gBAAgC,EAAU,CAC7C,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,WAAU,gBAAgB,EACjC,KAAK,UAAY,KAAK,MAAM,GAC5B,KAAK,OAAS,GAAI,IAAgB,EAAS,QAAS,GACpD,KAAK,WAAa,KAClB,KAAK,SAAW,KAChB,KAAK,mBAAqB,KAC1B,KAAK,oBAAsB,KAC3B,KAAK,kBAAoB,KACzB,KAAK,kBAAoB,GACzB,KAAK,cAAgB,GAIzB,oBAAoB,EAAW,EAAS,CAGpC,KAAK,oBAAsB,EAC3B,KAAK,kBAAoB,EACpB,KAAK,mBACN,SAAQ,UAAU,KAAK,IAAM,CACzB,KAAK,qBAAqB,KAAK,oBAAqB,KAAK,mBACzD,KAAK,kBAAoB,KAE7B,KAAK,kBAAoB,IAIjC,qBAAqB,EAAW,EAAS,CACrC,GAAI,GACJ,GAAI,GAAa,EAAS,CAEtB,KAAK,WAAa,EAClB,KAAK,SAAW,EAChB,KAAM,GAAa,KAAK,OAAO,aAAa,KAAK,YAC3C,EAAW,KAAK,OAAO,aAAa,KAAK,UAC/C,SAAW,KAAQ,MAAK,OAAO,cAAc,EAAY,EAAW,GAChE,EAAK,gBAET,EAAU,EAAa,GACvB,KAAK,iBAAiB,EAAY,KAAK,OAAO,OAAS,OAGvD,GAAU,GACV,KAAK,iBAAiB,IAG1B,AAAI,GAAW,CAAC,KAAK,oBACjB,MAAK,mBAAqB,KAAK,UAAU,UAAU,IAAI,KAAK,GAAiB,CACzE,KAAK,mBAAqB,KACrB,GAID,KAAK,oBAAoB,KAAK,oBAAqB,KAAK,yBAMpE,QAAQ,CACR,MAAO,MAAK,OAGhB,iBAAiB,EAAM,CACnB,AAAI,KAAK,gBAAkB,GACvB,MAAK,cAAgB,EACrB,KAAK,WAAW,oBAIpB,eAAe,CACf,MAAO,MAAK,eC5Fb,gBAAgC,EAAU,CAC7C,YAAY,EAAQ,CAChB,QACA,KAAK,QAAU,EACf,KAAK,SAAW,GAChB,KAAK,SAAW,KAGpB,cAAc,EAAO,OAEjB,AAAI,AADY,IAAI,SAAQ,KAAW,GAAI,SAAQ,KAAK,WAAa,CAAC,SAAK,WAAL,cAAe,GAAG,OAAO,EAAM,iBAEjG,MAAK,SAAW,KAAK,eAAe,KAAK,UACrC,GACA,MAAK,SAAW,KAAK,MAAM,KAAK,QAAQ,YAAY,IACpD,KAAK,SAAS,iBAElB,KAAK,WAAW,kBAChB,KAAK,KAAK,UAIlB,iBAAkB,CACd,KAAK,cAAc,SAGnB,iBAAiB,CACjB,MAAO,MAAK,YAGZ,cAAc,CACd,MAAO,MAAK,QAAQ,iBAGlB,aAAY,EAAS,CACvB,KAAM,GAAU,KAAM,MAAK,QAAQ,aAAa,EAAS,KAAK,UAC9D,MAAI,IACA,MAAK,SAAW,GAChB,KAAK,WAAW,WAChB,KAAK,mBAEF,EAGX,aAAc,CACV,KAAK,QAAQ,sBAGjB,UAAW,CACP,KAAK,QAAQ,mBAGjB,WAAY,CACR,KAAK,QAAQ,uBAGb,UAAU,CACV,MAAO,CAAC,KAAK,cAGX,UAAS,EAAM,CACjB,KAAM,GAAW,KAAK,SACtB,KAAK,SAAW,EAAK,SAAW,EAC5B,GAAY,CAAC,KAAK,UAClB,KAAK,QAAQ,MAAM,2BAEnB,IAAa,KAAK,UAClB,KAAK,WAAW,cAIpB,OAAO,CACP,MAAO,YCrER,gBAAyB,EAAU,CACtC,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,OAAS,EAAQ,SAItB,QAAQ,CACR,MAAO,SAMP,iBAAiB,CACjB,MAAO,MAGP,mBAAmB,CACnB,MAAO,MAGP,KAAK,CACL,MAAO,MAAK,OAAO,gBAGnB,YAAY,CACZ,MAAO,MAAK,OAAO,aAGnB,WAAW,CACX,MAAO,MAAK,OAAO,WAAa,KAAK,OAAO,aAAa,SAAW,EAAW,QAG/E,kBAAkB,CAClB,MAAO,MAAK,OAAO,WACf,CAAC,KAAK,OAAO,aAAa,kBAGlC,cAAe,OACX,QAAK,OAAO,eAAZ,QAA0B,QAI9B,cAAc,EAAY,CACtB,KAAK,cAAc,CAAC,WAAY,GAAa,CAMzC,AAAI,GACA,EAAW,KAAM,SAKzB,aAAa,CACb,MAAO,MAAK,UAGZ,aAAa,CACb,MAAO,MAAK,OAGhB,QAAQ,EAAM,CACV,MAAO,MAAK,WAAW,QAAQ,EAAK,YAGxC,aAAa,EAAO,CAChB,MAAO,MAAK,OAAO,QAAQ,GAI/B,YAAY,EAAO,EAAO,CACtB,KAAM,GAAqB,KAAK,QAAU,WAC1C,MAAI,CAAC,EAAM,OAAS,EAAM,aAAe,EAE9B,GAAa,QAAQ,SAE5B,MAAK,OAAS,EACP,GAAa,OAAO,IAMnC,aAAuB,CACnB,MAAO,GAIX,iBAAkB,CACd,MAAO,GAGX,uBAAgC,EAKhC,mBAA4B,EAI5B,eAAgB,EAEhB,SAAU,CACN,KAAK,cAAc,MACnB,MAAM,aAIN,QAAQ,CACR,MAAO,MAAK,QAAQ,QAGpB,UAAU,CACV,MAAO,MAAK,SAAS,UAGrB,YAAY,CACZ,MAAO,MAAK,SAAS,YAGrB,eAAe,CACf,MAAO,MAAK,UAAU,eAGtB,aAAa,CACb,MAAO,MAAK,SAAS,SAAS,ICnI/B,gBAAsB,GAAW,CACpC,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,SAAW,GAChB,KAAK,OAAS,KACd,KAAK,SAAW,GAChB,KAAK,gBAAkB,QAGrB,OAAO,CACT,GAAI,CAAC,KAAK,UAAY,CAAC,KAAK,OAAO,YAAa,CAC5C,KAAK,SAAW,GAChB,KAAK,WAAW,aAChB,GAAI,CACA,KAAM,MAAK,MAAM,QAAQ,KAAK,OAAQ,UACjC,EAAP,CACE,cAAQ,MAAM,mBAAmB,EAAI;AAAA,EAAa,EAAI,SACtD,KAAK,OAAS,EACd,KAAK,WAAW,SAGV,UAEN,KAAK,SAAW,GAChB,KAAK,WAAW,aAEhB,MAAO,GAEf,MAAO,QAGL,gBAAgB,CAGlB,GAAI,GAAQ,EACR,EACJ,KAAK,gBAAkB,GACvB,EACI,GAAc,KAAM,MAAK,OACzB,EAAQ,EAAQ,QACX,EAAQ,IAAM,CAAC,KAAK,iBAAmB,GAAe,CAAC,KAAK,eAGrE,UAAU,CACV,MAAO,MAAK,SAGhB,sBAAsB,EAAM,CACxB,MAAM,sBAAsB,GAC5B,KAAM,GAAU,CAAC,EACjB,AAAI,KAAK,WAAa,GAClB,MAAK,SAAW,EAChB,KAAK,WAAW,YAEpB,KAAK,gBAAkB,GAG3B,mBAAoB,CAIhB,KAAK,gBAAkB,GAG3B,YAAY,EAAO,EAAQ,EAAc,CAErC,MADA,OAAM,YAAY,EAAO,EAAQ,GAC5B,EAAM,MAGA,GAAa,UAFb,GAAa,YAMxB,QAAQ,CACR,MAAO,SAGP,YAAY,CACZ,MAAO,MAAK,YAGZ,QAAQ,CACR,MAAI,MAAK,OAEE,kBADK,KAAK,OAAO,WAAa,WAAa,oBACR,KAAK,OAAO,UAEnD,MCxFR,QAAyB,CAC5B,YAAY,EAAY,CACpB,KAAK,YAAc,EACnB,KAAK,KAAO,GAAI,IAChB,KAAK,WAAa,KAAK,KAAK,WAAW,CAAC,EAAG,IAAM,EAAE,SAAS,IAIhE,OAAO,EAAa,EAAoB,CACpC,GAAI,GACA,SAAW,KAAO,GACd,GAAI,EAAY,eAAe,GAAM,CACjC,KAAM,GAAa,EAAY,GACzB,EAAW,KAAK,KAAK,IAAI,GAC/B,AAAI,EACI,EAAS,WAAW,IACpB,KAAK,KAAK,OAAO,GAGrB,KAAK,KAAK,IAAI,EAAK,GAAI,IAAkB,EAAK,EAAY,KAAM,KAAK,eAKrF,GAAI,EACA,SAAW,CAAC,EAAK,IAAe,GAAmB,UAAW,CAC1D,KAAM,GAAW,KAAK,KAAK,IAAI,GAC/B,AAAI,EACA,GAAS,kBAAkB,GAC3B,KAAK,KAAK,OAAO,IAEjB,KAAK,KAAK,IAAI,EAAK,GAAI,IAAkB,EAAK,KAAM,EAAY,KAAK,cAIjF,SAAW,KAAe,MAAK,KAAK,OAAQ,CACxC,KAAM,GAAa,iBAAoB,IAAI,GACrC,EAAY,iBAAa,eAAe,GAC9C,AAAI,CAAC,GAAa,CAAC,EACf,KAAK,KAAK,OAAO,GACd,AAAK,EAIA,GACJ,KAAK,KAAK,IAAI,GAAa,kBAAkB,OAC7C,KAAK,KAAK,OAAO,GALjB,KAAK,KAAK,IAAI,GAAa,WAAW,OACtC,KAAK,KAAK,OAAO,OAU7B,YAAY,CACZ,MAAO,MAAK,WAGhB,YAAY,EAAK,CACb,MAAO,MAAK,KAAK,IAAI,IAI7B,QAAwB,CACpB,YAAY,EAAK,EAAY,EAAS,EAAY,CAC9C,KAAK,KAAO,EACZ,KAAK,YAAc,EACnB,KAAK,SAAW,EAChB,KAAK,YAAc,EACnB,KAAK,YAAc,GAGvB,WAAW,EAAY,CACnB,KAAM,GAAoB,CAAC,CAAC,KAAK,aAAgB,CAAC,CAAC,EAE7C,EAAe,AADL,KAAK,aAAe,GAEhC,GAAW,KAAO,KAAK,YAAY,IACnC,EAAW,QAAU,KAAK,YAAY,OACtC,EAAW,iBAAmB,KAAK,YAAY,gBAEnD,MAAI,IAAqB,EACrB,MAAK,YAAc,EACZ,IAEJ,GAGX,kBAAkB,EAAS,CACvB,MAAI,CAAC,GAAW,CAAC,KAAK,SACX,GAEX,MAAK,SAAW,EACT,OAGP,MAAM,CACN,MAAO,MAAK,QAGZ,QAAQ,SACR,MAAQ,UAAK,WAAL,cAAe,QAAS,GAAM,UAAK,cAAL,cAAkB,QAAS,MAGjE,YAAY,CACZ,MAAO,MAAK,WAAa,QAOzB,WAAW,OACX,MAAO,SAAK,cAAL,cAAkB,KAAM,KAAK,aAGpC,iBAAiB,CACjB,GAAI,GAAK,OAAO,iBAChB,MAAI,MAAK,aACL,GAAK,KAAK,IAAI,EAAI,KAAK,YAAY,iBAEnC,KAAK,UACL,GAAK,KAAK,IAAI,EAAI,KAAK,SAAS,iBAE7B,EAGX,SAAS,EAAO,CAIZ,GAAI,IAAU,KACV,MAAO,GAEX,GAAI,KAAK,QAAU,EAAM,MACrB,MAAO,GAAM,MAAQ,KAAK,MACvB,CACH,KAAM,GAAM,KAAK,eAAiB,EAAM,eACxC,MAAI,KAAQ,EACD,KAAK,IAAM,EAAM,IAAM,GAAK,EAEhC,QAIT,QAAO,EAAM,KAAM,CACrB,GAAI,KAAK,YAAa,CAClB,QAAQ,IAAI,kCACZ,OAEJ,KAAK,YAAc,GACnB,GAAI,CACA,KAAM,MAAK,YAAY,eAAe,KAAK,IAAK,WAEhD,KAAK,YAAc,KCpJxB,gBAA8B,GAAW,CAC5C,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,MAAQ,KAAK,OAAO,UAAY,GAAI,MAAK,KAAK,OAAO,WAAa,KACvE,KAAK,gBAAkB,GACvB,KAAK,WAAa,KAClB,KAAK,WAAa,KACd,MAAK,OAAO,aAAe,KAAK,OAAO,qBACvC,KAAK,mBAET,KAAK,yBAAyB,EAAQ,aAAc,QAGxD,eAAgB,OACZ,MAAM,gBACN,QAAK,aAAL,QAAiB,mBAIjB,mBAAmB,CACnB,MAAO,MAAK,MAAM,mBAGlB,YAAY,CACZ,MAAO,uBAAuB,mBAAmB,KAAK,MAAM,OAAO,mBAAmB,KAAK,OAAO,SAGlG,oBAAoB,CACpB,MAAO,uBAAuB,mBAAmB,KAAK,aAGtD,cAAc,CACd,MAAO,MAAK,OAAO,aAAe,KAAK,UAGvC,SAAS,CACT,MAAO,MAAK,OAAO,UAGnB,kBAAkB,CAClB,MAAO,GAAG,KAAK,WAAW,gBAAgB,kBAAkB,KAAK,YAIjE,oBAAoB,CACpB,MAAO,GAAyB,KAAK,OAAO,QAGhD,UAAU,EAAM,CACZ,MAAO,IAAiB,KAAK,OAAO,UAAW,EAAM,KAAK,SAAU,KAAK,qBAGzE,eAAe,CACf,MAAO,GAAe,KAAK,WAG3B,cAAc,CACd,MAAO,MAAK,eAGZ,OAAO,CACP,MAAO,MAAK,OAAS,KAAK,MAAM,mBAAmB,GAAI,CAAC,MAAO,UAAW,IAAK,eAG/E,OAAO,CACP,MAAO,MAAK,OAAS,KAAK,MAAM,mBAAmB,GAAI,CAAC,KAAM,UAAW,OAAQ,eAGjF,QAAQ,CACR,MAAO,MAAK,OAAO,SAAW,KAAK,WAAW,UAG9C,iBAAiB,CACjB,MAAO,MAAK,mBAGZ,eAAe,CACf,MAAO,MAAK,OAAO,gBAGnB,UAAU,CACV,MAAO,MAAK,OAAO,QAGvB,aAAc,CACV,MAAO,MAAK,OAAO,QAGvB,sBAAsB,EAAM,CACxB,MAAM,sBAAsB,GAC5B,GAAI,GAAiB,GACrB,GAAI,GAAQ,YAAgB,KAAmB,EAAK,SAAW,KAAK,OAAQ,CAExE,KAAM,GAAc,KAAK,OAAO,UAC1B,EAAiB,EAAK,OAAO,UAEnC,EAAkB,EAAc,EAAmB,EAAI,GAAK,IAEhE,AAAI,IAAmB,KAAK,iBACxB,MAAK,gBAAkB,EACvB,KAAK,WAAW,mBAIxB,YAAY,EAAO,EAAO,EAAc,CACpC,KAAM,GAAS,MAAM,YAAY,EAAO,EAAO,GAC/C,MAAI,GAAO,cACP,KAAK,mBAET,KAAK,yBAAyB,EAAc,GACrC,EAGX,yBAAyB,EAAc,EAAO,SAC1C,KAAM,GAAa,KAAK,OAAO,aAC/B,GAAI,EAAY,CAEZ,KAAM,GAAS,QAAK,aAAL,cAAiB,YAAY,EAAY,EAAO,GAC/D,AAAI,mBAAQ,gBAAiB,CAAC,KAAK,aAC/B,MAAK,eAAe,KAAK,YACzB,KAAK,WAAa,EAAa,IAEhC,kBAAQ,eACP,SAAK,aAAL,QAAiB,eAK7B,YAAa,CACT,KAAK,QAAQ,WAAW,KAAK,QAGjC,MAAM,EAAS,EAAM,EAAM,KAAM,CAC7B,MAAO,MAAK,MAAM,UAAU,iBAAkB,KAAK,OAAO,MAAM,EAAS,GAAO,KAAM,GAG1F,OAAO,EAAQ,EAAK,CAChB,MAAO,MAAK,MAAM,cAAc,KAAK,OAAO,GAAI,EAAQ,MAGxD,YAAY,CACZ,MAAO,MAAK,aAAa,oBAAoB,KAAK,OAAO,WAGzD,YAAY,CACZ,MAAI,MAAK,QAAU,WACR,KAAK,WAET,QAGP,WAAW,CACX,MAAO,MAAK,aAAa,YAAY,cAGzC,MAAM,EAAK,EAAM,KAAM,CACnB,MAAO,MAAK,OAAO,UAAU,EAAK,QAAS,KAAM,IAAO,SACpD,GAAI,CAAC,KAAK,SAAU,CAChB,EAAI,IAAI,qBAAsB,IAC9B,OAEJ,GAAI,KAAK,OAAO,eAAe,GAAM,CACjC,EAAI,IAAI,kBAAmB,IAC3B,OAEJ,KAAM,GAAY,WAAK,OAAO,qBAAZ,cAAgC,IAAI,KAApC,cAA0C,eAC5D,AAAI,GAAa,CAAC,EAAU,aAAa,kBACrC,GAAI,IAAI,kBAAmB,IAC3B,KAAM,GAAU,aAAa,SAE7B,KAAM,MAAK,MAAM,UAAU,aAAc,KAAK,OAAO,SAAS,GAAM,KAAM,KAKtF,eAAe,EAAK,EAAM,KAAM,CAC5B,MAAO,MAAK,OAAO,UAAU,EAAK,iBAAkB,KAAM,IAAO,SAC7D,GAAI,CAAC,KAAK,aAAa,oBAAoB,KAAK,WAAW,QAAS,CAChE,EAAI,IAAI,qBAAsB,IAC9B,OAEJ,GAAI,CAAC,KAAK,OAAO,eAAe,GAAM,CAClC,EAAI,IAAI,kBAAmB,IAC3B,OAEJ,GAAI,GAAQ,WAAK,OAAO,qBAAZ,cAAgC,IAAI,KAApC,cAA0C,gBACtD,AAAK,GACD,GAAQ,KAAM,MAAK,UAAU,sBAAsB,KAAK,OAAO,GAAI,IAEvE,AAAI,EACA,KAAM,MAAK,MAAM,cAAc,EAAM,GAAI,KAAM,GAE/C,EAAI,IAAI,cAAe,MAKnC,eAAe,EAAK,EAAM,KAAM,CAC5B,MAAO,MAAK,OAAO,UAAU,EAAK,iBAAkB,KAAM,IAAO,CAC7D,AAAI,KAAK,OAAO,eAAe,GAC3B,KAAM,MAAK,eAAe,EAAK,GAE/B,KAAM,MAAK,MAAM,EAAK,KAKlC,kBAAmB,CACf,KAAM,CAAC,cAAa,sBAAsB,KAAK,OAC/C,AAAI,CAAC,GAAe,CAAC,EACb,KAAK,YACL,MAAK,WAAa,MAGjB,MAAK,YACN,MAAK,WAAa,GAAI,IAAmB,OAE7C,KAAK,WAAW,OAAO,EAAa,OAIxC,YAAY,CACZ,MAAK,MAAK,OAAO,eAGV,KAAK,WAFD,MC9NnB,KAAM,IAAS,4BACT,GAAwB,cACxB,GAAgB,uBAMhB,GAAO,GAAG,SAAoB,MAAiB,KAM/C,GAAiB,sBAAsB,QAWvC,GAAW,GAAG,KAAS,KAAO,MAEvB,GAAQ,GAAI,QAAO,GAAU,MCtBnC,YAAiB,EAAM,EAAU,CACpC,KAAM,GAAU,EAAK,SAAS,IAC9B,GAAI,GAAO,EACX,OAAS,KAAS,GAAS,CACvB,KAAM,GAAgB,EAAK,MAAM,EAAM,EAAM,OAC7C,EAAS,EAAe,IACxB,EAAS,EAAM,GAAI,IACnB,KAAM,GAAM,EAAM,GAAG,OACrB,EAAO,EAAM,MAAQ,EAEzB,KAAM,GAAgB,EAAK,MAAM,GACjC,EAAS,EAAe,IC7BrB,YAAwB,EAAM,CACjC,KAAM,GAAQ,GACR,EAAQ,EAAK,MAAM;AAAA,GAGnB,EAAkB,CAAC,EAAM,IAAW,CACtC,AAAI,EACA,EAAM,KAAK,GAAI,IAAS,EAAM,CAAC,GAAI,IAAS,MAE5C,EAAM,KAAK,GAAI,IAAS,KAIhC,OAAS,GAAI,EAAG,EAAI,EAAM,OAAQ,GAAK,EAAG,CACtC,KAAM,GAAO,EAAM,GACnB,AAAI,EAAK,QACL,GAAQ,EAAM,GAGb,AADc,GAAM,EAAM,OAAS,GAEpC,EAAM,KAAK,GAAI,KAIvB,MAAO,IAAI,IAAY,EAAM,GAG1B,YAAsB,EAAM,CAC/B,MAAO,IAAI,IAAY,EAAM,CAAC,GAAI,IAAS,KAGxC,QAAkB,CACrB,YAAY,EAAO,EAAS,CACxB,KAAK,MAAQ,EACb,KAAK,QAAU,KAGf,OAAO,CAAE,MAAO,UAGjB,QAAgB,CACnB,YAAY,EAAU,EAAM,CACxB,KAAK,SAAW,EAChB,KAAK,KAAO,KAGZ,OAAO,CAAE,MAAO,aAGjB,QAAgB,CACnB,YAAY,EAAa,EAAO,CAC5B,KAAK,MAAQ,EACb,KAAK,YAAc,KAGnB,OAAO,CAAE,MAAO,QAGjB,QAAiB,CACpB,YAAY,EAAM,EAAM,CACpB,KAAK,KAAO,EACZ,KAAK,KAAO,KAGZ,OAAO,CAAE,MAAO,SAGjB,QAAe,IACd,OAAO,CAAE,MAAO,QAGjB,QAAkB,IACjB,OAAO,CAAE,MAAO,WAGjB,QAAiB,CACpB,YAAY,EAAQ,EAAU,CAC1B,KAAK,OAAS,EAAO,cACrB,KAAK,SAAW,KAGhB,OAAO,CAAE,MAAO,UAGjB,QAAgB,CACnB,YAAY,EAAK,EAAO,EAAQ,EAAK,EAAO,CACxC,KAAK,IAAM,EACX,KAAK,MAAQ,EACb,KAAK,OAAS,EACd,KAAK,IAAM,EACX,KAAK,MAAQ,KAGb,OAAO,CAAE,MAAO,SAGjB,QAAe,CAClB,YAAY,EAAI,EAAM,EAAU,CAC5B,KAAK,GAAK,EACV,KAAK,KAAO,EACZ,KAAK,SAAW,KAGhB,OAAO,CAAE,MAAO,UAEhB,oBAAoB,CACpB,MAAO,GAAyB,KAAK,OAGrC,iBAAiB,CACjB,MAAO,GAAe,KAAK,KAI5B,QAAe,CAClB,YAAY,EAAK,EAAS,CACtB,KAAK,IAAM,EACX,KAAK,QAAU,KAGf,OAAO,CAAE,MAAO,QAGjB,QAAe,CAClB,YAAY,EAAM,CACd,KAAK,KAAO,KAGZ,OAAO,CAAE,MAAO,QAGxB,YAAsB,EAAK,CACvB,MAAO,GAAK,OAAS,UAAY,EAAK,SAAW,aAG9C,QAAkB,CACrB,YAAY,EAAc,EAAO,CAC7B,KAAK,aAAe,EACpB,KAAK,MAAQ,EAGjB,YAAY,EAAQ,CAIhB,GAAI,GAAI,EACR,KAAO,EAAI,KAAK,MAAM,QAAU,GAAa,KAAK,MAAM,IAAK,IAAI,CACjE,KAAK,MAAM,OAAO,EAAG,EAAG,GAAI,IAAS,KCvItC,KAAM,IAAa,GAAW,QAAS,QAEvC,gBAA2B,GAAgB,CAC9C,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,aAAe,KACpB,KAAK,QAAU,QAGf,QAAQ,CACR,MAAO,UAGX,WAAW,EAAM,CACb,MAAO,IAAa,GAGxB,gBAAiB,CACb,MAAO,IAAW,SAGlB,OAAO,CACP,KAAM,GAAO,KAAK,WACZ,EAAS,KAAK,iBAKpB,MAAI,EAAC,KAAK,cAAgB,KAAK,aAAa,eAAiB,GAAQ,KAAK,UAAY,IAKlF,MAAK,aAAe,KAAK,WAAW,EAAM,GAC1C,KAAK,QAAU,GAEZ,KAAK,cC3BpB,KAAM,IAAc,CAAC,KAAM,SAAU,OAAQ,MAAO,QAC9C,GAAa,CAAC,MAAO,cACrB,GAAc,CAAC,QAAS,OAAQ,MAAO,SAAU,UAAU,IAAI,GAAQ,GAAG,QAC1E,GAAU,oBACV,GAAa,GAAG,QAEtB,QAAmB,CACf,YAAY,EAAQ,EAAiB,CACjC,KAAK,OAAS,EACd,KAAK,gBAAkB,EAG3B,cAAc,EAAM,CAChB,GAAI,CAAC,EAAK,WAAW,IACjB,MAAO,MAEX,KAAM,GAAW,EAAK,UAAU,GAAW,QAC3C,MAAI,GAAS,KAAO,IACT,EAEJ,KAGX,UAAU,EAAM,EAAU,CACtB,KAAM,GAAO,KAAK,OAAO,kBAAkB,EAAM,QAC3C,EAAQ,iBAAM,cAEpB,GAAI,CAAC,GAAS,CAAC,GAAY,KAAK,GAAU,EAAM,WAAW,IACvD,MAAO,IAAI,IAAW,OAAQ,GAElC,KAAM,GAAS,KAAK,cAAc,GAClC,MAAI,GACO,GAAI,IAAS,EAAQ,EAAM,GAE/B,GAAI,IAAS,EAAM,GAG9B,UAAU,EAAM,CACZ,KAAM,GAAS,KAAK,OACpB,GAAI,GAAQ,KACZ,AAAI,EAAO,mBAAmB,KAAU,MAEpC,GAAQ,SAAS,EAAO,kBAAkB,EAAM,WAAa,GAEjE,KAAM,GAAQ,GACd,SAAW,KAAS,GAAO,cAAc,GAAO,CAC5C,GAAI,EAAO,mBAAmB,KAAW,KACrC,SAEJ,KAAM,GAAO,KAAK,cAAc,EAAO,cAAc,IACrD,EAAM,KAAK,GAEf,MAAO,IAAI,IAAU,EAAO,GAGhC,eAAe,EAAM,EAAK,CACtB,MAAO,IACH,KAAK,OAAO,cAAc,IAC1B,KAAK,OAAO,mBAAmB,KAAU,EAGjD,eAAe,EAAM,CACjB,KAAM,GAAS,KAAK,OACpB,GAAI,GACJ,SAAW,KAAS,GAAO,cAAc,GAAO,CAC5C,EAAW,EACX,MAEJ,GAAI,GAAW,KACf,GAAI,CAAC,KAAK,eAAe,EAAU,QAC/B,MAAO,IAAI,IAAU,EAAU,KAAK,OAAO,YAAY,IAE3D,KAAM,GAAK,EAAO,kBAAkB,EAAU,UAAY,GAC1D,SAAW,KAAU,GAAG,MAAM,KAC1B,GAAI,EAAO,WAAW,cAAgB,CAAC,EAAO,WAAW,cAAe,CACpE,EAAW,EAAO,UAAU,GAC5B,MAGR,MAAO,IAAI,IAAU,EAAU,KAAK,OAAO,YAAY,IAG3D,WAAW,EAAM,CACb,KAAM,GAAS,KAAK,OACd,EAAM,EAAO,kBAAkB,EAAM,QAAU,GAC/C,EAAM,KAAK,gBAAgB,OAAO,GAExC,GAAI,CAAC,EACD,MAAO,MAEX,KAAM,GAAQ,SAAS,EAAO,kBAAkB,EAAM,WAAa,KAC7D,EAAS,SAAS,EAAO,kBAAkB,EAAM,YAAc,KAC/D,EAAM,EAAO,kBAAkB,EAAM,OACrC,EAAQ,EAAO,kBAAkB,EAAM,SAC7C,MAAO,IAAI,IAAU,EAAK,EAAO,EAAQ,EAAK,GAGlD,cAAc,EAAK,EAAK,CACpB,KAAM,GAAQ,GACd,SAAW,KAAQ,MAAK,OAAO,cAAc,GAAM,CAC/C,GAAG,CAAC,KAAK,eAAe,EAAM,GAC1B,SAEJ,KAAM,GAAW,KAAK,OAAO,cAAc,GACrC,EAAU,KAAK,iBAAiB,GACtC,EAAM,KAAK,GAEf,MAAO,GAGX,eAAe,EAAM,CACjB,GAAI,GAAU,KACd,SAAW,KAAQ,MAAK,OAAO,cAAc,GAAO,CAChD,EAAU,EACV,MAEJ,MAAI,MAAK,eAAe,EAAS,MACtB,KAAK,cAAc,EAAS,MAEhC,KAGX,eAAe,EAAM,CACjB,KAAM,GAAO,GACb,SAAW,KAAQ,MAAK,OAAO,cAAc,GACzC,AAAG,CAAC,KAAK,eAAe,EAAM,OAG9B,EAAK,KAAK,KAAK,cAAc,EAAM,OAEvC,MAAO,GAGX,WAAW,EAAM,CAEb,KAAM,GAAW,MAAM,KAAK,KAAK,OAAO,cAAc,IACtD,GAAI,GAAM,EACV,MAAI,MAAK,eAAe,EAAS,GAAI,UAAY,KAAK,eAAe,EAAS,GAAI,SAC9E,GAAO,KAAK,eAAe,EAAS,IACpC,EAAO,KAAK,eAAe,EAAS,KAC7B,KAAK,eAAe,EAAS,GAAI,UACxC,GAAO,KACP,EAAO,KAAK,eAAe,EAAS,KAEjC,GAAI,IAAW,EAAM,GAShC,mBAAmB,EAAM,CACrB,KAAM,GAAS,KAAK,OACd,EAAM,EAAO,mBAAmB,GAChC,EAAW,EAAO,cAAc,GACtC,OAAQ,OACC,IAAK,CACN,KAAM,GAAU,KAAK,iBAAiB,GACtC,MAAO,MAAK,UAAU,EAAM,OAE3B,KACD,MAAO,IAAI,YACN,CACL,GAAI,CAAC,GAAY,SAAS,GACtB,MAAO,MAEX,KAAM,GAAU,KAAK,iBAAiB,GACtC,MAAO,IAAI,IAAW,EAAK,KAUvC,gBAAgB,EAAM,CAClB,MAAI,MAAK,OAAO,cAAc,GACnB,KAAK,mBAAmB,GAE5B,KASX,kBAAkB,EAAM,CACpB,KAAM,GAAS,KAAK,OACd,EAAM,EAAO,mBAAmB,GAChC,EAAW,EAAO,cAAc,GACtC,OAAQ,OACC,SACA,SACA,SACA,SACA,SACA,KAAM,CACP,KAAM,GAAU,KAAK,iBAAiB,GACtC,MAAO,IAAI,IAAY,SAAS,EAAI,IAAK,OAExC,SACA,KACD,MAAO,MAAK,UAAU,OACrB,MACD,MAAO,MAAK,eAAe,OAC1B,KACD,MAAO,IAAI,QACV,MACD,MAAO,MAAK,WAAW,OACtB,IAAK,CACN,KAAM,GAAU,KAAK,iBAAiB,GACtC,MAAO,IAAI,IAAW,EAAK,OAE1B,QACD,MAAO,MAAK,WAAW,WAClB,CACL,GAAI,CAAC,GAAW,SAAS,GACrB,MAAO,MAEX,KAAM,GAAS,KAAK,cAAc,GAClC,MAAO,IAAI,IAAW,EAAK,KAUvC,eAAe,EAAM,CACjB,MAAI,MAAK,OAAO,cAAc,GACnB,KAAK,kBAAkB,GAE3B,KAGX,gBAAgB,EAAM,EAAM,CACxB,GAAG,CAAC,KAAK,OAAO,WAAW,GACvB,MAAO,GAIX,KAAM,GAAkB,CAAC,EAAM,IAAW,CACtC,AAAI,EACA,EAAK,KAAK,GAAI,IAAS,EAAM,CAAC,GAAI,IAAS,MAE3C,EAAK,KAAK,GAAI,IAAS,KAG/B,UAAQ,KAAK,OAAO,YAAY,GAAO,GAChC,GAGX,eAAe,EAAM,CACjB,MAAO,CAAC,KAAK,eAAe,EAAM,YAGtC,kBAAkB,EAAO,EAAM,CAC3B,SAAW,KAAY,GAAO,CAC1B,GAAI,KAAK,gBAAgB,EAAU,GAG/B,SAEJ,KAAM,GAAO,KAAK,gBAAgB,GAClC,GAAI,EAAM,CACN,EAAK,KAAK,GACV,SAIJ,AAAI,KAAK,eAAe,IACpB,KAAK,kBAAkB,KAAK,OAAO,cAAc,GAAW,IAKxE,iBAAiB,EAAO,CACpB,KAAM,GAAO,GACb,YAAK,kBAAkB,EAAO,GACvB,EAIX,eAAe,EAAO,EAAM,CACxB,SAAW,KAAY,GAAO,CAC1B,GAAI,KAAK,gBAAgB,EAAU,GAG/B,SAEJ,KAAM,GAAO,KAAK,gBAAgB,IAAa,KAAK,eAAe,GACnE,GAAI,EAAM,CACN,EAAK,KAAK,GACV,SAGJ,AAAI,KAAK,eAAe,IACpB,KAAK,eAAe,KAAK,OAAO,cAAc,GAAW,IAKrE,cAAc,EAAO,CACjB,KAAM,GAAO,GACb,YAAK,eAAe,EAAO,GACpB,GAIR,YAAuB,EAAU,EAAiB,EAAM,CAC3D,KAAM,GAAc,EAAS,UAAU,GAEjC,EAAQ,AADO,GAAI,IAAa,EAAa,GACxB,cAAc,EAAY,WACrD,MAAO,IAAI,IAAY,EAAM,GC1U1B,gBAAuB,GAAa,CACvC,kBAAkB,EAAK,OACnB,MAAO,SAAK,gBAAL,cAAqB,KAAQ,GAGxC,eAAgB,CACZ,MAAO,MAAK,kBAAkB,QAGlC,mBAAoB,CAChB,MAAO,MAAK,kBAAkB,kBAGlC,UAAW,CACP,MAAI,MAAK,mBAAqB,GAAW,KAC9B,KAAK,oBAEL,KAAK,gBAIpB,gBAAiB,OACb,MAAI,SAAK,gBAAL,cAAoB,UAAW,yBACxB,GAAW,KAEX,GAAW,MAI1B,WAAW,EAAM,EAAQ,OACrB,GAAI,GACJ,MAAI,KAAW,GAAW,KACtB,EAAc,GAAc,KAAK,SAAU,KAAK,iBAAkB,GAElE,EAAc,GAAe,GAE7B,SAAK,gBAAL,cAAoB,WAAY,WAChC,EAAY,YAAY,KAAK,KAAK,gBAE/B,GCzCR,gBAA2B,GAAgB,IAC1C,QAAQ,CACR,MAAO,cAGP,cAAc,CACd,KAAM,CAAC,mBAAmB,KAAK,OAC/B,MAAI,MAAK,YACD,EACO,KAAK,sCAAsC,MAE3C,KAAK,qCAGZ,EACO,KAAK,sCAAsC,MAE3C,KAAK,wCAKpB,cAAc,CACd,MAAO,MAAK,OAAO,eAInB,YAAY,CACZ,MAAO,GAGX,uBAAwB,CACpB,MAAO,MAAK,OAAO,yBC/B3B,KAAM,IAAa,IACb,GAAY,IAEX,gBAA4B,GAAgB,CAC/C,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,oBAAsB,KAC3B,KAAK,eAAiB,KACtB,KAAK,WAAa,GAClB,KAAK,OAAS,QAGd,cAAc,CACd,MAAO,MAAK,WAAa,KAAK,OAAO,aAAa,SAAW,EAAW,wBAGxE,mBAAmB,CACnB,KAAM,CAAC,gBAAgB,KAAK,OAC5B,MAAO,IAAgB,KAAK,MAAO,EAAa,qBAAuB,EAAa,sBAAyB,QAG7G,aAAa,CACb,KAAM,CAAC,gBAAgB,KAAK,OAC5B,OAAQ,iBAAc,YACb,GAAW,QACZ,MAAO,MAAK,mBACX,GAAW,0BACX,GAAW,WACZ,MAAO,MAAK,sBACX,GAAW,qBACZ,MAAO,MAAK,qBACX,GAAW,QACZ,MAAO,MAAK,mBACX,GAAW,MACZ,MAAO,MAAK,cAAc,EAAa,MAAM,kBAE7C,MAAO,OAIf,eAAe,SACf,GAAI,CAAC,KAAK,WACN,MAAO,GAEX,GAAI,KAAK,oBACL,MAAO,MAAK,oBAAoB,IAC7B,CACH,KAAM,GAAe,QAAK,cAAc,OAAnB,cAAyB,cAC9C,GAAI,EACA,MAAO,MAAK,iBAAiB,gBAAgB,EAAc,KAAK,MAAO,KAAK,OAAQ,SAG5F,GAAI,KAAK,OAAO,UAAW,CACvB,KAAM,GAAa,KAAK,OAAO,aAAa,cAAc,sBAC1D,MAAO,IAAc,EAAW,aAAa,IAEjD,GAAI,KAAK,uBAAwB,CAC7B,GAAI,KAAK,eACL,MAAO,MAAK,eAAe,IACxB,CACH,KAAM,GAAS,QAAK,gBAAL,cAAoB,IACnC,GAAI,MAAO,IAAW,SAClB,MAAO,MAAK,iBAAiB,gBAAgB,EAAQ,KAAK,MAAO,KAAK,OAAQ,UAI1F,MAAO,GAGX,eAAgB,CACZ,MAAM,gBACN,KAAK,WAAa,GAClB,KAAK,WAAW,gBACX,KAAK,WACN,KAAK,gCAIT,QAAQ,OACR,KAAM,GAAO,QAAK,gBAAL,cAAoB,KACjC,MAAO,MAAK,MAAM,kBAAM,GAAI,KAAK,mBAGjC,SAAS,OACT,KAAM,GAAO,QAAK,gBAAL,cAAoB,KACjC,MAAO,MAAK,MAAM,kBAAM,GAAI,KAAK,mBAGjC,WAAW,OACX,KAAM,GAAO,QAAK,gBAAL,cAAoB,KACjC,MAAO,kBAAM,YAGb,QAAQ,CACR,MAAO,MAAK,cAAc,QAG1B,QAAQ,CACR,MAAI,MAAK,OACE,yBAAyB,KAAK,OAAO,UAEzC,KAGX,aAAa,EAAK,CACd,KAAK,OAAS,EACd,KAAK,WAAW,cAGd,oBAAmB,EAAM,CAC3B,KAAM,GAAO,KAAM,MAAK,iBAAiB,sBAAsB,EAAM,IACrE,GAAI,KAAK,WAAY,CACjB,EAAK,UACL,OAEJ,MAAO,MAAK,MAAM,QAGhB,6BAA6B,OAC/B,GAAI,CACA,KAAM,GAAgB,QAAK,cAAc,OAAnB,cAAyB,eACzC,EAAO,KAAK,cAAc,KAChC,AAAI,EACA,MAAK,oBAAsB,KAAM,MAAK,mBAAmB,GACzD,KAAK,WAAW,iBACT,GAAQ,KAAK,wBACpB,MAAK,eAAiB,KAAM,MAAK,mBAAmB,GACpD,KAAK,WAAW,uBAEf,EAAP,CACE,KAAK,OAAS,EACd,KAAK,WAAW,UAIxB,cAAe,OACX,KAAM,GAAO,QAAK,gBAAL,cAAoB,KAC3B,EAAoB,GAAa,kBAAM,GACvC,EAAmB,GAAY,kBAAM,GAG3C,MAAO,MAAK,IAAI,EAAkB,EAAmB,GAGzD,sBAAuB,CACnB,MAAO,ICjJR,gBAAwB,GAAc,CACzC,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,aAAe,KAAK,WAAW,eAAe,CAE/C,KAAK,WAAW,QAAQ,OAAQ,KAAK,MAAM,IAC3C,KAAK,WAAW,QAAQ,WAAY,KAAK,OAAO,SAIpD,cAAc,CACd,MAAK,MAAK,UAGH,GAFI,KAAK,gBAKhB,QAAQ,CACR,MAAO,SClBR,gBAAwB,GAAc,MACnC,YAAY,CACd,KAAM,GAAO,KAAK,cAAc,KAChC,AAAI,GAAQ,CAAC,KAAK,gBACd,MAAK,eAAiB,KAAM,MAAK,mBAAmB,GACpD,KAAK,WAAW,gBAIpB,WAAW,OACX,GAAI,KAAK,eACL,MAAO,MAAK,eAAe,IAE/B,KAAM,GAAS,QAAK,gBAAL,cAAoB,IACnC,MAAI,OAAO,IAAW,SACX,KAAK,iBAAiB,OAAO,GAEjC,MAGP,QAAQ,CACR,MAAO,QAGX,sBAAuB,CACnB,MAAO,gBC3BY,EAAc,EAAmB,EAAW,IAC/D,OAAO,cAAc,GAAO,MACtB,GAAO,KAAK,IAAI,EAAG,KAAK,MAAM,KAAK,IAAI,GAAQ,KAAK,IAAI,QACxD,EAAgB,KAAK,MAAM,EAAO,KAAK,IAAI,KAAM,IAAO,QAAQ,UAC9D,OACC,SAAU,GAAG,cACb,SAAU,GAAG,WACb,SAAU,GAAG,WACb,SAAU,GAAG,cAGnB,GCPJ,gBAAuB,GAAgB,CAC1C,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,eAAiB,KACtB,KAAK,aAAe,QAGlB,WAAW,CACb,GAAI,KAAK,cAAgB,KAAK,UAC1B,OAEJ,KAAM,GAAU,KAAK,cACf,EAAW,EAAQ,KACzB,KAAK,aAAe,GACpB,KAAK,WAAW,SAChB,GAAI,GACJ,GAAI,CACA,EAAO,KAAM,MAAK,iBAAiB,mBAAmB,GACtD,KAAK,SAAS,WAAW,EAAM,SAC1B,EAAP,CACE,KAAK,eAAiB,UAEtB,WAAM,UACN,KAAK,aAAe,GAExB,KAAK,WAAW,YAGhB,QAAQ,OACR,GAAI,KAAK,eACL,MAAO,4BAA4B,KAAK,eAAe,UAG3D,KAAM,GAAW,AADD,KAAK,cACI,KAEzB,GAAI,KAAK,OAAO,UAAW,CACvB,KAAM,CAAC,gBAAgB,KAAK,OAC5B,OAAQ,iBAAc,YACb,GAAW,QACZ,MAAO,MAAK,uBAAuB,SAClC,GAAW,0BACX,GAAW,WACZ,MAAO,MAAK,kBAAkB,SAC7B,GAAW,qBAAqB,CACjC,KAAM,GAAU,KAAK,MAAO,EAAa,qBAAuB,EAAa,sBAAyB,KACtG,MAAO,MAAK,iBAAiB,MAAa,SAEzC,GAAW,YACX,GAAW,KACZ,MAAO,MAAK,eAAe,SAC1B,GAAW,MACZ,MAAO,MAAK,6BAA6B,MAAa,EAAa,MAAM,kBAEzE,MAAO,2BAA2B,SAEvC,CACH,KAAM,GAAO,GAAW,QAAK,cAAc,OAAnB,cAAyB,MACjD,MAAI,MAAK,aACE,KAAK,mBAAmB,MAAa,MAErC,KAAK,gBAAgB,MAAa,SAKjD,QAAQ,CACR,MAAO,QCrER,gBAA2B,GAAgB,IAC1C,QAAQ,CACR,MAAO,cAGP,WAAW,CACX,GAAI,CACA,KAAM,GAAM,GAAI,KAAI,KAAK,cAAc,SACvC,GAAI,EAAI,WAAa,OACjB,MAAO,GAEX,KAAM,CAAC,KAAgB,GAAe,EAAI,SAAS,MAAM,KACnD,CAAC,EAAQ,GAAW,EAAY,MAAM,KACtC,EAAM,WAAW,GACjB,EAAO,WAAW,GACxB,GAAI,GACJ,SAAW,KAAc,GAAa,CAClC,KAAM,CAAC,EAAM,GAAS,EAAW,MAAM,KACvC,AAAI,IAAS,KACT,GAAc,WAAW,IAGjC,GAAI,KAAK,SAAS,MACd,MAAO,6BAA6B,KAAO,IACxC,CACH,GAAI,GAAM,OAAO,KAAO,IACxB,MAAI,IACA,GAAM,EAAM,MAAM,KAEf,QAEb,CACE,MAAO,OAIX,QAAQ,CACR,MAAO,MAAK,OAAO,KAAK,mCCrCzB,gBAA2B,GAAW,IAErC,QAAQ,CACR,MAAO,kBAGP,eAAe,CACf,KAAM,GAAU,KAAK,OAAO,QAC5B,MAAO,GAAG,KAAK,OAAO,aAAe,KAAK,OAAO,0BAA0B,iBAAS,SCRrF,gBAA6B,GAAW,IAEvC,QAAQ,CACR,MAAO,kBAGP,eAAe,SACf,KAAM,CAAC,SAAQ,UAAS,cAAa,YAAY,KAAK,OAChD,EAAc,KAAK,OAAO,aAAe,EACzC,EAAa,IAAW,EAAW,EAAc,SAAK,OAAO,UAAZ,cAAqB,cAAe,EACrF,EAAa,GAAW,EAAQ,WAChC,EAAiB,GAAe,EAAY,WAElD,GAAI,IAAmB,QAAU,IAAe,OAAQ,CACpD,GAAI,EAAQ,aAAe,EAAY,WACnC,MAAO,GAAG,yBACP,GAAI,EAAQ,cAAgB,EAAY,YAC3C,MAAK,GAAQ,YAGN,GAAG,KAAY,cAAZ,OAA2B,2BAAkC,EAAQ,cAFpE,GAAG,yBAAgC,EAAY,mBAI3D,IAAI,IAAe,OACtB,MAAO,GAAG,oBACP,GAAI,IAAe,SACtB,MAAO,GAAG,gCAAyC,IAChD,GAAI,IAAmB,SAAU,CACpC,GAAI,IAAe,OACf,MAAO,GAAG,6CACP,GAAI,IAAe,QACtB,MAAO,GAAG,qDAEP,IAAe,QAAS,CAC/B,GAAI,IAAa,EACb,MAAO,GAAG,kBACP,CACH,KAAM,GAAS,EAAQ,OACvB,MAAO,GAAG,iCAA0C,IAAa,EAAS,KAAK,IAAW,cAEvF,IAAe,MACtB,MAAO,GAAG,iCAA0C,IAGxD,MAAO,GAAG,2BAAgC,EAAQ,cC1CnD,gBAAiC,GAAa,CACjD,YAAY,EAAO,EAAQ,EAAc,CACrC,KAAM,GAAe,MAAM,YAAY,EAAO,EAAQ,GAEtD,MAAI,GAAM,YAAc,mBAEb,GAAa,QAAQ,SAErB,KAIX,QAAQ,CACR,MAAO,iBAGX,UAAW,CACP,KAAM,GAAkB,KAAK,OAAO,gBAC9B,EAAO,iBAAiB,KAC9B,GAAI,GACJ,MAAI,KAAS,oBACT,EAAS,KAAK,8DAEd,EAAS,kBAAiB,UAAW,KAAK,2DAEvC,GC1BR,gBAAoC,GAAW,IAC9C,QAAQ,CACR,MAAO,kBAGP,eAAe,CACf,KAAM,GAAc,KAAK,OAAO,aAAe,KAAK,OAAO,OAC3D,MAAO,MAAK,OAAO,uCCPpB,gBAAoC,GAAgB,IACnD,QAAQ,CACR,MAAO,wBAGP,QAAQ,CACR,KAAM,GAAO,KAAK,cAAc,KAEhC,MAAI,AADY,MAAK,cAAc,UACnB,UACL,KAAK,iBAAiB,6DAEtB,KAAK,gBAAgB,8DCAjC,YAAsB,EAAa,CAkDtC,MAjDqB,YAAsB,EAAO,EAAY,CAC1D,KAAM,GAAU,OAAO,OAAO,CAAC,QAAO,aAAY,gBAAe,GACjE,GAAI,EAAM,MACN,MAAO,IAAI,IAAQ,GAChB,GAAI,EAAM,WAAa,EAAM,aAAa,qBAC7C,MAAO,IAAI,IAAsB,GAC9B,GAAI,EAAM,UACb,OAAQ,EAAM,eACL,iBAAkB,CACnB,GAAI,EAAM,WACN,MAAO,IAAI,IAAa,GAE5B,KAAM,GAAU,EAAM,QAEtB,OADgB,GAAW,EAAQ,aAE1B,aACA,eACA,UACD,MAAO,IAAI,IAAS,OACnB,UACD,MAAO,IAAI,IAAU,OACpB,UACD,MAAO,IAAI,IAAU,OACpB,SACD,MAAO,IAAI,IAAS,OACnB,aACD,MAAO,IAAI,IAAa,WAGxB,MAAO,WAGd,cACD,MAAO,IAAI,IAAa,OACvB,gBACD,MAAO,IAAI,IAAe,OACzB,mBACD,MAAI,GAAM,WACC,GAAI,IAAa,GAErB,GAAI,IAAmB,OAC7B,oBACD,MAAO,IAAI,IAAsB,WAGjC,MAAO,QC3DpB,YAAqB,EAAO,CAC/B,MAAO,CACH,EAAG,EAAM,MACT,EAAG,EAAM,OACT,SAAU,EAAM,KAAK,SACrB,KAAM,EAAM,KAAK,MCGlB,gBAA4B,EAAU,CACzC,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,QAAQ,EACf,KAAK,MAAQ,EACb,KAAK,YAAc,KACnB,KAAK,cAAgB,KACrB,KAAK,cAAgB,KAAK,cAAc,KAAK,MAC7C,KAAK,eAAiB,KACtB,KAAK,WAAa,KAClB,KAAK,YAAc,KACnB,AAAI,EAAK,WACL,KAAK,YAAc,GAAI,IAAkB,KAAK,aAAa,CAAC,aAAc,KAE1E,KAAK,YAAc,GAAI,IAAkB,MAE7C,KAAK,mBAAqB,KAC1B,KAAK,UAAY,KAAK,WAAW,gBAAgB,gBAG/C,OAAO,CACT,KAAK,MAAM,GAAG,SAAU,KAAK,eAC7B,GAAI,CACA,KAAM,GAAW,KAAM,MAAK,MAAM,eAClC,KAAK,cAAgB,GAAa,KAAK,aAAa,CAChD,OAAQ,KACR,cAEJ,KAAK,YAAc,KAAK,MAAM,GAAI,IAAkB,KAAK,aAAa,CAClE,aAAc,KAAK,cACnB,eAEJ,KAAK,WAAW,2BACX,EAAP,CACE,QAAQ,MAAM,wBAAwB,EAAI;AAAA,EAAa,EAAI,SAC3D,KAAK,eAAiB,EACtB,KAAK,WAAW,SAEpB,KAAK,8BAGH,yBAAyB,CAC3B,GAAI,OAAK,MAAM,YAAc,KAAK,oBAGlC,MAAK,mBAAqB,KAAK,MAAM,cAAc,KACnD,GAAI,CACA,KAAM,MAAK,mBAAmB,UAC9B,KAAM,MAAK,MAAM,cACjB,KAAK,mBAAqB,WACrB,EAAP,CACE,GAAI,EAAI,OAAS,aACb,KAAM,KAKlB,OAAQ,CACJ,KAAK,yBAGT,SAAU,CACN,MAAM,UACN,KAAK,MAAM,IAAI,SAAU,KAAK,eAC1B,KAAK,MAAM,YACX,KAAK,MAAM,UAEX,KAAK,oBACL,MAAK,mBAAmB,QACxB,KAAK,mBAAqB,MAMlC,eAAgB,CAEZ,KAAK,YAAY,aACjB,KAAK,gBAGL,OAAO,CAAE,MAAO,UAChB,WAAW,CAAE,MAAO,MAAK,aACzB,OAAO,CAAE,MAAO,MAAK,MAAM,MAAQ,KAAK,oBACxC,KAAK,CAAE,MAAO,MAAK,MAAM,MACzB,oBAAoB,CAAE,MAAO,MAAK,eAClC,cAAc,CAAE,MAAO,MAAK,MAAM,eAElC,QAAQ,CACR,MAAI,MAAK,eACE,8CAA8C,KAAK,eAAe,UAEzE,KAAK,WACE,8CAA8C,KAAK,WAAW,UAElE,MAGP,eAAe,CACf,MAAO,GAAe,KAAK,SAG3B,oBAAoB,CACpB,MAAO,GAAyB,KAAK,MAAM,eAG/C,UAAU,EAAM,CACZ,MAAO,IAAiB,KAAK,MAAM,UAAW,EAAM,KAAK,SAAU,KAAK,MAAM,oBAG9E,cAAc,CACd,MAAO,MAAK,QAGZ,WAAW,CACX,MAAO,MAAK,MAAM,SAGtB,WAAY,CACR,KAAK,MAAM,WAGX,YAAY,CACZ,MAAO,MAAK,MAAM,WAGtB,YAAa,CACT,KAAK,MAAM,YAGX,YAAY,CACZ,MAAO,MAAK,MAAM,WAGtB,YAAa,CACT,KAAK,MAAM,OAGf,YAAY,EAAO,CACf,MAAO,MAAK,cAAc,QAGxB,cAAa,EAAS,EAAY,CACpC,GAAI,CAAC,KAAK,MAAM,YAAc,EAAS,CACnC,GAAI,CACA,GAAI,GAAU,SACd,AAAI,EAAQ,WAAW,SACnB,GAAU,EAAQ,OAAO,GAAG,OAC5B,EAAU,WAEd,AAAI,EACA,KAAM,GAAW,MAAM,EAAS,GAEhC,KAAM,MAAK,MAAM,UAAU,iBAAkB,CAAC,UAAS,KAAM,UAE5D,EAAP,CACE,eAAQ,MAAM,uBAAuB,EAAI;AAAA,EAAa,EAAI,SAC1D,KAAK,WAAa,EAClB,KAAK,eAAiB,KACtB,KAAK,WAAW,SACT,GAEX,MAAO,GAEX,MAAO,QAGL,mBAAmB,CACrB,GAAI,CACA,KAAM,GAAO,KAAM,MAAK,SAAS,WACjC,MAAK,GAGE,KAAK,UAAU,GAFlB,aAGC,EAAP,CACE,QAAQ,MAAM,SAIhB,WAAU,EAAM,CAClB,KAAM,GAAU,CACZ,KAAM,EAAK,KACX,QAAS,UAEb,KAAM,MAAK,MAAM,UAAU,iBAAkB,EAAS,CAClD,IAAO,KAAK,MAAM,iBAAiB,EAAK,KAAM,EAAK,aAIrD,oBAAoB,CACtB,GAAI,CACA,GAAI,CAAC,KAAK,SAAS,yBAA0B,CACzC,MAAM,4EACN,OAEJ,KAAM,GAAO,KAAM,MAAK,SAAS,SAAS,WAC1C,GAAI,CAAC,EACD,OAEJ,GAAI,CAAC,EAAK,KAAK,SAAS,WAAW,UAC/B,MAAO,MAAK,UAAU,GAE1B,GAAI,GACJ,GAAI,CACA,EAAQ,KAAM,MAAK,SAAS,UAAU,EAAK,YACtC,EAAP,CAEE,KAAI,aAAe,QAAO,YAAc,EAAI,OAAS,EAC3C,GAAI,OAAM,gDAAgD,iBAAM,KAAK,aAErE,EAGd,KAAM,GAAU,CACZ,KAAM,EAAK,KACX,QAAS,UACT,KAAM,GAAY,IAEhB,EAAc,CAChB,IAAO,KAAK,MAAM,iBAAiB,EAAM,KAAM,EAAK,OAIlD,EAAe,AADP,KAAM,MAAK,SAAS,gBAAgB,OAAO,uBAC3B,KAAK,IAAI,EAAM,aAAc,KACrD,EAAY,KAAM,GAAM,MAAM,GACpC,EAAQ,KAAK,eAAiB,GAAY,GAC1C,EAAY,sBACR,KAAK,MAAM,iBAAiB,EAAU,KAAM,EAAK,MACrD,KAAM,MAAK,MAAM,UAAU,iBAAkB,EAAS,SACjD,EAAP,CACE,KAAK,WAAa,EAClB,KAAK,WAAW,SAChB,QAAQ,MAAM,EAAI,aAIpB,sBAAsB,CACxB,GAAI,CACA,GAAI,CAAC,KAAK,SAAS,yBAA0B,CACzC,MAAM,4EACN,OAEJ,KAAM,GAAO,KAAM,MAAK,SAAS,SAAS,WAC1C,GAAI,CAAC,EACD,OAEJ,GAAI,CAAC,EAAK,KAAK,SAAS,WAAW,UAC/B,MAAO,MAAK,UAAU,GAE1B,GAAI,GAAQ,KAAM,MAAK,SAAS,UAAU,EAAK,MAC/C,KAAM,GAAQ,KAAM,MAAK,SAAS,gBAAgB,OAAO,sBACzD,GAAI,GAAS,EAAM,aAAe,EAAO,CACrC,KAAM,GAAc,KAAM,GAAM,MAAM,GACtC,EAAM,UACN,EAAQ,EAEZ,KAAM,GAAU,CACZ,KAAM,EAAK,KACX,QAAS,UACT,KAAM,GAAY,IAEhB,EAAc,CAChB,IAAO,KAAK,MAAM,iBAAiB,EAAM,KAAM,EAAK,OAExD,GAAI,EAAM,aAAe,IAAK,CAC1B,KAAM,GAAY,KAAM,GAAM,MAAM,KACpC,EAAQ,KAAK,eAAiB,GAAY,GAC1C,EAAY,sBACR,KAAK,MAAM,iBAAiB,EAAU,KAAM,EAAK,MAEzD,KAAM,MAAK,MAAM,UAAU,iBAAkB,EAAS,SACjD,EAAP,CACE,KAAK,WAAa,EAClB,KAAK,WAAW,SAChB,QAAQ,MAAM,EAAI,WAItB,OAAO,CACP,MAAO,MAAK,SAGZ,oBAAoB,CACpB,MAAO,MAAK,YAGhB,kBAAmB,CACf,GAAI,GAAO,KAAK,WAAW,KAAK,MAAM,QACtC,EAAO,EAAK,KAAK,KAAK,WAAW,QAAQ,cAAe,KACxD,EAAO,EAAK,KAAK,KAAK,WAAW,QAAQ,UAAW,KACpD,KAAK,WAAW,UAAU,GAG9B,WAAW,EAAO,CACd,AAAK,KAAK,MAAM,YACZ,KAAK,YAAY,cAAc,IAK3C,YAAqB,EAAO,CACxB,KAAM,GAAO,GAAY,GACzB,SAAK,SAAW,EAAM,SACf,EAGX,gBAAgC,EAAU,CACtC,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,cAAgB,EAAQ,gBAG7B,cAAc,CACd,MAAI,MAAK,cAAc,SACf,KAAK,cAAc,WACZ,KAAK,wCAAwC,KAAK,cAAc,SAAS,iBAAiB,KAAK,cAAc,aAE7G,KAAK,wCAAwC,KAAK,cAAc,SAAS,QAE7E,KAAK,cAAc,SACtB,KAAK,cAAc,WACZ,KAAK,wCAAwC,KAAK,cAAc,SAAS,iBAAiB,KAAK,cAAc,aAE7G,KAAK,wCAAwC,KAAK,cAAc,SAAS,QAG7E,KAAK,4BAIhB,OAAO,CACP,MAAO,YCjVR,gBAAmC,EAAU,CAChD,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,gBAAe,WAAW,EACjC,KAAK,SAAW,EAChB,KAAK,cAAgB,EACrB,KAAK,OAAS,KACd,KAAK,MAAQ,MAGb,QAAQ,OACR,MAAO,QAAK,SAAL,cAAa,aAGlB,OAAO,CACT,KAAK,MAAQ,GACb,KAAK,WAAW,QAChB,GAAI,CACA,KAAM,GAAS,KAAM,MAAK,SAAS,SAAS,KAAK,eAKjD,KAAK,WAAW,KAAK,OAAQ,SAExB,EAAP,CACE,KAAK,OAAS,EACd,KAAK,MAAQ,GACb,KAAK,WAAW,aAIpB,OAAO,CACP,MAAO,MAAK,SAGZ,OAAO,CACP,MAAO,WCnCR,gBAA8B,EAAU,CAC3C,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,SAAQ,mBAAmB,EAClC,KAAK,QAAU,EACf,KAAK,iBAAmB,EACxB,KAAK,gBAAkB,KAAK,gBAAgB,KAAK,MACjD,KAAK,OAAS,KACd,KAAK,UAAY,KAAK,WAAW,gBAAgB,WACjD,KAAK,QAAQ,GAAG,SAAU,KAAK,iBAC/B,KAAK,SAAW,KACZ,KAAK,QAAQ,SACb,MAAK,SAAW,GAAI,IAAoB,KAAK,QAAQ,QAAS,EAAiB,KAAK,WAExF,KAAK,iBAAmB,KAAK,4BAG7B,OAAO,CAAE,MAAO,YAChB,WAAW,CAAE,MAAO,MAAK,aACzB,OAAO,CAAE,MAAO,MAAK,QAAQ,QAC7B,KAAK,CAAE,MAAO,MAAK,QAAQ,MAC3B,cAAc,CAAE,MAAO,MAAK,QAAQ,eACpC,kBAAkB,CAAE,MAAO,MAAK,QAAQ,mBACxC,UAAU,CAAE,MAAO,MAAK,YACxB,OAAO,CAAE,MAAO,MAAK,QAAQ,WAAa,KAAK,QAAQ,aAEvD,QAAQ,CACR,MAAI,MAAK,OACE,yBAAyB,KAAK,OAAO,UAEzC,MAGP,eAAe,CACf,MAAO,GAAe,KAAK,SAG3B,oBAAoB,CACpB,MAAO,GAAyB,KAAK,QAAQ,eAGjD,UAAU,EAAM,CACZ,MAAO,IAAiB,KAAK,QAAQ,UAAW,EAAM,KAAK,SAAU,KAAK,kBAG9E,wBAAyB,CACrB,KAAM,GAAQ,GACd,MAAI,MAAK,QAAQ,SACb,EAAM,KAAK,eAEX,EAAM,KAAK,gBAGX,KAAK,QAAQ,gBACb,EAAM,KAAK,KAAK,QAAQ,gBAErB,EAAM,KAAK,eAGlB,kBAAkB,CAClB,MAAO,MAAK,oBAGZ,cAAc,CACd,MAAO,MAAK,KAGhB,OAAQ,OAEF,SAAS,CACX,GAAI,CACA,KAAM,MAAK,QAAQ,eACd,EAAP,CACE,KAAK,OAAS,EACd,KAAK,WAAW,eAIlB,SAAS,CACX,GAAI,CACA,KAAM,MAAK,QAAQ,eACd,EAAP,CACE,KAAK,OAAS,EACd,KAAK,WAAW,UAIxB,iBAAkB,CACd,KAAK,aAGT,SAAU,CACN,MAAM,UACN,KAAK,QAAQ,IAAI,SAAU,KAAK,kBAIxC,QAA0B,CACtB,YAAY,EAAQ,EAAiB,EAAU,CAC3C,KAAK,QAAU,EACf,KAAK,iBAAmB,EACxB,KAAK,UAAY,KAGjB,KAAK,CACL,MAAO,MAAK,QAAQ,UAGpB,OAAO,CACP,MAAO,MAAK,QAAQ,QAGpB,eAAe,CACf,MAAO,GAAe,KAAK,SAG3B,oBAAoB,CACpB,MAAO,GAAyB,KAAK,QAAQ,QAGjD,UAAU,EAAM,CACZ,MAAO,IAAiB,KAAK,QAAQ,UAAW,EAAM,KAAK,UAAW,KAAK,qBAG3E,cAAc,CACd,MAAO,MAAK,MC7Hb,gBAAwC,EAAU,CACrD,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,mBAAkB,mBAAmB,EAC5C,KAAK,kBAAoB,EACzB,KAAK,iBAAmB,EACxB,KAAK,cAAgB,KAAK,cAAc,KAAK,MAC7C,KAAK,UAAY,KAAK,WAAW,gBAAgB,WACjD,KAAK,kBAAkB,GAAG,SAAU,KAAK,kBAGzC,OAAO,CAAE,MAAO,sBAChB,WAAW,CAAE,MAAO,MAAK,aACzB,OAAO,CAAE,MAAO,MAAK,kBAAkB,QACvC,KAAK,CAAE,MAAO,MAAK,kBAAkB,MACrC,cAAc,CAAE,MAAO,MAAK,kBAAkB,eAC9C,QAAQ,CACR,KAAM,CAAC,SAAS,KAAK,kBACrB,MAAI,GACI,EAAM,OAAS,kBACR,KAAK,6BAEL,EAAM,QAGd,MAEP,eAAe,CAAE,MAAO,GAAe,KAAK,SAC5C,oBAAoB,CAAE,MAAO,GAAyB,KAAK,kBAAkB,kBAC7E,cAAc,CAAE,MAAO,MAAK,KAEhC,UAAU,EAAM,OAEZ,MAAO,QAAK,kBAAkB,gBAAvB,OACH,GAAiB,KAAK,kBAAkB,UAAW,EAAM,KAAK,SAAU,KAAK,kBAGrF,OAAQ,EAER,eAAgB,CACZ,KAAK,aAGT,QAAS,CACL,KAAK,kBAAkB,SAEvB,KAAK,WAAW,UAAU,KAAK,WAAW,KAAK,MAAM,YAGzD,SAAU,CACN,MAAM,UACN,KAAK,kBAAkB,IAAI,SAAU,KAAK,gBCrD3C,gBAAgC,EAAU,CAC7C,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,SAAW,EAAQ,QACxB,KAAK,qBAAuB,KAC5B,KAAK,gBAAkB,KACvB,KAAK,UAAY,KAAK,WAAW,gBAAgB,QACjD,KAAK,YAAc,KACnB,KAAK,MAAQ,KACb,KAAK,kBAAkB,EAAQ,KAAM,EAAQ,SAGjD,kBAAkB,EAAM,EAAS,CAC7B,KAAM,GAAkB,EAAK,aAAa,GAC1C,KAAK,MAAM,EAAgB,UAAU,GAAc,CAC/C,KAAK,WAAW,EAAM,MAE1B,KAAK,WAAW,EAAM,EAAgB,YAGpC,YAAW,EAAM,EAAY,CAC/B,GAAI,CAAC,EACD,OAEJ,KAAM,CAAC,mBAAmB,EAC1B,KAAK,YAAc,EACnB,KAAM,CAAC,WAAW,KAAK,YACvB,KAAK,MAAQ,KAAK,YAAY,UAAY,GAAI,MAAK,KAAK,YAAY,WAAa,KACjF,AAAI,EAAQ,IACR,MAAK,qBAAuB,EAAgB,OAAO,EAAQ,KAC3D,KAAK,WAAW,aACT,EAAQ,MACf,MAAK,gBAAkB,KAAK,MAAM,KAAM,GAAgB,sBAAsB,EAAQ,OACtF,KAAK,WAAW,gBAIpB,aAAa,WACb,MAAO,cAAK,cAAL,cAAkB,UAAlB,cAA2B,OAA3B,cAAiC,KAGxC,cAAc,WACd,MAAO,cAAK,cAAL,cAAkB,UAAlB,cAA2B,OAA3B,cAAiC,KAGxC,OAAO,SACP,MAAO,WAAK,cAAL,cAAkB,UAAlB,cAA2B,QAGlC,SAAS,OACT,MAAO,QAAK,cAAL,cAAkB,eAGzB,WAAW,CACX,MAAI,MAAK,gBACE,KAAK,gBAAgB,IACrB,KAAK,qBACL,KAAK,qBAEL,MAIX,OAAO,CACP,MAAO,MAAK,OAAS,KAAK,MAAM,mBAAmB,GAAI,CAAE,QAAS,OAAQ,KAAM,UAAW,MAAO,OAAQ,IAAK,eAG/G,OAAO,CACP,MAAO,MAAK,OAAS,KAAK,MAAM,mBAAmB,GAAI,CAAC,KAAM,UAAW,OAAQ,eAGjF,WAAW,CACX,MAAO,MAAK,UAGhB,OAAQ,CACJ,KAAK,SAAS,QAAQ,QAAQ,KAAK,WCzE3C,KAAM,GAAgB,GAClB,eACA,aACA,YACA,UACA,UACA,aAGG,gBAAqC,EAAU,CAClD,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,OAAM,cAAa,WAAW,EACrC,KAAK,MAAQ,EACb,KAAK,aAAe,EACpB,KAAK,QAAU,KAAK,gBAAgB,EAAY,iBAAiB,MAAO,EAAK,OAAO,OACpF,KAAK,SAAW,EAChB,KAAK,mBAAqB,KAAK,WAAW,cAAc,YACxD,KAAK,sBAAwB,GAGjC,OAAQ,CACJ,KAAM,GAAS,IAAM,KAAK,gBAC1B,KAAK,MAAM,KAAK,MAAM,OAAO,UAAU,IACvC,KAAK,MAAM,KAAK,aAAa,iBAAiB,UAAU,IACxD,KAAK,MAAM,KAAK,SAAS,eAAe,UAAU,IAAM,CACpD,KAAK,mBAIT,oBAAqB,CACrB,MAAO,MAAK,sBAGZ,UAAU,CACV,MAAQ,MAAK,SAAS,eAAe,OAAS,CAAC,KAAK,uBAA0B,KAAK,UAAY,EAAc,WAG7G,cAAc,CACd,OAAQ,KAAK,aACJ,GAAc,aAAa,CAC5B,KAAM,GAAU,KAAK,MAAM,KAAK,aAAa,QAAU,KACvD,MAAO,MAAK,4CAA4C,UAEvD,GAAc,WACf,MAAO,MAAK,mCACX,GAAc,UACf,MAAO,MAAK,+CACX,GAAc,UACf,MAAO,MAAK,8BAA8B,KAAK,MAAM,QAE7D,MAAI,MAAK,SAAS,eAAe,MACtB,KAAK,uDAET,MAGP,YAAY,CACZ,OAAQ,KAAK,aACJ,GAAc,eACd,GAAc,UACf,MAAO,WAEP,MAAO,IAInB,eAAgB,CACZ,KAAM,GAAY,KAAK,gBACnB,KAAK,aAAa,iBAAiB,MACnC,KAAK,MAAM,OAAO,OAEtB,AAAI,IAAc,KAAK,SACnB,CAAI,IAAc,EAAc,aAC5B,KAAK,YAAc,KAAK,MAAM,KAAK,MAAM,eAAe,IAAM,CAC1D,KAAK,WAAW,gBACjB,MAEH,KAAK,YAAc,KAAK,eAAe,KAAK,aAEhD,KAAK,QAAU,EACf,KAAK,cAIb,gBAAgB,EAAkB,EAAY,CAC1C,GAAI,IAAqB,GAAiB,OACtC,OAAQ,OACC,IAAiB,aAClB,MAAO,GAAc,eACpB,IAAiB,QAClB,MAAO,GAAc,qBAEtB,IAAe,EAAW,QACjC,OAAQ,OAGC,GAAW,gBACX,GAAW,YACZ,MAAO,GAAc,cACpB,GAAW,QACZ,MAAO,GAAc,cAK7B,OAAO,GAAc,WAIzB,oBAAoB,CACpB,MAAO,MAAK,UAAY,EAAc,gBAGtC,uBAAuB,CAEvB,MAAO,MAAK,UAAY,EAAc,SAAW,KAAK,SAAS,eAAe,OAAS,CAAC,KAAK,yBAG7F,aAAa,CACb,MAAO,MAAK,qBAGhB,SAAU,CACN,AAAI,KAAK,sBACL,MAAK,sBAAwB,GAC7B,KAAK,cAIb,YAAa,CACT,AAAI,KAAK,mBACL,KAAK,aAAa,UCtI9B,YAAsB,EAAS,CAC3B,MAAO,GAAQ,IAAI,CAAC,EAAI,IAAQ,CAC5B,GAAI,GAAQ,MAAM,EAAG,GAAK,SAAS,GAG/B,MAAO,KAKZ,gBAAgC,EAAU,CAC7C,YAAY,EAAS,CACjB,MAAM,GAEN,KAAK,OAAS,EAAQ,MACtB,KAAK,QAAU,EAAQ,OACvB,KAAK,+BAAiC,EAAQ,8BAC9C,KAAK,eAAiB,EACtB,KAAK,uBAAyB,GAC9B,KAAK,mBAGT,kBAAmB,CACf,KAAM,GAAiB,KAAK,WAAW,QAAQ,mBAC/C,KAAK,MAAM,EAAe,UAAU,GAAS,CACzC,AAAI,MAAO,IAAU,UACjB,KAAK,eAAe,MAGxB,MAAO,GAAe,OAAU,UAChC,MAAK,eAAiB,EAAe,OAGzC,KAAM,GAAc,KAAK,WAAW,QAAQ,QAC5C,KAAK,MAAM,EAAY,UAAU,GAAU,CACvC,AAAI,GAKA,KAAK,cAAc,MAM/B,gBAAgB,EAAG,OACf,MAAO,QAAK,uBAAuB,KAA5B,cAAgC,SAGvC,aAAa,CACb,MAAO,MAAK,kBAGZ,QAAQ,CACR,MAAO,MAAK,UAGZ,SAAS,CACT,MAAO,MAAK,QAGhB,cAAc,EAAQ,CAClB,GAAI,GAAO,KAAK,WAAW,KAAK,MAAM,SACtC,EAAO,EAAK,KAAK,KAAK,WAAW,QAAQ,OAAQ,IACjD,EAAO,GAAiB,KAAK,WAAY,GACzC,KAAK,WAAW,UAAU,GAG9B,UAAU,EAAO,CACb,GAAI,IAAU,KAAK,eACf,OAEJ,KAAM,GAAM,KAAK,uBAAuB,GACxC,AAAI,EACA,KAAK,cAAc,EAAI,IAEvB,KAAK,WAAW,KAAK,kBAAmB,GAKhD,+BAA+B,EAAS,EAAgB,CACpD,EAAU,GAAa,GACvB,GAAI,GAAa,GACjB,GAAI,EAAgB,CAChB,KAAM,GAAQ,EAAQ,QAAQ,EAAe,IAC7C,AAAI,IAAU,IACV,MAAK,uBAAuB,GAAS,KAAK,MAAM,GAChD,EAAe,UAAU,GAAa,KAAK,sBAAsB,IACjE,EAAa,IAGrB,KAAK,WAAW,GAEhB,KAAM,GAAc,KAAK,WAAW,KAAK,IAAI,QAC7C,GAAI,EAAa,CACb,KAAM,GAAQ,KAAK,uBAAuB,UAAU,GAAO,GAAO,EAAI,KAAO,EAAY,OACzF,AAAI,IAAU,IACV,MAAK,eAAiB,GAG9B,MAAO,GAIX,WAAW,EAAS,CAChB,EAAU,GAAa,GACvB,GAAI,GAAU,GACd,KAAM,GAAM,KAAK,QAAU,KAAK,OAChC,OAAS,GAAI,EAAG,EAAI,EAAK,GAAK,EAAG,CAC7B,KAAM,GAAQ,EAAQ,GAChB,EAAM,KAAK,uBAAuB,GAExC,GAAK,CAAC,GAAO,GAAW,GAAO,EAAI,KAAO,EAAQ,CAI9C,GAHI,GACA,MAAK,uBAAuB,GAAK,KAAK,eAAe,IAErD,EAAO,CACP,KAAM,GAAM,KAAK,+BAA+B,GAChD,KAAK,uBAAuB,GAAK,KAAK,MAAM,GAC5C,EAAI,UAAU,GAAa,KAAK,sBAAsB,IACtD,EAAI,aAER,EAAU,IAGlB,MAAI,IACA,KAAK,aAEF,EAGX,sBAAsB,EAAW,CAC7B,KAAK,aACL,WAAW,QAIf,qBAAqB,EAAQ,CACzB,KAAM,GAAQ,KAAK,uBAAuB,UAAU,GAAO,GAAO,EAAI,KAAO,GAC7E,GAAI,IAAU,GAAI,CACd,KAAM,GAAM,KAAK,uBAAuB,GACxC,YAAK,QAAQ,GACb,EAAI,iBACJ,KAAK,uBAAuB,GAAS,KAC9B,GAIf,eAAe,EAAK,OAChB,GAAI,IAAQ,KAAK,gBAAkB,GAAQ,KAAK,OAAS,KAAK,QAC1D,OAEJ,KAAK,eAAiB,EACtB,KAAM,GAAM,KAAK,uBAAuB,KAAK,gBAC7C,oBAAK,QAAL,QAAY,QACZ,KAAK,WAAW,cAGpB,cAAc,EAAQ,CAClB,KAAM,GAAQ,KAAK,uBAAuB,UAAU,GAAO,kBAAK,MAAO,GACvE,AAAI,GAAS,GACT,KAAK,eAAe,IClKzB,KAAM,GAAS,GAAW,UAAW,WAAY,cAAe,UAAW,uBACrE,GAAoB,GAAW,UAAW,UAAW,OAAQ,WAEnE,gBAAiC,EAAU,CAC9C,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,SAAW,EAAQ,QACxB,KAAK,OAAS,KACd,KAAK,QAAU,GACf,KAAK,oBAAsB,OAC3B,KAAK,QAAU,OACf,KAAK,iBAAmB,KAAK,SAAS,UAAU,QAAQ,GAAa,EAAU,qBAC/E,KAAK,UAAY,KAAK,iBAAiB,QAAQ,GAAM,EAAG,UACxD,KAAK,MAAM,KAAK,iBAAiB,UAAU,IAAM,CAE7C,KAAK,oBACL,KAAK,WAAW,kBAEpB,KAAK,MAAM,KAAK,UAAU,UAAU,IAAM,KAAK,WAAW,sBAC1D,KAAK,oBACL,KAAK,MAAM,KAAK,SAAS,UAAU,UAAU,IAAM,CAC/C,AAAI,KAAK,qBACL,KAAK,WAAW,aAK5B,mBAAoB,CAChB,GAAI,KAAK,QACL,MAAO,GAEX,GAAI,GACJ,KAAM,GAAY,KAAK,SAAS,UAAU,MAC1C,AAAI,EACA,EAAS,EAAU,YAAc,EAAO,oBAAsB,EAAO,QAClE,AAAI,IAAc,KACrB,EAAS,KAAK,kBAAoB,EAAO,YAAc,EAAO,SAE9D,EAAS,EAAO,QAEpB,KAAM,GAAU,IAAW,KAAK,QAChC,YAAK,QAAU,EACR,KAGP,gBAAgB,CAChB,MAAO,MAAK,gBAGZ,UAAU,CACV,MAAO,MAAK,wBAGhB,4BAA6B,CACzB,MAAO,MAGP,qBAAqB,CACrB,MAAO,MAAK,uBAGZ,SAAS,CACT,MAAO,MAAK,WAGZ,gBAAgB,OAChB,MAAO,QAAK,SAAS,UAAU,QAAxB,cAA+B,WAGtC,oBAAoB,CACpB,KAAM,GAAY,KAAK,SAAS,UAAU,MAC1C,GAAK,GAEE,GAAI,EAAU,WACjB,MAAO,IAAkB,YAFzB,OAAO,IAAkB,QAK7B,MADkB,GAAU,oBAAoB,MAErC,GAAkB,QAClB,EAAU,mBACV,GAAkB,KAElB,GAAkB,WAI7B,cAAc,SACd,MAAO,WAAK,SAAS,UAAU,QAAxB,cAA+B,QAA/B,cAAsC,WAG7C,SAAS,CACT,MAAO,MAAK,WAGZ,QAAQ,OACR,MAAO,QAAK,SAAL,cAAa,QAGxB,iBAAkB,CACd,AAAI,KAAK,UAAY,EAAO,UACxB,MAAK,QAAU,EAAO,YACtB,KAAK,WAAW,WAIxB,cAAe,CACX,AAAI,KAAK,UAAY,EAAO,aACxB,MAAK,QAAU,EAAO,SACtB,KAAK,WAAW,gBAIlB,mBAAkB,EAAS,EAAY,EAAuB,CAChE,GAAI,EACA,GAAI,CACA,KAAK,QAAU,GACf,KAAK,WAAW,UAChB,KAAM,GAAM,KAAM,MAAK,SAAS,oBAAoB,EAAS,GAC7D,AAAI,GACA,MAAK,oBAAsB,KAAM,MAAK,SAAS,sBAAsB,UAEpE,EAAP,CACE,QAAQ,MAAM,GACd,KAAK,OAAS,EACd,KAAK,WAAW,iBAEhB,KAAK,QAAU,GACf,KAAK,oBACL,KAAK,WAAW,KAK5B,oBAAoB,EAAY,EAAuB,CACnD,KAAK,kBAAkB,GAAQ,WAAY,EAAY,GAG3D,iBAAiB,EAAa,EAAuB,CACjD,KAAK,kBAAkB,GAAQ,YAAa,EAAa,QAGvD,UAAU,CACZ,GAAI,CACA,KAAK,QAAU,GACf,KAAK,WAAW,UAChB,KAAM,MAAK,SAAS,6BACf,EAAP,CACE,QAAQ,MAAM,GACd,KAAK,OAAS,EACd,KAAK,WAAW,iBAEhB,KAAK,QAAU,GACf,KAAK,oBACL,KAAK,WAAW,QAIpB,cAAc,CACd,MAAO,CAAC,CAAC,KAAK,iBAAiB,SAG/B,mBAAmB,CACnB,KAAM,GAAW,KAAK,UAAU,MAChC,MAAI,GACO,KAAK,MAAO,EAAS,SAAW,EAAS,MAAS,KAEtD,KAGP,wBAAwB,CACxB,KAAM,GAAW,KAAK,UAAU,MAChC,MAAI,GACO,KAAK,OAAO,EAAS,eAAe,EAAS,QAEjD,KAAK,QAGhB,cAAe,OACX,QAAK,iBAAiB,QAAtB,QAA6B,QAGjC,aAAc,OACV,QAAK,SAAS,UAAU,QAAxB,QAA+B,SCvLvC,QAA6B,CACzB,aAAc,CACV,KAAK,UAAY,KACjB,KAAK,QAAU,GACf,KAAK,SAAW,GAChB,KAAK,gBAAkB,KACvB,KAAK,YAAc,MAI3B,YAAmB,EAAK,CACpB,KAAM,GAAa,EACb,EAAY,KAAK,KAAK,EAAI,OAAS,GACzC,GAAI,GAAe,GACnB,OAAS,GAAI,EAAG,EAAI,EAAW,GAAK,EAChC,GAAiB,GAAa,OAAS,IAAM,IAAM,EAAI,MAAM,EAAI,EAAa,GAAI,GAAK,GAE3F,MAAO,GAGJ,gBAAgC,EAAU,CAC7C,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,eAAiB,EAAQ,cAC9B,KAAM,CAAC,UAAU,EACjB,KAAK,QAAU,EACf,KAAK,oBAAsB,KAAK,MAAM,GAAI,IAAmB,KAAK,aAAa,CAAC,QAAS,KAAK,aAC9F,KAAK,UAAY,KAAK,WAAW,gBAAgB,WACjD,KAAK,UAAY,KACjB,KAAK,mBAAqB,KAC1B,KAAK,sBAAwB,IAC7B,KAAK,sBAAwB,IAC7B,KAAK,kBAAoB,GAAI,OAG7B,WAAW,CACX,MAAO,MAAK,QAAQ,aAGlB,SAAS,CACX,KAAK,WAAW,KAAK,SAAU,KAAK,QAAQ,WAGhD,sBAAsB,EAAM,CACxB,AAAI,EAAO,KAAK,uBAAyB,EAAO,KAAK,sBACjD,MAAK,mBAAqB,KAC1B,KAAK,SAAS,gBAAgB,OAAO,uBAErC,MAAK,mBAAqB,KAAK,MAAM,GACrC,KAAK,SAAS,gBAAgB,OAAO,qBAAsB,IAE/D,KAAK,WAAW,2BAGd,OAAO,CACT,KAAK,UAAY,KAAM,MAAK,SAAS,uBACrC,KAAK,mBAAqB,KAAM,MAAK,SAAS,gBAAgB,OAAO,sBACrE,KAAK,kBAAkB,UAAY,KAAM,MAAK,SAAS,oBAAoB,eAC3E,KAAK,kBAAkB,QAAU,KAAM,MAAK,SAAS,8BACrD,KAAK,WAAW,OAGhB,WAAW,CACX,MAAO,MAAK,aAGZ,iBAAiB,CACjB,KAAM,GAAM,KAAK,SAAS,eAC1B,MAAK,GAGE,GAAU,GAFN,QAKX,WAAW,CACX,MAAO,MAAK,SAAS,YAGrB,SAAS,CACT,MAAO,MAAK,SAAS,UAGrB,UAAU,CACV,KAAM,CAAC,iBAAiB,KAAK,SAC7B,MAAI,GACO,GAAG,EAAc,YAAY,EAAc,aAE/C,KAAK,0BAGhB,gBAAiB,OACb,QAAK,SAAS,gBAAd,QAA6B,oBAG7B,mBAAmB,CACnB,MAAO,CAAC,CAAC,KAAK,SAAS,iBAGvB,qBAAqB,CACrB,MAAO,MAAK,uBAGZ,eAAe,OACf,MAAO,MAAK,aAAa,QAAK,YAAL,cAAgB,UAGzC,eAAe,OACf,MAAO,MAAK,aAAa,QAAK,YAAL,cAAgB,OAG7C,aAAa,EAAG,CACZ,MAAI,OAAO,IAAM,SACN,KAAK,MAAM,EAAK,MAAO,OAAO,QAAQ,GAAK,MAE3C,KAAK,mBAId,aAAa,CACf,KAAM,GAAY,KAAM,MAAK,OAAO,SACpC,KAAK,SAAS,WAAW,EAAU,SAAU,iBAAiB,KAAK,SAAS,MAAM,mBAGhF,0BAA0B,CAC5B,KAAK,kBAAkB,SAAW,GAClC,KAAK,kBAAkB,gBAAkB,KACzC,KAAK,kBAAkB,YAAc,KACrC,KAAK,WAAW,8BAChB,GAAI,CACA,AAAI,KAAM,MAAK,SAAS,wBAAwB,CAAC,KAAK,kBAAkB,UACpE,MAAK,kBAAkB,QAAU,CAAC,KAAK,kBAAkB,QACrD,KAAK,kBAAkB,SACvB,KAAK,SAAS,oBAAoB,iBAAiB,KAAK,mDAIpE,KAAK,kBAAkB,SAAW,GAC9B,KAAK,WAAW,oCAIlB,2BAA2B,CAC7B,KAAK,kBAAkB,gBAAkB,KACzC,KAAK,kBAAkB,YAAc,KACrC,GAAI,CACA,KAAK,kBAAkB,gBAAkB,KAAM,MAAK,SAAS,iCAC7D,KAAK,WAAW,2CACX,EAAP,CACE,KAAK,kBAAkB,YAAc,EACrC,KAAK,WAAW,mCCpJrB,gBAAkC,EAAU,CAC/C,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,WAAW,EAClB,KAAK,SAAW,EAChB,KAAK,MAAQ,OACb,KAAK,OAAS,OACd,KAAK,WAAa,OAClB,KAAK,UAAY,GACjB,KAAK,aAAe,GACpB,KAAK,iBAAmB,GACxB,KAAK,sBAAwB,GAC7B,KAAK,kBAAoB,OACzB,KAAK,gBAAkB,OACvB,KAAK,YAAc,UAGnB,WAAW,CAAE,MAAO,MAAK,aACzB,cAAc,CAAE,MAAO,MAAK,gBAC5B,YAAY,CAAE,MAAO,CAAC,CAAC,KAAK,MAChC,WAAY,CAAE,MAAO,MAAK,kBAAkB,OACxC,cAAc,CAAE,MAAO,MAAK,SAC5B,eAAe,CAAE,MAAO,MACxB,oBAAoB,CAAE,MAAO,MAC7B,YAAY,CAAE,MAAO,CAAC,CAAC,KAAK,qBAC5B,uBAAuB,CAAE,MAAO,MAAK,yBACrC,kBAAkB,CAAE,MAAO,MAAK,iBAEpC,QAAQ,EAAM,CACV,KAAK,MAAQ,EACb,KAAK,WAAW,aAGpB,aAAa,EAAW,CACpB,KAAK,WAAa,EAGtB,SAAS,EAAO,CACZ,KAAK,OAAS,EAGlB,UAAU,EAAU,CAChB,KAAK,UAAY,EACjB,KAAK,WAAW,YAGpB,aAAa,EAAa,CACtB,KAAK,aAAe,EACpB,KAAK,WAAW,eAGpB,sBAAsB,EAAS,CAC3B,KAAK,sBAAwB,EAC7B,KAAK,WAAW,wBAGpB,qBAAsB,CAClB,KAAK,iBAAmB,CAAC,KAAK,iBAC9B,KAAK,WAAW,mBAGpB,QAAS,SACL,GAAI,GACJ,AAAI,KAAK,mBACL,GAAS,CACL,KAAM,KAAK,YACX,KAAM,KAAK,gBACX,KAAM,KAAK,oBAGnB,KAAM,GAAmB,KAAK,SAAS,WAAW,CAC9C,KAAM,KAAK,SAAW,EAAS,OAAS,EAAS,QACjD,KAAM,QAAK,QAAL,OAAc,OACpB,MAAO,QAAK,SAAL,OAAe,OACtB,YAAa,CAAC,KAAK,UAAY,KAAK,aACpC,qBAAsB,KAAK,sBAC3B,MAAO,KAAK,SAAW,GAAuB,KAAK,YAAc,OACjE,WAEJ,KAAK,WAAW,KAAK,OAAQ,EAAiB,SAG5C,eAAe,CACjB,GAAI,CAAC,KAAK,SAAS,yBAA0B,CACzC,MAAM,4EACN,OAEJ,AAAI,KAAK,mBACL,KAAK,kBAAkB,UAE3B,KAAK,kBAAoB,OACzB,KAAK,gBAAkB,OACvB,KAAK,YAAc,OAEnB,KAAM,GAAO,KAAM,MAAK,SAAS,SAAS,WAC1C,GAAI,CAAC,GAAQ,CAAC,EAAK,KAAK,SAAS,WAAW,UAAW,CAEnD,KAAK,WAAW,aAChB,OAEJ,GAAI,GAAQ,KAAM,MAAK,SAAS,UAAU,EAAK,MAC/C,KAAM,GAAQ,IACd,GAAI,EAAM,aAAe,EAAO,CAC5B,KAAM,GAAc,KAAM,GAAM,MAAM,GACtC,EAAM,UACN,EAAQ,EAEZ,KAAK,kBAAoB,EAAM,KAC/B,KAAK,YAAc,GAAY,GAC/B,KAAK,gBAAkB,EAAK,KAC5B,KAAK,WAAW,cAIxB,YAAgC,EAAoB,CAChD,AAAI,EAAmB,WAAW,MAC9B,GAAqB,EAAmB,OAAO,IAEnD,KAAM,GAAW,EAAmB,QAAQ,KAC5C,MAAI,KAAa,IACb,GAAqB,EAAmB,OAAO,EAAG,IAE/C,EC1GJ,gBAAsC,EAAgB,CACzD,YAAY,EAAkB,EAAiB,CAC3C,MAAM,MACN,KAAK,oBAAsB,KAC3B,KAAK,kBAAoB,EACzB,KAAK,GAAK,OASR,aAAa,CACf,KAAM,CAAC,WAAW,KAAK,kBAAkB,QACnC,EAAmB,KAAM,GAAQ,kBAAkB,KAAK,IAC9D,KAAK,IAAI,KAAM,MAAK,mBAAmB,EAAiB,QACxD,KAAK,oBAAsB,EAAiB,UAAU,KAAM,IAAU,OAElE,QAAK,QAAL,QAAY,UACZ,KAAK,IAAI,KAAM,MAAK,mBAAmB,WAIzC,oBAAmB,EAAQ,CAC7B,GAAI,EAAS,EAAW,SACpB,GAAI,EAAS,EAAW,aAAc,CAClC,KAAM,CAAC,WAAW,KAAK,kBAAkB,QACnC,EAAmB,EAAQ,kBAAkB,IAAI,KAAK,IAC5D,KAAK,kBAAkB,mBAAmB,EAAiB,GAAI,EAAiB,YAEhF,MAAM,IAAI,OAAM,sDAAyD,GAAS,EAAW,eAE9F,OAAI,GAAS,EAAW,aACpB,KAAK,kBAAkB,iCAAiC,KAAK,IAC7D,EAAS,EAAW,QACpB,KAAK,kBAAkB,uBAAuB,KAAK,IACnD,EAAS,EAAW,OACpB,KAAK,kBAAkB,6BAA6B,KAAK,IACzD,EAAS,EAAW,SACpB,KAAM,MAAK,kBAAkB,6BAA6B,KAAK,IAE/D,KAAK,kBAAkB,4BAA4B,KAAK,IAIvE,SAAU,OACN,AAAI,KAAK,qBACL,MAAK,oBAAsB,KAAK,uBAEpC,KAAK,iBACL,QAAK,QAAL,QAAY,WCrEb,gBAAmC,EAAU,CAChD,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,MAAQ,EAAQ,KACrB,KAAK,cAAgB,KAAK,cAAc,KAAK,MAC7C,KAAK,MAAM,GAAG,SAAU,KAAK,kBAG7B,OAAO,CACP,MAAO,kBAGP,uBAAuB,CACvB,MAAO,MAGP,sBAAsB,CACtB,MAAO,MAGP,SAAS,CACT,MAAO,MAAK,MAAM,MAGlB,iBAAiB,CACjB,MAAO,MAAK,MAAM,kBAGlB,OAAO,CACP,MAAO,MAAK,MAAM,QAGlB,cAAc,CACd,MAAO,CAAC,CAAC,KAAK,MAAM,eAGpB,cAAc,CACd,MAAO,MAAK,MAAM,qBAGlB,eAAe,CACf,MAAO,GAAe,KAAK,SAG3B,oBAAoB,CACpB,MAAO,GAAyB,KAAK,MAAM,eAG/C,UAAU,EAAM,CACZ,MAAO,IAAiB,KAAK,MAAM,UAAW,EAAM,KAAK,SAAU,KAAK,MAAM,oBAG9E,cAAc,CACd,MAAO,MAAK,KAGhB,eAAgB,CACZ,KAAK,aAGT,SAAU,CACN,MAAM,UACN,KAAK,MAAM,IAAI,SAAU,KAAK,eAGlC,UAAU,EAAS,CACf,GAAI,GAAO,KAAK,WAAW,KAAK,MAAM,QACtC,EAAO,EAAK,KAAK,KAAK,WAAW,QAAQ,cAAe,KACxD,EAAO,EAAK,KAAK,KAAK,WAAW,QAAQ,EAAS,KAClD,KAAK,WAAW,UAAU,ICrE3B,gBAAkC,EAAU,CAC/C,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,QAAU,KAAK,SAAS,OAC7B,KAAK,iBAAmB,EAAQ,gBAChC,KAAK,cAAgB,KACrB,KAAK,aAAe,MAGpB,OAAO,CACP,MAAO,GAAG,KAAK,QAAQ,OAAO,KAAK,yBAGnC,sBAAsB,CACtB,MAAO,MAAK,cAAgB,KAAK,KAAK,UAAY,MAGlD,SAAS,CACT,MAAO,MAAK,QAAQ,UAGpB,eAAe,CACf,MAAO,MAAK,iBAGZ,cAAc,CACd,MAAO,MAAK,gBAGZ,aAAa,CACb,KAAM,GAAS,KAAK,WAAW,KAAK,IAAI,QAAQ,MAChD,MAAO,GAAG,KAAK,WAAW,kBAAkB,aAAkB,KAAK,QAAQ,SAG/E,oBAAoB,EAAS,CACzB,KAAM,GAAc,KAAK,QAAQ,KACjC,AAAI,IAAgB,EAChB,MAAK,cAAgB,EACrB,KAAK,aAAe,IAEpB,KAAK,aAAe,GAI5B,kBAAkB,EAAQ,CACtB,KAAK,cAAgB,EACrB,KAAK,aAGT,WAAW,EAAW,CAClB,KAAK,oBAAoB,EAAU,MACnC,KAAK,QAAU,KAGf,eAAe,CACf,MAAO,GAAe,KAAK,SAG3B,oBAAoB,CACpB,MAAO,GAAyB,KAAK,QAGzC,UAAU,EAAM,CACZ,MAAO,IAAiB,KAAK,QAAQ,UAAW,EAAM,KAAK,SAAU,KAAK,qBAG1E,cAAc,CACd,MAAO,MAAK,MCpEb,YAAgC,EAAa,CAChD,KAAM,GAAW,GAAI,MAAK,SACpB,EAAkB,GAAU,EAAO,OAAO,KAAO,IAAK,EAAO,MAAM,GAAK,EAE9E,MAAO,UAAoB,EAAQ,EAAa,CAC5C,KAAM,GAAK,EAAY,aAAa,EAAO,QACrC,EAAK,EAAY,aAAa,EAAY,QAChD,GAAI,IAAO,EAAM,MAAO,GAAK,EAC7B,KAAM,GAAO,EAAgB,EAAO,MAC9B,EAAY,EAAgB,EAAY,MAC9C,MAAO,GAAS,QAAQ,EAAM,ICZ/B,QAAoB,CACvB,aAAc,CACV,KAAK,KAAO,GAAI,KAGpB,gBAAgB,EAAI,EAAO,CACvB,KAAM,GAAM,EAAM,QAAQ,GAC1B,GAAI,IAAQ,GAAI,CACZ,KAAM,CAAC,GAAW,EAAM,OAAO,EAAK,GACpC,EAAQ,kBAAkB,KAIlC,oBAAoB,EAAI,CACpB,KAAM,GAAe,EAAG,aACxB,GAAI,MAAO,IAAiB,SAAY,OACxC,KAAM,GAAQ,KAAK,KAAK,IAAI,GAC5B,GAAI,MAAM,QAAQ,IAEd,GADA,KAAK,gBAAgB,EAAI,GACrB,EAAM,SAAW,EAAG,CACpB,KAAM,GAAK,EAAM,GACjB,EAAG,kBAAkB,IACrB,KAAK,KAAK,IAAI,EAAc,QAGhC,MAAK,KAAK,OAAO,GAIzB,WAAW,EAAI,CACX,KAAM,GAAO,EAAG,KACV,EAAQ,KAAK,KAAK,IAAI,GAC5B,GAAI,EAAO,CACP,GAAI,MAAM,QAAQ,GACd,MAAI,GAAM,UAAU,GAAU,EAAO,SAAW,EAAG,UAAY,GAAM,OACrE,GAAM,KAAK,GACJ,GACJ,GAAG,EAAG,SAAW,EAAM,OAAQ,CAClC,KAAM,GAAQ,CAAC,EAAO,GACtB,YAAK,KAAK,IAAI,EAAM,GACb,OAGX,MAAK,KAAK,IAAI,EAAM,GAI5B,aAAa,EAAI,CACb,GAAI,CAAC,EAAG,YAAe,OACvB,KAAK,oBAAoB,GACzB,KAAM,GAAQ,KAAK,WAAW,GAC9B,WAAO,QAAQ,AAAC,GAAO,EAAG,kBAAkB,MC9C7C,gBAAkC,EAAU,CAC/C,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,GAAO,EAAQ,QAEf,EAAwB,EAAQ,sBACtC,KAAK,MAAM,EAAsB,UAAU,IAAM,KAEjD,KAAM,GAAc,EAAsB,MAC1C,KAAK,qBAAuB,KAAK,mBAAmB,EAAK,QAAQ,aAAa,GAAU,EAAO,aAAe,SAC7E,WAAW,GAAuB,IACnE,KAAK,kBAAoB,GAAI,IAC7B,KAAK,gBAAkB,EAAQ,mBAG/B,OAAO,CAAE,MAAO,iBAEhB,uBAAuB,CAAE,MAAO,MAEhC,sBAAsB,CAAE,MAAO,UAEnC,mBAAmB,EAAS,CACxB,KAAM,GAAS,CAAC,EAAQ,IAAe,CACnC,KAAM,GAAkB,KAAK,gBACvB,EAAK,GAAI,IAAoB,KAAK,aAAa,CAAC,SAAQ,aAAY,qBAC1E,YAAK,kBAAkB,aAAa,GAC7B,GAEL,EAAU,CAAC,EAAI,EAAQ,IAAc,CACvC,EAAG,WAAW,GACd,KAAK,kBAAkB,aAAa,IAExC,MAAO,GAAQ,UAAU,EAAQ,ICjClC,gBAAqC,EAAU,CAClD,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,kBAAoB,EAAQ,iBACjC,KAAK,iBAAmB,EAAQ,gBAChC,KAAK,QAAU,KAAK,kBAAkB,MACtC,KAAK,aAAe,EAAQ,YAC5B,KAAK,uBAAyB,EAAQ,sBACtC,KAAK,SAAW,EAAQ,QACxB,KAAK,MAAM,KAAK,uBAAuB,UAAU,IAAM,KAAK,yBAC5D,KAAK,MAAM,KAAK,kBAAkB,UAAW,IAAM,KAAK,uBAGxD,OAAO,CAAE,MAAO,MAAK,QAAQ,QAC7B,SAAS,CAAE,MAAO,MAAK,QAAQ,UAE/B,OAAO,CAAE,MAAO,oBAChB,uBAAuB,CAAE,MAAO,MAChC,sBAAsB,CAAE,MAAO,aAE/B,OAAO,CACP,MAAI,MAAK,YAAc,IAAc,KAAK,YACjC,KAAK,YAAc,GAAa,KAAK,gBACrC,KAAK,aAAe,EAAY,KAAK,cAChC,KAAK,eAAe,KAAK,cAG3C,iBAAkB,CACd,KAAK,QAAU,KAAK,kBAAkB,MACtC,KAAK,WAAW,UAGpB,sBAAuB,CACnB,KAAK,WAAW,WAGhB,eAAe,CACf,MAAO,GAAe,KAAK,SAG3B,oBAAoB,CACpB,MAAO,GAAyB,KAAK,QAGzC,UAAU,EAAM,CACZ,MAAO,IAAiB,KAAK,QAAQ,UAAW,EAAM,KAAK,SAAU,KAAK,qBAG1E,cAAc,CACd,MAAO,MAAK,QAGZ,cAAc,CACd,MAAO,MAAK,gBAGZ,aAAa,OACb,MAAO,QAAK,uBAAuB,QAA5B,cAAmC,aAAa,KAAK,QAAQ,WAGpE,aAAa,CACb,MAAO,uBAAuB,mBAAmB,KAAK,QAAQ,eAG5D,oBAAoB,CACtB,KAAM,GAAO,KAAK,SAAS,2BAA2B,KAAK,QAC3D,GAAI,GAAS,iBAAM,GACnB,AAAK,GAKD,GAAS,AAJgB,MAAM,MAAK,SAAS,WAAW,CACpD,KAAM,EAAS,cACf,QAAS,CAAC,KAAK,WAEO,IAE9B,KAAK,WAAW,KAAK,OAAQ,ICzE9B,gBAAkC,EAAU,CAC/C,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,MAAQ,EAAQ,KACrB,KAAK,SAAW,EAAQ,QACxB,KAAK,SAAW,KAChB,KAAK,sBAGL,kBAAkB,CAAE,MAAO,MAAK,sBAE9B,0BAA0B,CAC5B,AAAK,KAAK,UACN,MAAK,SAAW,KAAM,MAAK,MAAM,iBACjC,KAAK,MAAM,IAAM,KAAK,SAAS,YAEnC,KAAM,GAAO,KAAK,MACZ,EAAwB,KAAM,MAAK,MAAM,qBAC/C,MAAO,CAAC,QAAS,KAAK,SAAU,wBAAuB,gBAAiB,EAAK,sBAG3E,6BAA6B,CAE/B,KAAM,GAAS,AADC,KAAK,WAAW,KAAK,IAAI,UAClB,MACjB,EAAmB,KAAM,MAAK,MAAM,cAAc,GACxD,GAAI,CAAC,EACD,MAAO,GAEX,KAAM,GAAc,KAAK,MAAM,YACzB,EAAwB,KAAM,MAAK,MAAM,qBAC/C,MAAO,CACH,mBACA,cACA,wBACA,gBAAiB,KAAK,MAAM,gBAC5B,QAAS,KAAK,UAItB,kBAAmB,CACf,KAAK,sBAAsB,UAAW,GAAsB,IAAe,EAAC,KAAM,KAAK,SACvF,KAAK,sBAAsB,UAAW,GAAqB,IAAM,KAAK,2BACtE,KAAK,sBAAsB,SAAU,GAAwB,IAAM,KAAK,6BACpE,IAAM,CAEF,KAAM,GAAM,GAAG,KAAK,WAAW,gBAAgB,kBAC/C,KAAK,WAAW,QAAQ,KAKpC,sBAAsB,EAAS,EAAW,EAAY,EAAc,CAChE,KAAM,GAAa,KAAK,WAAW,QAAQ,GACrC,EAAU,KAAK,cAAc,EAAS,EAAW,EAAY,GACnE,KAAK,MAAM,EAAW,UAAU,IAGpC,cAAc,EAAS,EAAW,EAAY,EAAc,CACxD,KAAM,GAAU,MAAO,EAAc,KAAU,OAK3C,GAJK,GACD,MAAK,iBAAmB,KAAK,eAAe,KAAK,mBAEtC,CAAC,CAAC,SAAK,WAAW,KAAK,IAAI,KAAzB,cAAmC,OACxC,CACR,KAAM,GAAO,KAAM,KACnB,GAAI,CAAC,GAAQ,EAAc,CACvB,IACA,OAEJ,KAAK,iBAAmB,KAAK,MAAM,GAAI,GAAU,KAAK,aAAa,KAEvE,KAAK,WAAW,oBAEpB,SAAQ,IACD,EAGX,YAAa,CACT,KAAM,GAAO,KAAK,WAAW,KAAK,MAAM,QACxC,KAAK,WAAW,UAAU,GAG9B,mBAAoB,CAChB,KAAM,GAAc,KAAK,gBAAgB,oBACzC,GAAI,EAAa,CACb,GAAI,GAAO,KAAK,WAAW,KAAK,MAAM,QACtC,EAAO,EAAK,KAAK,KAAK,WAAW,QAAQ,cAAe,KACxD,EAAO,EAAK,KAAK,KAAK,WAAW,QAAQ,EAAa,KACtD,KAAK,WAAW,UAAU,KC9E/B,gBAA+B,EAAU,CAC5C,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,UAAU,EACjB,KAAK,QAAU,KAAK,MAAM,GAC1B,KAAK,wBAA0B,KAAK,MAAM,GAAI,IAAuB,KAAK,aAAa,CACnF,KAAM,EAAO,KACb,YAAa,EAAO,YACpB,QAAS,EAAO,YAEpB,KAAK,oBAAsB,KAAK,MAAM,GAAI,IAAmB,KAAK,aAAa,CAAC,QAAS,KAAK,QAAQ,YACtG,KAAK,mBAAqB,KAC1B,KAAK,yBAA2B,KAChC,KAAK,eAAiB,KACtB,KAAK,qBAAuB,KAC5B,KAAK,mBAGT,kBAAmB,CACf,KAAM,GAAY,KAAK,WAAW,QAAQ,SAE1C,KAAK,MAAM,EAAU,UAAU,GAAW,CACtC,KAAK,YAAY,MAEjB,EAAU,OACV,KAAK,YAAY,EAAU,OAG/B,KAAM,GAAgB,KAAK,WAAW,QAAQ,QAE9C,KAAK,MAAM,EAAc,UAAU,GAAU,CACzC,AAAK,KAAK,gBACN,KAAK,YAAY,GAErB,KAAK,uBAEJ,KAAK,gBACN,KAAK,YAAY,EAAc,OAGnC,KAAM,GAAW,KAAK,WAAW,QAAQ,YACzC,KAAK,MAAM,EAAS,UAAU,GAAgB,CAC1C,KAAK,gBAAgB,MAEzB,KAAK,gBAAgB,EAAS,OAE9B,KAAM,GAAa,KAAK,WAAW,QAAQ,eAC3C,KAAK,MAAM,EAAW,UAAU,GAAkB,CAC9C,KAAK,kBAAkB,MAE3B,KAAK,kBAAkB,EAAW,OAElC,KAAM,GAAW,KAAK,WAAW,QAAQ,YACzC,KAAK,MAAM,EAAS,UAAU,GAAW,CACrC,KAAK,gBAAgB,MAEzB,KAAK,gBAAgB,EAAS,OAG9B,KAAM,GAAa,KAAK,WAAW,QAAQ,eAC3C,KAAK,MAAM,EAAW,UAAU,IAAM,KAAK,sBAC3C,KAAK,uBAGL,KAAK,CACL,MAAO,MAAK,QAAQ,UAGxB,OAAQ,CACJ,KAAK,wBAAwB,WAG7B,wBAAwB,OACxB,MAAO,SAAK,2BAAL,cAA+B,QAAS,KAAK,gBAAkB,KAAK,oBAAsB,KAAK,wBAGtG,oBAAoB,CACpB,MAAO,MAAK,kBAGZ,qBAAqB,CACrB,MAAO,MAAK,uBAGZ,yBAAyB,CACzB,MAAO,MAAK,2BAGZ,oBAAoB,CACpB,MAAO,MAAK,sBAGZ,uBAAuB,OACvB,MAAO,QAAK,2BAAL,cAA+B,SAGtC,sBAAsB,CACtB,MAAO,MAAK,wBAGZ,sBAAsB,CACtB,MAAO,MAAK,qBAGhB,YAAY,EAAS,OACjB,KAAM,GAAU,CAAE,MAAK,gBAAkB,GACnC,EAAgB,KAAK,WAAW,KAAK,IAAI,QAC/C,GAAI,EACA,AAAK,KAAK,eAcN,KAAK,eAAe,WAAW,GAb/B,MAAK,eAAiB,KAAK,MAAM,GAAI,IAAkB,KAAK,aAAa,CACrE,MAAO,EACP,OAAQ,EACR,8BAA+B,GAAU,GAAI,IAAwB,KAAM,OAG/E,QAAK,2BAAL,QAA+B,iBAC/B,AAAI,KAAK,eAAe,+BAA+B,EAAS,KAAK,0BACjE,KAAK,yBAA2B,KAAK,QAAQ,KAAK,0BAC3C,KAAK,0BACZ,MAAK,yBAA2B,KAAK,eAAe,KAAK,oCAK1D,KAAK,gBAAkB,CAAC,EAAS,CAExC,GAAI,EAAe,CACf,KAAM,GAAM,KAAK,eAAe,qBAAqB,EAAc,OACnE,AAAI,GACA,MAAK,yBAA2B,KAAK,MAAM,GAC3C,KAAK,yBAAyB,UAAU,IAAM,CAC1C,KAAK,WAAW,4BAI5B,KAAK,eAAiB,KAAK,eAAe,KAAK,gBAEnD,AAAI,GACA,KAAK,WAAW,yBAIxB,6BAA6B,EAAQ,CACjC,KAAM,GAAO,KAAK,QAAQ,QAAQ,MAAM,IAAI,GAC5C,GAAI,EAAM,CACN,KAAM,GAAS,GAAI,IAAc,KAAK,aAAa,CAAC,UACpD,SAAO,OACA,EAEX,MAAO,MAGX,4BAA4B,EAAe,CACvC,MAAO,IAAI,IAAqB,KAAK,aAAa,CAC9C,gBACA,QAAS,KAAK,QAAQ,gBAIxB,8BAA6B,EAAQ,CACvC,KAAM,GAAO,KAAM,MAAK,QAAQ,QAAQ,iBAAiB,GACzD,GAAI,EAAM,CACN,KAAM,GAAS,GAAI,IAAc,KAAK,aAAa,CAAC,UACpD,SAAO,OACA,EAEX,MAAO,MAGX,uBAAuB,EAAQ,CAC3B,KAAM,GAAS,KAAK,QAAQ,QAAQ,QAAQ,IAAI,GAChD,MAAI,GACO,GAAI,IAAgB,KAAK,aAAa,CACzC,SACA,gBAAiB,KAAK,QAAQ,QAAQ,mBAGvC,KAGX,iCAAiC,EAAS,CACtC,KAAM,GAAmB,KAAK,QAAQ,QAAQ,kBAAkB,IAAI,GACpE,MAAI,GACO,GAAI,IAA0B,KAAK,aAAa,CACnD,mBACA,gBAAiB,KAAK,QAAQ,QAAQ,mBAGvC,KAGX,YAAY,EAAQ,OAEhB,GAAI,SAAK,2BAAL,cAA+B,MAAO,EACtC,OAMJ,GAHI,KAAK,0BACL,MAAK,yBAA2B,KAAK,eAAe,KAAK,2BAEzD,CAAC,EAAQ,CAGT,KAAK,WAAW,yBAChB,OAEJ,KAAM,GAAM,GAAI,IAAwB,KAAM,GAC9C,KAAK,yBAA2B,KAAK,MAAM,GAE3C,KAAK,yBAAyB,UAAU,IAAM,CAC1C,KAAK,WAAW,2BAEpB,EAAI,aAGR,gBAAgB,EAAc,CAC1B,AAAI,KAAK,oBACL,MAAK,mBAAqB,KAAK,eAAe,KAAK,qBAEnD,GACA,MAAK,mBAAqB,KAAK,MAAM,GAAI,IAAkB,KAAK,aAAa,CACzE,OAAQ,KAAK,YAEjB,KAAK,mBAAmB,QAE5B,KAAK,WAAW,yBAGpB,kBAAkB,EAAgB,CAC9B,AAAI,KAAK,sBACL,MAAK,qBAAuB,KAAK,eAAe,KAAK,uBAErD,GACA,MAAK,qBAAuB,KAAK,MAAM,GAAI,IAAoB,KAAK,aAAa,CAAC,QAAS,KAAK,QAAQ,aAE5G,KAAK,WAAW,yBAGpB,gBAAgB,EAAS,CAIrB,GAHI,KAAK,oBACL,MAAK,mBAAqB,KAAK,eAAe,KAAK,qBAEnD,EAAS,CACT,KAAM,GAAO,KAAK,sBAClB,KAAK,mBAAqB,KAAK,MAAM,GAAI,IAAkB,KAAK,aAAa,CAAC,UAAS,WAE3F,KAAK,WAAW,wBAGhB,oBAAoB,CACpB,MAAO,MAAK,mBAGhB,qBAAsB,OAClB,KAAM,GAAS,QAAK,WAAW,KAAK,IAAI,UAAzB,cAAkC,MAEjD,MADa,MAAK,QAAQ,QAAQ,MAAM,IAAI,GAIhD,mBAAoB,OAGhB,GAFA,KAAK,qBAAuB,KAAK,eAAe,KAAK,sBACtC,CAAC,CAAC,SAAK,WAAW,KAAK,IAAI,iBAAzB,cAAyC,OAC9C,CACR,KAAM,GAAO,KAAK,sBAClB,KAAK,qBAAuB,KAAK,MAAM,GAAI,IAAoB,KAAK,aAAa,CAAC,OAAM,QAAS,KAAK,QAAQ,YAElH,KAAK,WAAW,uBAGpB,mBAAmB,EAAO,EAAO,CAC7B,KAAK,WAAW,KAAK,OAAQ,ICzR9B,gBAAoC,EAAU,CACjD,YAAY,EAAc,CACtB,QACA,KAAK,cAAgB,EACrB,KAAK,kBAAoB,OACzB,KAAK,kCAAoC,OACrC,KAAK,cAAc,2BACnB,MAAK,kCAAoC,GAAI,IAAiC,KAAM,GAAoB,CACpG,KAAK,kBAAoB,EACzB,KAAK,kCAAoC,OACzC,KAAK,WAAW,yBAKxB,mCAAmC,CACnC,MAAO,MAAK,qCAGZ,kBAAkB,CAClB,MAAO,CAAC,CAAC,KAAK,qBAGd,qBAAqB,CACrB,MAAO,MAAK,cAAc,0BAA0B,SAGxD,QAAS,CACL,KAAK,cAAc,OAAO,KAAK,oBAKvC,gBAA+C,EAAU,CACrD,YAAY,EAAuB,EAAmB,CAClD,QACA,KAAK,uBAAyB,EAC9B,KAAK,QAAU,GACf,KAAK,QAAU,EAAO,SACtB,KAAK,OAAS,OACd,KAAK,mBAAqB,KAG1B,gBAAgB,CAChB,MAAO,MAAK,iBAGZ,UAAU,CACV,MAAO,MAAK,sCAGZ,6BAA6B,CAC7B,MAAO,MAGP,qBAAqB,OACrB,MAAO,QAAK,uBAAuB,oBAA5B,cAA+C,YAGtD,SAAS,CACT,MAAO,MAAK,WAGZ,gBAAgB,CAAE,MAAO,MAEzB,SAAS,CACT,MAAO,MAAK,WAGZ,QAAQ,OACR,MAAO,QAAK,SAAL,cAAa,QAGxB,iBAAkB,CACd,AAAI,KAAK,UAAY,EAAO,UACxB,MAAK,QAAU,EAAO,YACtB,KAAK,WAAW,WAIxB,cAAe,CACX,AAAI,KAAK,UAAY,EAAO,aACxB,MAAK,QAAU,EAAO,SACtB,KAAK,WAAW,gBAIlB,mBAAkB,EAAS,EAAY,CACzC,GAAI,EACA,GAAI,CACA,KAAK,QAAU,GACf,KAAK,WAAW,UAChB,KAAM,CAAC,6BAA6B,KAAK,uBAAuB,cAC1D,EAAmB,KAAM,GAA0B,QAAQ,EAAS,GAC1E,KAAK,mBAAmB,SACnB,EAAP,CACE,QAAQ,MAAM,GACd,KAAK,OAAS,EACd,KAAK,WAAW,iBAEhB,KAAK,QAAU,GACf,KAAK,WAAW,KAK5B,oBAAoB,EAAY,CAC5B,KAAK,kBAAkB,GAAQ,WAAY,GAG/C,iBAAiB,EAAa,CAC1B,KAAK,kBAAkB,GAAQ,YAAa,GAGhD,SAAU,GCjHP,gBAAmC,EAAU,CAChD,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,SAAQ,QAAO,aAAY,yBAAyB,EAC3D,KAAK,QAAU,EACf,KAAK,OAAS,EACd,KAAK,YAAc,EACnB,KAAK,uBAAyB,EAC9B,KAAK,SAAW,GAChB,KAAK,OAAS,KACd,KAAK,QAAU,KAAK,WAAW,cAAc,UAAW,IACxD,KAAK,uBAAyB,YAI5B,QAAQ,CACV,GAAI,MAAK,SAGT,GAAI,CACA,KAAK,SAAW,GAChB,KAAK,WAAW,WAChB,KAAK,YAAc,KAAK,QAAQ,WAAW,QAAQ,GAC/C,CAAI,IAAM,EAAW,aACjB,KAAK,uBAAyB,GAAI,IAAsB,KAAK,QAAQ,cAErE,KAAK,uBAAyB,OAElC,KAAK,WAAW,aAIT,AAFe,IAAM,EAAW,WACnC,KAAK,QAAQ,KAAK,OAAO,QAAU,EAAW,aAE9C,IAAM,EAAW,aACjB,IAAM,EAAW,OACjB,IAAM,EAAW,QAEzB,GAAI,CACA,KAAM,MAAK,YAAY,aACzB,CACE,OAQJ,KAAM,GAAa,KAAK,QAAQ,WAAW,MACrC,EAAY,KAAK,QAAQ,UAC/B,GAAI,IAAe,EAAW,WAAa,IAAe,EAAW,MAAO,CACxE,KAAM,GAAS,KAAK,QAIpB,KAAK,QAAU,KACf,KAAK,OAAO,GAEhB,AAAI,GACA,QAAQ,MAAM,qBAAsB,SAEnC,EAAP,CACE,KAAK,OAAS,EACd,QAAQ,MAAM,mCAAoC,EAAI,eAEtD,KAAK,SAAW,GAEhB,KAAK,WAAW,YAKxB,SAAU,CACN,AAAI,KAAK,SACL,MAAK,QAAQ,UACb,KAAK,QAAU,MAEf,KAAK,aAEL,MAAK,YAAY,UACjB,KAAK,YAAc,SAKvB,UAAU,CACV,KAAM,GAAS,KAAK,QACpB,MAAI,IAAU,EAAO,WAAW,QAAU,EAAW,aAC1C,GAEJ,KAAK,YAGZ,YAAY,CACZ,KAAM,GAAS,KAAK,QACd,EAAQ,KAAK,YACnB,GAAI,GAAU,GAAU,EAAO,WAAW,QAAU,EAAW,MAC3D,MAAO,yBAAyB,GAAS,EAAM,WAInD,GAAI,EACA,OAAQ,EAAO,WAAW,WACjB,GAAW,aACZ,MAAO,8CACN,GAAW,aACZ,MAAO,OACN,GAAW,aACZ,MAAO,4CACN,GAAW,QACZ,MAAO,uCACN,GAAW,UACZ,MAAO,2DAEP,MAAO,MAAK,QAAQ,WAAW,MAI3C,MAAO,kBAGX,WAAY,OACR,MAAO,MAAK,QAAU,SAAK,UAAL,cAAc,cAGpC,WAAW,CACX,MAAO,CAAC,CAAC,KAAK,iBAGZ,aAAa,CACf,KAAM,GAAY,KAAM,MAAK,OAAO,SACpC,KAAK,SAAS,WAAW,EAAU,SAAU,iBAAiB,KAAK,SAAS,MAAM,mBAGhF,SAAS,CACX,KAAM,MAAK,QAAQ,SACnB,KAAK,WAAW,KAAK,UAAW,OAGhC,wBAAwB,CACxB,MAAO,MAAK,wBC9Ib,gBAAqC,EAAU,CAClD,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,eAAc,gBAAgB,EACrC,KAAK,cAAgB,EACrB,KAAK,cAAgB,EACrB,KAAK,QAAU,GACf,KAAK,cAAgB,MAGrB,SAAS,CAAE,MAAO,MAAK,WACvB,eAAe,CAAE,MAAO,MAAK,cAEjC,QAAQ,EAAQ,CACZ,KAAK,QAAU,EACf,KAAK,WAAW,UAGpB,WAAW,EAAS,CAChB,KAAK,cAAgB,EACrB,KAAK,WAAW,qBAGd,OAAM,EAAU,EAAU,CAC5B,KAAK,cAAgB,GACrB,KAAK,WAAW,gBAChB,KAAM,GAAS,KAAM,MAAK,cAAc,KAAK,cAAc,SAAS,EAAU,IAC9E,GAAI,GAAQ,GACZ,OAAQ,OACC,IAAa,YACd,EAAQ,KAAK,8DACb,UACC,IAAa,WACd,EAAQ,KAAK,wBAAwB,KAAK,cAAc,cACxD,UACC,IAAa,QACd,EAAQ,KAAK,mEACb,MAER,AAAI,GACA,KAAK,WAAW,ICzCrB,gBAAqC,EAAS,CACjD,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,KAAO,EAAQ,aAAa,IACjC,KAAK,QAAU,MAGf,SAAS,CAAE,MAAO,MAAK,QAE3B,QAAQ,EAAQ,CACZ,KAAK,QAAU,EACf,KAAK,WAAW,eAGd,gBAAgB,CAClB,KAAM,MAAK,SAAS,gBAAgB,UAAU,+BAAgC,KAAK,KAAK,YACxF,KAAM,GAAO,KAAK,KAAK,qBAAqB,KAAK,WAAW,wBAC5D,KAAK,SAAS,QAAQ,IChBvB,gBAAwC,EAAU,CACrD,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CACF,aACA,SACA,gBACA,EACJ,KAAK,YAAc,EACnB,KAAK,QAAU,EACf,KAAK,cAAgB,EACrB,KAAK,cAAgB,GACrB,KAAK,+BAGL,eAAe,CAAE,MAAO,MAAK,cAEjC,WAAW,EAAS,CAChB,KAAK,cAAgB,EACrB,KAAK,WAAW,qBAGd,4BAA4B,CAC9B,GAAI,CAAC,KAAK,YACN,OAEJ,KAAM,GAAa,KAAM,MAAK,SAAS,gBAAgB,UAAU,gCACjE,GAAI,GACJ,GAAI,CACA,EAAe,KAAM,MAAK,QAAQ,WAAW,GAAY,aAEtD,EAAP,CACI,KAAK,WAAW,EAAI,SACpB,OAEJ,GAAI,CAAC,EAAa,MAAO,CACrB,KAAK,WAAW,KAAK,WACrB,OAEJ,KAAM,GAAS,KAAM,MAAK,cAAc,EAAa,MAAM,KAAK,cAChE,GAAI,GAAQ,GACZ,OAAQ,OACC,IAAa,YACd,EAAQ,KAAK,mCACb,UACC,IAAa,WACd,EAAQ,KAAK,wBAAwB,KACrC,UACC,IAAa,QACd,EAAQ,KAAK,4DACb,MAER,AAAI,GACA,KAAK,WAAW,IChDrB,gBAA6B,EAAU,CAC1C,YAAY,EAAS,CACjB,MAAM,GACN,KAAM,CAAC,QAAO,oBAAmB,cAAc,EAC/C,KAAK,OAAS,EACd,KAAK,YAAc,EACnB,KAAK,QAAU,GAAI,IAAO,KAAK,UAC/B,KAAK,cAAgB,KACrB,KAAK,wBAA0B,KAC/B,KAAK,wBAA0B,KAC/B,KAAK,2BAA6B,KAClC,KAAK,eAAiB,KACtB,KAAK,2BAA6B,KAClC,KAAK,YAAc,EACnB,KAAK,mBAAqB,KAC1B,KAAK,cAAgB,GACrB,KAAK,gBAAkB,GACvB,KAAK,QAAU,GACf,KAAK,6BAA+B,KACpC,KAAK,qBAAuB,KAC5B,KAAK,qBAGL,yBAAyB,CAAE,MAAO,MAAK,2BACvC,yBAAyB,CAAE,MAAO,MAAK,2BACvC,4BAA2B,CAAE,MAAO,MAAK,8BACzC,aAAa,CAAE,MAAO,MAAK,eAC3B,qBAAqB,OAAE,MAAO,QAAK,gBAAL,cAAoB,cAClD,eAAe,CAAE,MAAO,MAAK,iBAC7B,iBAAiB,CAAE,MAAO,CAAC,KAAK,mBAChC,gBAAgB,CAAC,MAAO,MAAK,kBAC7B,SAAS,CAAE,MAAO,MAAK,WACvB,yBAAyB,CAAE,MAAO,CAAC,CAAC,KAAK,qBAE7C,QAAS,CACL,KAAK,WAAW,KAAK,gBAGnB,kBAAkB,CACpB,AAAI,KAAK,YACL,MAAK,gBAAkB,GACvB,KAAK,2BAA6B,KAAK,MAAM,GAAI,IAC7C,KAAK,aACD,CACI,OAAQ,KAAK,QACb,aAAc,GAAe,KAAK,aAAa,GAC/C,WAAY,KAAK,gBAE7B,KAAK,WAAW,8BAGhB,KAAM,MAAK,kBAInB,oBAAqB,CACjB,KAAK,wBAA0B,KAAK,MAAM,GAAI,IAC1C,KAAK,aAAa,CACd,aAAc,KAAK,cACnB,aAAc,GAAe,KAAK,aAAa,OAEvD,KAAK,WAAW,0BAGpB,eAAgB,CACZ,KAAK,wBAA0B,KAAK,MAChC,GAAI,IAAuB,KAAK,aAAa,CAAC,aAAc,KAAK,kBAErE,KAAK,WAAW,0BAGpB,WAAW,EAAS,CAChB,KAAK,cAAgB,EACrB,KAAK,WAAW,gBAGpB,SAAS,EAAQ,SACb,KAAK,QAAU,EACf,QAAK,0BAAL,QAA8B,QAAQ,GACtC,QAAK,0BAAL,QAA8B,QAAQ,GACtC,KAAK,WAAW,eAGd,cAAa,EAAa,CAC5B,KAAK,SAAS,IACd,KAAK,QAAQ,eAAe,EAAa,CAAC,oBAAqB,KAC/D,KAAM,GAAa,KAAK,QAAQ,WAKhC,MAHA,MAAM,AADS,GAAW,QAAQ,GAAU,IAAW,EAAW,OACrD,QACb,KAAK,SAAS,IAEV,AADW,EAAW,QACX,EAAW,YACf,KAAK,QAAQ,aAExB,MAAK,gBAAkB,GACvB,KAAK,WAAW,kBAChB,KAAK,qBACL,KAAK,uBACE,MAGX,sBAAuB,CACnB,KAAK,2BAA6B,KAAK,eAAe,KAAK,4BAC3D,KAAK,eAAiB,KAAK,eAAe,KAAK,gBAC/C,KAAK,eAAiB,KAAK,MACvB,GAAI,IACA,KAAK,aAAa,CACd,MAAO,AAAC,GAAW,CAEf,KAAK,QAAU,KACf,KAAK,OAAO,IAEhB,OAAQ,KAAK,QACb,WAAY,KAAK,gBAI7B,KAAK,eAAe,QACpB,KAAK,WAAW,iBAChB,KAAK,2BAA6B,KAAK,MACnC,KAAK,eAAe,aAAa,SAAU,IAAM,CAC7C,AAAK,KAAK,eAAe,SACrB,MAAK,2BAA6B,KAAK,eAAe,KAAK,6BAE/D,KAAK,SAAS,OAK1B,oBAAqB,CACjB,KAAK,wBAA0B,KAAK,eAAe,KAAK,oBACxD,KAAK,wBAA0B,KAAK,eAAe,KAAK,yBACxD,KAAK,2BAA6B,KAAK,eAAe,KAAK,4BAC3D,KAAK,WAAW,0BAGd,eAAc,EAAe,CAC/B,KAAK,YAAc,EAEnB,KAAK,cAAgB,KACrB,KAAK,mBAAqB,KAC1B,KAAK,WAAW,IAChB,KAAK,qBACL,KAAK,qBAAuB,KAAK,eAAe,KAAK,sBACrD,KAAK,aAEL,KAAK,eAAe,KAAK,8BACzB,KAAM,GAAU,KAAK,MAAM,cAAc,KACzC,KAAK,6BAA+B,KAAK,MAAM,IAAM,EAAQ,SAC7D,GAAI,CACA,KAAM,GAAQ,gBACT,EAAP,CACE,GAAI,EAAI,OAAS,aACb,OAEA,KAAM,GAGd,KAAK,6BAA+B,KAAK,eAAe,KAAK,8BAC7D,KAAK,uBAGH,kBAAkB,CAEpB,GAAI,OAAK,cAAgB,KAAK,oBAAsB,KAAK,cAAgB,IAGzE,MAAK,mBAAqB,KAAK,YAO/B,KAAK,6BAA+B,KAAK,eAAe,KAAK,8BAE7D,KAAK,qBAAuB,KAAK,eAAe,KAAK,sBACrD,GAAI,CACA,KAAM,GAAiB,KAAK,QAAQ,WAAW,KAAK,aACpD,KAAK,qBAAuB,KAAK,MAAM,IAAM,EAAe,SAC5D,KAAK,WAAW,0BAChB,KAAK,cAAgB,KAAM,GAAe,OAC1C,KAAK,WAAW,4BAEb,EAAP,CACI,GAAI,EAAE,OAAS,aACX,OAEA,KAAK,cAAgB,aAGzB,KAAK,qBAAuB,KAAK,eAAe,KAAK,sBACrD,KAAK,WAAW,0BAEpB,AAAI,KAAK,cACD,MAAK,cAAc,KAAO,KAAK,gBAC/B,KAAK,cAAc,UAAY,KAAK,qBACpC,CAAC,KAAK,cAAc,KAAO,CAAC,KAAK,cAAc,UAC/C,KAAK,WAAW,wEAIpB,KAAK,WAAW,8CAA8C,KAAK,eAI3E,SAAU,CACN,MAAM,UACF,KAAK,SAGL,KAAK,QAAQ,iBCxNlB,gBAA8B,EAAU,CAC3C,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,WAAa,EAAQ,UAC1B,KAAK,MAAQ,GACb,KAAK,aAAe,GACpB,KAAK,OAAS,UAGd,cAAc,CACd,MAAO,MAAK,gBAGZ,OAAO,CACP,MAAO,MAAK,SAGZ,YAAY,CACZ,MAAO,MAAK,WAAW,cAAc,UAAW,SAG9C,SAAS,CACX,KAAK,MAAQ,GACb,KAAK,aAAe,GACpB,KAAK,WAAW,QAChB,GAAI,CAEA,KAAM,AADS,IAAI,IAAO,KAAK,UAClB,YAAY,KAAK,YAC9B,KAAK,WAAW,KAAK,UAAW,UAC3B,EAAP,CACE,KAAK,OAAS,EACd,KAAK,MAAQ,GACb,KAAK,WAAW,YAIpB,SAAS,CACT,MAAI,MAAK,OACE,KAAK,oCAAoC,KAAK,OAAO,UAErD,KAAK,gDCvCxB,gBAAmC,EAAU,CACzC,YAAY,EAAS,EAAU,CAC3B,MAAM,GACN,KAAK,UAAY,EACjB,KAAK,aAAe,EAAQ,YAC5B,KAAK,YAAc,GACnB,KAAK,YAAc,GACnB,KAAK,OAAS,KACd,KAAK,eAAiB,QAGtB,QAAQ,CACR,MAAO,MAAK,QAAU,KAAK,OAAO,WAGlC,KAAK,CACL,MAAO,MAAK,aAAa,MAGzB,UAAU,CACV,MAAO,MAAK,WAAW,cAAc,UAAW,KAAK,OAGrD,QAAQ,CACR,KAAM,CAAC,SAAQ,WAAY,KAAK,aAChC,MAAI,GACO,GAAG,MAAW,KAEd,KAIX,cAAc,CACd,MAAO,MAAK,gBAGZ,gBAAgB,CAChB,MAAO,MAAK,kBAGZ,oBAAoB,CACpB,MAAO,GAAyB,KAAK,aAAa,WAGlD,iBAAiB,CACjB,MAAO,GAAe,KAAK,aAAa,SAKzC,gBAAqC,EAAU,CAClD,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,UAAY,GAAI,IAAY,CAAC,EAAI,IAAO,EAAG,GAAG,cAAc,EAAG,KACpE,KAAK,eAAiB,KACtB,KAAK,OAAS,UAIZ,OAAO,CACT,KAAM,GAAW,KAAM,MAAK,SAAS,mBAAmB,SACxD,KAAK,UAAU,gBAAgB,EAAS,IAAI,GACjC,GAAI,IAAqB,KAAK,aAAa,CAAC,YAAa,IAAK,WAKzE,gBAAgB,CAChB,MAAO,MAAK,kBAGZ,WAAW,CACX,MAAO,MAAK,aAGZ,YAAY,CACZ,MAAO,MAAK,WAAW,cAAc,UCxEtC,gBAA4B,EAAU,CACzC,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,OAAS,KACd,KAAK,wBAA0B,KAC/B,KAAK,sBAAwB,KAC7B,KAAK,gBAAkB,KACvB,KAAK,iBAAmB,KACxB,KAAK,kBAAoB,KACzB,KAAK,eAAiB,UAGpB,OAAO,CACT,KAAK,MAAM,KAAK,WAAW,QAAQ,SAAS,UAAU,IAAM,KAAK,qBACjE,KAAK,MAAM,KAAK,WAAW,QAAQ,WAAW,UAAU,IAAM,KAAK,qBACnE,KAAK,MAAM,KAAK,WAAW,QAAQ,OAAO,UAAU,IAAM,KAAK,qBAC/D,KAAK,iBAAiB,SAGpB,kBAAiB,EAAsB,WACzC,KAAM,GAAU,KAAK,WAAW,KAAK,IAAI,SACnC,EAAkB,QAAK,WAAW,KAAK,IAAI,YAAzB,cAAoC,MACtD,EAAY,QAAK,WAAW,KAAK,IAAI,aAAzB,cAAqC,MACjD,EAAa,QAAK,WAAW,KAAK,IAAI,SAAzB,cAAiC,MACpD,GAAI,EACA,AAAI,KAAK,gBAAkB,SACvB,KAAK,qBAEF,EACP,AAAI,KAAK,gBAAkB,UACvB,KAAK,YAAY,WAEd,IAAc,GACrB,AAAI,KAAK,gBAAkB,UACvB,KAAK,sBAEF,GACP,GAAI,CAAC,KAAK,mBAAqB,KAAK,kBAAkB,KAAO,EAEzD,GAAI,KAAK,gBAAkB,KAAK,eAAe,YAAc,EAAW,CACpE,KAAM,GAAS,KAAK,eACpB,KAAK,eAAiB,KACtB,KAAK,aAAa,OAGlB,AAAI,MAAK,gBACL,MAAK,eAAe,UACpB,KAAK,eAAiB,MAE1B,KAAK,mBAAmB,WAGzB,EACP,KAAK,WAAW,eACZ,KAAK,gBAAkB,SACvB,KAAK,WAAW,OAIpB,IAAI,CACA,GAAI,CAAE,IAAwB,KAAK,WAAW,qBAAsB,CAChE,KAAM,GAAe,KAAM,MAAK,SAAS,mBAAmB,SAC5D,AAAI,EAAa,SAAW,EACxB,KAAK,WAAW,KAAK,SAClB,AAAI,EAAa,SAAW,EAC/B,KAAK,WAAW,KAAK,UAAW,EAAa,GAAG,IAEhD,KAAK,WAAW,KAAK,kBAGxB,EAAP,CACE,KAAK,YAAY,IAAM,KAAK,OAAS,SAK3C,cAAc,CAChB,KAAK,YAAY,IAAM,CACnB,KAAK,wBAA0B,GAAI,IAAuB,KAAK,kBAEnE,GAAI,CACA,KAAM,MAAK,wBAAwB,aAC9B,EAAP,CACE,KAAK,YAAY,IAAM,KAAK,OAAS,IAI7C,WAAW,EAAY,CACnB,KAAK,YAAY,IAAM,CACnB,KAAK,gBAAkB,GAAI,IAAe,KAAK,aAAa,CACxD,kBAAmB,KAAK,SAAS,OAAO,kBACxC,MAAO,GAAU,CASb,KAAK,eAAiB,EACtB,KAAK,WAAW,KAAK,UAAW,EAAO,YAE3C,kBAKZ,YAAY,EAAW,CACnB,KAAK,YAAY,IAAM,CACnB,KAAK,iBAAmB,GAAI,IAAgB,KAAK,aAAa,CAAC,iBAIvE,aAAa,EAAQ,CACjB,KAAK,YAAY,IAAM,CACnB,KAAK,kBAAoB,GAAI,IAAiB,KAAK,aAAa,CAAC,YACjE,KAAK,kBAAkB,UAI/B,mBAAmB,EAAW,CAC1B,KAAM,GAAS,GAAI,IAAO,KAAK,UAC/B,EAAO,yBAAyB,GAChC,KAAK,YAAY,IAAM,CACnB,KAAK,sBAAwB,GAAI,IAAqB,KAAK,aAAa,CACpE,SACA,MAAO,GAAU,KAAK,aAAa,MAEvC,KAAK,sBAAsB,aAI/B,gBAAgB,CAChB,MAAI,MAAK,OACE,QACA,KAAK,kBACL,UACA,KAAK,gBACL,QACA,KAAK,iBACL,SACA,KAAK,wBACL,SACA,KAAK,sBACL,UAEA,cAIf,YAAY,EAAQ,CAEhB,KAAK,OAAS,KACd,KAAK,wBAA0B,KAAK,eAAe,KAAK,yBACxD,KAAK,sBAAwB,KAAK,eAAe,KAAK,uBACtD,KAAK,gBAAkB,KAAK,eAAe,KAAK,iBAChD,KAAK,iBAAmB,KAAK,eAAe,KAAK,kBACjD,KAAK,kBAAoB,KAAK,eAAe,KAAK,mBAElD,IACA,KAAK,yBAA2B,KAAK,MAAM,KAAK,yBAChD,KAAK,uBAAyB,KAAK,MAAM,KAAK,uBAC9C,KAAK,iBAAmB,KAAK,MAAM,KAAK,iBACxC,KAAK,kBAAoB,KAAK,MAAM,KAAK,kBACzC,KAAK,mBAAqB,KAAK,MAAM,KAAK,mBAC1C,KAAK,WAAW,oBAGhB,QAAQ,CAAE,MAAO,MAAK,UACtB,mBAAmB,CAAE,MAAO,MAAK,qBACjC,iBAAiB,CAAE,MAAO,MAAK,mBAC/B,kBAAkB,CAAE,MAAO,MAAK,oBAChC,yBAAyB,CAAE,MAAO,MAAK,2BACvC,uBAAuB,CAAE,MAAO,MAAK,uBC/KtC,kBAAoB,EAAU,CACjC,GAAI,CAUA,KAAM,GAAa,KACnB,EAAS,cAAc,GACvB,KAAM,GAAY,GAAa,CAAC,aAAY,QAAS,EAAS,UAC9D,EAAU,SACV,KAAM,GAAK,GAAI,IAAc,CACzB,WAGA,WAAY,EACZ,eAEJ,KAAM,GAAG,OACT,EAAS,uBAAuB,SAC5B,EAAN,CACE,QAAQ,MAAM,GAAG,EAAI;AAAA,EAAa,EAAI,sBCzBf,EAA+B,EAAuB,EAA2B,EAAoC,MAC1I,GAAU,EAAc,MAE1B,GAAW,YACP,UAAU,KACd,IAAM,GACS,KACG,SAElB,IAAM,IAGH,EAAgB,KACnB,MACY,QACD,GAEX,GAAO,SACK,QAEJ,EAAI,OAAS,cAAgB,EACvB,GAAI,IAAgB,2BAA2B,MAAmB,IAElE,IC7Bf,YAAwB,EAAQ,EAAS,KAAK,OAAQ,CAIzD,MAAI,GAAO,SAAS,KAChB,EAAS,EAAS,IAElB,EAAS,EAAS,IAEf,EAAS,gBAAgB,KAAK,KAAK,IAAW,OAAO,oBCJhE,QAAoB,CAChB,YAAY,EAAS,EAAK,CACtB,KAAK,SAAW,EAChB,KAAK,KAAO,EAGhB,OAAQ,CACJ,KAAK,KAAK,QAGd,UAAW,CACP,MAAO,MAAK,UAIpB,YAAmB,EAAK,CAAC,SAAQ,UAAS,UAAS,SAAQ,kBAAiB,CACxE,KAAM,GAAM,GAAI,gBAYhB,GAVI,GACA,EAAI,OAAO,iBAAiB,WAAY,GAAO,EAAe,EAAI,SAGtE,EAAI,KAAK,EAAQ,GAEb,IAAW,UAEX,GAAI,aAAe,eAEnB,EACA,SAAU,CAAC,EAAM,IAAU,GAAQ,UAC/B,GAAI,CACA,EAAI,iBAAiB,EAAM,SACtB,EAAP,CACE,QAAQ,KAAK,iBAAiB,aAAgB,EAAI,WAI9D,MAAI,IACA,GAAI,QAAU,GAGX,EAGX,YAAsB,EAAK,EAAQ,EAAK,CACpC,MAAO,IAAI,SAAQ,CAAC,EAAS,IAAW,CACpC,EAAI,iBAAiB,OAAQ,IAAM,EAAQ,IAC3C,EAAI,iBAAiB,QAAS,IAAM,EAAO,GAAI,KAC/C,EAAI,iBAAiB,QAAS,IAAM,EAAO,GAAI,IAAgB,SAAS,KAAU,OAClF,EAAI,iBAAiB,UAAW,IAAM,EAAO,GAAI,IAAgB,WAAW,KAAU,IAAO,QAI9F,YAAoB,EAAK,EAAS,CACrC,GAAI,CAAC,QAAO,SAAQ,OAAM,UAAU,EACpC,AAAK,GACD,GAAM,GAAe,IAEzB,KAAM,GAAM,GAAU,EAAK,GACrB,EAAU,GAAa,EAAK,EAAQ,GAAK,KAAK,GAAO,CACvD,KAAM,CAAC,UAAU,EACjB,GAAI,GAAO,KACX,MAAI,KAAW,SACX,EAAO,EAAI,SACJ,EAAI,kBAAkB,kBAAoB,oBACjD,GAAO,KAAK,MAAM,EAAI,eAEnB,CAAC,SAAQ,UAIpB,MAAI,kBAAM,aACN,GAAO,EAAK,YAEhB,EAAI,KAAK,GAAQ,MAEV,GAAIC,IAAc,EAAS,GCzEtC,QAAoB,CAChB,YAAY,EAAS,EAAY,CAC7B,GAAK,EAYD,KAAK,QAAU,EACf,KAAK,YAAc,MAbN,CACb,KAAM,GAAe,GAAI,SAAQ,CAAC,EAAG,IAAW,CAC5C,KAAK,YAAc,CACf,OAAQ,CACJ,KAAM,GAAM,GAAI,OAAM,yBACtB,EAAI,KAAO,aACX,EAAO,OAInB,KAAK,QAAU,QAAQ,KAAK,CAAC,EAAS,KAO9C,OAAQ,CACJ,KAAK,YAAY,QAGrB,UAAW,CACP,MAAO,MAAK,SAIb,YAA4B,EAAe,EAAsB,CACpE,MAAO,UAAsB,EAAK,EAAgB,CAC9C,GAAI,iBAAsB,aAKtB,MAAO,IAAI,IAAc,GAAI,SAAQ,IAAM,IAAK,IAGpD,GAAI,iBAAgB,eAChB,MAAO,IAAW,EAAK,GAE3B,GAAI,CAAC,SAAQ,UAAS,OAAM,UAAS,SAAQ,QAAQ,IAAS,EAC9D,KAAM,GAAa,MAAO,kBAAoB,WAAa,GAAI,iBAAoB,KAEnF,AAAI,kBAAM,aACN,GAAO,EAAK,YAEhB,GAAI,GAAU,CAAC,SAAQ,QA0BvB,GAzBI,GACA,GAAU,OAAO,OAAO,EAAS,CAC7B,OAAQ,EAAW,UAGtB,GACD,GAAM,GAAe,IAEzB,EAAU,OAAO,OAAO,EAAS,CAC7B,KAAM,OACN,YAAa,OACb,SAAU,cAYV,MAAO,YAEP,EAAS,CACT,KAAM,GAAe,GAAI,SACzB,SAAU,CAAC,EAAM,IAAU,GAAQ,UAC/B,EAAa,OAAO,EAAM,GAE9B,EAAQ,QAAU,EAEtB,KAAM,GAAU,MAAM,EAAK,GAAS,KAAK,KAAM,IAAY,CACvD,KAAM,CAAC,UAAU,EACjB,GAAI,GACJ,GAAI,CACA,AAAI,IAAW,OACX,EAAO,KAAM,GAAS,OACf,IAAW,UAClB,GAAO,KAAM,GAAS,qBAErB,EAAP,CAEE,GAAI,CAAE,GAAI,OAAS,eAAiB,GAAU,KAC1C,KAAM,GAGd,MAAO,CAAC,SAAQ,SACjB,GAAO,CACN,KAAI,GAAI,OAAS,aAGP,GAAI,GACH,YAAe,WAOhB,GAAI,IAAgB,GAAG,KAAU,MAAQ,EAAI,WAEjD,IAEJ,EAAS,GAAI,IAAc,EAAS,GAE1C,MAAI,IACA,GAAO,QAAU,GAAe,EAAe,EAAS,EAAQ,EAAO,UAGpE,WC5GgD,CAG3D,YAAY,EAAc,MACjB,MAAQ,EAGjB,QAAkC,MACxB,GAAe,aAAa,QAAQ,KAAK,UAC3C,EAAc,MACR,GAAW,KAAK,MAAM,MACxB,MAAM,QAAQ,SACP,SAAQ,QAAQ,SAGxB,SAAQ,QAAQ,SAGrB,gBAAe,EAAY,EAAkC,MACzD,GAAW,KAAM,MAAK,YACxB,EAAU,MACJ,GAAU,EAAS,KAAK,GAAW,EAAQ,KAAO,GACpD,MACQ,SAAW,eACN,QAAQ,KAAK,MAAO,KAAK,UAAU,WAKtD,KAAI,EAA+C,MAC/C,GAAW,KAAM,MAAK,YACxB,QACO,GAAS,KAAK,GAAW,EAAQ,KAAO,QAIjD,KAAI,EAA0C,MAC1C,GAAW,KAAM,MAAK,WACnB,KAAK,gBACD,QAAQ,KAAK,MAAO,KAAK,UAAU,SAG9C,QAAO,EAAkC,IACvC,GAAW,KAAM,MAAK,WACf,EAAS,OAAO,GAAK,EAAE,KAAO,gBAC5B,QAAQ,KAAK,MAAO,KAAK,UAAU,KChEjD,QAAsB,CACzB,YAAY,EAAQ,CAChB,KAAK,QAAU,OAGb,QAAO,EAAK,EAAO,CACrB,KAAK,KAAK,EAAK,QAGb,QAAO,EAAK,EAAe,EAAG,CAChC,KAAM,GAAQ,OAAO,aAAa,QAAQ,GAAG,KAAK,UAAU,KAC5D,MAAI,OAAO,IAAU,SACV,SAAS,EAAO,IAEpB,OAGL,SAAQ,EAAK,EAAO,CACtB,KAAK,KAAK,EAAK,QAGb,SAAQ,EAAK,EAAe,GAAO,CACrC,KAAM,GAAQ,OAAO,aAAa,QAAQ,GAAG,KAAK,UAAU,KAC5D,MAAI,OAAO,IAAU,SACV,IAAU,OAEd,OAGL,WAAU,EAAK,EAAO,CACxB,KAAK,KAAK,EAAK,QAGb,WAAU,EAAK,CACjB,MAAO,QAAO,aAAa,QAAQ,GAAG,KAAK,UAAU,UAGnD,QAAO,EAAK,CACd,OAAO,aAAa,WAAW,GAAG,KAAK,UAAU,UAG/C,MAAK,EAAK,EAAO,CACnB,OAAO,aAAa,QAAQ,GAAG,KAAK,UAAU,IAAO,IC3CtD,QAAW,CACd,aAAc,CACV,KAAK,SAAW,KAChB,KAAK,SAAW,KAGpB,OAAO,EAAK,CACR,MAAK,MAAK,UACN,MAAK,SAAW,GAAI,cAEjB,KAAK,SAAS,OAAO,GAGhC,OAAO,EAAQ,CACX,MAAK,MAAK,UACN,MAAK,SAAW,GAAI,cAEjB,KAAK,SAAS,OAAO,ICd7B,QAAa,CAChB,eAAe,EAAQ,CACnB,KAAM,GAAMC,GAAO,OAAO,GACpB,EAAa,EAAI,QAAQ,KAC/B,MAAI,KAAe,GACR,EAAI,OAAO,EAAG,GAEd,EAIf,OAAO,EAAQ,CACX,MAAOA,IAAO,OAAO,GAGzB,OAAO,EAAK,CACR,MAAOA,IAAO,OAAO,IChBtB,QAAa,CAChB,OAAO,EAAQ,CACX,MAAO,IAAK,OAAO,GAGvB,OAAO,EAAK,CACR,MAAO,IAAK,OAAO,ICJpB,QAAe,CAClB,aAAc,CACV,KAAK,KAAO,GAAI,IAChB,KAAK,OAAS,GAAI,IAClB,KAAK,OAAS,GAAI,KCRnB,QAAgB,CACnB,YAAY,EAAY,CACpB,KAAK,YAAc,EAGvB,cAAc,EAAS,EAAY,CAC/B,KAAM,GAAa,EAAQ,eAAe,EAAQ,qBAClD,MAAO,MAAK,YAAY,KAAK,CAAC,KAAM,iBAAkB,aAAY,oBAGhE,sBAAqB,EAAS,EAAW,CAE3C,GAAI,GACJ,AAAI,OAAO,UACP,GAAe,CACX,OAAO,SAAS,gBAAgB,GAAI,YAAW,KAC/C,OAAO,SAAS,gBAAgB,GAAI,YAAW,EAAY,OAGnE,KAAM,GAAS,KAAM,MAAK,YAAY,KAAK,CAAC,KAAM,0BAA2B,eAAc,cAAY,WACvG,EAAQ,SAAS,GAAI,QAGnB,0BAAyB,EAAS,EAAY,EAAkB,EAAiB,CACnF,KAAM,GAAgB,EAAQ,OAAO,IACrC,GAAI,GACJ,AAAI,OAAO,UACP,GAAe,CACX,OAAO,SAAS,gBAAgB,GAAI,YAAW,OAGvD,KAAM,GAAgB,KAAM,MAAK,YAAY,KAAK,CAAC,KAAM,sBAAuB,gBAAe,mBAAkB,kBAAiB,iBAAe,WACjJ,EAAW,SAAS,GAAI,GAG5B,SAAU,CACN,KAAK,YAAY,mBC/BgB,CAUrC,YAAY,EAA8B,EAAoB,EAAoB,EAA+B,MACxG,QAAU,OACV,MAAQ,EAAO,YAEf,QAAU,MAAO,IAAkB,SAAW,CAAC,EAAG,GAAiB,OACnE,SAAW,OACX,eAAiB,EAI1B,YAAY,EAA8B,EAAgC,EAAqB,EAAyC,OAC7H,MAAK,QAAQ,YAAY,EAAe,EAAU,EAAU,GAIvE,aAAa,EAA8B,EAAgC,EAAqB,EAAqC,MAC5H,YAAY,KAAK,YAAY,EAAe,EAAU,EAAU,IAKzE,YAAY,EAAmB,EAA2B,GAC9C,mBACH,IAAI,CAAC,IAAK,EAAQ,OAAO,OAAQ,GAG1C,aAAoB,CACX,KAAK,QAAQ,YACT,IAAI,QAAS,KAAK,QAAQ,gBAOvC,KAAQ,EAA8B,EAA0B,EAAqB,EAAkC,OAE5G,AADM,MAAK,MAAM,EAAe,EAAU,GACrC,IAAI,MAGhB,WAA+B,IAC3B,KAAK,UACE,MAAK,IAAM,KAAK,MAM/B,oBAAoB,EAAkC,MAC5C,GAAiB,KAAK,eAAe,MACvC,KAAK,UAAY,QACV,MAAK,SAAW,EAI/B,eAAe,EAAkC,OACzC,MAAK,QAAQ,IAAM,EACZ,KAAK,SACL,KAAK,UACL,KAAK,UAAU,OAAO,CAAC,EAAK,IAAM,MAC/B,GAAW,EAAE,eAAe,SAC3B,cAAmB,IAC3B,GAEI,EASf,IAAI,EAA8B,EAA+B,MACvD,GAAO,KAAK,MAAM,EAAe,YAClC,IAAM,EAAK,MACT,EAGX,IAAI,EAAsB,EAA2B,IAC9C,MAAO,IAAQ,SAAU,MAClB,GAAS,SACR,OAAO,KAAK,QAAS,aAEvB,QAAQ,GAAO,QAEjB,MAGX,UAAU,EAAmB,EAAqC,EAA8C,IACxG,KAAK,kBACD,GACS,KAAK,eAAe,GAAI,IAAU,GAAS,YAC/C,WACG,MAAM,4BAA6B,MAG/C,GAA0C,QAC1C,KAAK,cACM,KAAK,UAAU,OAAO,CAAC,EAA+B,IAAM,MAC7D,GAAI,EAAE,UAAU,EAAQ,KAAK,MAAO,UACtC,IACI,KAAU,SACF,MAEN,KAAK,IAER,GACR,OAEH,GAAU,CAAC,EAAO,OAAO,KAAM,eAI7B,GAAwB,CAE1B,EAAG,MAAO,IAAoB,SAAW,KAAK,MAAQ,EAAkB,KAAK,MAE7E,EAAG,KAAK,SAER,EAAG,KAAK,QAER,EAAG,KAAK,gBAER,MAAK,UAEA,EAAI,CACL,MAAO,KAAK,MAAM,MAClB,KAAM,KAAK,MAAM,KACjB,QAAS,KAAK,MAAM,QAAQ,MAAM;AAAA,GAAM,KAG5C,MACK,EAAI,IAET,MAEK,EAAI,GAEN,EAgBX,IAAO,EAA6B,CAC5B,KAAK,MAAQ,gBACL,MAAM,wEAEd,MACM,GAAS,EAAS,YACpB,aAAkB,SACX,EAAO,KAAK,SACV,SACE,GACR,GAAO,MACA,MAAK,MAAM,WAGhB,SACE,SAEN,QACC,MAAK,MAAM,IAQzB,QAAe,IACP,KAAK,MAAQ,OAAW,IACpB,KAAK,mBACK,KAAK,MAAK,YACd,cAGL,IAAM,KAAK,QAAQ,WAK5B,QAAyB,OAClB,GAGX,MAAM,EAAmB,aAChB,MAAQ,OACR,SAAW,EAAS,WACpB,SACE,EAGX,MAAM,EAA8B,EAAqB,EAAwC,CACzF,KAAK,aACG,MAAM,qEAEb,MACU,KAAK,UAAY,EAAS,WAEnC,GAAO,GAAI,IAAQ,EAAe,EAAU,KAAK,QAAS,SAC3D,MAAK,iBACD,UAAY,SAEhB,UAAU,KAAK,GACb,KAGP,SAAqB,OACd,MAAK,WAGZ,SAAwB,OACjB,MAAK,WAGZ,WAAuC,OAChC,MAAK,mBC7OgC,CAKhD,YAAY,CAAC,WAAU,wBAAwB,AAAC,GAA0B,GAAO,iBAJ5C,GAAI,UAKhC,UAAY,OACZ,uBAAyB,EAGlC,IAAI,EAA8B,EAAqB,EAAS,KAAY,MAClE,GAAO,GAAI,IAAQ,EAAe,EAAU,QAC7C,IAAM,EAAK,WACX,aAAa,EAAM,OAAW,IAIvC,UAAa,EAA4B,EAA8B,EAA0B,EAAqB,EAAkC,OAChJ,GACO,EAAK,KAAK,EAAe,EAAU,EAAU,GAE7C,KAAK,IAAI,EAAe,EAAU,EAAU,GAS3D,YAAe,EAA8B,EAA0B,EAAqB,EAAyC,CAC5H,MACU,EAAS,WAElB,GAAO,GAAI,IAAQ,EAAe,EAAU,kBAC7C,KAAK,EAAM,EAAU,EAAU,GAA6C,GAC1E,EAMX,IAAO,EAA8B,EAA0B,EAAqB,EAAkC,CAC9G,IAAa,WACF,EAAS,WAElB,GAAO,GAAI,IAAQ,EAAe,EAAU,YAC3C,MAAK,KAAK,EAAM,EAAU,EAAU,GAAM,GAMrD,KAAQ,EAAe,EAA0B,EAAoB,EAAqB,EAAyC,MAC1H,WAAW,IAAI,QAEd,GAAa,IAAM,IACjB,GAAS,GAAI,OACb,KACI,GACS,EAAc,EAAQ,SAC1B,WACG,MAAM,kCAAmC,UAI5C,EAAO,SAAS,MAEzB,MACK,aAAa,EAAM,EAAQ,UAC3B,WACG,MAAM,6BAA8B,QAE3C,WAAW,OAAO,OAGvB,IACI,GAAS,EAAK,IAAI,MAClB,YAAkB,eACR,EAAO,KAAK,QAEX,GACR,GAAO,QAEF,OACM,KAGV,QACO,eAIR,QACQ,SAGV,UAED,OACM,IAKlB,kBAAmB,UACJ,KAAY,MAAK,WAAY,GAC3B,YACL,MAKK,aAAa,EAAU,GAAI,IAAa,UACxC,WACG,MAAM,+BAAgC,SAGjD,WAAW,WAQhB,QAAyB,OAClB,GAGX,MAAe,OACJ,MAAK,UAAU,MAAM,MAGhC,cAAuB,OACZ,MAAK,MAAM,KAAK,UAAU,SAAW,OAAO,mCCzH5B,GAAW,CAMtC,YAAY,EAAyJ,OAC3J,QACA,CAAC,OAAM,gBAAgB,GAAK,IAAM,QAAQ,KAAQ,OACnD,MAAQ,OACR,OAAS,OACT,aAAe,KAAK,0BAElB,iBAAiB,WAAY,KAAM,SACrC,eAAiB,KAAK,UAAU,MAAM,eAAe,IAAM,KAAK,YAAa,GAItF,SAAgB,QACL,oBAAoB,WAAY,KAAM,SACxC,eAAe,UAGxB,YAAY,EAAkB,CACtB,EAAI,OAAS,iBACR,0BAIP,YAA2B,MACvB,GAAK,KAAM,MAAK,aAClB,MACM,GAAM,EAAG,YAAY,CAAC,QAAS,aAC/B,EAAO,EAAI,YAAY,QACvB,EAAS,KAAK,aAAa,gBACvB,KAAK,MAAK,eACX,IAAI,QAEP,GAAY,KAAM,GAAa,EAAK,YACtC,EAAY,KAAK,OAAQ,IAErB,GAAgB,EAAY,KAAK,OAAU,KAAK,MAAM,GAAM,KAAK,aAC/D,GAAc,EAAK,aAAc,CAAC,EAAG,EAAI,OACpC,YACS,EACT,CAAC,KAAM,IAAiB,UAGjC,IAAa,QACd,aAAa,OAAO,EAAG,SACvB,WACG,MAAM,uBAAwB,cAElC,GACG,iBAKf,oBAA2B,MAClB,wBACA,IAAI,CAAC,EAAG,yBAA0B,EAAG,oBACrC,oBAAoB,KAAK,cAGlC,kBAAiC,MACvB,GAAM,GAAG,KAAK,uBAChB,MACM,GAAO,OAAO,aAAa,QAAQ,MACrC,gBACO,aAAa,WAAW,GACxB,KAAK,MAAM,SAEjB,WACG,MAAM,kCAAmC,SAE9C,GAGX,SAAgC,OACrB,IAAa,KAAK,MAAO,GAAM,EAAG,kBAAkB,OAAQ,CAAC,QAAS,KAAM,cAAe,KAAQ,GAG9G,aAAa,EAAmB,EAAmB,EAAuB,MAChE,GAAiB,EAAQ,UAAU,EAAQ,OAAW,MACxD,EAAgB,MACV,GAA4B,KAAK,uBAAuB,QACzD,aAAa,KAAK,CACnB,KAAM,KAAK,UAAU,MAKjC,oBAAoB,EAA2B,IACvC,QACO,aAAa,QAAQ,GAAG,KAAK,oBAAqB,KAAK,UAAU,UACnE,WACG,MAAM,+EAAgF,SAIhG,SAA8B,MAC1B,GAAK,KAAM,MAAK,aAClB,MAEM,GAAO,AADD,EAAG,YAAY,CAAC,QAAS,YACpB,YAAY,QAEvB,EAAW,AADiB,MAAM,IAAa,EAAK,aAAc,IAAM,KACjD,OAAO,KAAK,oBAClC,IAAI,IAAa,EAAU,KAAM,KAAK,sBAEzC,GACG,sBAKT,cAAa,EAAoC,MAC7C,GAAK,KAAM,MAAK,aAClB,MACM,GAAM,EAAG,YAAY,CAAC,QAAS,aAC/B,EAAO,EAAI,YAAY,iBAClB,KAAQ,MACX,MAAO,GAAK,IAAO,WACd,OAAO,EAAK,QACd,MAEG,GAAY,KAAK,aAAa,QAAQ,GACxC,IAAc,SACT,aAAa,OAAO,EAAW,QAI1C,IAAa,cAEf,GACG,kBAMnB,QAAyC,CAKrC,YAAY,EAAqB,EAAmB,EAAoB,MAC/D,OAAS,OACT,QAAU,OACV,UAAY,KAGjB,QAAgB,OACT,MAAK,OAAO,OAMvB,iBAAiC,OACtB,MAAK,QAAQ,aAAa,KAAK,QAG1C,QAAqB,YACX,GAAM,CACR,cAAe,EACf,WAAY,QAAK,UAAU,gBAAf,cAA8B,QAC1C,MAAO,KAAK,OAAO,IAAI,GAAK,KAAK,MAAM,EAAE,QAEvC,EAAO,KAAK,UAAU,GACtB,EAAqB,KAAK,UAAU,SAAS,KAAK,OAAO,SACtC,MAAK,UAAU,WAAW,EAAQ,qCC5LhC,GAAW,CAC1C,aAAa,EAAqB,IACf,QAGb,SAA0C,GAKpD,KAAM,IAAwB,CAAC,IAAK,MACpC,YAAsB,EAA6C,OACxD,QAAO,QAAQ,GACjB,OAAO,CAAC,CAAC,KAAS,CAAC,GAAsB,SAAS,IAClD,OAAO,CAAC,EAAoB,CAAC,EAAK,QACzB,GAAO,KACT,GAAO,EACJ,GACR,MAGX,YAAwB,EAAqB,MACnC,GAAQ,GAAG,GAAY,OAAU,EAAK,cACtC,EAAiB,GAAa,EAAK,QACnC,EAAc,EAAK,UAAY,KACjC,GACI,EAAK,cACG,MAAM,WAEN,eAAe,GAEvB,EAAK,eACG,MAAM,EAAK,QAGnB,EAAK,cACG,MAAM,EAAK,eAEX,IAAI,GAGhB,WACQ,MAAM,GAEd,EAAK,kBACK,KAAK,GAAK,YACD,GAGnB,WACQ,WAIhB,YAAqB,EAAwB,OACrC,GAAK,OAAO,IAAM,UACX,GAAG,EAAK,OAAO,UAAU,EAAK,OAAO,MACrC,EAAK,OAAO,GAAK,MAAO,GAAK,OAAO,IAAO,YAC3C,GAAG,EAAK,OAAO,KAAK,EAAK,OAAO,KAChC,EAAK,OAAO,GAAK,MAAO,GAAK,OAAO,QAAW,YAC/C,GAAG,EAAK,OAAO,MAAM,EAAK,OAAO,UACjC,EAAK,OAAO,GAAK,EAAK,MACtB,GAAG,EAAK,OAAO,WACf,MAAO,GAAK,OAAO,KAAQ,YAC3B,OAAO,EAAK,OAAO,MAEnB,EAAK,OAAO,GAAK,EAAK,OAAO,iBC5DjB,EAAiE,OAEjF,OAAO,IAAa,UAAY,YAAc,IAAY,MAAM,QAAQ,eAGrD,EAAoB,EAAkB,OACzD,QAAO,QAAQ,GAAK,OAAO,CAAC,EAAI,CAAC,EAAM,KACtC,OAAO,IAAY,eACT,EAAQ,IAElB,EACO,KAAS,OAAS,IAAM,IAAM,EAE9B,GAEZ,gBAGsB,EAAa,EAAc,EAA+B,CAC/E,IAAS,gBACF,SAEP,IAAU,KACP,gBAAgB,GAEf,KAAU,OACF,KAET,aAAa,EAAM,gBAIX,EAAqB,EAAuD,EAAqC,OACzH,IAAK,GAAS,EAAa,EAAY,eAG7B,EAAY,EAAqB,EAAuD,EAAqC,CAC1I,GAAc,GAAW,OACd,IACE,aAGX,GAAI,SAAS,gBAAgB,EAAI,MAEnC,SACS,CAAC,EAAM,IAAU,QAAO,QAAQ,GACjC,MAAO,IAAU,aAGR,IAAU,MAAQ,IAAS,YAAe,GAAW,EAAO,QAAa,OAEzE,EAAG,EAAM,MAI1B,EAAU,CACL,MAAM,QAAQ,OACJ,CAAC,WAEP,KAAK,GACN,MAAO,IAAM,aACT,GAAK,MAEX,YAAY,SAGf,eAGU,EAAmB,OAC7B,UAAS,eAAe,QAGtB,IAAkB,+BAClB,GAAiB,6BAEjB,GAAY,EACpB,IAAU,CACP,KAAM,IAAK,KAAM,KAAM,KAAM,MAAO,KAAM,KAAM,KAAM,KAAM,KAAM,KAClE,IAAK,SAAU,KAAM,OAAQ,MAAO,UAAW,OAAQ,UAAW,QAAS,MAAO,aAClF,QAAS,QAAS,QAAS,KAAM,KAAM,KAAM,KAC7C,MAAO,OAAQ,SAAU,OAAQ,QAAS,WAAY,QAAS,OAAQ,WAAY,SAAU,UAChG,IAAS,CAAC,MAAO,WAGT,EAAyJ,GAEtK,SAAW,CAAC,EAAI,IAAS,QAAO,QAAQ,aACzB,KAAW,KACd,GAAW,SAAS,EAAY,EAAU,OACnC,IAAK,EAAI,EAAS,EAAY,gBChGvB,EAAa,EAAkC,IACjE,MACA,GACO,EAAK,MAAM,SACb,KACE,GAAW,SAEf,eAGgB,EAAuB,MACxC,GAAQ,GAAI,SAAQ,SACtB,GAAwB,WACxB,OACS,EAAM,MAAM;AAAA,GAAM,IAExB,EAAI,IAAI,CACX,EAAI,GAAG,8BACP,EAAI,GAAG,EAAM,SACb,EAAI,EAAE,+BAA+B,MACrC,EAAI,IAAI,EAAM,qBAIG,EAAqB,EAAa,EAAuB,IAC/D,IAAQ,EAAW,oBAEnB,YAAY,OACpB,MACG,GAAc,EAAW,SAAS,KAC7B,aAAa,EAAW,gBAIZ,EAA2B,GAC3C,UAAY,WCxBkD,CAYzE,YACI,CAAC,OAAM,cAAa,YAAW,UAAU,KAAM,wBAAwB,IACvE,EACF,MACO,aAAe,OACf,MAAQ,OACR,WAAa,OACb,SAAW,OACX,MAAQ,YACR,cAAgB,YAChB,cAAgB,OAChB,gBAAkB,YAClB,WAAa,CAAC,yBAGvB,MAA4B,OAEjB,MAAK,MAGhB,OAAO,EAA4B,IAC3B,EAAW,KAAM,IACb,KAAK,uBACA,cACE,KAAK,MAAO,gBACV,MAAO,UAAU,cAGzB,MAAQ,EAAW,UACnB,YAIb,OAAiB,MACP,GAA8B,GAChC,KAAK,eACA,UAAY,KAAK,iBAEpB,GAAO,KAAK,MAAQ,GAAG,KAAK,SAAU,eACvC,WACD,KAAK,gBACA,iBAAiB,QAAS,MAE5B,EAGX,YAAY,EAAY,CAChB,EAAI,OAAS,cACR,aAAa,GAI1B,SAAgB,CACR,KAAK,YACA,cAIL,aAAa,EAAgB,IAC7B,EAAM,SAAW,KAAK,OAAS,CAAC,KAAK,uBAGrC,GAAY,EAAM,YACf,EAAU,aAAe,KAAK,SACrB,EAAU,gBAEpB,GAAQ,MAAM,UAAU,QAAQ,KAAK,KAAK,MAAO,WAAY,GAC7D,EAAY,KAAK,gBAAiB,GACpC,QACK,aAAa,EAAW,GAI7B,aAAc,MACb,cAAgB,KAAK,uBACjB,KAAS,MAAK,kBACb,eAEL,gBAAkB,OAGjB,UAAW,IACb,CAAC,KAAK,kBAGL,cAAgB,KAAK,MAAM,UAAU,WACrC,gBAAkB,QACjB,GAAW,SAAS,gCACjB,KAAQ,MAAK,MAAO,MACnB,GAAQ,KAAK,cAAc,QAC5B,gBAAiB,KAAK,KAClB,YAAY,GAAU,EAAO,KAAK,kBAE1C,MAAO,YAAY,GAG5B,SAAU,UACK,KAAS,MAAK,kBACf,OAAQ,WACR,eAEL,gBAAiB,OAAS,EAGnC,MAAM,EAAa,EAAU,MACpB,SAAS,EAAK,GAGvB,SAAS,EAAa,EAAU,MACvB,YAAY,GAGrB,OAAO,EAAiB,EAAe,EAAU,MACxC,UAAU,EAAS,GAG5B,SAAS,EAAW,EAAU,EAAa,MAClC,YAAY,EAAG,EAAO,GAGrB,SAAS,EAAkB,EAAU,MACrC,GAAQ,KAAK,cAAc,QAC5B,gBAAiB,OAAO,EAAU,EAAG,MACjC,KAAK,MAAQ,EAAU,GAAU,EAAO,KAAK,aAGhD,YAAY,EAAkB,MAC9B,CAAC,GAAS,KAAK,gBAAiB,OAAO,EAAU,KACjD,OAAQ,WACR,UAGA,UAAU,EAAsB,EAAoB,MACpD,CAAC,GAAS,KAAK,gBAAiB,OAAO,EAAc,QACtD,gBAAiB,OAAO,EAAY,EAAG,KACtC,OAAQ,YACL,KAAK,MAAQ,EAAY,EAAM,QAGlC,YAAY,EAAkB,EAAU,EAAa,IACvD,KAAK,gBAAiB,MAChB,GAAW,KAAK,gBAAiB,MAC3B,EAAS,OAAO,EAAO,IAKjC,aAAa,EAAe,EAAU,IACxC,KAAK,gBAAiB,MAChB,GAAQ,KAAK,cAAc,MAC7B,CAAC,OACI,SAAS,EAAO,OAClB,MACG,CAAC,GAAY,KAAK,gBAAiB,OAAO,EAAO,EAAG,QACrD,MAAO,aAAa,EAAM,MAAM,KAAK,YAAa,EAAS,UACvD,YAKd,wBAAwB,EAA4B,aAChD,QAAK,kBAAL,cAAuB,YCnL4C,CAQ9E,YAAY,EAAU,MACb,OAAS,OAET,sBAAwB,KAGjC,iBAAiB,EAA4B,CAEpC,AADyB,GAAW,EAAQ,4BAExC,aAIb,SAAgB,MACP,kBAGL,QAAW,OACJ,MAAK,OAGhB,iBAAiB,EAAyB,MACjC,OAAO,KAAK,OAAQ,GAG7B,YAAmB,OACX,MAAO,SAAK,SAAL,cAAa,KAAO,kBACtB,sBAAwB,KAAK,iBAAiB,KAAK,WACnD,OAAO,GAAG,SAAU,KAAK,wBAItC,cAAqB,CACb,KAAK,uBACD,OAAO,MAAK,OAAO,KAAQ,iBACtB,OAAO,IAAI,SAAU,KAAK,4BAE9B,sBAAwB,OC/CzC,YAAmB,EAAmE,UACxE,KAAS,QAAO,OAAO,MACzB,MAAO,IAAU,iBACV,SAGR,kBAyB4D,GAAkB,CAAlF,aArDP,0CAsDyG,sBAChE,kBACV,sBAEL,OAEtB,SAAgB,IACR,KAAK,uBACI,CAAC,OAAM,OAAM,KAAI,eAAe,MAAK,kBACrC,iBAAiB,EAAM,EAAI,GAK5C,SAAgB,IACR,KAAK,uBACI,CAAC,OAAM,OAAM,KAAI,eAAe,MAAK,kBACrC,oBAAoB,EAAM,EAAI,GAO/C,MAAM,EAAgC,MAC5B,GAAU,GAAI,IAAgB,SAChC,MACK,MAAQ,KAAK,OAAO,EAAS,KAAK,kBAE/B,oBAGP,iBAAiB,QACjB,UACE,KAAK,MAGhB,SAAgB,SACP,gBACC,UACF,KAAK,mBACM,KAAK,MAAK,YACf,UAKd,MAA6B,OAClB,MAAK,MAGhB,OAAO,EAAU,EAAwB,SAChC,OAAS,EACV,KAAK,mBACM,KAAW,MAAK,cAMnC,kBAAkB,EAAe,EAAc,EAA4B,EAAsB,GAAa,CACrG,KAAK,uBACD,gBAAkB,SAEtB,gBAAgB,KAAK,CAAC,OAAM,OAAM,KAAI,eAG/C,YAAY,EAA6B,CAChC,KAAK,iBACD,UAAY,SAEhB,UAAU,KAAK,GAGxB,WAAW,EAAmB,CACrB,KAAK,iBACD,UAAY,SAEhB,UAAU,KAAK,GAGxB,cAAc,EAAmB,IACzB,CAAC,KAAK,sBACJ,GAAM,KAAK,UAAU,QAAQ,GAC/B,IAAQ,SACH,UAAU,OAAO,EAAK,GAInC,eAAe,EAAyB,EAAiB,IACjD,KAAK,mBACM,KAAK,MAAK,YACf,OAAO,EAAO,YAOyB,CAIrD,YAAY,EAA+B,cAFhB,QAGlB,cAAgB,EAGzB,OAAc,MACL,QAAU,GAGnB,YAAY,EAAsB,CAC1B,KAAK,iBACG,MAAM,qEAEb,cAAc,YAAY,MAG/B,SAAY,OACL,MAAK,cAAc,MAG9B,iBAAiB,EAAe,EAAc,EAA4B,EAAsB,GAAa,MACpG,cAAc,kBAAkB,EAAM,EAAM,EAAI,GAGzD,qBAAqB,EAAe,EAAc,EAA0C,IACpF,QACE,GAAU,IAAM,MACZ,GAAW,EAAG,KAAK,QACrB,IAAc,MACF,KACC,EAAM,EAAM,UAG5B,YAAY,OAIrB,sBAAsB,EAAe,EAA0B,MACtD,qBAAqB,EAAM,YAAa,GAAS,GAAW,EAAK,IAG1E,gBAAgB,EAAgC,MACtC,GAAe,EAAG,KAAK,QACvB,EAAO,GAAK,MACd,GAAY,OACV,GAAU,IAAM,MACZ,GAAW,EAAG,KAAK,QACrB,IAAc,MACF,IACP,YAAc,EAAS,iBAI/B,YAAY,GACV,EAGX,gBAAgB,EAAa,EAAsD,OAGxE,GAAI,WAAW,OAAS,EAAI,OAAS,GAAK,MAAO,IAAU,WAGtE,mBAAmB,EAAe,EAAiC,QACvD,CAAC,EAAK,IAAU,QAAO,QAAQ,MAE/B,MAAO,IAAU,SAAU,IACvB,IAAQ,aAAe,IAAU,cAIjC,GAAU,QACL,sBAAsB,EAAM,MAEpB,EAAM,EAAK,GAAW,EAAO,KAAK,iBAE5C,KAAK,gBAAgB,EAAK,GAAQ,MACnC,GAAY,EAAI,OAAO,EAAG,GAAG,cAAgB,EAAI,OAAO,GACxD,EAAU,OACX,cAAc,kBAAkB,EAAM,EAAW,OAC/C,OAAO,IAAU,gBACnB,qBAAqB,EAAM,EAAK,MAExB,EAAM,EAAK,GAKpC,iBAAiB,EAAe,EAAgC,CACvD,MAAM,QAAQ,OACJ,CAAC,WAEP,KAAS,GACV,MAAO,IAAU,aACT,KAAK,gBAAgB,GACtB,MAAO,IAAU,aAEhB,GAAK,MAEZ,YAAY,GAIzB,uBAA0B,EAAqB,EAA0D,IACjG,GAAY,EAAG,KAAK,QACpB,EAAO,EAAW,WAEhB,GAAU,IAAM,MACZ,GAAW,EAAG,KAAK,WACrB,IAAc,EAAU,GACZ,OACN,GAAU,EAAW,GACvB,EAAK,cACA,WAAW,aAAa,EAAS,KAEnC,gBAGV,YAAY,GACV,EAGX,GAAG,EAAc,EAA8C,EAAsC,OAC1F,MAAK,KAAK,GAAS,EAAM,EAAY,GAGhD,KAAK,EAAY,EAAc,EAA8C,EAAsC,CAC3G,IAAe,QAAa,GAAW,OAC5B,IACE,aAGX,GAAO,SAAS,gBAAgB,EAAI,SAEtC,SACK,mBAAmB,EAAM,GAE9B,QACK,iBAAiB,EAAM,GAGzB,EAKX,KAAK,EAAa,EAAqC,aAC9C,cAAc,WAAW,GACvB,GAAU,EAAM,GAI3B,QAAW,EAAwB,EAAoD,OAC5E,MAAK,uBAAuB,EAAO,AAAC,GAAa,IAChD,GAAY,EAAS,WAAa,KAAK,aAAc,MAC/C,GAAW,KAAK,cAAc,aAChC,EAAU,MACJ,GAAU,EAAS,UAAU,GAAK,EAAE,SAAW,MACjD,IAAY,GAAI,MACV,CAAC,GAAQ,EAAS,OAAO,EAAS,KACnC,iBAIX,GAAO,EAAY,EAAM,KAAK,eAChC,GACO,KAAK,KAAK,GAEV,SAAS,cAAc,8BAQ1C,IAAO,EAAwB,EAAmE,OACvF,MAAK,QAAQ,EAAO,GAChB,GAAI,IAAmB,KAAK,OAAQ,CAAC,EAAG,IAAO,MAC5C,GAAW,EAAS,EAAa,EAAG,SACrC,IAGM,SAAS,cAAc,sBAO9C,OAAO,EAAkC,EAA4C,OAC1E,MAAK,QACR,GAAS,CAAC,CAAC,EAAU,GACrB,GAAW,EAAU,EAAY,KAAK,QAAU,MAMxD,GAAG,EAAkC,EAA8C,OACxE,MAAK,OAAO,EAAW,GAAM,GAAI,IAAmB,EAAI,IAUnE,cAAiB,EAAwB,EAAoD,IACrF,GAAY,EAAM,KAAK,aACrB,GAAU,IAAM,MACZ,GAAW,EAAM,KAAK,QACxB,IAAc,MACH,EAAU,KACT,SAGf,YAAY,KACN,EAAW,SAK9B,SAAW,CAAC,EAAI,IAAS,QAAO,QAAQ,aACzB,KAAO,MACE,UAAU,GAAO,SAAS,EAAY,EAAU,OACrD,MAAK,KAAK,EAAI,EAAK,EAAY,oBAKP,EAAgB,CAGvD,YAAY,EAAU,EAAqB,OACjC,QACD,QAAU,EAGV,OAAO,EAAe,EAAoB,OACxC,MAAK,QAAQ,EAAG,ICxXxB,YAA4B,EAAI,EAAM,EAAe,OAAW,CACnE,KAAM,GAAY,CAAC,CAAC,EAAG,UAAU,GACjC,GAAI,GAAgB,GAAW,CAC3B,OAAQ,IACP,QAAQ,KAAS,IACjB,YAAY,EAAG,qBAAsB,CAAC,IAE3C,AAAI,GACA,IAAiB,IAAI,KAEzB,KAAM,GAAgB,EAAY,GAAU,EAAI,GAAQ,GAAK,EAAG,cAC1D,EAAS,EAAI,IAAI,CAAC,UAAW,GAAgB,CAAC,IACpD,MAAI,IACA,IAAa,EAAQ,qBAAsB,EAAG,cAC9C,GAAa,EAAQ,oBAAqB,EAAG,oBAE1C,EAGJ,YAAmB,EAAI,EAAM,CAChC,KAAM,GAAU,EAAK,WACrB,MAAO,GAAI,IAAI,CAAC,IAAK,EAAG,UAAU,GAAO,MAAO,EAAS,OAAQ,EAAS,MAAO,EAAG,cAGxF,YAAuB,EAAG,CACtB,KAAM,GAAU,EAAE,OACZ,EAAS,EAAQ,cACvB,MAAO,GAAQ,UAAY,OAAS,EAAO,UAAU,SAAS,UAG3D,YAA2B,EAAG,CACjC,GAAI,CAAC,GAAc,GAAM,OACzB,KAAM,GAAS,EAAE,OAAO,cAClB,EAAoB,EAAO,aAAa,qBAC9C,EAAO,UAAU,IAAI,YAAY,KACjC,KAAM,GAAe,EAAO,aAAa,sBACzC,EAAO,YAAc,EClClB,gBAAyB,GAAe,CAK3C,YAAY,EAAO,EAAM,CACrB,MAAM,GACN,KAAK,MAAQ,KACb,KAAK,WAAa,KAClB,KAAK,aAAe,KACpB,KAAK,cAAgB,KACrB,KAAK,MAAQ,EAGjB,mBAAoB,CAChB,MAAI,MAAK,MAAM,UAAU,KAAK,SAAW,KAAK,WAC1C,MAAK,WAAa,KAAK,MAAM,UAAU,KAAK,OACrC,IAEJ,GAGX,qBAAsB,CAClB,MAAI,MAAK,MAAM,cAAgB,KAAK,aAChC,MAAK,aAAe,KAAK,MAAM,YACxB,IAEJ,GAGX,sBAAuB,CACnB,MAAI,MAAK,MAAM,eAAiB,KAAK,cACjC,MAAK,cAAgB,KAAK,MAAM,aACzB,IAEJ,GAGX,MAAM,EAAS,CACX,YAAK,oBACL,KAAK,uBACL,KAAK,sBACL,KAAK,MAAQ,GAAmB,KAAK,MAAO,KAAK,OAEjD,KAAK,iBAAiB,GACf,KAAK,MAGhB,MAAO,CACH,MAAO,MAAK,MAGhB,OAAO,EAAI,CAEP,GAAI,KAAK,oBAAqB,CAE1B,KAAM,GAAe,YAAY,EAAG,oBACpC,AAAI,EAAG,UAAU,KAAK,OAClB,MAAK,MAAM,aAAa,GAAU,EAAI,KAAK,OAAQ,KAAK,MAAM,YAC9D,KAAK,MAAM,UAAU,OAAO,IAE5B,MAAK,MAAM,YAAc,EAAG,aAC5B,KAAK,MAAM,UAAU,IAAI,IAGjC,KAAM,GAAY,CAAC,CAAC,EAAG,UAAU,KAAK,OACtC,GAAI,KAAK,uBAAyB,EAAW,CACzC,KAAM,GAAU,KAAK,MAAM,WAC3B,AAAI,EAAQ,UAAY,OACpB,EAAQ,aAAa,QAAS,EAAG,aAGzC,AAAI,KAAK,wBAA0B,CAAC,GAChC,MAAK,MAAM,YAAc,EAAG,eCjFxC,GAAI,IAEG,YAAiB,EAAG,EAAe,OAAW,CACjD,AAAI,KAAc,QACd,IAAY,SAAS,cAAc,cAEvC,KAAM,GAAU,OAAO,OAAO,CAAC,QAAW,IAAO,GACjD,MAAI,oBAAW,UAAU,SAAS,WACvB,EAAE,IAAI,CAAC,UAAW,GAAU,CAC/B,EAAE,MACF,EAAE,MACF,EAAE,MACF,EAAE,QAGC,EAAE,IAAI,CAAC,UAAW,EAAS,QAAQ,eACtC,EAAE,OAAO,CAAC,GAAG,MAAO,GAAG,MAAO,EAAE,MAAO,WAAW,SCXvD,gBAA2B,EAAa,CAC3C,OAAO,EAAG,EAAI,CACV,KAAM,GAAU,CACZ,OAAU,GAAM,EAAG,OACnB,OAAU,GAAM,EAAG,QAEvB,MAAO,GAAE,GAAG,CAAC,UAAa,GAAU,CAChC,EAAE,EAAE,CAAC,KAAM,EAAG,KAAM,CAChB,EAAE,KAAK,GAAI,IAAW,EAAI,IAAK,CAAC,sBAAuB,KACvD,EAAE,IAAI,CAAC,UAAW,eAAgB,CAC9B,EAAE,IAAI,CAAC,UAAW,CAAC,KAAQ,GAAM,OAAQ,GAAM,EAAG,WAAY,GAAM,EAAG,MACvE,EAAE,IAAI,GAAM,EAAG,KAAM,GACb,EACO,GAAQ,GAER,EAAE,IAAI,CACT,UAAW,CACP,MAAO,GACP,YAAa,GAAM,EAAG,cACtB,OAAQ,GAAM,CAAC,EAAG,aAEvB,GAAM,EAAG,mBAQpC,OAAO,EAAO,EAAO,CACjB,MAAM,OAAO,GAEb,KAAK,eAAe,EAAO,ICjCnC,gBAA0B,EAAa,CACnC,OAAO,EAAG,EAAS,CACf,KAAM,GAAQ,IAAM,CAChB,EAAY,MAAQ,GACpB,EAAY,OACZ,EAAY,OACZ,EAAQ,SAEN,EAAc,EAAE,MAAM,CACxB,KAAM,OACN,YAAa,iBAAS,MACtB,aAAc,iBAAS,MACvB,aAAc,iBAAS,aACvB,aAAc,SACd,KAAM,iBAAS,KACf,QAAS,GAAS,EAAQ,IAAI,EAAM,OAAO,OAC3C,UAAW,GAAS,CAChB,AAAI,GAAM,MAAQ,UAAY,EAAM,MAAQ,QACxC,KAGR,QAAS,IAAM,EAAY,WAEzB,EAAc,EAAE,OAAO,CACzB,QAAS,EACT,MAAO,EAAQ,YACf,aAAc,EAAQ,cAE1B,MAAO,GAAE,IAAI,CAAC,UAAW,eAAgB,CAAC,EAAa,KAIxD,gBAA4B,EAAa,CAC5C,OAAO,EAAG,EAAI,CACV,KAAM,GAAkB,GACb,EAAG,YACN,EAAG,uBACH,EAAG,yBAEL,EAAW,EAAE,KAAK,GAAI,IACxB,CACI,UAAW,WACX,KAAM,EAAG,gBAEb,GAAU,GAAI,IAAa,KAEzB,EAAe,EAAE,IAAI,CAAC,UAAW,aAAc,CACjD,EAAE,EAAE,CAAC,UAAW,+BAAgC,KAAM,EAAG,SAAU,aAAc,EAAG,2BAA4B,MAAO,EAAG,6BAC1H,EAAE,KAAK,GAAI,IAAY,CACnB,KAAM,EAAG,KACT,MAAO,EAAG,oBACV,KAAM,cACN,aAAc,GACd,IAAK,GAAS,CAEV,AAAI,EAAG,UAAU,IACb,GAAS,UAAY,IAG7B,MAAO,IAAM,EAAG,iBAEpB,EAAE,OAAO,CACL,QAAS,IAAM,EAAG,aAClB,UAAW,CACP,iBAAkB,GAClB,KAAM,GACN,GAAI,GAAM,EAAG,aAEjB,MAAO,EACP,aAAc,IAElB,EAAE,EAAE,CAAC,UAAW,0BAA2B,KAAM,EAAG,YAAa,aAAc,EAAG,eAAgB,MAAO,EAAG,iBAC5G,EAAE,EAAE,CAAC,UAAW,wBAAyB,KAAM,EAAG,cAAe,aAAc,EAAG,kBAAmB,MAAO,EAAG,sBAGnH,MAAO,GAAE,IAAI,CAAC,UAAW,aAAc,CACnC,EACA,KC/EL,QAAY,CACf,YAAY,EAAM,EAAgB,KAAM,CACpC,KAAK,MAAQ,EACb,KAAK,QAAU,KACf,KAAK,aAAe,KACpB,KAAK,UAAY,KACjB,KAAK,UAAY,KACjB,KAAK,sBAAwB,KAC7B,KAAK,eAAiB,EAG1B,oBAAqB,CACjB,KAAM,GAAe,KAAK,QAAQ,QAAQ,aAC1C,GAAI,GAAiB,EAAa,cAAc,mBAChD,MAAK,IACD,GAAiB,EAAI,IAAI,CAAC,UAAW,mBACrC,EAAa,YAAY,IAEtB,EAGX,oBAAoB,EAAc,CAC9B,KAAK,sBAAwB,EAC7B,KAAK,sBAAsB,WAAW,MAG1C,eAAe,EAAQ,EAAkB,EAAG,CACxC,KAAK,QAAU,EACf,KAAK,iBAAmB,EACxB,KAAK,UAAY,GAAiB,KAAK,SACvC,KAAK,MAAM,QACX,KAAK,qBAAqB,YAAY,KAAK,QAC3C,KAAK,YACD,KAAK,WACL,SAAS,KAAK,iBAAiB,SAAU,KAAM,IAEnD,WAAW,IAAM,CACb,SAAS,KAAK,iBAAiB,QAAS,KAAM,KAC/C,OAGH,SAAS,CACT,MAAO,CAAC,CAAC,KAAK,MAGlB,OAAQ,CACJ,AAAI,KAAK,OACL,MAAK,MAAM,UACX,KAAK,sBAAsB,cAAc,MACrC,KAAK,WACL,SAAS,KAAK,oBAAoB,SAAU,KAAM,IAEtD,SAAS,KAAK,oBAAoB,QAAS,KAAM,IACjD,KAAK,OAAO,SACZ,KAAK,MAAQ,KACT,KAAK,gBACL,KAAK,qBAKb,SAAS,CACT,MAAO,MAAK,MAAM,OAGtB,YAAY,EAAK,CACb,AAAI,EAAI,OAAS,SACT,KAAK,aACL,KAAK,QAEF,EAAI,OAAS,SACpB,KAAK,SAAS,GAItB,UAAW,CACP,KAAK,QAGT,WAAY,CACR,KAAM,GAAiB,KAAK,QAAQ,wBAC9B,EAAa,KAAK,OAAO,YACzB,EAAc,KAAK,OAAO,aAC1B,EAAY,MAAK,UAAY,KAAK,UAAY,SAAS,iBAAiB,wBAE9E,GACI,EAAe,IAAM,EAAS,QAC9B,EAAe,KAAO,EAAS,OAC/B,EAAe,OAAS,EAAS,KACjC,EAAe,MAAQ,EAAS,KAEhC,MAAO,GAEX,GAAI,EAAS,QAAU,EAAe,OAAS,EAE3C,KAAK,OAAO,MAAM,IAAM,GAAG,EAAe,OAAS,KAAK,6BACjD,EAAS,KAAO,EAAe,IAAM,EAE5C,KAAK,OAAO,MAAM,IAAM,GAAG,EAAe,IAAM,EAAc,KAAK,yBAEnE,OAAO,GAEX,GAAI,EAAS,OAAS,EAAe,MAAQ,EAEzC,KAAK,OAAO,MAAM,KAAO,GAAG,EAAe,iBACpC,EAAS,MAAQ,EAAe,KAAO,EAE9C,KAAK,OAAO,MAAM,KAAO,GAAG,EAAe,MAAQ,UAEnD,OAAO,GAEX,MAAO,GAIX,MAAO,CACH,MAAO,MAAK,UAGhB,OAAQ,CACJ,YAAK,UAAY,SAAS,cAAc,SACjC,KAAK,UAGhB,SAAU,CACN,KAAK,QAGT,QAAS,GAGb,YAA0B,EAAI,CAC1B,GAAI,GAAS,EACb,EAEI,IADA,EAAS,EAAO,cACZ,EAAO,aAAe,EAAO,aAAc,CAM3C,KAAM,GAAY,AADJ,OAAO,iBAAiB,GACd,iBAAiB,cACzC,GAAI,IAAc,QAAU,IAAc,SACtC,MAAO,SAGV,IAAW,SAAS,MClJ1B,eAAmB,EAAa,OAC5B,QAAO,EAAO,EAAU,CAC3B,MAAO,IAAI,IAAW,EAAO,GAGjC,YAAY,EAAS,CACjB,QACA,KAAK,SAAW,EAGpB,OAAO,EAAG,CACN,MAAO,GAAE,GAAG,CAAC,UAAW,OAAQ,KAAM,QAAS,KAAK,SAAS,IAAI,GAAK,EAAE,MAAM,MAItF,QAAiB,CACb,YAAY,EAAO,EAAU,CACzB,KAAK,MAAQ,EACb,KAAK,SAAW,EAChB,KAAK,KAAO,KACZ,KAAK,YAAc,GAGvB,QAAQ,EAAW,CACf,YAAK,KAAO,EACL,KAGX,gBAAiB,CACb,YAAK,YAAc,GACZ,KAGX,MAAM,EAAG,CACL,KAAM,GAAY,CACd,YAAa,KAAK,aAEtB,MAAI,MAAK,MACL,GAAU,KAAO,GACjB,EAAU,KAAK,MAAQ,IAEpB,EAAE,GAAG,CACR,aACD,EAAE,OAAO,CAAC,UAAU,YAAa,QAAS,KAAK,UAAW,KAAK,SC1CnE,gBAA4B,GAAS,CACxC,YAAY,EAAoB,CAC5B,KAAM,GAAU,CACZ,UAAW,4BACX,QAAS,MACT,KAAM,EAAmB,UACzB,YAAa,GAAgB,EAAa,WAE9C,MAAM,EAAS,GAAc,GAAI,IAAa,KAItD,gBAA2B,EAAa,CACpC,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,OAAO,CACZ,UAAW,CACP,OAAQ,GAAM,EAAG,SACjB,QAAS,GAAM,EAAG,YAEvB,CAAC,EAAG,IAAK,IAAK,GAAM,GAAG,EAAG,UAGjC,SAAU,CACN,KAAK,MAAM,UCjBZ,gBAA8B,EAAa,CAC9C,YAAY,EAAO,EAAa,EAAU,KAAM,CAC5C,MAAM,GACN,KAAK,WAAa,KAClB,KAAK,SAAW,EAEhB,KAAK,aAAe,KAGpB,eAAe,SAAE,MAAO,WAAK,eAAL,cAAmB,cAAnB,OAAkC,MAC1D,kBAAkB,OAAE,MAAO,QAAK,eAAL,cAAmB,MAElD,OAAO,EAAG,EAAI,CACV,KAAM,GAAW,CAAC,KAAK,kBAAkB,EAAG,IAC5C,AAAI,KAAK,cACL,EAAS,KAAK,EAAE,OAAO,CAAC,UAAW,2BAA4B,WAEnE,KAAM,GAAK,EAAE,GAAG,KAAK,SAAU,CAAC,UAAW,CACvC,iBAAoB,GACpB,IAAK,EAAG,MACR,OAAQ,EAAG,SACX,WAAY,EAAG,aACf,SAAU,CAAC,KAAK,aAChB,aAAc,GAAM,EAAG,iBACvB,GAMJ,EAAE,cAAc,GAAM,EAAG,eAAgB,CAAC,EAAgB,IAAoB,CAC1E,GAAI,GAAkB,IAAoB,GACtC,EAAG,YAAY,EAAG,cAAc,4BAChC,EAAG,YAAY,EAAG,cAAc,oCACzB,CAAC,GAAkB,CAAC,KAAK,gBAAiB,CACjD,KAAM,GAAS,EAAI,EAAE,CAAC,KAAM,EAAG,gBAAiB,UAAW,0BAA2B,CAAC,GAAmB,EAAI,MACxG,EAAS,EAAI,IAAI,CAAC,UAAW,mCAAmC,EAAG,qBAAsB,EAAG,aAClG,EAAG,aAAa,EAAQ,EAAG,YAC3B,EAAG,aAAa,EAAQ,EAAG,eAKnC,GAAI,GAAgB,KACpB,SAAE,cAAc,GAAM,EAAG,UAAW,GAAa,CAC7C,AAAI,GAAa,KAAK,cAAgB,CAAC,EACnC,GAAgB,GAAI,IAAc,GAClC,KAAK,WAAW,GAChB,EAAG,YAAY,GAAU,KAClB,CAAC,GAAa,GACrB,GAAG,YAAY,EAAc,QAC7B,EAAc,UACd,KAAK,cAAc,GACnB,EAAgB,QAGjB,EAIX,QAAQ,EAAK,CACT,AAAI,EAAI,OAAO,YAAc,2BACzB,KAAK,YAAY,EAAI,QAI7B,YAAY,EAAQ,CAChB,GAAI,KAAK,YAAc,KAAK,WAAW,OACnC,KAAK,WAAW,YACb,CACH,KAAM,GAAU,KAAK,kBAAkB,KAAK,OAC5C,GAAI,CAAC,EAAQ,OACT,OAEJ,KAAK,OAAO,UAAU,IAAI,YAC1B,KAAM,GAAU,IAAM,KAAK,OAAO,UAAU,OAAO,YACnD,KAAK,WAAa,GAAI,IAAM,GAAI,GAAK,GAAU,GAC/C,KAAK,WAAW,oBAAoB,MACpC,KAAK,WAAW,eAAe,EAAQ,IAI/C,kBAAkB,EAAI,CAClB,KAAM,GAAU,GAChB,MAAI,GAAG,UAAY,EAAG,QAAU,YAAc,CAAC,EAAG,WAC9C,GAAQ,KAAK,GAAI,IAAyB,IAC1C,EAAQ,KAAK,EAAK,OAAO,EAAG,YAAa,IAAM,EAAG,gBAEtD,AAAI,EAAG,gBACH,EAAQ,KAAK,EAAK,OAAO,EAAG,aAAc,IAAM,EAAG,iBAC5C,EAAG,WACV,EAAQ,KAAK,EAAK,OAAO,EAAG,aAAc,IAAM,EAAG,UAAU,kBAE1D,EAGX,mBAAoB,GAGxB,QAA+B,CAC3B,YAAY,EAAI,CACZ,KAAK,IAAM,EAEf,MAAM,EAAG,CACL,KAAM,GAAe,CAAC,YAAM,YAAM,YAAM,YAAM,YAAM,eAAM,YAAM,aAAM,IAAI,GAC/D,EAAE,OAAO,CAAC,QAAS,IAAM,KAAK,IAAI,MAAM,IAAS,IAEtD,EAAe,EAAE,OAAO,CAAC,QAAS,IAAM,CAC1C,KAAM,GAAM,OAAO,+BACnB,AAAI,GACA,KAAK,IAAI,MAAM,KAEnB,UACJ,MAAO,GAAE,GAAG,CAAC,UAAW,mBAAoB,CAAC,GAAG,EAAc,KCtH/D,gBAA+B,EAAa,CAC/C,OAAO,EAAG,EAAI,CACV,KAAM,GAAY,GAAkB,GACpC,GAAI,CAAC,EACD,KAAM,IAAI,OAAM,SAAS,EAAG,0BAEhC,KAAM,GAAO,GAAI,GAAU,EAAI,CAAE,MAAO,GAAM,YAAa,KAC3D,MAAO,GAAE,IACL,CAAE,UAAW,oBACb,EAAE,WAAW,CACT,EAAE,EAAE,CAAE,UAAW,OAAQ,KAAM,EAAG,WAAa,eAC/C,EAAE,EAAE,CAAE,UAAW,OAAQ,KAAM,EAAG,mBAAqB,CACnD,GAAmB,EAAI,GAAI,QAC3B,EAAG,cAEP,EAAE,KACF,EAAE,KAAK,OAMhB,gBAAgC,EAAa,CAChD,OAAO,EAAG,CACN,MAAO,GAAE,WAAW,CAAE,UAAW,oBAAsB,CACnD,EAAE,IAAI,CAAE,UAAW,sCAAwC,qCCzBhE,gBAA8B,GAAgB,CACjD,kBAAkB,EAAG,EAAI,CACrB,KAAM,GAAO,EAAE,KAAK,CAAC,UAAW,CAAC,OAAQ,CAAC,EAAG,OAAQ,EAAG,KAAO,IAAM,EAAG,MAClE,EAAY,EAAE,IAAI,CACpB,UAAW,CACP,qBAAwB,GACxB,cAAe,GAAM,EAAG,QAAU,mBAEvC,EAAE,QAAQ,GAAM,EAAG,UAAW,GACzB,KAAK,gBAEE,KAEF,EAAG,SAAW,CAAC,EACb,GAAI,IAEN,EACE,GAAI,IAAiB,GAGrB,OAKT,EAAe,AAAC,GAAY,kBAAS,YAAa,KAAK,cAAgB,EAAQ,YAAc,mBAEnG,SAAE,cAAc,GAAM,EAAG,KAAM,GAAQ,CACnC,KAAO,EAAa,EAAU,YAC1B,EAAU,YAAY,EAAU,WAEpC,SAAW,KAAQ,GAAK,MACpB,EAAU,YAAY,GAAW,IAErC,EAAU,YAAY,KAGnB,GAIf,YAAoB,EAAW,CAC3B,KAAM,GAAQ,EAAU,MAAM,IAAI,GAAQ,EAAI,GAAG,GAAY,KACvD,EAAQ,EAAU,YACxB,MAAI,GACO,EAAI,GAAG,CAAE,SAAS,GAElB,EAAI,GAAG,GAItB,YAAqB,EAAW,CAC5B,KAAM,GAAa,CAAE,IAAK,EAAU,KACpC,MAAI,GAAU,OAAS,GAAW,MAAQ,EAAU,OAChD,EAAU,QAAU,GAAW,OAAS,EAAU,QAClD,EAAU,KAAO,GAAW,IAAM,EAAU,KAC5C,EAAU,OAAS,GAAW,MAAQ,EAAU,OAC7C,EAAI,IAAI,GAGnB,YAAoB,EAAU,CAI1B,KAAM,GAAU,2BAA2B,EAAS,oBAC9C,EAAS,EAAI,IAAI,CAAC,MAAO,GAAU,GAAK,EAAS,iBACjD,EAAW,GAAY,EAAS,UACtC,SAAS,QAAQ,GACV,EAAI,EAAE,CAAC,MAAO,OAAQ,KAAM,EAAS,KAAM,IAAK,WAAY,OAAQ,UAAW,GAG1F,YAAqB,EAAW,CAC5B,KAAM,GAAW,GACjB,GAAI,EAAU,KAAM,CAChB,KAAM,GAAU,EAAU,KACrB,IAAI,GAAQ,EAAI,GAAG,GAAY,KACpC,EAAS,KAAK,EAAI,MAAM,EAAI,GAAG,KAEnC,KAAM,GAAO,GACb,SAAW,KAAO,GAAU,KAAM,CAC9B,KAAM,GAAO,EAAI,IAAI,GAAQ,EAAI,GAAG,GAAY,KAChD,EAAK,KAAK,EAAI,GAAG,IAErB,SAAS,KAAK,EAAI,MAAM,IACjB,EAAI,MAAM,GAMrB,KAAM,IAAiB,CACnB,OAAQ,GAAe,EAAI,IAAM,KAAK,IAAI,EAAE,EAAY,QAAQ,GAAY,EAAY,UACxF,UAAW,GAAa,EAAI,IAAI,EAAI,KAAK,GAAK,EAAU,QACxD,MAAO,GAAc,GAAY,GACjC,KAAM,GAAY,EAAI,KAAK,GAAK,EAAS,OACzC,KAAM,GAAY,GAAK,EAAS,MAChC,KAAM,GAAY,EAAI,EAAE,CAAC,KAAM,EAAS,IAAK,UAAW,OAAQ,OAAQ,SAAU,IAAK,YAAc,GAAY,EAAS,UAC1H,KAAM,GACN,OAAQ,GAAc,EAAI,EAAW,QAAQ,GAAY,EAAW,WACpE,KAAM,IAAM,EAAI,KAChB,KAAM,GACN,MAAO,GACP,QAAS,IAAM,EAAI,MAGvB,YAAoB,EAAM,CACtB,KAAM,GAAI,GAAe,EAAK,MAC9B,MAAK,GAGE,EAAE,GAFE,GAAK,sBAAsB,EAAK,SAK/C,YAAqB,EAAO,CACxB,MAAO,OAAM,KAAK,EAAO,ICpHtB,gBAA4B,GAAgB,CAC/C,kBAAkB,EAAG,EAAI,CAErB,GAAI,GAAc,gBADU,EAAG,OAAS,EAAG,MAAS,QAEpD,AAAI,EAAG,SAAS,QAQZ,GAAc,WAAW,EAAG,YAEhC,KAAM,GAAW,CACb,EAAE,IAAI,CAAC,UAAW,SAAU,MAAO,IACnC,KAAK,YAAY,EAAG,GACpB,EAAE,KAAK,EAAG,KAAO,IAAM,EAAG,OAE9B,GAAI,EAAG,UAAW,CACd,KAAM,GAAa,EAAE,IAAI,CACrB,UAAW,CACP,WAAY,GACZ,OAAQ,GAAM,CAAC,EAAG,aAEvB,GAAM,EAAG,YACN,EAAW,EAAE,SAAS,CACxB,IAAK,EACL,IAAK,IACL,MAAO,GAAM,EAAG,iBAChB,UAAW,CAAC,OAAQ,GAAM,CAAC,EAAG,eAElC,EAAS,KAAK,EAAY,GAE9B,MAAO,GAAE,IAAI,CAAC,UAAW,wBAAyB,CAC9C,EAAE,IAAI,CAAC,UAAW,QAAS,MAAO,cAAc,EAAG,WAAY,GAC/D,EAAE,GAAG,GAAM,EAAG,MAAO,GAAK,EAAE,EAAE,CAAC,UAAW,SAAU,EAAG,WCpC5D,gBAAwB,GAAc,CACzC,YAAY,EAAG,EAAI,CACf,KAAM,GAAM,EAAE,IAAI,CACd,IAAK,GAAM,EAAG,aACd,IAAK,GAAM,EAAG,MACd,MAAO,GAAM,EAAG,MAChB,MAAO,cAAc,EAAG,wBAAwB,EAAG,cAEvD,MAAO,GAAG,UAAY,EAAM,EAAE,EAAE,CAAC,KAAM,EAAG,aAAc,ICVzD,YAA2B,EAAS,EAAc,CACrD,MAAO,IAAI,SAAQ,CAAC,EAAS,IAAW,CACpC,GAAI,GACJ,KAAM,GAAc,GAAO,CACvB,IACA,EAAO,EAAI,OAAO,QAEhB,EAAgB,IAAM,CACxB,IACA,KAEJ,EAAS,IAAM,CACX,EAAQ,oBAAoB,EAAc,GAC1C,EAAQ,oBAAoB,QAAS,IAEzC,EAAQ,iBAAiB,EAAc,GACvC,EAAQ,iBAAiB,QAAS,KCbnC,gBAAwB,GAAc,CACzC,YAAY,EAAG,CACX,KAAM,GAAQ,EAAE,MAAM,CAGlB,IAAK,GAAM,EAAG,UAAY,QAAQ,EAAG,YACrC,MAAO,GAAM,EAAG,MAChB,SAAU,GACV,QAAS,OACT,OAAQ,GAAM,EAAG,aACjB,OAAQ,KAAK,QAAQ,KAAK,MAC1B,MAAO,GAAM,cAAc,EAAG,wBAAwB,EAAG,YAAY,EAAG,UAAY,cAAe,OAGvG,SAAM,iBAAiB,QAAS,KAAK,SAAS,KAAK,OAE5C,OAGL,SAAQ,EAAK,CACf,KAAM,GAAK,KAAK,MAEhB,GAAI,CAAC,EAAG,SACJ,GAAI,CACA,KAAM,GAAQ,EAAI,OAElB,KAAM,GAAG,YAGT,KAAM,GAAc,GAAkB,EAAO,cAE7C,EAAM,OACN,KAAM,GACN,EAAM,YACR,GAIV,SAAS,EAAK,CACV,KAAM,GAAK,KAAK,MACV,EAAQ,EAAI,OACZ,EAAM,EAAM,MAClB,GAAI,YAAe,QAAO,YAAc,EAAI,OAAS,EACjD,GAAI,CAAC,EAAM,IAAI,WAAW,SACtB,EAAG,aAAa,GAAI,OAAM,gDAAgD,EAAG,kBAG7E,YAGJ,GAAG,aAAa,ICnDrB,gBAAuB,GAAgB,CAC1C,kBAAkB,EAAG,EAAI,CACrB,KAAM,GAAW,GACjB,MAAI,GAAG,UACH,EAAS,KAAK,GAAM,EAAG,OAEvB,EAAS,KACL,EAAE,OAAO,CAAC,UAAW,OAAQ,QAAS,IAAM,EAAG,YAAa,GAAM,EAAG,OACrE,EAAE,KAAK,EAAG,KAAO,IAAM,EAAG,OAG3B,EAAE,EAAE,CAAC,UAAW,sCAAuC,ICX/D,gBAA2B,GAAgB,CAC9C,kBAAkB,EAAG,EAAI,CACrB,MAAO,GAAE,EAAE,CAAC,UAAW,sCAAuC,CAC1D,EAAE,KAAK,EAAG,OACV,EAAE,EAAE,CAAC,UAAW,wBAAyB,KAAM,EAAG,SAAU,OAAQ,SAAU,IAAK,YAAa,EAAG,oBACnG,EAAE,KAAK,EAAG,KAAO,IAAM,EAAG,SCL/B,gBAAoC,GAAgB,CACvD,kBAAkB,EAAG,EAAI,CACrB,MAAO,GAAE,EAAE,CAAC,UAAW,sCAAuC,EAAG,QCFlE,gBAA+B,EAAa,CAC/C,OAAO,EAAG,CACN,MAAO,GAAE,GAAG,CAAC,UAAW,oBAAqB,EAAE,IAAI,GAAM,EAAG,eAIhE,SAAU,GCLP,gBAA2B,GAAgB,CAC9C,kBAAkB,EAAG,CACjB,MAAO,GAAE,EAAE,CAAC,UAAW,sCAAuC,GAAM,EAAG,aAG3E,kBAAkB,EAAI,CAClB,KAAM,GAAU,MAAM,kBAAkB,GACxC,MAAI,GAAG,aACH,EAAQ,KAAK,EAAK,OAAO,EAAG,aAAc,IAAM,EAAG,0BAEhD,GCVR,gBAAsB,EAAa,CACtC,OAAO,EAAG,CACN,KAAM,GAAY,CACd,QAAS,GACT,UAAW,GAAM,EAAG,UACpB,QAAS,GAAM,EAAG,SAEtB,MAAO,GAAE,GAAG,CAAC,aAAY,CACrB,GAAQ,GACR,EAAE,IAAI,GAAM,EAAG,UAAY,EAAG,8BAAgC,EAAG,oBACjE,EAAE,GAAG,GAAM,EAAG,MAAO,GAAK,EAAE,OAAO,GAAM,EAAG,UAKpD,SAAU,eCFoB,EAAoD,QAC1E,EAAM,WACL,YACM,QACN,qBACM,QACN,cACA,uBACM,QACN,cACM,QACN,cACM,QACN,aACM,QACN,iBACM,QACN,2BACM,QACN,iBACM,KClBnB,YAAgB,EAA2B,OAChC,GAAK,UAAY,EAAK,aAGjC,YAAqC,EAAoB,EAAa,EAAsB,EAAM,SAAS,OAAS,EAAY,QACnH,GAAI,EAAY,GAAK,EAAG,OAEzB,AADS,EAAM,SAAS,GACnB,UAAY,QACV,SAIR,mBAGuB,EAAgC,CAA3D,aAjDP,yCAoDqC,qBACA,GAIjC,OAAO,EAA+B,EAAuB,uBAEnC,IAAM,MAEnB,+BAEJ,UAAY,GAAI,IAAc,EAAG,MAAO,IAAM,KAAK,8BAClD,GAAO,EAAE,IAAI,CAAC,UAAW,YAAa,CACxC,EAAE,IAAI,CACF,UAAW,0CACX,SAAU,IAAM,KAAK,YACtB,EAAE,KAAK,KAAK,YACf,EAAE,OAAO,CACL,UAAW,CACP,kBAAqB,GACrB,OAAQ,GAAM,CAAC,EAAG,cAEtB,MAAO,YACP,QAAS,IAAM,KAAK,qBAIxB,OAAO,iBAAmB,kBACrB,eAAiB,GAAI,gBAAe,IAAM,MACtC,+BAEJ,eAAe,QAAQ,IAGzB,KAGC,aAA0B,OAC1B,MAAK,OAAwB,qBAG7B,YAAyB,OAC1B,MAAK,UAAW,OAGnB,UAAW,MACT,CAAC,cAAc,UAChB,cAAgB,KACV,UAAY,EAAW,aAG/B,SAAU,OACP,UACF,KAAK,sBACA,eAAe,UAAU,KAAK,aAC9B,eAAiB,QAItB,uBAAwB,MACtB,CAAC,aAAY,aAAa,KAE1B,EAAqB,EAAW,aAAe,EAAU,gBAC3D,EAAqB,EAAG,GACd,MAAM,YAAY,aAAc,GAAG,YAEvC,GAAM,KAAK,MAAM,MAAM,YACxB,mBAAmB,EAAG,EAAM,aAEvB,MAAM,eAAe,cAC3B,KAAK,gBACM,UAAY,EAAW,qBAC3B,KAAK,aAAc,MACpB,GAAoB,GAAO,KAAK,iBAClC,IAAsB,KAAK,eAAgB,MACrC,GAAa,EAAoB,KAAK,eAIxC,MAAO,GAAW,UAAa,aACpB,SAAS,EAAG,KAEZ,UAAY,EAAW,UAAY,OAE7C,eAAiB,IAQ9B,UAAiB,MACf,CAAC,aAAY,aAAa,KAC1B,CAAC,eAAc,YAAW,gBAAgB,KAE5C,WACC,cAAgB,KAAK,IAAI,KAA4B,IAAiB,EACvE,KAAK,gBAEa,AADN,KAAK,MAAM,MAAM,OACL,MACrB,MACG,GAAiB,EAAY,EAC7B,EAAoB,GAA4B,EAAW,QAC5D,aAAe,EAAU,WAAW,QACpC,eAAiB,GAAO,KAAK,gBAChB,KAElB,GAAe,GAA4B,EAAW,EAAW,QAChE,mBAAmB,EAAc,GAGlC,mBAAmB,EAAoB,EAAkB,MAEvD,GAAoB,KAAK,UAAW,wBAAwB,GAC5D,EAAmB,KAAK,UAAW,wBAAwB,QAC5D,MAAM,oBAAoB,iBAAmB,MAAO,iBAAkB,QAInF,gBAA4B,GAA+B,CAIvD,YAAY,EAAmC,EAAuB,MAC5D,GAAU,CACZ,KAAM,EACN,YAAa,CAAC,EAAU,IAAQ,EAAS,QAAQ,UAE/C,EAAS,GAAS,MACd,GAAO,GAAkB,MAC3B,QACO,IAAI,GAAK,UAGnB,UAAY,EAGrB,SAAU,OACA,eACD,YAGT,SAAS,EAAe,EAAmB,EAAY,IAC/C,IAAU,QAAS,MACb,GAAgB,GAAkB,GAClC,EAAQ,KAAK,wBAAwB,MACvC,CAAC,GAAiB,cAAmB,IAAgB,OAI/C,aAAa,EAAO,iBAI5B,SAAS,EAAO,EAAO,QACxB,YAGT,MAAM,EAAa,EAAmB,OAC5B,MAAM,EAAK,QACZ,YAGT,SAAS,EAAa,EAAmB,OAC/B,SAAS,EAAK,QACf,YAGT,OAAO,EAAiB,EAAe,EAAmB,OAChD,OAAO,EAAS,EAAO,QACxB,aC5MN,gBAAkC,EAAa,CAClD,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,IAAI,CAAC,UAAW,uBAAwB,CAC7C,GAAQ,GACR,EAAE,IAAI,EAAG,YAAc,EAAG,kCAAoC,EAAG,4BCFtE,gBAA8B,EAAa,CAC9C,YAAY,EAAW,CACnB,MAAM,GACN,KAAK,OAAS,KACd,KAAK,iBAAmB,KACxB,KAAK,YAAc,KACnB,KAAK,iBAAmB,OAG5B,OAAO,EAAG,EAAI,CACV,KAAK,OAAS,EAAE,SAAS,CACrB,UAAW,GAAK,KAAK,WAAW,GAChC,QAAS,IAAM,CACX,EAAG,SAAS,KAAK,OAAO,OACxB,AAAI,KAAK,OAAO,MACZ,KAAK,gBAEL,KAAK,gBAGb,YAAa,GAAM,EAAG,YAAc,kCAA+B,uBACnE,KAAM,MAEV,KAAK,YAAc,IAAM,KAAK,OAAO,QACrC,KAAK,MAAM,GAAG,QAAS,KAAK,aAC5B,KAAM,GAAe,EAAE,IAAI,GAAM,EAAG,eAAgB,CAAC,EAAK,IAAM,CAC5D,KAAM,GAAO,GAAO,GAAkB,GACtC,MAAK,GACE,EAAE,IAAI,CACL,UAAW,gCACZ,CACC,EAAE,KAAK,CAAE,UAAW,YAAc,YAClC,EAAE,OAAO,CACL,UAAW,SACX,QAAS,IAAM,KAAK,oBACrB,SACP,EAAE,KAAK,GAAI,GAAK,EAAK,CAAE,YAAa,IAAS,UAT7B,OAYlB,EAAQ,EAAE,IAAI,CAAC,UAAW,yBAA0B,CACtD,KAAK,OACL,EAAE,OAAO,CACL,UAAW,WACX,MAAO,EAAG,sBACV,QAAS,GAAO,KAAK,sBAAsB,IAC5C,EAAG,iBACN,EAAE,OAAO,CACL,UAAW,OACX,MAAO,EAAG,WACV,QAAS,IAAM,KAAK,YACrB,EAAG,cAEV,MAAO,GAAE,IAAI,CAAE,UAAW,CACtB,gBAAiB,GACjB,wBAAyB,GAAM,EAAG,UACjC,CAAC,EAAc,IAGxB,SAAU,CACN,AAAI,KAAK,aACL,KAAK,MAAM,IAAI,QAAS,KAAK,aAEjC,MAAM,UAGV,kBAAmB,CACf,KAAK,MAAM,uBAGT,WAAW,CACb,KAAK,OAAO,QAKZ,KAAM,CAAC,SAAS,KAAK,OACf,EAAe,IAAM,CACvB,KAAK,OAAO,MAAQ,EACpB,KAAK,iBAET,KAAK,OAAO,MAAQ,GACpB,KAAK,eACL,GAAI,CACA,AAAK,KAAM,MAAK,MAAM,YAAY,IAC9B,UAEC,EAAP,CACE,IACA,QAAQ,MAAM,IAItB,WAAW,EAAO,CACd,AAAI,EAAM,MAAQ,SAAW,CAAC,EAAM,UAEhC,GAAM,iBACN,KAAK,YAIb,sBAAsB,EAAK,CACvB,GAAI,KAAK,kBAAoB,KAAK,iBAAiB,OAC/C,KAAK,iBAAiB,YACnB,CACH,KAAM,GAAK,KAAK,MAChB,KAAK,iBAAmB,GAAI,IAAM,GAAI,GAAK,CACvC,EAAK,OAAO,EAAG,iBAAkB,IAAM,EAAG,aAAa,QAAQ,SAC/D,EAAK,OAAO,EAAG,mBAAoB,IAAM,EAAG,eAAe,QAAQ,WACnE,EAAK,OAAO,EAAG,gBAAiB,IAAM,EAAG,YAAY,QAAQ,WAEjE,KAAK,iBAAiB,oBAAoB,MAC1C,KAAK,iBAAiB,eAAe,EAAI,OAAQ,KAIzD,eAAgB,CACZ,AAAI,KAAK,kBAGT,MAAK,iBAAmB,OAAO,sBAAsB,IAAM,CACvD,KAAM,GAAe,KAAK,OAAO,aACjC,KAAK,OAAO,MAAM,OAAS,GAAG,MAC9B,KAAK,iBAAmB,UAIhC,cAAe,CACX,KAAK,OAAO,MAAM,eAAe,WClIlC,gBAA+B,EAAa,CAC/C,OAAO,EAAG,CACN,MAAO,GAAE,IAAI,CAAC,UAAW,oBAAqB,EAAE,GAAG,GAAM,EAAG,eCM7D,gBAAuB,EAAa,CACvC,YAAY,EAAS,CACjB,MAAM,GACN,KAAK,cAAgB,KAGzB,OAAO,EAAG,EAAI,CACV,GAAI,GACJ,MAAI,GAAG,kBAAkB,OAAS,WAC9B,EAAa,GAAI,IAAgB,EAAG,mBAC7B,EAAG,kBAAkB,OAAS,YACrC,GAAa,GAAI,IAAiB,EAAG,oBAElC,EAAE,KAAK,CAAC,UAAW,mBAAoB,CAC1C,EAAE,IAAI,CAAC,UAAW,4BAA6B,CAC3C,EAAE,EAAE,CAAC,UAAW,8BAA+B,KAAM,EAAG,SAAU,MAAO,EAAG,mBAC5E,EAAE,KAAK,GAAI,IAAW,EAAI,KAC1B,EAAE,IAAI,CAAC,UAAW,oBAAqB,CACnC,EAAE,GAAG,GAAM,EAAG,QAElB,EAAE,OAAO,CACL,UAAW,8BACX,aAAa,EAAG,mBAChB,QAAS,GAAO,KAAK,mBAAmB,OAGhD,EAAE,IAAI,CAAC,UAAW,iBAAkB,CAChC,EAAE,IAAI,CAAC,UAAW,kBAAmB,GAAM,EAAG,OAC9C,EAAE,QAAQ,GAAM,EAAG,kBAAmB,GAC3B,EACH,GAAI,IAAa,GACjB,GAAI,IAAoB,IAEhC,EAAE,KAAK,OAKnB,mBAAmB,EAAK,CACpB,GAAI,KAAK,eAAiB,KAAK,cAAc,OACzC,KAAK,cAAc,YAChB,CACH,KAAM,GAAK,KAAK,MACV,EAAU,GAWhB,GAVA,EAAQ,KAAK,EAAK,OAAO,EAAG,mBAAoB,IAAM,EAAG,qBACrD,EAAG,UACH,EAAQ,KAAK,EAAK,OAAO,EAAG,iBAAkB,IAAM,KAAK,uBAAuB,kBAEhF,EAAG,WACH,EAAQ,KAAK,EAAK,OAAO,EAAG,kBAAmB,IAAM,EAAG,cAAc,kBAEtE,EAAG,WACH,EAAQ,KAAK,EAAK,OAAO,EAAG,kBAAmB,IAAM,EAAG,eAExD,CAAC,EAAQ,OACT,OAEJ,KAAK,cAAgB,GAAI,IAAM,GAAI,GAAK,IACxC,KAAK,cAAc,oBAAoB,MACvC,KAAK,cAAc,eAAe,EAAI,OAAQ,KAItD,qBAAsB,CAClB,AAAI,QAAQ,KAAK,MAAM,uCAAuC,KAAK,MAAM,WACrE,KAAK,MAAM,aCzEhB,gBAA8B,EAAa,CAC9C,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,KAAK,CAAC,UAAW,0BAA2B,EAAE,IAAI,CACvD,EAAE,GAAG,CACD,EAAG,gCAAgC,EAAG,iBACtC,EAAE,KACF,EAAG,yBAEP,EAAE,OAAO,CACL,UAAW,wBACX,QAAS,IAAM,EAAG,OAClB,SAAU,GAAM,EAAG,MACpB,EAAG,iBACN,EAAE,GAAG,GAAM,EAAG,MAAO,GAAK,EAAE,EAAE,CAAC,UAAW,SAAU,EAAG,YCZ5D,QAAiB,CACpB,YAAY,EAAO,EAAS,OAAW,CACnC,AAAI,MAAO,IAAU,YAAc,CAAC,GAChC,GAAS,EACT,EAAQ,MAEZ,KAAK,MAAQ,EAAS,EAAO,EAAK,GAAS,KAAK,OAAO,EAAK,GAGhE,OAAQ,CACJ,MAAO,MAAK,MAGhB,MAAO,CACH,MAAO,MAAK,MAGhB,SAAU,EACV,QAAS,GClBN,gBAA0B,GAAW,CACxC,YAAY,EAAQ,UAAW,CAC3B,MAAM,EAAO,CAAC,EAAG,IACN,EAAE,IAAI,CAAE,UAAW,eAAiB,CAAC,GAAQ,GAAI,MCD7D,gBAAmC,EAAa,CACnD,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,KAAK,CAAC,UAAW,mBAAoB,CAC1C,EAAE,IAAI,CAAC,UAAW,4BAA6B,CAC3C,EAAE,EAAE,CAAC,UAAW,8BAA+B,KAAM,EAAG,SAAU,MAAO,EAAG,mBAC5E,EAAE,KAAK,GAAI,IAAW,EAAI,KAC1B,EAAE,IAAI,CAAC,UAAW,oBAAqB,CACnC,EAAE,GAAG,GAAM,EAAG,UAGtB,EAAE,IAAI,CAAC,UAAW,iBAAkB,CAChC,EAAE,QAAQ,GAAM,EAAG,MAAO,GAClB,EACO,GAAI,IAAU,GAEd,GAAI,IAAY,EAAG,kCAQlD,gBAAwB,EAAa,CACjC,OAAO,EAAE,EAAI,CACT,MAAO,GAAE,IAAI,CAAC,UAAW,0CAA2C,CAChE,EAAE,GAAG,EAAG,wDACR,EAAE,IAAI,CAAC,UAAW,6BAA8B,EAAG,OACnD,EAAE,IAAI,CAAC,UAAW,cACd,EAAE,OAAO,CACL,UAAW,oCACX,QAAS,IAAM,EAAG,UACnB,EAAG,kBCjCf,gBAAyB,EAAa,CACzC,OAAO,EAAG,EAAI,OACV,GAAI,GAAc,GAClB,AAAI,EAAG,iBACH,EAAY,KAAK,GAAmB,EAAI,IAAK,wBAEjD,GAAI,GACJ,MAAI,GAAG,gBACH,EAAe,CAAC,EAAE,OAAO,EAAG,MAAO,KAAK,KAAG,UAAH,cAAY,+BACjD,AAAI,EAAG,QACV,EAAe,CAAC,GAAmB,EAAG,QAAS,IAAK,EAAE,OAAO,EAAG,QAAQ,MAAO,KAAK,EAAG,QAAQ,oBAE/F,EAAe,4BAEnB,EAAY,KAAK,EAAE,EAAE,CAAC,UAAW,sBAAuB,IACnD,EAAG,iBACJ,EAAY,KAAK,EAAE,IAAI,CAAC,UAAW,0BAA2B,CAC1D,GAAmB,EAAI,GAAI,yBAC3B,EAAE,GAAG,EAAG,MACR,EAAE,EAAE,CAAC,UAAW,8BAA+B,EAAG,oBAInD,EAAE,KAAK,CAAC,UAAW,qBAAsB,CAC5C,EAAE,IAAI,CAAC,UAAW,4BAA6B,CAC3C,EAAE,EAAE,CAAC,UAAW,8BAA+B,KAAM,EAAG,SAAU,MAAO,EAAG,qBAC5E,GAAmB,EAAI,IACvB,EAAE,IAAI,CAAC,UAAW,oBAAqB,CACnC,EAAE,GAAG,GAAM,EAAG,UAGtB,EAAE,GAAG,GAAM,EAAG,MAAO,GAAK,EAAE,IAAI,CAAC,UAAW,kBAAmB,GAAM,EAAG,QACxE,EAAE,IAAI,CAAC,UAAW,mBAAoB,CAClC,EAAE,IAAI,CAAC,UAAW,qBAAsB,CACpC,GAAG,EACH,EAAE,IAAI,CAAC,UAAW,wBACd,EAAE,OAAO,CACL,UAAW,wBACX,SAAU,GAAM,EAAG,KACnB,QAAS,IAAM,EAAG,UACnB,EAAG,eAEV,EAAE,IAAI,CAAC,UAAW,wBACd,EAAE,OAAO,CACL,UAAW,oCACX,SAAU,GAAM,EAAG,KACnB,QAAS,IAAM,EAAG,UACnB,EAAG,sBChDvB,gBAA2B,EAAa,CAC3C,OAAO,EAAG,EAAI,CACV,KAAM,GAAQ,EAAE,EAAE,CAAC,KAAM,EAAG,SAAU,MAAO,EAAG,YAAa,UAAW,UAClE,EAAQ,EAAE,IAAI,CAChB,KAAM,MACN,aAAc,GAAM,EAAG,KACvB,MAAO,GAAM,EAAG,KAChB,UAAW,CACP,QAAS,GACT,OAAQ,GAAM,CAAC,EAAG,UAEtB,MAAO,GAAM,0BAA0B,EAAG,0BAA0B,EAAG,6BAA6B,EAAG,mBAErG,EAAU,EAAE,IAAI,CAClB,UAAW,CACP,QAAS,GACT,OAAQ,GAAM,CAAC,CAAC,EAAG,WAExB,CACC,GAAQ,GACR,EAAE,IAAI,EAAG,wBAEP,EAAU,EAAE,IAAI,CAClB,UAAW,WACZ,CAAC,EAAE,OAAO,GAAM,EAAG,MAAO,EAAE,KAAM,eAAgB,EAAE,OAAO,GAAM,EAAG,QAAS,GAAM,OAAO,EAAG,WAAW,EAAG,UACxG,EAAS,EAAE,IAAI,CACjB,KAAM,SACN,UAAW,WACX,QAAS,GAAO,KAAK,aAAa,GAClC,UAAW,GAAO,KAAK,cAAc,IACtC,CAAC,EAAO,EAAS,EAAS,IAC7B,UAAU,EAAG,GACN,EAGX,aAAa,EAAK,CACd,AAAI,EAAI,SAAW,KAAK,QACpB,KAAK,MAAM,QAInB,cAAc,EAAK,CACf,AAAI,GAAI,MAAQ,UAAY,EAAI,MAAQ,QACpC,KAAK,MAAM,SAKvB,YAAmB,EAAG,EAAS,CAC3B,KAAM,GAAW,GAAW,GACtB,EAAQ,EAAS,GACjB,EAAO,EAAS,EAAS,OAAS,GAExC,EAAE,iBAAiB,EAAS,UAAW,GAAO,CAC1C,AAAI,EAAI,MAAQ,OACZ,CAAI,EAAI,SACA,SAAS,gBAAkB,GAC3B,GAAK,QACL,EAAI,kBAGJ,SAAS,gBAAkB,GAC3B,GAAM,QACN,EAAI,oBAIjB,IACH,QAAQ,UAAU,KAAK,IAAM,CACzB,EAAM,UAId,YAAoB,EAAS,CACzB,MAAO,GAAQ,iBAAiB,4CC1E7B,gBAAgC,EAAa,CAChD,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,IAAI,CAAC,UAAW,CACrB,kBAAqB,GACrB,OAAU,GAAM,CAAC,EAAG,UACpB,CACA,GAAQ,EAAG,CAAC,OAAQ,GAAM,CAAC,EAAG,YAC9B,EAAE,EAAE,GAAM,EAAG,aACb,EAAE,GAAG,GAAM,EAAG,kBAAmB,GAAK,EAAE,OAAO,CAAC,UAAW,OAAQ,QAAS,IAAM,EAAG,cAAe,cACpG,EAAE,GAAG,GAAM,EAAG,qBAAsB,GAAK,EAAE,EAAE,CAAC,KAAM,EAAG,mBAAoB,mBAC3E,EAAE,GAAG,GAAM,EAAG,WAAY,GAAK,EAAE,IAAI,CAAC,UAAW,OAAQ,EAAE,OAAO,CAAC,UAAW,UAAW,QAAS,IAAM,EAAG,iBCPhH,gBAA2B,EAAa,CAC3C,OAAO,EAAG,EAAI,CACV,KAAM,GAAW,GACjB,OAAS,GAAI,EAAG,EAAK,EAAG,OAAS,EAAG,MAAQ,GAAG,EAC3C,EAAS,KAAK,EAAE,IAAI,CAChB,QAAS,IAAM,EAAG,UAAU,GAC5B,UAAW,IAAM,EAAG,UAAU,GAC9B,UAAW,CACP,UAAa,IACZ,OAAO,KAAM,GACd,QAAW,GAAM,EAAG,aAAe,IAExC,EAAE,QAAQ,GAAM,EAAG,gBAAgB,GAAI,GAClC,EACI,EAAO,OAAS,mBACT,GAAI,IAAqB,GACzB,EAAO,OAAS,SAChB,GAAI,IAAW,GAEf,GAAI,IAAS,GAGjB,GAAI,IAAW,GAAK,EAAE,IAAI,CAAC,UAAW,oBAAqB,CAC9D,EAAE,GAAG,CAAC,UAAW,WAAY,EAAG,iCAChC,EAAE,GAAG,CAAC,UAAW,aAAc,EAAG,uCAKlD,SAAS,KAAK,EAAE,IAAI,CAAC,UAAW,GAAM,kBAAkB,EAAG,gBACpD,EAAE,IAAI,CAAC,UAAW,iCAAkC,IClC5D,gBAAoC,EAAa,CACpD,OAAO,EAAG,CACN,MAAO,GAAE,IAAI,CACT,EAAE,IAAI,GAAM,EAAG,OAAQ,CAAC,EAAQ,EAAG,IAAO,CACtC,OAAQ,OACC,UAAW,MAAO,IAAc,EAAG,OACnC,sBAAuB,MAAO,IAA0B,EAAG,OAC3D,WAAY,MAAO,IAAoB,EAAG,OAC1C,cAAe,MAAO,IAAuB,EAAG,OAChD,UAAW,MAAO,GAAE,EAAE,EAAG,gCAGtC,EAAE,IAAI,GAAM,EAAG,kBAAmB,CAAC,EAAQ,EAAG,IAAO,CACjD,OAAQ,OACC,UAAW,CACZ,KAAM,GAAW,EAAE,SAAS,CACxB,IAAK,EACL,IAAK,IACL,MAAO,GAAM,EAAG,mBAEpB,MAAO,GAAE,IAAI,CAAC,sBAAuB,EAAU,IAAK,GAAM,EAAG,4BAE5D,UAAW,CACZ,GAAI,GAEJ,MADc,GAAG,YAEb,EAAQ,2CAA2C,EAAG,cAEtD,EAAQ,qBAEL,EAAE,EAAE,EAAO,IAAK,EAAE,OAAO,CAAC,QAAS,IAAM,EAAG,eAAgB,mBAElE,OACD,MAAO,GAAE,EAAE,mCAEX,MAAO,YAO/B,YAAuB,EAAG,EAAI,CAC1B,KAAM,GAAQ,CACV,EAAE,EAAE,CAAC,EAAG,mDAAmD,EAAG,kBAAmB,EAAE,OAAO,CAAC,QAAS,IAAM,EAAG,WAAY,EAAG,kBAEhI,MAAI,GAAG,oBACH,EAAM,KAAK,EAAE,EAAE,EAAG,iDAAiD,EAAG,8FAEnE,EAAE,IAAI,GAGjB,YAAmC,EAAG,EAAI,CACtC,KAAM,GAAQ,CACV,EAAE,EAAE,CAAC,EAAG,0HAA2H,EAAE,OAAO,CAAC,QAAS,IAAM,EAAG,WAAY,EAAG,kBAElL,MAAO,GAAE,IAAI,GAGjB,YAA6B,EAAG,EAAI,CAChC,KAAM,GAAqB,EAAE,OAAO,CAAC,UAAW,OAAQ,QAAS,IAAM,EAAG,mBAAoB,EAAG,6BACjG,MAAO,GAAE,IAAI,CACT,EAAE,EAAE,EAAG,uDAAuD,EAAG,wOACjE,GAAY,GACZ,GAAqB,EAAG,EAAI,EAAG,mBAAoB,CAAC,EAAK,IAA0B,EAAG,iBAAiB,EAAK,IAC5G,EAAE,EAAE,CAAC,EAAG,8BAA+B,EAAoB,EAAG,4BAItE,YAAgC,EAAG,EAAI,CACnC,KAAM,GAAkB,EAAE,OAAO,CAAC,UAAW,OAAQ,QAAS,IAAM,EAAG,gBAAiB,EAAG,6BAC3F,MAAO,GAAE,IAAI,CACT,EAAE,EAAE,EAAG,0DAA0D,EAAG,2SACpE,GAAY,GACZ,GAAqB,EAAG,EAAI,EAAG,sBAAuB,CAAC,EAAQ,IAA0B,EAAG,oBAAoB,EAAQ,IACxH,EAAE,EAAE,CAAC,EAAG,oBAAqB,EAAiB,EAAG,YAIzD,YAA8B,EAAG,EAAI,EAAO,EAAU,CAClD,GAAI,GACJ,KAAM,GAAe,IAAM,EAAS,EAAM,MAAO,kBAAuB,UAAW,IAC7E,EAAQ,EAAE,MAAM,CAAC,KAAM,WAAY,SAAU,GAAM,EAAG,OAAQ,YAAa,IAC3E,EAAW,CACb,EAAE,EAAE,CACA,EACA,EAAE,OAAO,CAAC,SAAU,GAAM,EAAG,OAAQ,QAAS,GAAe,EAAG,kBAGxE,GAAI,EAAG,2BAA4B,CAC/B,EAAwB,EAAE,MAAM,CAAC,KAAM,WAAY,GAAG,6BACtD,KAAM,GAAW,EAAE,EAAE,CAAC,KAAM,6FAA8F,OAAQ,SAAU,IAAK,YAAa,aAC9J,EAAS,KAAK,EAAE,EAAE,CACd,EACA,EAAE,MAAM,CAAC,IAAK,EAAsB,IAAK,CAAC,EAAG,kCAAmC,EAAU,SAGlG,MAAO,GAAE,IAAI,CAAC,UAAW,OAAQ,CAC7B,EAAE,IAAI,CAAC,UAAW,SAAU,GAC5B,EAAE,IAAI,CAAC,UAAW,WAAY,KAItC,YAAqB,EAAG,CACpB,MAAO,GAAE,GAAG,GAAM,EAAG,MAAO,CAAC,EAAG,IACrB,EAAE,IAAI,CACT,EAAE,EAAE,CAAC,UAAW,SAAU,GAAM,EAAG,oCAAoC,EAAG,UAC1E,EAAE,EAAE,EAAG,gIC1GZ,gBAA2B,EAAa,CAC3C,OAAO,EAAG,EAAI,CACV,GAAI,GAAU,EAAG,QACjB,AAAI,EAAG,kBACH,GAAU,EAAE,KAAK,CACb,EAAG,QACH,EAAE,OAAO,CAAC,QAAS,IAAM,EAAG,kBAAmB,EAAG,4BAI1D,KAAM,GAAM,CAAC,EAAG,EAAO,EAAS,EAAa,KAClC,EAAE,IAAI,CAAC,UAAW,OAAO,KAAe,CAC3C,EAAE,IAAI,CAAC,UAAW,SAAU,GAC5B,EAAE,IAAI,CAAC,UAAW,WAAY,KAIhC,EAAe,GAErB,SAAa,KACT,EAAE,GAAG,WACL,EAAI,EAAG,EAAG,cAAe,EAAG,QAC5B,EAAI,EAAG,EAAG,iBAAkB,EAAG,SAAU,QACzC,EAAI,EAAG,EAAG,kBAAmB,EAAG,eAAgB,QAChD,EAAI,EAAG,GAAI,EAAE,OAAO,CAChB,QAAS,IAAM,EAAG,SAClB,SAAU,GAAM,EAAG,cACpB,EAAG,iBAEV,EAAa,KACT,EAAE,GAAG,cACL,EAAE,KAAK,GAAI,IAAsB,EAAG,sBAGxC,EAAa,KACT,EAAE,GAAG,iBACL,EAAE,IAAI,GAAM,EAAG,kBAAkB,UAAW,CAAC,EAAW,IAAM,CAC1D,GAAI,IAAc,KACd,MAAO,GAAE,EAAE,EAAG,gBACX,GAAI,EAAW,CAClB,KAAM,GAAQ,GAAM,EAAG,kBAAkB,QACrC,EAAG,qCACH,EAAG,sCACD,EAAc,GAAM,EAAG,kBAAkB,QAC3C,EAAG,cACH,EAAG,aACP,MAAO,GAAI,EAAG,EAAO,EAAE,OAAO,CAC1B,QAAS,IAAM,EAAG,0BAClB,SAAU,GAAM,EAAG,kBAAkB,UACtC,QAEH,OAAO,GAAE,EAAE,EAAG,8DAGtB,EAAE,GAAG,GAAM,EAAG,kBAAkB,WAAa,EAAG,kBAAkB,QAAS,GAChE,EAAE,IAAI,CACT,EAAE,EAAE,CACA,4DACA,EAAE,OAAO,CAAC,UAAW,OAAQ,QAAS,IAAM,EAAG,4BAA6B,SAC5E,wCAEJ,EAAE,IAAI,GAAM,EAAG,kBAAkB,gBAAiB,CAAC,EAAS,IAAM,CAC9D,GAAI,IAAY,GACZ,MAAO,GAAE,EAAE,gLACR,GAAI,IAAY,GACnB,MAAO,GAAE,EAAE,sJAGnB,EAAE,IAAI,GAAM,EAAG,kBAAkB,YAAa,CAAC,EAAK,IAAM,CACtD,GAAI,EACA,MAAO,GAAE,EAAE,iCAAmC,EAAI,eAOtE,EAAa,KACT,EAAE,GAAG,eACL,EAAI,EAAG,EAAG,qCAAsC,KAAK,uBAAuB,EAAG,KAEnF,EAAa,KACT,EAAE,GAAG,eACL,EAAI,EAAG,EAAG,cAAe,GACzB,EAAI,EAAG,EAAG,oBAAqB,GAAM,GAAG,EAAG,kBAAkB,EAAG,gBAChE,EAAI,EAAG,EAAG,iBAAkB,EAAE,OAAO,CAAC,QAAS,IAAM,EAAG,cAAe,WACvE,EAAE,EAAE,CAAC,+PACD,EAAE,EAAE,CAAC,KAAM,6BAA8B,OAAQ,SAAU,IAAK,YAAa,kBAAmB,OAGjG,EAAE,KAAK,CAAC,UAAW,mBAAoB,CAC1C,EAAE,IAAI,CAAC,UAAW,iBAAkB,CAChC,EAAE,EAAE,CAAC,UAAW,8BAA+B,KAAM,EAAG,SAAU,MAAO,EAAG,uBAC5E,EAAE,GAAG,cAET,EAAE,IAAI,CAAC,UAAW,gBAAiB,KAI3C,uBAAuB,EAAG,EAAI,CAC1B,KAAM,GAAO,GACP,EAAM,KAAK,KAAK,EAAG,sBAAwB,GAAQ,EACnD,EAAO,MAAK,MAAM,EAAG,sBAAwB,GAAQ,GAAK,EAC1D,EAAgB,GAAO,EAAG,sBAAsB,SAAS,EAAI,OAAO,MAAO,KACjF,MAAO,CAAC,EAAE,MAAM,CACZ,KAAM,QACN,OACA,MACA,MACA,MAAO,GAAM,EAAG,oBAAsB,EACtC,QAAS,EACT,SAAU,IACV,IAAK,EAAE,OAAO,GACP,EAAG,mBACN,EAAG,iBAAiB,EAAG,uBACvB,EAAG,qBCjHZ,gBAA6B,EAAa,CAC7C,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,KAAK,CAAC,UAAW,UACtB,EAAE,IAAI,CAAC,UAAW,kCAAmC,CACjD,EAAE,GAAG,eAEL,EAAE,KAAK,CAAC,UAAW,kCAAmC,SAAU,GAAO,KAAK,aAAa,GAAM,SAAU,GAAO,KAAK,SAAS,IAAO,CACjI,EAAE,IAAI,CAAC,UAAW,mBAAoB,CAClC,EAAE,OAAO,CAAC,KAAM,SAAU,UAAW,8BAA+B,QAAS,IAAM,EAAG,gBAClF,EAAE,QAAQ,GAAM,EAAG,UAAW,GACtB,EACO,GAAI,IAAW,EAAI,IAEnB,GAAI,IAAW,OAAW,GACtB,EAAE,IAAI,CAAC,UAAW,8CAKzC,EAAE,IAAI,CAAC,UAAW,yBAA0B,CACxC,EAAE,MAAM,CAAC,IAAK,QAAS,EAAG,iBAC1B,EAAE,MAAM,CACJ,QAAS,GAAO,EAAG,QAAQ,EAAI,OAAO,OACtC,KAAM,OAAQ,KAAM,OAAQ,GAAI,OAChC,YAAa,EAAG,8BAI5B,EAAE,IAAI,CAAC,UAAW,iBAAkB,CAChC,EAAE,MAAM,CAAC,IAAK,SAAU,EAAG,wBAC3B,EAAE,SAAS,CACP,QAAS,GAAO,EAAG,SAAS,EAAI,OAAO,OACvC,KAAM,QAAS,GAAI,QACnB,YAAa,EAAG,gBAGxB,EAAE,IAAI,CAAC,UAAW,cAAe,CAC7B,EAAE,IAAI,CAAC,UAAW,kBAAmB,CACjC,EAAE,MAAM,CAAC,KAAM,QAAS,KAAM,WAAY,GAAI,YAAa,MAAO,QAAS,QAAS,CAAC,EAAG,WACxF,EAAE,MAAM,CAAC,IAAK,aAAc,EAAG,6CAEnC,EAAE,IAAI,CAAC,UAAW,kBAAmB,CACjC,EAAE,MAAM,CAAC,KAAM,QAAS,KAAM,WAAY,GAAI,WAAY,MAAO,OAAQ,QAAS,EAAG,WACrF,EAAE,MAAM,CAAC,IAAK,YAAa,EAAG,wCAGtC,EAAE,IAAI,CAAC,UAAW,CAAC,iBAAkB,GAAM,OAAQ,GAAM,EAAG,WAAY,CACpE,EAAE,MAAM,CAAC,KAAM,WAAY,KAAM,cAAe,GAAI,cAAe,QAAS,EAAG,cAC/E,EAAE,MAAM,CAAC,IAAK,eAAgB,EAAG,sCAErC,EAAE,IAAI,CAAC,UAAW,CAAC,gBAAiB,GAAM,OAAQ,GAAM,CAAC,EAAG,WAAY,CACpE,EAAE,MAAM,CAAC,IAAK,aAAc,EAAG,kBAC/B,EAAE,MAAM,CACJ,QAAS,GAAO,EAAG,aAAa,EAAI,OAAO,OAC3C,KAAM,OAAQ,KAAM,YAAa,GAAI,YACrC,YAAa,EAAG,8DAExB,EAAE,IAAI,CAAC,UAAW,cAAe,CAC7B,EAAE,IAAI,EAAE,OAAO,CAAC,UAAW,OAAQ,KAAM,SAAU,QAAS,IAAM,EAAG,uBACjE,GAAM,EAAG,gBAAkB,EAAG,6BAA+B,EAAG,+BACpE,EAAE,IAAI,CAAC,UAAW,CAAC,iBAAkB,GAAM,OAAQ,GAAM,CAAC,EAAG,kBAAmB,CAC5E,EAAE,MAAM,CAAC,KAAM,WAAY,KAAM,uBAAwB,GAAI,uBAAwB,QAAS,EAAG,uBACjG,EAAE,MAAM,CAAC,IAAK,wBAAyB,CACnC,EAAG,yBACH,EAAE,EAAE,CAAC,UAAW,wBAAyB,EAAG,yPAIxD,EAAE,IAAI,CAAC,UAAW,cAAe,CAC7B,EAAE,OAAO,CACL,UAAW,wBACX,KAAM,SACN,SAAU,GAAM,CAAC,EAAG,WACrB,EAAG,0BAO1B,aAAa,EAAK,CACd,OAAQ,EAAI,OAAO,UACV,cACD,KAAK,MAAM,aAAa,EAAI,OAAO,SACnC,UACC,WACD,KAAK,MAAM,UAAU,EAAI,cAAc,SAAS,QAAU,QAC1D,UACC,uBACD,KAAK,MAAM,sBAAsB,EAAI,OAAO,SAC5C,OAIZ,SAAS,EAAK,CACV,EAAI,iBACJ,KAAK,MAAM,UCjGZ,gBAA8B,EAAa,CAC9C,OAAO,EAAG,EAAI,CACV,KAAM,GAAmB,IAAM,EAAG,YAAc,EAAG,SAAW,EAAG,UACjE,MAAO,GAAE,IAAI,CAAC,UAAW,mBAAoB,CACzC,EAAE,IAAI,CAAC,UAAW,0BACd,CACI,EAAE,KAAK,GAAI,IAAW,EAAI,KAC1B,EAAE,QAAQ,GAAM,EAAG,YAAa,GAAe,GAAI,IAAmB,MAE9E,EAAE,IAAI,CAAC,UAAW,wBAAyB,CAAC,EAAE,GAAG,GAAM,EAAG,QAC1D,KAAK,wBAAwB,GAC7B,EAAE,IAAI,CAAC,UAAW,wBACd,CACI,KAAK,2BAA2B,EAAG,EAAG,aAAc,CAAE,YAAa,IAAQ,GAAM,EAAG,YACpF,IAAM,EAAG,UAAU,YACnB,KAAK,qBAAqB,EAAG,EAAG,iBAAkB,CAAC,iBAAkB,IAAO,OAK5F,wBAAwB,EAAI,CACxB,MAAO,GAAG,eAAiB,EAAI,IAAI,CAAC,UAAW,sBAAuB,CAAC,EAAG,iBACtE,GAGR,qBAAqB,EAAG,EAAO,EAAY,EAAO,CAC9C,KAAM,GAAmB,GAAW,IAAC,sBAAuB,IAAS,IACrE,MAAO,GAAE,IAAI,CAAC,UAAW,uBAAwB,CAC7C,EAAE,IAAI,CAAC,UAAW,GAAmB,CAAC,IACtC,EAAE,IAAI,CAAC,UAAW,yBAA0B,KAIpD,2BAA2B,EAAG,EAAO,EAAY,EAAO,EAAS,CAC7D,KAAM,GAAmB,GAAW,IAAC,sBAAuB,IAAS,IACrE,MAAO,GAAE,OAAO,CAAC,UAAW,sBAAuB,WAAU,CACzD,EAAE,IAAI,CAAC,UAAW,GAAmB,CAAC,IACtC,EAAE,IAAI,CAAC,UAAW,yBAA0B,MAMxD,gBAAiC,EAAa,CAC1C,OAAO,EAAG,EAAa,CACnB,MAAO,GAAE,IAAI,CAAC,UAAW,sBACrB,CAAC,EAAE,IAAI,CAAC,UAAW,EAAc,+BAAiC,8CC/C3D,CACf,YACoB,EACA,EAClB,4BAEE,SAAS,OACF,MAAK,IAAM,KAAK,MAG3B,SAAS,EAAuB,OACrB,GAAM,OAAS,KAAK,OAAS,EAAM,KAAO,KAAK,IAG1D,cAAc,EAAsB,OACzB,IAAO,KAAK,OAAS,EAAM,KAAK,IAG3C,aAAa,EAAa,OACf,GAAM,KAAK,MAGtB,WAAW,EAAuB,OACvB,GAAM,MAAQ,KAAK,KAAO,KAAK,MAAQ,EAAM,IAGxD,kBAAqB,EAAiB,EAAoC,IAClE,GAAI,MACH,EAAI,EAAG,EAAI,KAAK,MAAO,GAAK,IAC1B,WAEF,EAAI,EAAG,EAAI,KAAK,OAAQ,GAAK,EAAG,MAC3B,GAAS,EAAG,UACd,EAAO,aAGE,EAAO,MAAO,KAAK,MAAQ,KAK/C,OAAO,WAA8B,OAC3B,IAAI,IAAc,MAG7B,iBAAoC,OACzB,IAAI,IAAqB,MAGpC,WAAW,EAAa,EAAM,KAAK,IAAM,EAAG,OACjC,MAAK,IAAI,KAAK,IAAI,KAAK,MAAO,GAAM,GAG/C,aAAa,EAAgB,OACrB,GAAM,KAAK,MACJ,GAAU,OACV,EAAM,KAAK,IACX,GAAU,OAEV,GAAU,UAKjB,IAAL,UAAK,EAAL,YACM,GAAT,uDADQ,aAMZ,QAAgD,CAE5C,YAA6B,EAAc,mBAClC,IAAM,EAAM,MAAQ,EAG7B,MAA+B,OACvB,MAAK,IAAO,KAAK,MAAM,IAAM,QACxB,KAAO,EACL,CAAC,MAAO,KAAK,IAAK,KAAM,KAExB,CAAC,MAAO,OAAW,KAAM,KAK5C,QAAyE,CAErE,YAA6B,EAAc,mBAClC,IAAM,EAAM,KAGpB,OAAO,WAAY,OACT,MAGX,MAA+B,OACvB,MAAK,IAAM,KAAK,MAAM,YACjB,KAAO,EACL,CAAC,MAAO,KAAK,IAAK,KAAM,KAExB,CAAC,MAAO,OAAW,KAAM,KCrG5C,YAA2B,EAAiB,EAAsB,IAC1D,GAAI,OACD,EAAI,SACF,EACF,EAAG,OAAO,WACF,SAGR,GAGX,YAAkC,EAAiB,EAA4B,IACvE,GAAe,EAAI,GAAM,MACnB,GAAS,EAAG,UACd,CAAC,EAAO,WACD,GAAO,UAMd,IAAL,UAAK,EAAL,kIAAK,6BAkDmB,GAAM,CACjC,YACI,EACA,EACQ,EACA,EAA6B,EAAM,EAC7C,OACQ,EAAO,iDAGjB,OAAO,EAA2B,IAE1B,KAAK,SAAW,QACT,WAEL,GAAW,KAAK,IAAI,EAAG,KAAK,MAAQ,GACpC,EAAS,KAAK,IAAI,KAAK,YAAa,KAAK,IAAM,SAC9C,IAAI,IACP,EACA,EACA,KAAK,YACL,KAAK,uBAIT,cAAsB,OACf,MAAK,gBAGZ,oBAA4B,OACrB,MAAK,yBAGT,cAAa,EAAoB,EAAoB,EAAoB,EAAmB,MACzF,GAAW,KAAK,IAAI,KAAK,IAAI,EAAG,KAAK,MAAM,EAAY,IAAc,GACrE,EAAgB,EAAa,EAC7B,EAAoB,IAAe,EAAI,KAAK,KAAK,EAAa,GAAc,EAC5E,EAAc,KAAK,IAAI,EAAmB,SACzC,IAAI,IAAU,EAAU,EAAW,EAAa,EAAY,GAGvE,SAAY,EAAa,EAAU,EAAuC,MAChE,GAAY,KAAK,kBAAoB,KAAK,OAAS,KAAK,IAAM,KAAK,IAAM,KAC3E,GAAO,EAAW,MAGZ,GAAS,KAAK,WAAW,EAAK,GAC9B,EAAW,IAAW,EAAM,EAAQ,GAAsB,EAAK,OAAO,YAAa,SAClF,MAAK,gBAAmB,EAAQ,cAGhC,CAAC,KAAM,EAAwB,SAAU,KAAK,YAAY,EAAG,IAI5E,YAAe,EAAa,EAAuC,IAC3D,EAAM,KAAK,IAAK,MACV,GAAY,KAAK,WAAW,SAC3B,MAAK,mBAAmB,EAAW,cAEnC,CAAC,KAAM,EAAwB,SAAU,KAAK,YAAY,GAAI,IAI7E,UAAa,EAAiB,EAAe,EAAU,EAAgE,MAC7G,GAAW,KAAK,aAAa,GAC7B,EAAS,KAAK,aAAa,MAC7B,IAAa,EAAQ,IACjB,IAAa,GAAU,QAAU,IAAa,GAAU,gBAEjD,IAAa,GAAU,aACvB,CAAC,KAAM,EAAiB,UAAS,aAEzC,MACG,GAAS,KAAK,WAAW,GACzB,EAAY,KAAK,WAAW,GAC5B,EAAW,IAAW,EAAQ,EAAQ,GAAsB,EAAK,OAAO,YAAa,SACpF,CAAC,KAAM,EAAyB,YAAW,SAAQ,MAAO,IAIjE,gBAAmB,EAAgB,EAA8B,IAEjE,KAAK,kBAAoB,KAAK,aACvB,CAAC,KAAM,EAAgB,SAAQ,QAAO,SAAU,KAAK,YAAY,EAAG,IACxE,MACG,GAAY,KAAK,WAAW,OAAO,wBAClC,CAAC,KAAM,EAAyB,YAAW,SAAQ,QAAO,SAAU,KAAK,YAAY,EAAG,KAI/F,mBAAsB,EAAmB,EAAuC,IAChF,KAAK,IAAM,KAAK,YAAa,MAEvB,GAAS,KAAK,WAAW,OAAO,kBAGhC,EAAQ,GAAsB,EAAK,OAAO,YAAa,SACtD,CAAC,KAAM,EAAyB,YAAW,QAAO,SAAQ,SAAU,KAAK,YAAY,GAAI,YACzF,KAAK,QAAU,EAAG,MAEnB,GAAW,KAAK,YAAY,GAAI,EAAG,GACnC,EAAS,EAAS,MAGlB,EAAQ,GAAsB,EAAK,OAAO,YAAa,SACtD,CAAC,KAAM,EAAyB,YAAW,QAAO,SAAQ,uBAG1D,CAAC,KAAM,EAAmB,YAAW,SAAU,KAAK,YAAY,GAAI,IAI3E,YAAY,EAAwB,EAA+B,EAAoB,EAAc,MACnG,GAAQ,KAAK,MAAQ,EACrB,EAAc,KAAK,YAAc,EAEjC,EAAM,KAAK,IAAI,KAAK,IAAI,EAAO,KAAK,IAAM,EAAY,GAAwB,SAC7E,IAAI,IACP,EACA,EACA,EACA,KAAK,oCCzLqC,GAAe,CAOjE,YACI,EACA,EACF,CAFE,QAAC,cAAY,gBAAgB,IAA7B,EAAoC,KAApC,EAAoC,CAAnC,aAAY,wBAGP,EAAS,QACV,WAAa,OACb,cAAgB,EAGzB,YAAY,EAAU,CACd,EAAE,OAAS,cACN,qBAEC,YAAY,GAI1B,cAAe,MACL,GAAe,KAAK,sBAItB,EAAa,SAAW,GAAK,CAAC,KAAK,YAAa,SAAS,GAAe,MAClE,GAAkB,KAAK,iBACxB,YAAc,EAAa,OAAO,KAAK,oBACvC,aAAa,EAAiB,KAAK,mBAK1C,WAAW,SAMP,IAAI,SAAQ,GAAK,sBAAsB,SACvC,IAAI,SAAQ,GAAK,sBAAsB,IAEzC,CAAC,KAAK,kBAGL,cAAgB,KAAK,MAAM,UAAU,WACpC,GAAe,KAAK,wBACrB,YAAc,EAAa,OAAO,KAAK,oBACvC,gBAAkB,QAClB,kBAAkB,KAAK,aAGxB,kBAAmB,MACjB,CAAC,eAAc,aAAa,KAAK,UACnC,IAAiB,OACX,IAAI,OAAM,kCAEb,IAAU,aAAa,KAAK,MAAM,OAAQ,KAAK,WAAY,EAAc,GAG5E,kBAAkB,EAAkB,IACzB,KAAK,mBACd,GAAW,SAAS,yBACpB,EAAK,KAAK,MAAM,OAAO,iBACxB,gBAAiB,OAAS,IACzB,kBAAkB,EAAI,GAAQ,MAC1B,GAAQ,KAAK,cAAc,QAC5B,gBAAiB,KAAK,KAClB,YAAY,GAAU,EAAO,KAAK,oBAE1C,aAAc,YAAY,QAC1B,cAAc,GAGf,aAAa,EAAsB,EAAqB,IACxD,EAAS,WAAW,GAAY,UAErB,KAAa,GAAU,qBAC1B,CAAC,EAAS,cAAc,GAAY,MAC9B,GAAW,EAAY,EAAU,WAClC,YAAY,KAKhB,kBAAkB,KAAK,MAAM,OAAO,YAAa,CAAC,EAAM,IAAc,IACvE,CAAC,EAAU,cAAc,GAAY,MAC/B,GAAW,EAAY,EAAS,WACjC,SAAS,EAAU,WAG3B,cAAc,aAEd,kBAAkB,GAIvB,cAAc,EAAkB,MAC9B,GAAa,EAAM,MAAQ,KAAK,WAChC,KAAuB,YAAc,EAAM,KAAO,KAAK,WACvD,EAAQ,KAAK,aAAc,QAC3B,WAAa,GAAG,QAChB,cAAgB,GAAG,MAG7B,OAAQ,MACE,GAAc,MAAM,oBACrB,gBAAkB,EAAI,IAAI,CAAC,UAAW,kBAAmB,QACzD,gBAAgB,iBAAiB,SAAU,MACzC,KAAK,gBAGhB,SAAU,MACD,OAAQ,oBAAoB,SAAU,WACtC,gBAAkB,aACjB,UAGV,MAA4B,OACjB,MAAK,mBAGJ,eAAwC,OACzC,OAAM,OAGjB,MAAM,EAAa,EAAU,MACnB,GAAS,KAAK,YAAa,SAAS,EAAK,EAAO,KAAK,YACtD,qBAAqB,GAG9B,SAAS,EAAa,EAAU,MACtB,GAAS,KAAK,YAAa,YAAY,EAAK,KAAK,YAClD,qBAAqB,GAG9B,OAAO,EAAiB,EAAe,EAAU,MACvC,GAAS,KAAK,YAAa,UAAU,EAAS,EAAO,EAAO,KAAK,OACnE,IACI,EAAO,OAAS,GAAW,UACtB,UACD,KAAK,YAAa,aAAa,EAAO,SACtC,KAAK,YAAa,aAAa,EAAO,aAGrC,qBAAqB,IAKtC,SAAS,EAAW,EAAU,EAAa,CACnC,KAAK,YAAa,cAAc,SAC3B,YAAY,KAAK,YAAa,aAAa,GAAI,EAAO,GAI3D,qBAAqB,EAA4B,CAEjD,GAAO,OAAS,GAAW,QAAU,EAAO,OAAS,GAAW,oBAC3D,YAAY,KAAK,YAAa,aAAa,EAAO,YAEvD,EAAO,gBACF,YAAc,EAAO,cACrB,cAAc,KAAK,cAExB,GAAO,OAAS,GAAW,KAAO,EAAO,OAAS,GAAW,oBACxD,SAAS,KAAK,YAAa,aAAa,EAAO,QAAS,EAAO,QClLzE,gBAA6B,EAAa,CAC7C,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,GAAG,CAAE,UAAW,kBACrB,EAAE,EAAE,CAAE,KAAM,EAAG,YACf,CACI,EAAE,KAAK,GAAI,IAAW,EAAI,KAC1B,EAAE,IAAI,CAAE,UAAW,uBAAyB,AAAC,GAAO,EAAG,UCNhE,gBAA6B,GAAa,CAC7C,YAAY,EAAI,CACZ,MAAM,CACF,KAAM,EAAG,qBACT,UAAW,iBACX,WAAY,IACb,GAAiB,GAAI,IAAe,KCNxC,gBAAgC,EAAa,CAChD,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,IAAI,CAAC,UAAW,qBACrB,CAAI,EAAE,KAAK,GAAI,IAAW,EAAI,MAC1B,EAAE,IAAI,CAAC,UAAW,0BAA2B,EAAE,GAAG,GAAM,EAAG,OAC3D,EAAE,IAAI,CAAC,UAAW,wBAAyB,EAAG,QAC9C,KAAK,eAAe,EAAG,EAAG,WAAY,GAAM,EAAG,MAC/C,KAAK,eAAe,EAAG,EAAG,eAAgB,EAAG,YACzC,EAAG,sDACH,EAAG,2DAEP,KAAK,eAAe,EAAG,KAInC,eAAe,EAAG,EAAO,EAAO,CAC5B,MAAO,GAAE,IAAI,CAAE,UAAW,6BACtB,CACI,EAAE,IAAI,CAAC,UAAW,2BAA4B,GAC9C,EAAE,IAAI,CAAC,UAAW,2BAA4B,KAI1D,eAAe,EAAG,EAAI,CAClB,MAAO,GAAE,IAAI,CAAE,UAAW,6BACtB,CACI,EAAE,IAAI,CAAC,UAAW,2BAA4B,EAAG,eACjD,EAAE,IAAI,CAAC,UAAW,6BACd,CACI,EAAE,EAAE,CAAC,KAAM,EAAG,WAAY,OAAQ,SAAU,IAAK,YAAa,EAAG,yBACjE,EAAE,OAAO,CAAC,UAAW,OAAQ,QAAS,IAAM,EAAG,qBAAsB,EAAG,gCC3BzF,gBAA6B,EAAa,CAC7C,OAAO,EAAG,CACN,MAAO,GAAE,IAAI,CAAE,UAAW,kBACtB,CACI,EAAE,OAAO,GAAM,EAAG,gBAAiB,GAAM,GAAI,IAAY,IACzD,EAAE,QAAQ,GAAM,EAAG,gBAAiB,GAAM,KAAK,cAAc,MAKzE,cAAc,EAAI,CAEd,OADa,iBAAI,UAER,eACD,MAAO,IAAI,IAAgB,OAC1B,cACD,MAAO,IAAI,IAAe,OACzB,iBACD,MAAO,IAAI,IAAkB,WAE7B,MAAO,IAAI,MAK3B,gBAA0B,EAAa,CACnC,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,IAAI,CAAE,UAAW,0BACtB,CACA,EAAE,OAAO,CACL,UAAW,CACP,KAAQ,GACR,iBAAkB,GAClB,KAAQ,CAAC,EAAG,gBAAgB,sBAC7B,QAAS,IAAM,EAAG,sBACzB,EAAE,OAAO,CAAC,UAAW,uBAAwB,QAAS,IAAM,EAAG,kBC1BpE,gBAA0B,EAAa,CAC1C,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,IAAI,CACT,UAAW,CACP,YAAe,GACf,eAAgB,GAAM,CAAC,CAAC,EAAG,sBAC3B,cAAe,GAAM,CAAC,CAAC,EAAG,sBAE/B,CACC,EAAE,KAAK,GAAI,IAAkB,EAAG,yBAChC,EAAE,KAAK,GAAI,IAAc,EAAG,qBAC5B,EAAE,QAAQ,GAAM,EAAG,sBAAuB,IAClC,EAAG,kBACI,GAAI,IAAa,EAAG,mBACpB,EAAG,kBACH,GAAI,IAAa,EAAG,mBACpB,EAAG,oBACH,GAAI,IAAe,EAAG,qBACtB,EAAG,qBACN,EAAG,qBAAqB,OAAS,SAC1B,GAAI,IAAW,EAAG,sBAClB,EAAG,qBAAqB,OAAS,OACjC,GAAI,IAAS,EAAG,sBAChB,EAAG,qBAAqB,OAAS,mBACjC,GAAI,IAAqB,EAAG,sBAE5B,GAAI,IAAgB,EAAG,sBAG3B,GAAI,IAAW,GAAK,EAAE,IAAI,CAAC,UAAW,oBAAqB,EAAE,GAAG,EAAG,0CAGlF,EAAE,QAAQ,GAAM,EAAG,kBAAmB,GAAqB,EAAoB,GAAI,IAAa,GAAqB,MACrH,EAAE,QAAQ,GAAM,EAAG,oBAAqB,GAAuB,EAAsB,GAAI,IAAe,GAAuB,SChDpI,YAA4B,EAAG,CAClC,MAAsB,8BACX,EAAE,EAAE,CAAC,OAAQ,SAChB,KAAM,kEACN,qBAAgC,2CAE7B,EAAE,EAAE,CAAC,OAAQ,SAAU,KAAM,6CAChC,sBCLL,gBAAgC,EAAa,CAChD,OAAO,EAAG,EAAI,CACV,KAAM,GAAW,GAAM,CAAC,CAAC,EAAG,OACtB,EAAW,EAAE,MAAM,CACrB,GAAI,WACJ,KAAM,OACN,YAAa,EAAG,eAChB,aAEE,EAAW,EAAE,MAAM,CACrB,GAAI,WACJ,KAAM,WACN,YAAa,EAAG,eAChB,aAGJ,MAAO,GAAE,IAAI,CAAC,UAAW,0BAA2B,CAChD,EAAE,GAAG,GAAM,EAAG,MAAO,GAAK,EAAE,IAAI,CAAE,UAAW,SAAW,GAAM,EAAG,QACjE,EAAE,KAAK,CACH,SAAU,GAAQ,CACd,EAAK,iBACL,EAAG,MAAM,EAAS,MAAO,EAAS,SAEvC,CACC,EAAE,GAAG,GAAM,EAAG,aAAc,CAAC,EAAG,IAAO,EAAE,EAAE,CAAC,UAAW,SAAU,EAAG,KAAK,EAAG,gBAC5E,EAAE,IAAI,CAAE,UAAW,iBAAmB,CAAC,EAAE,MAAM,CAAE,IAAK,YAAc,EAAG,gBAAiB,IACxF,EAAE,IAAI,CAAE,UAAW,iBAAmB,CAAC,EAAE,MAAM,CAAE,IAAK,YAAc,EAAG,gBAAiB,IACxF,EAAE,IAAI,CAAE,UAAW,cAAgB,CAC/B,EAAE,OAAO,CACL,UAAW,wBACX,KAAM,SACN,YACD,EAAG,qBC/BnB,gBAA+B,EAAa,CAC/C,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,IAAI,CAAC,UAAW,YAAuD,CAC5E,EAAE,GAAG,EAAG,uCACR,EAAE,OAAO,GAAM,EAAG,iCAAkC,GAAM,GAAI,IAAsB,EAAG,mCACvF,EAAE,IAAI,GAAM,EAAG,gBAAiB,CAAC,EAAW,IACpC,EACO,EAAE,EAAE,EAAG,2CAEP,EAAE,EAAE,EAAG,6CAA6C,EAAG,mDAGtE,EAAE,IAAI,CAAE,UAAW,cAAgB,CAC/B,EAAE,OAAO,CACL,UAAW,wBACX,QAAS,IAAM,CAAE,EAAG,UACpB,KAAM,UACP,GAAM,EAAG,gBAAkB,EAAG,eAAiB,EAAG,uCCb9D,gBAAoC,EAAa,CACpD,OAAO,EAAG,CACN,KAAM,GAA2B,EAAE,GAAG,GAAM,EAAG,SAAU,CAAC,EAAG,IAClD,EAAE,OAAO,CACZ,QAAS,IAAM,EAAG,cACnB,EAAG,oBAEJ,EAAuB,EAAE,GAAG,GAAM,EAAG,SAAU,CAAC,EAAG,IAC9C,EAAE,OAAO,CACZ,QAAS,IAAM,EAAG,UACnB,EAAG,gBAEV,MAAO,GAAE,IAAI,CAAC,UAAW,yBAA0B,CAC/C,EAAE,EAAE,CAAC,UAAW,UAAW,CACvB,GAAQ,EAAG,CAAC,OAAQ,GAAM,CAAC,EAAG,UAC9B,EAAE,EAAE,GAAM,EAAG,WACb,EACA,IAEJ,EAAE,OAAO,GAAM,EAAG,sBAAuB,GAAM,GAAI,IAAiB,EAAG,2BCvB5E,gBAA8B,EAAa,CAC9C,OAAO,EAAG,CACN,MAAO,GAAE,IAAI,CAAE,UAAW,mBACtB,CACI,EAAE,EAAE,CAAE,UAAW,yBAA2B,+BAC5C,EAAE,GAAG,GAAM,EAAG,aAAc,CAAC,EAAG,IAAO,EAAE,EAAE,CAAC,UAAW,SAAU,EAAG,KAAK,EAAG,gBAC5E,EAAE,QAAQ,GAAM,EAAG,cAAe,GAAiB,EAAgB,GAAI,IAAsB,GAAiB,SCFvH,gBAAwB,EAAa,CACxC,OAAO,EAAG,EAAI,CACV,KAAM,GAAW,GAAM,EAAG,OAE1B,MAAO,GAAE,IAAI,CAAC,UAAW,oBAAqB,CAC1C,EAAE,OAAO,CACL,UAAW,gCACX,QAAS,IAAM,EAAG,SAClB,aAEJ,EAAE,IAAI,CAAC,UAAW,SAClB,EAAE,GAAG,CAAC,EAAG,gBACT,EAAE,QAAQ,GAAM,EAAG,0BAA2B,GAAM,EAAK,GAAI,IAAgB,GAAM,MACnF,EAAE,GAAG,GAAM,EAAG,eAAgB,CAAC,EAAG,IAAO,EAAE,IAAI,CAAE,UAAW,+BACxD,CACI,EAAE,MAAM,CAAC,IAAK,cAAe,EAAG,kBAChC,EAAE,MAAM,CACJ,GAAI,aACJ,KAAM,OACN,YAAa,EAAG,6BAChB,MAAO,EAAG,WACV,WACA,QAAS,GAAS,EAAG,cAAc,EAAM,OAAO,OAChD,SAAU,IAAM,EAAG,oBAEvB,EAAE,EAAE,CAAC,UAAW,CACZ,sBAAuB,GACvB,OAAQ,GAAM,CAAC,EAAG,qBAClB,GAAM,EAAG,2BAA2B,EAAG,uBAC3C,EAAE,GAAG,GAAM,EAAG,aAAc,CAAC,EAAG,IAAO,EAAE,EAAE,CAAC,UAAW,SAAU,EAAG,KAAK,EAAG,mBAGpF,EAAE,GAAG,GAAM,EAAG,uBAAwB,GAAK,EAAE,IAAI,CAAC,UAAW,2BAA4B,CAAC,GAAQ,GAAI,EAAE,EAAE,0CAC1G,EAAE,QAAQ,GAAM,EAAG,uBAAwB,GAAM,EAAK,GAAI,IAAkB,GAAK,MACjF,EAAE,GAAG,GAAM,EAAG,wBAA0B,EAAG,uBAAwB,GAAK,EAAE,EAAE,CAAC,UAAW,uBAAwB,EAAG,WACnH,EAAE,QAAQ,GAAM,EAAG,uBAAwB,GAAM,EAAK,GAAI,IAAkB,GAAM,MAClF,EAAE,QAAQ,GAAM,EAAG,cAAe,GAAiB,EAAgB,GAAI,IAAsB,GAAiB,MAE9G,EAAE,EAAE,GAAmB,OAKnC,gBAAgC,EAAa,CACzC,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,IAAI,CAAE,UAAW,qBACtB,EAAE,OAAO,CACL,UAAW,mDACX,KAAM,SACN,QAAS,IAAM,EAAG,gBAClB,SAAU,GAAM,EAAG,QACpB,EAAG,yBCvDX,gBAAyB,EAAa,CACzC,OAAO,EAAG,EAAI,CACV,KAAM,GAAc,GAAI,IAAmB,EAAI,GACpC,EAAE,IAAI,CACT,EAAE,EAAE,qCACJ,EAAE,IAAI,CAAE,UAAW,cAAgB,CAC/B,EAAE,EAAE,CACA,UAAW,gBACX,KAAM,SACN,KAAM,EAAG,WACV,CAAC,WACJ,EAAE,OAAO,CACL,UAAW,oCACX,KAAM,SACN,QAAS,IAAM,EAAG,UACnB,EAAG,oBAIZ,EAAe,GAAI,IAAmB,EAAI,GACrC,EAAE,EAAE,CAAC,UAAW,SAAU,OAAQ,GAAM,CAAC,EAAG,YAAa,CAC5D,GAAQ,EAAG,CAAC,OAAQ,GAAM,CAAC,EAAG,OAAQ,EAAE,KAAK,GAAM,EAAG,WAI9D,MAAO,GAAE,IAAI,CAAC,UAAW,gBAAiB,CACtC,EAAE,IAAI,CAAC,UAAW,WAAY,CAC1B,EAAE,QAAQ,GAAM,EAAG,YAAa,GACrB,EAAc,EAAc,QC5BhD,gBAA8B,EAAa,CAC9C,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,IAAI,CAAC,UAAW,oBAAqB,CAC1C,EAAE,IAAI,CAAC,UAAW,SAClB,EAAE,IAAI,CAAC,UAAW,mBAAoB,CAClC,EAAE,KAAK,GAAI,IAAsB,MAErC,EAAE,IAAI,CAAC,UAAW,CAAC,aAAc,GAAM,OAAQ,GAAM,EAAG,UACpD,EAAE,EAAE,CAAC,UAAW,wBAAyB,KAAM,EAAG,SAAU,EAAG,mBCN/E,gBAAoC,EAAa,CAC7C,gBAAiB,CACb,AAAI,QAAQ,kBACR,KAAK,MAAM,SAInB,eAAgB,CACZ,AAAI,QAAQ,kBACR,KAAK,MAAM,QAInB,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,GAAG,CACR,EAAE,EAAE,CAAC,UAAW,eAAgB,KAAM,EAAG,SAAU,CAC/C,EAAE,IAAI,CAAC,UAAW,mBAAmB,EAAG,qBAAsB,GAAM,EAAG,gBACvE,EAAE,IAAI,CAAC,UAAW,WAAY,GAAM,EAAG,YAMhD,gBAAgC,EAAa,CAChD,OAAO,EAAG,EAAI,CACV,KAAM,GAAc,GAAI,IAAS,CAC7B,KAAM,EAAG,SACT,sBAAuB,IACxB,GACQ,GAAI,IAAsB,IAGrC,MAAO,GAAE,IAAI,CAAC,UAAW,oBAAqB,CAC1C,EAAE,IAAI,CAAC,UAAW,SAClB,EAAE,IAAI,CAAC,UAAW,qBAAsB,CACpC,EAAE,GAAG,CAAC,uBACN,EAAE,KAAK,GACP,EAAE,IAAI,CAAC,UAAW,cAAe,CAC7B,EAAE,EAAE,CACA,UAAW,wBACX,KAAM,EAAG,WACV,EAAG,iBAEV,EAAE,OAAO,GAAM,EAAG,cAAe,IAAM,GAAI,IAAsB,EAAG,gBACpE,EAAE,EAAE,GAAmB,SCzChC,gBAAuB,EAAa,CACvC,OAAO,EAAG,EAAI,CACV,MAAO,GAAE,QAAQ,GAAM,EAAG,cAAe,GAAiB,CACtD,OAAQ,OACC,QACD,MAAO,IAAI,IAAW,GACX,EAAE,IAAI,CAAC,UAAW,cAAe,CACpC,EAAE,GAAG,wBACL,EAAE,EAAE,EAAG,kBAGd,UACD,MAAO,IAAI,IAAY,EAAG,sBACzB,QACD,MAAO,IAAI,IAAU,EAAG,oBACvB,SACD,MAAO,IAAI,IAAW,EAAG,qBACxB,SACD,MAAO,IAAI,IAAkB,EAAG,4BAC/B,cACD,MAAO,IAAI,IAAW,GAAK,EAAE,EAAE,uBAC9B,UACD,MAAO,IAAI,IAAgB,EAAG,8BAE9B,KAAM,IAAI,OAAM,oBAAoB,EAAG,qBC9B3D,QAAc,CACV,YAAY,EAAI,CACZ,KAAK,QAAU,KACf,KAAK,QAAU,KACf,KAAK,SAAW,GAAI,SAAQ,CAAC,EAAS,IAAW,CAC7C,KAAK,QAAU,EACf,KAAK,QAAU,WAAW,IAAM,CAC5B,KAAK,QAAU,KACf,KACD,KAIX,SAAU,CACN,MAAO,MAAK,SAGhB,OAAQ,CACJ,AAAI,KAAK,SACL,MAAK,QAAQ,GAAI,IACjB,aAAa,KAAK,SAClB,KAAK,QAAU,KACf,KAAK,QAAU,MAIvB,SAAU,CACN,KAAK,SAIb,QAAe,CACX,YAAY,EAAI,EAAU,CACtB,KAAK,QAAU,YAAY,EAAU,GAGzC,SAAU,CACN,AAAI,KAAK,SACL,eAAc,KAAK,SACnB,KAAK,QAAU,OAK3B,QAAkB,CACd,aAAc,CACV,KAAK,OAAS,OAAO,YAAY,MAGrC,SAAU,CACN,MAAO,QAAO,YAAY,MAAQ,KAAK,QAIxC,QAAY,CACf,eAAgB,CACZ,MAAO,IAAI,IAGf,cAAc,EAAI,CACd,MAAO,IAAI,IAAQ,GAGvB,eAAe,EAAU,EAAI,CACzB,MAAO,IAAI,IAAS,EAAI,GAG5B,KAAM,CACF,MAAO,MAAK,OClEb,QAA2B,CAC9B,aAAc,CACV,KAAK,iBAAmB,GAAI,KAC5B,KAAK,kBAAoB,EACzB,KAAK,YAAc,KACnB,KAAK,cAAgB,KACrB,KAAK,qBAAuB,KAC5B,KAAK,mBAAqB,KAC1B,KAAK,aAAe,GAGxB,cAAc,EAAY,CACtB,KAAK,YAAc,EAGvB,iBAAiB,EAAM,CACnB,KAAK,qBAAwB,UAAY,CACrC,UAAU,cAAc,iBAAiB,UAAW,MACpD,UAAU,cAAc,iBAAiB,mBAAoB,MAC7D,KAAK,cAAgB,KAAM,WAAU,cAAc,SAAS,GAC5D,KAAM,WAAU,cAAc,MAC9B,KAAK,mBAAqB,UAAU,cAAc,WAClD,KAAK,cAAc,iBAAiB,cAAe,MACnD,KAAK,qBAAuB,KAExB,KAAK,cAAc,SAAW,KAAK,cAAc,QACjD,KAAK,iBAET,QAAQ,IAAI,iCAIpB,WAAW,EAAO,CACd,KAAM,CAAC,QAAQ,EACT,EAAU,EAAK,QACrB,GAAI,EAAS,CACT,KAAM,GAAU,KAAK,iBAAiB,IAAI,GAC1C,AAAI,GACA,MAAK,iBAAiB,OAAO,GAC7B,EAAQ,EAAK,UAGrB,GAAI,EAAK,OAAS,iBAAkB,CAChC,KAAM,GAAU,KAAK,YAAY,QAAQ,WAAW,QAAU,EAAK,QAAQ,UAC3E,EAAM,OAAO,YAAY,CAAC,QAAS,EAAK,GAAI,QAAS,YAC9C,EAAK,OAAS,cAAe,CACpC,KAAM,GAAiB,KAAK,YAAY,QAAQ,WAAW,QAAU,EAAK,QAAQ,UAC5E,EAAc,KAAK,YAAY,QAAQ,QAAQ,QAAU,EAAK,QAAQ,OAC5E,EAAM,OAAO,YAAY,CAAC,QAAS,EAAK,GAAI,QAAS,GAAkB,YAChE,EAAK,OAAS,eAAgB,CACrC,KAAM,CAAC,aAAa,EAAK,QACzB,KAAK,sBAAsB,GAAW,QAAQ,IAAM,CAChD,EAAM,OAAO,YAAY,CAAC,QAAS,EAAK,WAEzC,AAAI,GAAK,OAAS,eAErB,MAAK,aAAe,GACpB,EAAM,OAAO,YAAY,CAAC,QAAS,EAAK,MACjC,EAAK,OAAS,YACrB,KAAK,YAAY,KAAK,OAAQ,EAAK,QAAQ,QAInD,sBAAsB,EAAW,OAC7B,KAAM,GAAiB,QAAK,cAAL,cAAkB,KAAK,IAAI,WAClD,MAAI,IAAa,kBAAgB,SAAU,EAChC,GAAI,SAAQ,GAAW,CAC1B,KAAM,GAAc,KAAK,YAAY,eAAe,UAAU,GAAQ,CAClE,KAAM,GAAU,EAAK,IAAI,WACzB,AAAI,EAAC,GAAW,EAAQ,QAAU,IAC9B,KACA,OAGR,KAAK,YAAY,KAAK,aAGnB,QAAQ,eAIjB,iBAAiB,CACnB,GAAI,SAAS,OACT,OAEJ,KAAM,GAAU,KAAM,MAAK,qBAAqB,UAAW,KAAM,KAAK,cAAc,SACpF,AAAI,QAAQ,WAAW,EAAQ,YAAY,EAAQ,8CAI/C,MAAM,MAAK,qBAAqB,gBAGhC,KAAK,MAAM,cAAe,KAAM,KAAK,cAAc,UAI3D,YAAY,EAAO,CACf,OAAQ,EAAM,UACL,UACD,KAAK,WAAW,GAChB,UACC,cACD,KAAK,cAAc,WAAW,iBAAiB,cAAe,MAC9D,UACC,cAAe,CAChB,AAAI,EAAM,OAAO,QAAU,aACvB,MAAK,iBACL,EAAM,OAAO,oBAAoB,cAAe,OAEpD,UAEC,mBACD,AAAK,KAAK,mBAUN,SAAS,SAAS,SANlB,KAAK,mBAAqB,UAAU,cAAc,WAQtD,YAIN,OAAM,EAAM,EAAS,EAAS,OAAW,CAC3C,AAAI,KAAK,sBACL,KAAM,MAAK,qBAEV,GACD,GAAS,KAAK,cAAc,QAEhC,EAAO,YAAY,CAAC,OAAM,iBAGxB,sBAAqB,EAAM,EAAS,EAAS,OAAW,CAC1D,AAAI,KAAK,sBACL,KAAM,MAAK,qBAEV,GACD,GAAS,KAAK,cAAc,QAEhC,KAAK,mBAAqB,EAC1B,KAAM,GAAK,KAAK,kBACV,EAAU,GAAI,SAAQ,GAAW,CACnC,KAAK,iBAAiB,IAAI,EAAI,KAElC,SAAO,YAAY,CAAC,OAAM,KAAI,YACvB,KAAM,QAGX,iBAAiB,CACnB,AAAI,KAAK,sBACL,KAAM,MAAK,qBAEf,KAAK,cAAc,YAGnB,UAAU,CACV,MAAO,YAGP,YAAY,CACZ,MAAO,mCAGL,gCAA+B,EAAW,CAC5C,MAAO,MAAK,qBAAqB,eAAgB,CAAC,mBAGhD,kBAAkB,CACpB,MAAI,MAAK,sBACL,KAAM,MAAK,qBAER,KAAK,eCtLb,QAA0B,CAC7B,YAAY,EAAsB,EAAY,CAC1C,KAAK,sBAAwB,EAC7B,KAAK,YAAc,OAGjB,YAAW,EAAe,EAAgB,OAC5C,KAAM,GAAe,KAAM,SAAK,wBAAL,cAA4B,mBACvD,GAAI,iBAAc,YAAa,CAK3B,KAAM,GAAmB,AAJJ,MAAM,GAAa,YAAY,UAAU,CAC1D,gBAAiB,GACjB,qBAAsB,KAAK,YAAY,wBAEL,SAChC,EAAU,EAAiB,KAAK,OAChC,EAAO,CACT,SAAU,EAAiB,SAC3B,KAAM,EAAiB,KAAK,KAG5B,YAAa,GACb,gBAAiB,GAErB,MAAO,GAAc,WACjB,KAAK,YAAY,WACjB,KAAK,YAAY,MACjB,EACA,SAKN,cAAc,OAChB,KAAM,GAAe,KAAM,SAAK,wBAAL,cAA4B,mBACvD,GAAI,iBAAc,YAAa,CAC3B,KAAM,GAAe,KAAM,GAAa,YAAY,kBACpD,AAAI,GACA,KAAM,GAAa,oBAKzB,gBAAgB,OAClB,KAAM,GAAe,KAAM,SAAK,wBAAL,cAA4B,mBACvD,MAAI,kBAAc,aAEP,CAAC,CADa,KAAM,GAAa,YAAY,kBAGjD,QAGL,eAAe,OACjB,GAAI,CAAC,KAAK,YACN,MAAO,GAEX,KAAM,GAAe,KAAM,SAAK,wBAAL,cAA4B,mBACvD,MAAO,IAAgB,eAAiB,QAGtC,sBAAsB,CACxB,MAAI,gBAAkB,QACV,KAAM,cAAa,sBAAyB,UAEjD,QAGL,wBAAwB,CAC1B,MAAO,gBAAkB,aAGvB,0BAA0B,CAC5B,MAAI,gBAAkB,QACX,aAAa,aAAe,UAE5B,QAIT,kBAAiB,EAAO,EAAO,OAAW,OAC5C,GAAI,gBAAkB,QAAQ,CAC1B,GAAI,cAAa,EAAO,CAAC,SACzB,OAGJ,KAAM,GAAe,KAAM,SAAK,wBAAL,cAA4B,mBACvD,WAAc,iBAAiB,EAAO,CAAC,UCnFxC,gBAAsB,GAAoB,CAC7C,YAAY,EAAO,CACf,AAAI,EAAM,OAAS,cACf,MAAK,KAAK,KAAK,OACf,KAAK,WAAW,KAAK,QAI7B,KAAM,CAMF,MAAI,UAAS,SAAS,OAAO,SAAS,cAC3B,SAAS,SAAS,OAEtB,SAAS,SAAS,KAI7B,mBAAmB,EAAK,CACpB,OAAO,QAAQ,aAAa,KAAM,KAAM,GACxC,KAAK,WAAW,GAIpB,gBAAgB,EAAK,CACjB,OAAO,QAAQ,UAAU,KAAM,KAAM,GACrC,KAAK,WAAW,GAGpB,QAAQ,EAAK,CACT,SAAS,SAAS,KAAO,EAG7B,UAAU,EAAK,CACX,MAAI,GAAI,WAAW,KACR,EAAI,OAAO,GAEX,EAIf,UAAU,EAAM,CACZ,MAAO,IAAI,IAGf,kBAAmB,CACf,OAAO,iBAAiB,aAAc,MAG1C,mBAAoB,CAChB,OAAO,oBAAoB,aAAc,MAG7C,WAAW,EAAM,OACb,UAAO,eAAP,QAAqB,QAAQ,yBAA0B,GAG3D,YAAa,OACT,MAAO,UAAO,eAAP,cAAqB,QAAQ,2BC7DrC,gBAA2B,GAAoB,CAClD,aAAc,CACV,QACA,KAAK,WAAa,KAAK,WAAW,KAAK,MACvC,KAAK,UAAY,KAAK,UAAU,KAAK,MAGzC,YAAa,CACT,KAAK,KAAK,IAGd,WAAY,CACR,KAAK,KAAK,IAGd,KAAM,CACF,MAAO,WAAU,OAGrB,kBAAmB,CACf,OAAO,iBAAiB,UAAW,KAAK,YACxC,OAAO,iBAAiB,SAAU,KAAK,WAG3C,mBAAoB,CAChB,OAAO,oBAAoB,UAAW,KAAK,YAC3C,OAAO,oBAAoB,SAAU,KAAK,YCzBlD,WAA4B,EAAa,EAAQ,CAC7C,MAAI,aAAuB,SAChB,EAEA,GAAI,SAAQ,CAAC,EAAS,IAAW,CACpC,EAAY,WAAa,GAAK,EAAQ,EAAE,OAAO,QAC/C,EAAY,QAAU,IAAM,EAAO,GAAI,OAAM,mBAAqB,MAK9E,QAAiB,CACb,YAAY,EAAc,CACtB,KAAK,cAAgB,OAUnB,QAAO,EAAK,EAAK,EAAM,EAAM,CAC/B,KAAM,GAAO,CACT,KAAM,OACN,KAAM,CAAC,KAAM,GAAS,KAEpB,EAAU,KAAM,GAAmB,KAAK,cAAc,UACxD,MACA,EACA,EACA,GACA,CAAC,WACF,aAOH,MANmB,MAAM,GAAmB,KAAK,cAAc,OAC3D,EACA,EACA,EACA,GACD,eAID,SAAQ,EAAK,EAAM,EAAM,CAC3B,KAAM,GAAO,CACT,KAAM,OACN,KAAM,CAAC,KAAM,GAAS,KAEpB,EAAU,KAAM,GAAmB,KAAK,cAAc,UACxD,MACA,EACA,EACA,GACA,CAAC,SACF,aACG,EAAS,KAAM,GAAmB,KAAK,cAAc,KACvD,EACA,EACA,GACD,QACH,MAAO,IAAI,YAAW,IAI9B,QAAmB,CACf,YAAY,EAAc,EAAQ,EAAc,CAC5C,KAAK,cAAgB,EACrB,KAAK,QAAU,EACf,KAAK,cAAgB,OAWnB,QAAO,EAAU,EAAY,EAAM,EAAM,EAAQ,CACnD,GAAI,CAAC,KAAK,cAAc,WACpB,KAAM,IAAI,OAAM,2BAEpB,KAAM,GAAM,KAAM,GAAmB,KAAK,cAAc,UACpD,MACA,EACA,CAAC,KAAM,UACP,GACA,CAAC,eACF,aACG,EAAU,KAAM,GAAmB,KAAK,cAAc,WACxD,CACI,KAAM,SACN,OACA,aACA,KAAM,GAAS,IAEnB,EACA,GACD,cACH,MAAO,IAAI,YAAW,QAYpB,MAAK,EAAK,EAAM,EAAM,EAAM,EAAQ,CACtC,GAAI,CAAC,KAAK,cAAc,WACpB,MAAO,MAAK,cAAc,KAAK,KAAK,QAAS,EAAK,EAAM,EAAM,EAAM,GAExE,KAAM,GAAU,KAAM,GAAmB,KAAK,cAAc,UACxD,MACA,EACA,CAAC,KAAM,QACP,GACA,CAAC,eACF,aACG,EAAU,KAAM,GAAmB,KAAK,cAAc,WAAW,CAC/D,KAAM,OACN,OACA,OACA,KAAM,GAAS,IAEnB,EACA,GACD,cACH,MAAO,IAAI,YAAW,IAI9B,QAAgB,CACZ,YAAY,EAAc,EAAQ,CAC9B,KAAK,cAAgB,EACrB,KAAK,QAAU,OAWb,YAAW,CAAC,MAAK,SAAQ,KAAI,OAAM,gBAAgB,IAAK,CAC1D,KAAM,GAAO,CACT,KAAM,UACN,QAAS,EACT,OAAQ,GAEZ,GAAI,GACJ,GAAI,CACA,KAAM,GAAc,GAAO,EACrB,EAAS,EAAS,MAAQ,MAChC,EAAS,KAAM,GAAmB,KAAK,cAAc,UACjD,EACA,EACA,EACA,GACA,CAAC,YACF,mBACE,EAAP,CACE,KAAM,IAAI,OAAM,gDAAgD,EAAI,WAExE,GAAI,CACA,KAAM,GAAY,KAAM,GAAmB,KAAK,cAAc,QAE1D,EACA,EACA,GACD,WACH,MAAO,IAAI,YAAW,SACjB,EAAP,CACE,KAAM,IAAI,OAAM,mCAAmC,EAAI,iBAIzD,YAAW,CAAC,MAAK,SAAQ,KAAI,QAAO,CACtC,KAAM,GAAO,CACT,KAAM,UACN,QAAS,EACT,OAAQ,IAEZ,GAAI,GACJ,KAAM,GAAc,GAAO,EACrB,EAAS,EAAS,MAAQ,MAChC,GAAI,CACA,EAAS,KAAM,GAAmB,KAAK,cAAc,UACjD,EACA,EACA,EACA,GACA,CAAC,YACF,mBACE,EAAP,CACE,KAAM,IAAI,OAAM,gDAAgD,EAAI,WAExE,GAAI,CACA,KAAM,GAAa,KAAM,GAAmB,KAAK,cAAc,QAE3D,EACA,EACA,GACD,WACH,MAAO,IAAI,YAAW,SACjB,EAAP,CACE,KAAM,IAAI,OAAM,mCAAmC,EAAI,iBAUzD,aAAY,EAAQ,EAAS,IAAK,CACpC,KAAM,GAAY,KAAM,GAAmB,KAAK,cAAc,YAC1D,CAAC,KAAQ,UAAW,UAAS,GAAM,CAAC,UAAW,aACnD,MAAO,GAAmB,KAAK,cAAc,UAAU,EAAQ,SAG7D,aAAa,CACf,MAAO,IAAW,KAAK,UAI/B,YAAoB,EAAQ,CACxB,KAAM,GAAc,EAAO,gBAAgB,GAAI,YAAW,IACpD,EAAU,GAAI,YAAW,IAC/B,OAAS,GAAI,EAAG,EAAI,EAAY,OAAQ,GAAK,EACzC,EAAQ,GAAK,EAAY,GAE7B,MAAO,GAGX,YAAqB,EAAQ,CACzB,GAAI,EAAO,MAAQ,UACf,KAAM,IAAI,OAAM,sBAAsB,EAAO,OAEjD,GAAI,CAAC,EAAO,QAAQ,SAAS,WACzB,KAAM,IAAI,OAAM,gCAEpB,GAAI,EAAO,MAAQ,MACf,KAAM,IAAI,OAAM,qCAAqC,EAAO,OAIhE,KAAM,GAAY,AADG,EAAO,EACG,QAAQ,KAAM,KAAK,QAAQ,KAAM,KAChE,MAAOA,IAAO,OAAO,GAGzB,YAA8B,EAAQ,CAClC,KAAM,GAAMA,GAAO,OAAO,GACpB,EAAa,EAAI,QAAQ,KAC/B,MAAI,KAAe,GACR,EAAI,OAAO,EAAG,GAEd,EAIf,YAAyB,EAAQ,CAE7B,MAAO,AADU,IAAqB,GACtB,QAAQ,MAAO,KAAK,QAAQ,MAAO,KAGvD,YAAqB,EAAK,CACtB,MAAO,CACH,IAAO,UACP,IAAO,GACP,EAAK,GAAgB,GACrB,QAAW,CACP,UACA,WAEJ,IAAO,OAKf,QAAsB,CAClB,YAAY,EAAO,EAAQ,CACvB,KAAK,OAAS,EACd,KAAK,QAAU,OAUb,YAAW,CAAC,MAAK,SAAQ,KAAI,OAAM,gBAAgB,IAAK,CAC1D,GAAI,IAAkB,GAClB,KAAM,IAAI,OAAM,+BAA+B,KAEnD,AAAI,GACA,GAAM,GAAY,IAEtB,KAAM,GAAQ,KAAK,OACnB,GAAI,GAAS,GAAI,GAAM,gBAAgB,IAAI,GAAI,YAAW,GAAM,GAAI,GAAM,QAAQ,GAAI,YAAW,KACjG,MAAO,GAAO,QAAQ,GAAI,YAAW,SAGnC,YAAW,CAAC,MAAK,SAAQ,KAAI,QAAO,CACtC,AAAI,GACA,GAAM,GAAY,IAEtB,KAAM,GAAQ,KAAK,OACnB,GAAI,GAAS,GAAI,GAAM,gBAAgB,IAAI,GAAI,YAAW,GAAM,GAAI,GAAM,QAAQ,GAAI,YAAW,KACjG,MAAO,GAAO,QAAQ,GAAI,YAAW,SASnC,aAAY,EAAQ,EAAS,IAAK,CACpC,GAAI,GAAM,OAAO,gBAAgB,GAAI,YAAW,EAAS,IACzD,MAAI,KAAW,OACX,GAAM,GAAY,IAEf,OAGL,aAAa,CACf,MAAO,IAAW,KAAK,UAI/B,YAAkB,EAAM,CACpB,GAAI,IAAS,WAAa,IAAS,UAC/B,KAAM,IAAI,OAAM,sBAAsB,KAE1C,MAAO,GAGJ,QAAa,CAChB,YAAY,EAAc,CACtB,KAAM,GAAS,OAAO,QAAU,OAAO,SACjC,EAAe,EAAO,QAAU,EAAO,aAC7C,KAAK,cAAgB,EAGrB,AAAI,CAAC,EAAa,YAAc,kBAAc,OAC1C,KAAK,IAAM,GAAI,IAAgB,EAAa,MAAO,GAEnD,KAAK,IAAM,GAAI,IAAU,EAAc,GAE3C,KAAK,KAAO,GAAI,IAAW,GAC3B,KAAK,OAAS,GAAI,IAAa,EAAc,KAAM,QASjD,QAAO,EAAM,EAAM,CACrB,MAAO,MAAM,GAAmB,KAAK,cAAc,OAAO,GAAS,GAAO,IAG9E,WAAW,EAAM,CACb,OAAQ,GAAS,QACR,UAAW,MAAO,QAClB,UAAW,MAAO,YACd,KAAM,IAAI,OAAM,uBAAuB,GAAS,QC7X9D,mBAAsC,OACzC,GAAI,oCAAW,UAAX,cAAoB,SAAU,CAC9B,KAAM,CAAC,QAAO,SAAS,KAAM,WAAU,QAAQ,WAC/C,MAAO,CAAC,QAAO,aAEf,OAAO,CAAC,MAAO,KAAM,MAAO,MCHpC,QAAkB,CACd,YAAY,EAAQ,CAChB,KAAK,OAAS,EACd,KAAK,KAAO,GAGhB,OAAO,EAAM,CACT,KAAK,OAAO,iBAAiB,UAAW,GACxC,KAAK,OAAO,iBAAiB,QAAS,GAG1C,OAAO,EAAM,CACT,KAAK,OAAO,oBAAoB,UAAW,GAC3C,KAAK,OAAO,oBAAoB,QAAS,IAIjD,QAAc,CACV,YAAY,EAAS,EAAM,CACvB,KAAK,SAAW,GAAI,SAAQ,CAAC,EAAU,IAAY,CAC/C,KAAK,SAAW,EAChB,KAAK,QAAU,IAEnB,KAAK,SAAW,EAChB,KAAK,MAAQ,EACb,KAAK,QAAU,KAGnB,OAAQ,CACJ,AAAI,KAAK,gBACL,MAAK,MAAM,cAAc,MACzB,KAAK,YAIb,UAAW,CACP,MAAO,MAAK,SAGhB,UAAW,CACP,KAAK,QAAU,KACf,KAAK,SAAW,QAGhB,iBAAiB,CACjB,MAAO,MAAK,UAAY,KAAK,SAI9B,QAAiB,CAEpB,YAAY,EAAM,EAAQ,CACtB,KAAK,SAAW,GAChB,OAAS,GAAI,EAAG,EAAI,EAAS,EAAE,EAAG,CAC9B,KAAM,GAAS,GAAI,IAAY,GAAI,QAAO,IAC1C,EAAO,OAAO,MACd,KAAK,SAAS,GAAK,EAEvB,KAAK,UAAY,GAAI,KACrB,KAAK,SAAW,EAChB,KAAK,aAAe,GACpB,KAAK,MAAQ,KAIjB,MAAO,CACH,KAAM,GAAU,GAAI,SAAQ,CAAC,EAAS,IAAW,CAC7C,KAAK,MAAQ,CAAC,UAAS,YAE3B,YAAK,QAAQ,CAAC,KAAM,SACf,KAAK,KAAK,MAAM,QAAS,KAAK,MAAM,QACpC,QAAQ,IAAM,CACX,KAAK,MAAQ,OAEd,EAGX,YAAY,EAAG,CACX,GAAI,EAAE,OAAS,UAAW,CACtB,KAAM,GAAU,EAAE,KACZ,EAAU,KAAK,UAAU,IAAI,EAAQ,WAC3C,GAAI,EAAS,CAET,GADA,EAAQ,QAAQ,KAAO,GACnB,EAAQ,eAAgB,CACxB,GAAI,EAAQ,OAAS,UACjB,EAAQ,SAAS,EAAQ,iBAClB,EAAQ,OAAS,QAAS,CACjC,KAAM,GAAM,GAAI,OAAM,EAAQ,SAC9B,EAAI,MAAQ,EAAQ,MACpB,EAAQ,QAAQ,GAEpB,EAAQ,WAEZ,KAAK,UAAU,OAAO,EAAQ,WAElC,KAAK,mBACF,AAAI,GAAE,OAAS,SACd,MAAK,OACL,KAAK,MAAM,OAAO,GAAI,OAAM,6BAEhC,QAAQ,MAAM,eAAgB,IAItC,oBAAqB,CACjB,SAAW,KAAK,MAAK,UAAU,SAC3B,GAAI,CAAC,EAAE,QACH,MAAO,GAKnB,gBAAiB,CACb,SAAW,KAAK,MAAK,SACjB,GAAI,CAAC,EAAE,KACH,MAAO,GAKnB,cAAe,CACX,KAAK,aAAe,GACpB,GAAI,GACJ,EAAG,CACC,EAAU,GACV,KAAM,GAAU,KAAK,qBACrB,GAAI,EAAS,CACT,KAAM,GAAS,KAAK,iBACpB,AAAI,GACA,MAAK,UAAU,EAAS,GACxB,EAAU,WAGb,GAGb,UAAU,EAAS,EAAQ,CACvB,EAAQ,QAAU,EAClB,EAAO,KAAO,GACd,EAAO,OAAO,YAAY,EAAQ,UAGtC,gBAAgB,EAAS,CACrB,KAAK,UAAY,EACjB,EAAQ,GAAK,KAAK,SAClB,KAAM,GAAU,GAAI,IAAQ,EAAS,MACrC,YAAK,UAAU,IAAI,EAAQ,GAAI,GACxB,EAGX,KAAK,EAAS,CACV,KAAM,GAAU,KAAK,gBAAgB,GAC/B,EAAS,KAAK,iBACpB,MAAI,IACA,KAAK,UAAU,EAAS,GAErB,EAIX,QAAQ,EAAS,CACb,KAAM,GAAW,KAAK,SAAS,IAAI,GAAU,CACzC,KAAM,GAAU,KAAK,gBAAgB,OAAO,OAAO,GAAI,IACvD,YAAK,UAAU,EAAS,GACjB,EAAQ,aAEnB,MAAO,SAAQ,IAAI,GAGvB,SAAU,CACN,SAAW,KAAK,MAAK,SACjB,EAAE,OAAO,MACT,EAAE,OAAO,YAIjB,2BAA4B,CACxB,AAAK,KAAK,cACN,MAAK,aAAe,GACpB,QAAQ,UAAU,KAAK,IAAM,CACzB,KAAK,kBAKjB,cAAc,EAAS,CACnB,EAAQ,QAAQ,GAAI,IAChB,EAAQ,SACR,GAAQ,QAAQ,KAAO,IAE3B,KAAK,UAAU,OAAO,EAAQ,SAAS,IAEvC,KAAK,6BC/LN,QAAkB,aACR,UAAS,EAAM,CACxB,KAAM,GAAM,KAAM,IAAgB,GAC5B,CAAC,QAAO,UAAU,EACxB,MAAO,IAAI,IAAY,EAAM,EAAO,EAAQ,GAGhD,YAAY,EAAM,EAAO,EAAQ,EAAY,CACzC,KAAK,KAAO,EACZ,KAAK,MAAQ,EACb,KAAK,OAAS,EACd,KAAK,YAAc,KAGnB,eAAe,CACf,MAAO,MAAK,IAAI,KAAK,MAAO,KAAK,aAG/B,iBAAiB,CACnB,MAAK,MAAK,aACN,MAAK,YAAc,KAAM,IAAgB,KAAK,OAE3C,KAAK,iBAGV,OAAM,EAAc,CACtB,KAAM,GAAc,KAAK,MAAQ,KAAK,OAChC,EAAc,KAAK,IAAI,EAAG,EAAgB,IAAe,EAAI,KAAK,MAAQ,KAAK,SAC/E,EAAc,KAAK,MAAM,KAAK,MAAQ,GACtC,EAAe,KAAK,MAAM,KAAK,OAAS,GACxC,EAAS,SAAS,cAAc,UACtC,EAAO,MAAQ,EACf,EAAO,OAAS,EAChB,KAAM,GAAM,EAAO,WAAW,MACxB,EAAkB,KAAM,MAAK,iBACnC,EAAI,UAAU,EAAiB,EAAG,EAAG,EAAa,GAClD,GAAI,GAAW,KAAK,KAAK,WAAa,aAAe,aAAe,YAChE,EACJ,GAAI,EAAO,OACP,EAAa,KAAM,IAAI,SAAQ,GAAW,EAAO,OAAO,EAAS,YAC1D,EAAO,SAEd,EAAW,YACX,EAAa,EAAO,eAEpB,MAAM,IAAI,OAAM,oCAEpB,KAAM,GAAO,GAAW,SAAS,GACjC,MAAO,IAAI,IAAY,EAAM,EAAa,EAAc,MAG5D,SAAU,CACN,KAAK,KAAK,WAIX,gBAA0B,GAAY,IACrC,WAAW,CACX,GAAI,MAAO,MAAK,YAAY,UAAa,SACrC,MAAO,MAAK,MAAM,KAAK,YAAY,SAAW,iBAKzC,UAAS,EAAM,CACxB,KAAM,GAAQ,KAAM,IAAkB,GAChC,CAAC,aAAY,eAAe,EAClC,MAAO,IAAI,IAAY,EAAM,EAAY,EAAa,IAIvD,aAAkC,CACrC,KAAM,GAAS,SAAS,cAAc,UACtC,EAAO,MAAQ,EACf,EAAO,OAAS,EAChB,KAAM,GAAM,EAAO,WAAW,MACxB,EAAM,CACR,KAAK,MAAM,KAAK,SAAW,KAC3B,KAAK,MAAM,KAAK,SAAW,KAC3B,KAAK,MAAM,KAAK,SAAW,MAE/B,EAAI,UAAY,OAAO,EAAI,OAAO,EAAI,OAAO,EAAI,MACjD,EAAI,SAAS,EAAG,EAAG,EAAG,GACtB,KAAM,GAAO,EAAI,aAAa,EAAG,EAAG,EAAG,GAAG,KAC1C,MAAO,GAAK,KAAO,EAAI,IAAM,EAAK,KAAO,EAAI,IAAM,EAAK,KAAO,EAAI,GAGvE,kBAA+B,EAAM,CACjC,KAAM,GAAM,SAAS,cAAc,OAC7B,EAAc,GAAkB,EAAK,QAC3C,SAAI,IAAM,EAAK,IACf,KAAM,GACC,EAGX,kBAAiC,EAAM,CACnC,KAAM,GAAQ,SAAS,cAAc,SACrC,EAAM,MAAQ,GACd,KAAM,GAAc,GAAkB,EAAO,kBAC7C,EAAM,IAAM,EAAK,IACjB,EAAM,OACN,KAAM,GAGN,KAAM,GAAc,GAAkB,EAAO,UAG7C,YAAM,IAAI,SAAQ,GAAK,WAAW,EAAG,MACrC,EAAM,YAAc,GACpB,KAAM,GACC,ECjHJ,kBAAgC,EAAW,EAAW,EAAY,EAAU,EAAO,CACtF,GAAI,GAAS,EAAU,cAAc,0BACrC,GAAI,CAAC,EAAQ,CACT,EAAS,SAAS,cAAc,UAChC,EAAO,aAAa,UAAW,yEAC/B,EAAO,aAAa,MAAO,GAC3B,EAAO,UAAY,yBACnB,EAAU,YAAY,GACtB,GAAI,GACJ,KAAM,IAAI,SAAQ,CAAC,EAAS,IAAW,CACnC,EAAS,IAAM,CACX,EAAO,oBAAoB,OAAQ,GACnC,EAAO,oBAAoB,QAAS,IAExC,EAAO,iBAAiB,OAAQ,GAChC,EAAO,iBAAiB,QAAS,KAErC,IAEJ,GAAI,EAAO,CAGP,KAAM,GAAS,KAAM,GAAW,eAChC,EAAO,cAAc,YAAY,CAC7B,KAAM,iBACN,SACA,SAAU,EAAW,SACrB,SAAU,GACX,SAEH,GAAO,cAAc,YAAY,CAC7B,KAAM,eACN,KAAM,EAAW,WACjB,SAAU,GACX,KChCX,QAAsB,CAClB,YAAY,EAAU,CAClB,KAAK,UAAY,KAGjB,YAAY,CACZ,MAAO,OAAM,KAAK,KAAK,UAAU,YAGrC,cAAc,EAAM,CAChB,MAAO,OAAM,KAAK,EAAK,YAG3B,kBAAkB,EAAM,CACpB,MAAO,OAAM,KAAK,EAAK,qBAG3B,kBAAkB,EAAM,EAAM,CAC1B,MAAO,GAAK,aAAa,GAG7B,WAAW,EAAM,CACb,MAAO,GAAK,WAAa,KAAK,UAGlC,YAAY,EAAM,CACd,MAAO,GAAK,YAGhB,cAAc,EAAM,CAChB,MAAO,GAAK,WAAa,KAAK,aAGlC,mBAAmB,EAAM,CACrB,MAAO,GAAK,SAIpB,KAAM,IAAiB,CACnB,mBAAoB,8FACpB,YAAa,CAAC,YACd,aAAc,IAGX,YAAmB,EAAM,CAG5B,KAAM,GAAYC,GAAU,SAAS,EAAM,IACrC,EAAW,GAAI,aAAY,gBAAgB,EAAW,aAAa,KACzE,MAAO,IAAI,IAAgB,GC1B/B,YAAmB,EAAK,CACpB,MAAO,IAAI,SAAQ,SAAU,EAAS,EAAQ,CAC1C,GAAI,GAAI,SAAS,cAAc,UAC/B,EAAE,aAAa,MAAO,GACtB,EAAE,OAAO,EACT,EAAE,QAAQ,EACV,SAAS,KAAK,YAAY,KAIlC,kBAAuB,EAAU,CAM7B,MAHI,QAAO,UAAY,CAAC,OAAO,QAC3B,QAAO,OAAS,OAAO,UAEvB,EACA,CAAI,OAAO,YACP,MAAM,IAAU,EAAS,YACzB,KAAM,QAAO,IAAI,KAAK,CAAC,WAAY,IAAM,EAAS,QAElD,MAAM,IAAU,EAAS,cACzB,KAAM,QAAO,IAAI,QAEd,OAAO,KAEX,KAIX,YAAsB,EAAW,CAC7B,MAAK,GAAU,WAAW,KAGnB,EAFI,GAAI,KAAI,EAAW,SAAS,SAAS,MAAM,SAK1D,kBAA6B,EAAY,CACrC,KAAM,GAAa,GAAI,IAAW,EAAW,OAAQ,GACrD,YAAM,GAAW,OACjB,KAAM,GAAW,QAAQ,CACrB,KAAM,WACN,KAAM,GAAa,EAAW,IAAI,gBAEpB,GAAI,IAAU,GAMpC,YAAuC,EAAW,CAC9C,GAAI,CAAC,OAAO,eACR,OAEJ,KAAM,GAAU,IAAM,CAClB,KAAM,GAAc,EAAU,cAAc,gBAC5C,GAAI,CAAC,EACD,OAGJ,KAAM,GAAa,EAAU,cAAc,0BAC3C,GAAI,GAAiB,EAAc,EAEnC,AAAI,GACA,GAAkB,EAAW,UAC7B,EAAe,EAAW,cAK9B,KAAM,GAAY,EAAY,UAAY,EAAY,aAAe,OAAO,eAAe,OAE3F,EAAU,MAAM,YAAY,wBAAyB,OAAO,eAAe,OAAO,WAAa,MAC/F,EAAU,MAAM,YAAY,qBAAsB,EAAU,WAAa,MAErE,GACA,GAAc,EAAW,aACzB,EAAW,UAAY,EAAkB,EAAe,IAGhE,cAAO,eAAe,iBAAiB,SAAU,GAC1C,IAAM,CACT,OAAO,eAAe,oBAAoB,SAAU,IAIrD,QAAe,CAClB,YAAY,EAAW,EAAY,EAAQ,EAAU,KAAM,EAAe,KAAM,CAC5E,KAAK,WAAa,EAClB,KAAK,YAAc,EACnB,KAAK,QAAU,EACf,KAAK,gBAAkB,GAAI,IAAgB,wBAC3C,KAAK,MAAQ,GAAI,IACjB,KAAK,SAAW,GAAI,IACpB,KAAK,OAAS,KAAK,OACnB,KAAK,cAAc,iBAAS,aAC5B,KAAK,QAAU,GAAI,IACnB,KAAK,aAAe,GAAI,IACxB,KAAK,sBAAwB,KACzB,EAAW,eAAiB,iBAAmB,YAC/C,MAAK,sBAAwB,GAAI,IACjC,KAAK,sBAAsB,iBAAiB,EAAW,gBAE3D,KAAK,oBAAsB,GAAI,IAAoB,KAAK,sBAAuB,EAAO,MACtF,KAAK,OAAS,GAAI,IAAO,GACzB,KAAK,eAAiB,GAAI,IAAe,KAAK,uBAC9C,KAAK,mBAAqB,GAAI,IAAmB,wBACjD,KAAK,qBAAuB,GAC5B,AAAI,MAAO,QAAU,WACjB,KAAK,QAAU,GAAmB,KAAK,MAAM,cAAe,KAAK,uBAEjE,KAAK,QAAU,GAEnB,KAAM,GAAS,CAAC,CAAC,OAAO,sBAAwB,CAAC,CAAC,SAAS,aAC3D,KAAK,OAAS,EAEd,KAAM,GAAQ,mBAAmB,KAAK,UAAU,WAAc,UAAU,WAAa,YAAc,UAAU,eAAiB,GAAM,CAAC,OAAO,SAC5I,KAAK,MAAQ,EACb,KAAK,aAAe,GAAI,IACxB,KAAK,YAAc,OACnB,KAAK,eAAiB,OAG1B,cAAc,EAAe,CAEzB,KAAM,GAAc,AAAC,GAAS,OAC1B,MAAI,MAAK,IAAL,cAAQ,QACR,GAAK,EAAE,MAAQ,EAAK,EAAE,MAAM,QAAQ,sBAAuB,uBAExD,GAEX,AAAI,EACA,KAAK,OAAS,GAAI,IAAc,CAAC,SAAU,OAE3C,KAAK,OAAS,GAAI,IAAU,CAAC,KAAM,gBAAiB,SAAU,KAAM,sBAAuB,OAI/F,gBAAgB,CAChB,MAAO,MAAK,sBAGhB,SAAU,CACN,MAAK,MAAK,aACN,MAAK,YAAc,GAAQ,KAAK,YAAY,MAEzC,KAAK,eAGZ,SAAS,CACT,MAAO,MAAK,aAGV,gBAAgB,CAClB,GAAI,CAAC,OAAO,YACR,MAAK,MAAK,gBACN,MAAK,eAAiB,GAAc,KAAK,cAEtC,KAAK,eAIpB,uBAAuB,EAAI,CAIvB,GAHI,KAAK,QACL,MAAK,WAAW,WAAa,WAE7B,KAAK,MAAO,CACZ,KAAK,WAAW,WAAa,OAC7B,KAAM,GAAa,GAA8B,KAAK,YACtD,AAAI,GACA,KAAK,aAAa,MAAM,GAGhC,KAAK,WAAW,iBAAiB,QAAS,GAAmB,IAC7D,KAAK,aAAa,MAAM,IAAM,KAAK,WAAW,oBAAoB,QAAS,GAAmB,KAC9F,OAAO,oBAAsB,EAC7B,KAAM,GAAO,GAAI,IAAS,GAC1B,KAAK,WAAW,YAAY,EAAK,SAGrC,cAAc,EAAY,OACtB,QAAK,wBAAL,QAA4B,cAAc,GAG9C,WAAW,EAAQ,EAAU,CACzB,MAAO,IAAW,WAAW,EAAQ,GAGzC,WAAW,EAAY,EAAU,CAC7B,AAAI,UAAU,WACV,UAAU,WAAW,EAAW,WAAY,GAE5C,GAAiB,KAAK,WAAY,KAAK,YAAY,gBAAiB,EAAY,EAAU,KAAK,OAIvG,SAAS,EAAW,KAAM,CACtB,KAAM,GAAQ,SAAS,cAAc,SACrC,EAAM,aAAa,OAAQ,QAC3B,EAAM,UAAY,SACd,GACA,EAAM,aAAa,SAAU,GAEjC,KAAM,GAAU,GAAI,SAAQ,GAAW,CACnC,KAAM,GAAY,IAAM,CACpB,EAAM,oBAAoB,SAAU,EAAW,IAC/C,KAAM,GAAO,EAAM,MAAM,GACzB,KAAK,WAAW,YAAY,GAC5B,AAAI,EACA,EAAQ,CAAC,KAAM,EAAK,KAAM,KAAM,GAAW,SAAS,KAEpD,KAGR,EAAM,iBAAiB,SAAU,EAAW,MAGhD,YAAK,WAAW,YAAY,GAC5B,EAAM,QACC,EAGX,QAAQ,EAAK,CACT,SAAS,KAAO,EAGpB,UAAU,EAAM,CACZ,MAAO,IAAU,QAGf,WAAU,EAAM,CAClB,MAAO,IAAY,SAAS,QAG1B,WAAU,EAAM,CAClB,MAAO,IAAY,SAAS,GAGhC,wBAAyB,CACrB,MAAO,SAGP,mBAAmB,CACnB,MAAO,QAAO,kBAAoB,KAGlC,UAAU,CACV,MAAO,SAGX,SAAU,CACN,KAAK,aAAa,WCpS1B,OAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KCAA,6CCAA,+BCWA,CACX,gBAAiB,GACjB,OAAQ,GACR,IAAK,CACD,KAAM,GACN,aAAc,GACd,WAAY,KCXJ,GAAW,cAAgB,QAE/B,KAAM,IAAW,GAAI,IACjB,SAAS,KACT,GACA,KAAK,MAAM,IACX,CAAC,YAAa,KAElB,GAAK"}